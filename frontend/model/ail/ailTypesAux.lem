open import Pervasives Utils AilSyntax ErrorMonad TypingError Annot Ctype Global
import Implementation IntegerImpl Loc Debug

(* == Predicates on qualifiers ================================================ *)
val is_unqualified: qualifiers -> bool
let is_unqualified = function
  | <|
      const    = false;
      restrict = false;
      volatile = false;
    |> ->
      true
  | _ ->
      false
end

val sub_qualifiers: qualifiers -> qualifiers -> bool
let sub_qualifiers qs1 qs2 =
     (qs1.const    --> qs2.const)
  && (qs1.restrict --> qs2.restrict)
  && (qs1.volatile --> qs2.volatile)


(* == Predicates on integerTypes ============================================ *)
val     is_signed_ity: integerType -> bool
let rec is_signed_ity ity =
  match ity with
    | Char ->
        Implementation.is_signed_ity Char
    | Bool ->
        false
    | Signed _ ->
        true
    | Unsigned _ ->
        false
    | Enum tag_sym ->
        is_signed_ity (Implementation.typeof_enum tag_sym)
    | Size_t ->
        (* STD §7.19#2 *)
        false
    | Wchar_t ->
        Implementation.is_signed_ity Wchar_t
    | Wint_t ->
        Implementation.is_signed_ity Wint_t
    | Ptrdiff_t ->
        (* STD §7.19#2 *)
        true
    | Vaddr_t ->
        false
  end

(* STD §6.2.5#6, sentence 4 *)
val is_unsigned_ity: integerType -> bool
let is_unsigned_ity ity =
  not (is_signed_ity ity)


(* == constructor predicates on ctypes ====================================== *)
val is_integer: ctype -> bool
let is_integer = function
  | Ctype _ (Basic (Integer _)) ->
      true
  | _ ->
      false
end

val is_floating: ctype -> bool
let is_floating = function
  | Ctype _ (Basic (Floating _)) ->
      true
  | _ ->
      false
end

val is_void: ctype -> bool
let is_void = function
  | Ctype _ Void ->
      true
  | _ ->
      false
end

val is_pointer: ctype -> bool
let is_pointer = function
  | Ctype _ (Pointer _ _) ->
      true
  | _ ->
      false
end

val is_atomic: ctype -> bool
let is_atomic = function
  | Ctype _ (Atomic _) ->
      (* STD §6.2.5#20, bullet 6 *)
      true
  | _ ->
      false
end

(* TODO: I don't like that, in particular if pred = is_atomic this doesn't work... *)
val atomic_qualified_unqualified: (ctype -> bool) -> ctype -> bool
let atomic_qualified_unqualified pred = function
  | Ctype _ (Atomic ty) ->
      pred ty
  | ty ->
      pred ty
end

(* STD §6.2.5#15, sentence 1 *)
val is_character: ctype -> bool
let is_character = function
  | Ctype _ (Basic (Integer Char)) ->
      true
  | Ctype _ (Basic (Integer (Signed Ichar))) ->
      true
  | Ctype _ (Basic (Integer (Unsigned Ichar))) ->
      true
  | _ ->
      false
end

val is_Bool: ctype -> bool
let is_Bool = function
  | Ctype _ (Basic (Integer Bool)) ->
      true
  | _ ->
      false
end

val is_array: ctype -> bool
let is_array = function
  | Ctype _ (Array _ _) ->
      true
  | _ ->
      false
end

val is_array_unknown_size: ctype -> bool
let is_array_unknown_size = function
  | Ctype _ (Array _ Nothing) ->
      true
  | _ ->
      false
end

val is_array_of_character: ctype -> bool
let is_array_of_character = function
  | Ctype _ (Array elem_ty _) ->
      is_character elem_ty
  | _ ->
      false
end

(* STD §6.2.5#1, sentence 3 *)
val is_function: ctype -> bool
let is_function = function
  | Ctype _ (Function _ _ _) ->
      true
  | Ctype _ (FunctionNoParams _) ->
      true
  | _ ->
      false
end

val is_struct: ctype -> bool
let is_struct = function
  | Ctype _ (Struct _) ->
      true
  | _ ->
      false
end

val is_union: ctype -> bool
let is_union = function
  | Ctype _ (Union _) ->
      true
  | _ ->
      false
end

val is_struct_or_union: ctype -> bool
let is_struct_or_union ty =
  is_struct ty || is_union ty

val has_flexible_array_member: forall 'a. sigma 'a -> ctype -> bool
let has_flexible_array_member sigm = function
  | Ctype _ (Struct tag_sym) ->
      match List.lookup tag_sym sigm.tag_definitions with
        | Just (_, StructDef _ Nothing) ->
            false
        | Just (_, StructDef _ (Just _)) ->
            true
        | _ ->
            error "AilTypesAux.has_flexible_array_member: Struct, UnionDef or Nothing"
      end
  | _ ->
      false
end


(* == generic predicates on ctypes ========================================== *)
(* STD §6.2.5#1, sentence 3 *)
val is_object: ctype -> bool
let is_object ty =
  not (is_function ty)

(* STD §6.2.5#18, sentence 1 *)
val is_arithmetic: ctype -> bool
let is_arithmetic ty =
  is_integer ty || is_floating ty

(* STD §6.2.5#21, sentence 1 *)
val is_scalar: ctype -> bool
let is_scalar ty =
  is_pointer ty || is_arithmetic ty

(* STD §6.2.5#21, sentence 2 *)
val is_aggregate: ctype -> bool
let is_aggregate ty =
  is_array ty || is_struct ty


(* STD §6.2.5#1, sentence 4 *)
val     is_complete: forall 'a. sigma 'a -> ctype -> bool
let rec is_complete sigm ty =
  (* NOTE: for atomic types we look at the argument type. The standard doesn't say
     when/whether atomic types are complete...
     But I assume they are when their inner type is complete *)
  match unatomic_ ty with
  | Void ->
      (* STD §6.2.5#19 *)
      false
  | Basic _ ->
      (* STD §6.2.5#14, sentence 2 *)
      true
  | Array elem_ty n_opt ->
      (* STD §6.2.5#22, sentence 1-2 *)
      (* STD §6.7.6.2#4, sentence 1 *)
      (* NOTE: because this function is also called during the desugaring, it is possible for the element type
         to be incomplete: if it is a struct type whose declaration has not yet been completed *)
          is_complete sigm elem_ty
      &&  isJust n_opt
    (* the notion of complete/incomplete types only applies to object types *)
  | Function _ _ _ ->
      error "AilTypesAux.is_complete: called an a function type"
  | FunctionNoParams _ ->
      error "AilTypesAux.is_complete: called an a function type (no params)"
  | Pointer _ _ ->
      true
  | Atomic atom_ty ->
      (* NOTE: same as for Array, after desugaring there will never be an incomplete [atom_ty] *)
      is_complete sigm atom_ty
    (* STD §6.2.5#22, sentence 3-4 *)
  | Struct sym ->
      match List.lookup sym sigm.tag_definitions with
        | Just (_, StructDef _ _) ->
            (* TODO[note]: as far as I can tell, a struct with a flexible array member
                           is still a complete type *)
            true
        | Just (_, UnionDef _) ->
            error "AilTypesAux.is_complete: Struct --> tag resolved to a UnionDef"
        | Nothing ->
            false
      end
    (* STD §6.2.5#22, sentence 3-4 *)
  | Union sym ->
      match List.lookup sym sigm.tag_definitions with
        | Just (_, StructDef _ _) ->
            error "AilTypesAux.is_complete: Struct --> tag resolved to a StructDef"
        | Just (_, UnionDef _) ->
            true
        | Nothing ->
            false
      end
end

(* STD §6.2.5#1, sentence 4 *)
val is_incomplete: forall 'a. sigma 'a -> ctype -> bool
let is_incomplete sigm ty =
  not (is_complete sigm ty)


(* ========================================================================= *)
val in_integer_range: IntegerImpl.implementation -> integer -> integerType -> bool
let in_integer_range impl n ity =
  Range.mem n (IntegerImpl.integer_range impl ity)

val in_min_integer_range: integer -> integerType -> bool
let in_min_integer_range n ity =
  Range.mem n (IntegerImpl.min_integer_range ity)


val normalise_integerType: integerType -> integerType
let normalise_integerType ity =
  match ity with
   | Enum tag_sym ->
       Implementation.typeof_enum tag_sym
   | _ ->
       ity
  end

val le_integer_range: IntegerImpl.implementation -> integerType -> integerType -> bool
let le_integer_range impl ity1 ity2 =
  if ity1 = ity2 then
    (* reflexive cases *)
    true
  else match (normalise_integerType ity1, normalise_integerType ity2) with
    | (Char, Signed Ichar) ->
        Implementation.is_signed_ity Char
    | (Char, Signed ibty) ->
        Implementation.is_signed_ity Char || (Implementation.precision_ity Char) < (Implementation.precision_ity (Signed ibty))
    | (Signed Ichar, Char) ->
        Implementation.is_signed_ity Char
    | (Signed ibty, Char) ->
        Implementation.is_signed_ity Char && Implementation.precision_ity (Signed ibty) = Implementation.precision_ity Char
    | (Unsigned Ichar, Char) ->
        not (Implementation.is_signed_ity Char)
    | (Unsigned ibty, Char) ->
        not (Implementation.is_signed_ity Char) && Implementation.precision_ity (Unsigned ibty) = Implementation.precision_ity Char
    | (Char, Unsigned _) ->
        not (Implementation.is_signed_ity Char)
    | (Char, Bool) ->
        not (Implementation.is_signed_ity Char) && Implementation.precision_ity Char = Implementation.precision_ity Bool
    | (Bool, Char) ->
        not (Implementation.is_signed_ity Char) || (Implementation.precision_ity Bool) < (Implementation.precision_ity Char)

    | (Signed Ichar, Signed _) ->
        true
    | (Signed Short, Signed Int_) ->
        true
    | (Signed Short, Signed Long) ->
        true
    | (Signed Short, Signed LongLong) ->
        true
    | (Signed Int_, Signed Long) ->
        true
    | (Signed Int_, Signed LongLong) ->
        true
    | (Signed Long, Signed LongLong) ->
        true
    | (Signed ibty1, Signed ibty2) ->
        Implementation.precision_ity (Signed ibty1) = Implementation.precision_ity (Signed ibty2)
    | (Signed _, Bool) ->
        false
    | (Bool, Signed ibty2) ->
        (Implementation.precision_ity Bool) < (Implementation.precision_ity (Signed ibty2))
    
    | (Bool, Unsigned _) ->
        true
    | (Unsigned Ichar, Unsigned _) ->
        true
    | (Unsigned Short, Unsigned Int_) ->
        true
    | (Unsigned Short, Unsigned Long) ->
        true
    | (Unsigned Short, Unsigned LongLong) ->
        true
    | (Unsigned Int_, Unsigned Long) ->
        true
    | (Unsigned Int_, Unsigned LongLong) ->
        true
    | (Unsigned Long, Unsigned LongLong) ->
        true
    | (Unsigned ibty, Bool) ->
        Implementation.precision_ity (Unsigned ibty) = Implementation.precision_ity Bool
    | (Unsigned ibty1, Unsigned ibty2) ->
        Implementation.precision_ity (Unsigned ibty1) = Implementation.precision_ity (Unsigned ibty2)
    
    | (Signed _, Unsigned _) ->
        false
    
    | (Unsigned _, Signed Ichar) ->
        false
    | (Unsigned Short, Signed Short) ->
        false
    | (Unsigned Int_, Signed Int_) ->
        false
    | (Unsigned Long, Signed Long) ->
        false
    | (Unsigned LongLong, Signed LongLong) ->
        false
    | (Unsigned ibty1, Signed ibty2) ->
        (Implementation.precision_ity (Unsigned ibty1)) < (Implementation.precision_ity (Signed ibty2))
      
  | (Char, Char) -> true
  | (Bool, Bool) -> true
  | (Size_t, Size_t) -> true
  | (Wchar_t, Wchar_t) -> true
  | (Ptrdiff_t, Ptrdiff_t) -> true
  | (Vaddr_t, Vaddr_t) -> true
  | (Enum _, Enum _) ->
      (* impossible *)
      error "le_integer_range: Enum, Enum"
  
  | (Char, Size_t) ->
      error "WIP le_integer_range: Char, Size_t"
  | (Char, Ptrdiff_t) ->
      error "WIP le_integer_range: Char, Ptrdiff_t"
  | (Char, Vaddr_t) ->
      error "WIP le_integer_range: Char, Vaddr_t"
  | (Char, Enum _) ->
      error "WIP le_integer_range: Char, Enum"
  
  | (Bool, Size_t) ->
      error "WIP le_integer_range: Bool, Size_t"
  | (Bool, Ptrdiff_t) ->
      error "WIP le_integer_range: Bool, Ptrdiff_t"
  | (Bool, Vaddr_t) ->
      error "WIP le_integer_range: Bool, Vaddr_t"
  | (Bool, Enum _) ->
      (* impossible *)
      error "le_integer_range: Bool, Enum"
  
  | (Signed _, Size_t) ->
      error "WIP le_integer_range: Signed, Size_t"
  | (Signed _, Ptrdiff_t) ->
      error "WIP le_integer_range: Signed, Ptrdiff_t"
  | (Signed _, Vaddr_t) ->
      error "WIP le_integer_range: Signed, Vaddr_t"
  | (Signed _, Enum _) ->
      (* impossible *)
      error "le_integer_range: Signed, Enum"
  
  | (Unsigned _, Size_t) ->
      error "WIP le_integer_range: Unsigned, Size_t"
  | (Unsigned _, Ptrdiff_t) ->
      error "WIP le_integer_range: Unsigned, Ptrdiff_t"
  | (Unsigned _, Vaddr_t) ->
      error "WIP le_integer_range: Unsigned, Vaddr_t"
  | (Unsigned _, Enum _) ->
      (* impossible *)
      error "le_integer_range: Unsigned, Enum"
  
  | (Ptrdiff_t, Char) ->
      error "WIP le_integer_range: Ptrdiff_t, Char"
  | (Ptrdiff_t, Bool) ->
      error "WIP le_integer_range: Ptrdiff_t, Bool"
  | (Ptrdiff_t, Signed _) ->
      error "WIP le_integer_range: Ptrdiff_t, Signed"
  | (Ptrdiff_t, Unsigned _) ->
      error "WIP le_integer_range: Ptrdiff_t, Unsigned"
  | (Ptrdiff_t, Enum _) ->
      (* impossible *)
      error "le_integer_range: Ptrdiff_t, Enum"
  | (Ptrdiff_t, Size_t) ->
      error "WIP le_integer_range: Ptrdiff_t, Size_t"
  | (Ptrdiff_t, Vaddr_t) ->
      error "WIP le_integer_range: Ptrdiff_t, Vaddr_t"

  | (Vaddr_t, Char) ->
      error "WIP le_integer_range: Vaddr_t, Char"
  | (Vaddr_t, Bool) ->
      error "WIP le_integer_range: Vaddr_t, Bool"
  | (Vaddr_t, Signed _) ->
      error "WIP le_integer_range: Vaddr_t, Signed"
  | (Vaddr_t, Unsigned _) ->
      error "WIP le_integer_range: Vaddr_t, Unsigned"
  | (Vaddr_t, Enum _) ->
      (* impossible *)
      error "le_integer_range: Vaddr_t, Enum"
  | (Vaddr_t, Size_t) ->
      error "WIP le_integer_range: Vaddr_t, Size_t"
  | (Vaddr_t, Ptrdfiff_t) ->
      error "WIP le_integer_range: Vaddr_t, Ptrdiff_t"

  | (Size_t, Char) ->
      error "WIP le_integer_range: Size_t, Char"
  | (Size_t, Bool) ->
      error "WIP le_integer_range: Size_t, Bool"
  | (Size_t, Signed _) ->
      error "WIP le_integer_range: Size_t, Signed"
  | (Size_t, Unsigned _) ->
      error "WIP le_integer_range: Size_t, Unsigned"
  | (Size_t, Enum _) ->
      (* impossible *)
      error "le_integer_range: Size_t, Enum"
  | (Size_t, Ptrdiff_t) ->
      error "WIP le_integer_range: Size_t, Ptrdiff_t"
  | (Size_t, Vaddr_t) ->
      error "WIP le_integer_range: Size_t, Vaddr_t"

  | (Enum _, Char) ->
      (* impossible *)
      error "le_integer_range: Enum, Char"
  | (Enum _, Bool) ->
      (* impossible *)
      error "le_integer_range: Enum, Bool"
  | (Enum _, Signed _) ->
      (* impossible *)
      error "le_integer_range: Enum, Signed"
  | (Enum _, Unsigned _) ->
      (* impossible *)
      error "le_integer_range: Enum, Unsigned"
  | (Enum _, Size_t) ->
      (* impossible *)
      error "le_integer_range: Enum, Size_t"
  | (Enum _, Ptrdiff_t) ->
      (* impossible *)
      error "le_integer_range: Enum, Ptrdiff_t"
  | (Enum _, Vaddr_t) ->
      (* impossible *)
      error "le_integer_range: Enum, Vaddr_t"

  | (Wchar_t, _) ->
      error "WIP le_integer_range: wchar_t"
  | (_, Wchar_t) ->
      error "WIP le_integer_range: wchar_t"
  | (Wint_t, _) ->
      error "WIP le_integer_range: wint_t"
  | (_, Wint_t) ->
      error "WIP le_integer_range: wint_t"
  end


val eq_integer_rank_base: integerType -> integerType -> bool
let eq_integer_rank_base ity1 ity2 =
  match (ity1, ity2) with
  (* STD §6.3.1.1#1, bullet 4 *)
  | (Signed ibty1, Unsigned ibty2) ->
      ibty1 = ibty2
  | (Unsigned ibty1, Signed ibty2) ->
      ibty1 = ibty2
  (* STD §6.3.1.1#1, bullet 6 *)
  | (Char, Unsigned Ichar) ->
      true
  | (Char, Signed Ichar) ->
      true
  | (Unsigned Ichar, Char) ->
      true
  | (Signed Ichar, Char) ->
      true
  | _ ->
      false
  end


(* TODO: K this looks wrong, in particular the STD says "No two signed integer types shall have the same rank" *)
val eq_integer_rank: integerType -> integerType -> bool
let eq_integer_rank ity1 ity2 =
  ity1 = ity2 || eq_integer_rank_base ity1 ity2

val lt_integer_rank: integerType -> integerType -> bool
let lt_integer_rank ity1 ity2 =
  let lt_integer_rank_ISO ity1 ity2 =
    match (ity1, ity2) with
    (* Top: "The rank of _Bool shall be less than the rank of all other standard integer types." *)
    | (_, Bool) ->
        false
    | (Bool, _) ->
        true

    (* Bottom: In CHERI C intptr_t types have the highest rank so the capabilities metainfromation
       will be preserved during integer promotion *)
    | (Signed Intptr_t, _) ->
        false
    | (Unsigned Intptr_t, _) ->
        false

    | (_, Char) ->
        false
    | (_, Signed Ichar) ->
        false
    | (_, Unsigned Ichar) ->
        false
    | (Char, Signed _) ->
        true
    | (Char, Unsigned _) ->
        true
    | (Signed Ichar, Signed _) ->
        true
    | (Signed Ichar, Unsigned _) ->
        true
    | (Unsigned Ichar, Signed _) ->
        true
    | (Unsigned Ichar, Unsigned _) ->
        true
    
    | (_, Signed Short) ->
        false
    | (_, Unsigned Short) ->
        false
    | (Signed Short, Signed _) ->
        true
    | (Signed Short, Unsigned _) ->
        true
    | (Unsigned Short, Signed _) ->
        true
    | (Unsigned Short, Unsigned _) ->
        true
    
    | (_, Signed Int_) ->
        false
    | (_, Unsigned Int_) ->
        false
    | (Signed Int_, Signed _) ->
        true
    | (Signed Int_, Unsigned _) ->
        true
    | (Unsigned Int_, Signed _) ->
        true
    | (Unsigned Int_, Unsigned _) ->
        true
    
    | (_, Signed Long) ->
        false
    | (_, Unsigned Long) ->
        false
    | (Signed Long, Signed _) ->
        true
    | (Signed Long, Unsigned _) ->
        true
    | (Unsigned Long, Signed _) ->
        true
    | (Unsigned Long, Unsigned _) ->
        true
    
    | _ ->
        (* TODO: this is probably wrong for macro types *)
       false
    end in
  if Global.is_CHERI () then
    match ity1 with
      (* Bottom: In CHERI C intptr_t types have the highest rank so
         the capabilities metainfromation will be preserved during
         integer promotion *)
    | Signed Intptr_t -> false
    | Unsigned Intptr_t -> false
    | _ ->
       lt_integer_rank_ISO ity1 ity2
    end
  else
    lt_integer_rank_ISO ity1 ity2

val le_integer_rank: integerType -> integerType -> bool
let le_integer_rank ity1 ity2 =
  eq_integer_rank ity1 ity2 || lt_integer_rank ity1 ity2

val ge_integer_rank: integerType -> integerType -> bool
let ge_integer_rank ity1 ity2 =
  le_integer_rank ity2 ity1

(* STD §6.2.5#10 *)
val le_real_floating_range : realFloatingType -> realFloatingType -> bool
let le_real_floating_range fty1 fty2 =
  match (fty1, fty2) with
  | (Float, _) -> true
  | (Double, Double) -> true
  | (_, LongDouble) -> true
  | _ -> false
  end

val is_corresponding_unsigned: integerType -> integerType -> bool
let is_corresponding_unsigned ity1 ity2 =
  match (ity1, ity2) with
    | (Signed ibty1, Unsigned ibty2) ->
        ibty1 = ibty2
    | (_, _) ->
        false
  end

val corresponding_unsigned: integerType -> maybe integerType
let corresponding_unsigned = function
  | Signed ibty ->
      Just (Unsigned ibty)
  | _ ->
      Nothing
end

val make_corresponding_unsigned: integerType -> integerType
let make_corresponding_unsigned = function
  | Signed ibty ->
      Unsigned ibty
  | ity ->
      ity
end


val integer_promotion: IntegerImpl.implementation -> integerType -> integerType
let integer_promotion impl = function
  | Signed   Int_ ->
      Signed   Int_
  | Unsigned Int_ ->
      Unsigned Int_
  | Size_t ->
      (* TODO: this is not standard, but in cerberus we don't treat size_t as an aliased type *)
      Size_t
  | Signed Intptr_t ->
      (* TODO: this is not standard, but in cerberus we don't treat intptr_t as aliased types *)
      Signed Intptr_t
  | Unsigned Intptr_t ->
      (* TODO: this is not standard, but in cerberus we don't treat uintptr_t as aliased types *)
      Unsigned Intptr_t
  | ity ->
      if le_integer_rank ity (Signed Int_) then
        if le_integer_range impl ity (Signed Int_) then
          Signed Int_
        else
          Unsigned Int_
      else
        ity
  end


val promotion: IntegerImpl.implementation -> ctype -> maybe ctype
let promotion impl = function
  | Ctype annots (Basic (Integer ity)) ->
      Just (Ctype annots (Basic (Integer (integer_promotion impl ity))))
  | _ ->
      Nothing
end


val usual_arithmetic_integer: IntegerImpl.implementation -> integerType -> integerType -> integerType
let usual_arithmetic_integer impl ity1 ity2 =
  (* TODO: this is not standard, but in cerberus we don't treat (u)intptr_t and size_t as an aliased types *)
  let () = Debug.warn [] (fun () ->
    "NON STD: usual_arithmetic_integer ==> if any operand is of type size_t, then the common type is size_t"
  ) in
  match (ity1, ity2) with
    | (Signed Intptr_t, Unsigned Intptr_t) ->
        Unsigned Intptr_t
    | (Signed Intptr_t, _) ->
        Signed Intptr_t
    | (Unsigned Intptr_t, Signed Intptr_t) ->
        Unsigned Intptr_t
    | (_, Signed Intptr_t) ->
        Signed Intptr_t
    | (Unsigned Intptr_t, _) ->
        Unsigned Intptr_t
    | (_, Unsigned Intptr_t) ->
        Unsigned Intptr_t
    | (Size_t, _) ->
        Size_t
    | (_, Size_t) ->
        Size_t
    
    | _ ->
        let promoted_ity1 = integer_promotion impl ity1 in
        let promoted_ity2 = integer_promotion impl ity2 in
        if    (is_signed_ity promoted_ity1 && is_signed_ity promoted_ity2)
           || (is_unsigned_ity promoted_ity1 && is_unsigned_ity promoted_ity2) then
          if lt_integer_rank promoted_ity1 promoted_ity2 then
            promoted_ity2
          else
            promoted_ity1
        
        else if is_unsigned_ity promoted_ity1 && ge_integer_rank promoted_ity1 promoted_ity2 then
          promoted_ity1
        else if is_unsigned_ity promoted_ity2 && ge_integer_rank promoted_ity2 promoted_ity1 then
          promoted_ity2
        
        else if is_signed_ity promoted_ity1 then
          if le_integer_range impl promoted_ity2 promoted_ity1 then
            promoted_ity1
          else
            make_corresponding_unsigned promoted_ity1
        
        else (* if is_signed_ity promoted_ity2 then *)
          if le_integer_range impl promoted_ity1 promoted_ity2 then
            promoted_ity2
          else
            make_corresponding_unsigned promoted_ity2
  end


(* TODO *)
val usual_arithmetic_floating: IntegerImpl.implementation -> floatingType -> floatingType -> floatingType
let usual_arithmetic_floating impl ty1 ty2 = ty1


(* STD §6.2.5#12 *)
val corresponding_real_type: ctype -> maybe realFloatingType
let corresponding_real_type (Ctype _ ty as cty) =
  if is_floating cty then
    match ty with
    | Basic (Floating (RealFloating rfty)) ->
        Just rfty
(*
    | Basic (Floating (Complex fty))
        Basic (Floating fty)
*)
    | _ ->
        error "AilTypesAux.corresponding_real_type"
    end
  else
    Nothing


(* assuming [ty] is an lvalue type, [modifiable ty] is true iff
   [ty] is modifiable lvalue type (see §6.3.2.1#1, sentence 3) *)

(*
A modifiable lvalue is an lvalue that does not have array type, does not have an incomplete type, does not have a const- qualified type, and if it is a structure or union, does not have any member (including, recursively, any member or element of all contained aggregates or unions) with a const- qualified type.
*)
val modifiable: forall 'a. sigma 'a -> qualifiers -> ctype -> bool
let modifiable sigm qs ty =
  not (is_array ty) &&
  not (qs.const) &&
  is_object ty &&
  not (is_incomplete sigm ty)

val is_real: ctype -> bool
let is_real (Ctype _ ty) =
  match ty with
    | Basic (Integer _) ->
        true
    | Basic (Floating (RealFloating _)) ->
        true
    | _ ->
        false
  end


(* (§6.2.7) Compatible type *)
val            are_compatible: (qualifiers * ctype) -> (qualifiers * ctype) -> bool
let rec ~{coq} are_compatible (qs1, Ctype _ ty1) (qs2, Ctype _ ty2) =
  (* qualifiers need to be equal (see §6.7.3#10) *)
  qs1 = qs2 && match (ty1, ty2) with
    | (Void, Void) ->
        true
    | (Basic bty1, Basic bty2) ->
        let (bty1', bty2') = match (bty1, bty2) with
          | (Integer (Enum tag_sym1), Integer (Enum tag_sym2)) ->
              (Integer (Implementation.typeof_enum tag_sym1), Integer (Implementation.typeof_enum tag_sym2))
          | (Integer (Enum tag_sym1), _) ->
              (Integer (Implementation.typeof_enum tag_sym1), bty2)
          | (_, Integer (Enum tag_sym2)) ->
              (bty1, Integer (Implementation.typeof_enum tag_sym2))
          | _ ->
              (bty1, bty2)
        end in
        bty1' = bty2'
    | (Array elem_ty1 n1_opt, Array elem_ty2 n2_opt) ->
        (* STD §6.7.6.2#6 *)
           are_compatible (no_qualifiers, elem_ty1) (no_qualifiers, elem_ty2)
        && match (n1_opt, n2_opt) with
             | (Just n1, Just n2) -> n1 = n2
             | (Just _ , Nothing) -> true
             | (Nothing, Just _ ) -> true
             | (Nothing, Nothing) -> true
           end
    | (Function (ret_qs1, ret_ty1) params1 isVariadic1, Function (ret_qs2, ret_ty2) params2 isVariadic2) ->
        (* STD §6.7.6.3#15 *)
           are_compatible (ret_qs1, ret_ty1) (ret_qs2, ret_ty2)
        && are_compatible_params params1 params2
        && isVariadic1 = isVariadic2
    | (FunctionNoParams (ret_qs1, ret_ty1), FunctionNoParams (ret_qs2, ret_ty2)) ->
        are_compatible (ret_qs1, ret_ty1) (ret_qs2, ret_ty2)
    | (Function (ret_qs1, ret_ty1) _ isVariadic1, FunctionNoParams (ret_qs2, ret_ty2)) ->
        are_compatible (ret_qs1, ret_ty1) (ret_qs2, ret_ty2) && not isVariadic1
    | (FunctionNoParams (ret_qs1, ret_ty1), Function (ret_qs2, ret_ty2) _ isVariadic2) ->
        are_compatible (ret_qs1, ret_ty1) (ret_qs2, ret_ty2) && not isVariadic2
    | (Pointer ref_qs1 ref_ty1, Pointer ref_qs2 ref_ty2) ->
        (* STD §6.7.6.1#2 *)
        are_compatible (ref_qs1, ref_ty1) (ref_qs2, ref_ty2)
    | (Struct tag1, Struct tag2) ->
        (* STD §6.2.7#1 *)
        (* TODO: being conservative here (aka STD compliant) *)
        tag1 = tag2 (* TODO/NOTE: just looking at the tag should be enough since we only have one translation unit (?) *)
    | (Union tag1, Union tag2) ->
        (* STD §6.2.7#1 *)
        (* TODO: being conservative here (aka STD compliant) *)
        tag1 = tag2 (* TODO/NOTE: just looking at the tag should be enough since we only have one translation unit (?) *)
    | (Atomic atom_ty1, Atomic atom_ty2) ->
        are_compatible (no_qualifiers, atom_ty1) (no_qualifiers, atom_ty2)
    | _ ->
        (* TODO: we can't see Enum types here and there is some impl-def stuff *)
        false
  end

(* TYP: bool -> (list (qualifiers * ctype * bool) * list (qualifiers * ctype * bool)) -> bool *)
and are_compatible_params_aux acc = function
  | ([], []) ->
      acc
  | (((qs1, ty1, _) :: params1), ((qs2, ty2, _) :: params2)) ->
      are_compatible_params_aux (
        (* STD (§6.7.6.3#15) the unqualified versions of the parameters types are compared *)
        acc && are_compatible (no_qualifiers, ty1) (no_qualifiers, ty2)
      ) (params1, params2)
  | _ ->
      (* the list of params must have the same length to be compatible *)
      false
end

and are_compatible_params params1 params2 =
  are_compatible_params_aux true (params1, params2)


val make_composite_params_aux:
  (ctype -> ctype -> maybe ctype) ->
  (list (qualifiers * ctype * bool) * list (qualifiers * ctype * bool)) ->
  maybe (list (qualifiers * ctype * bool))
let rec ~{coq} make_composite_params_aux make_composite = function
  | ([], []) ->
      Just []
  | ((_, ty1, _) :: params1, (_, ty2, _) :: params2) ->
      match (make_composite ty1 ty2, make_composite_params_aux make_composite (params1, params2)) with
        | (Just ty, Just p) ->
            Just ((no_qualifiers, ty, false) :: p)
        | _ ->
            Nothing
      end
  | _ ->
      Nothing
end

(* (§6.2.7#3) composite type *)
(* TODO: this function is defined over Ail types, so function types
   are simpler than what the desugaring can see (functions have parameters). So
   this function SHOULD NOT be used by the desugaring *)
val            make_composite: ctype -> ctype -> maybe ctype
let rec ~{coq} make_composite (Ctype a1 ty1 as cty1) (Ctype a2 ty2 as cty2) =
  let make_composite_params params1 params2 = make_composite_params_aux make_composite (params1, params2) in
  (* a composite type can only be made from two compatible types *)
  if not (are_compatible (no_qualifiers, cty1) (no_qualifiers, cty2)) then
    Nothing
  else match (ty1, ty2) with
    | (Void, Void) ->
        Just (Ctype (a1++a2) Void)
    | (Basic bty1, Basic bty2) ->
        (* thanks to the compatibility test we know bty1 = bty2  *)
        Just (Ctype (a1++a2) (Basic bty1))
    | (Array elem_ty1 n1_opt, Array elem_ty2 n2_opt) ->
        (* STD §6.2.7#3, first bullet *)
        (* TODO(vla): more would be needed if we want to support VLAs *)
        let n_opt = match (n1_opt, n2_opt) with
          | (Just n1, Just n2) ->
              (* thanks to the compatibility test we know that n1 = n2  *)
              Just n1
          | (Just n1, Nothing) ->
              Just n1
          | (Nothing, Just n2) ->
              Just n2
          | (Nothing, Nothing) ->
              Nothing
        end in
          Maybe.map (fun ty -> Ctype (a1++a2) (Array ty n_opt)) (make_composite elem_ty1 elem_ty2)
    | (Function (ret_qs1, ret_ty1) params1 isVariadic1, Function (ret_qs2, ret_ty2) params2 isVariadic2) ->
        (* TODO: return qualifiers? *)
        (* TODO: like the preceding comment said, there is quite a bit of
           simplication here *)
        if isVariadic1 <> isVariadic2 then
          (* TODO: this is redundant given the compatibility check *)
          Nothing
        else match (make_composite ret_ty1 ret_ty2, make_composite_params params1 params2) with
          | (Just ret_ty, Just params) ->
              Just (Ctype (a1++a2) (Function (ret_qs1, ret_ty) params isVariadic1))
          | _ ->
              (* TODO: this is redundant given the compatibility check *)
              Nothing
        end
    | (FunctionNoParams (ret_qs1, ret_ty1), FunctionNoParams (ret_qs2, ret_ty2)) ->
        match make_composite ret_ty1 ret_ty2 with
          | Just ret_ty ->
              Just (Ctype (a1++a2) (FunctionNoParams (ret_qs1, ret_ty)))
          | Nothing ->
              Nothing
        end
    | (Function (ret_qs1, ret_ty1) params1 isVariadic1, FunctionNoParams (ret_qs2, ret_ty2)) ->
        if isVariadic1 then
          (* TODO: this is redundant given the compatibility check *)
          Nothing
        else match make_composite ret_ty1 ret_ty2 with
          | Just ret_ty ->
              Just (Ctype (a1++a2) (Function (ret_qs1, ret_ty) params1 isVariadic1))
          | Nothing ->
              (* TODO: this is redundant given the compatibility check *)
              Nothing
        end
    | (FunctionNoParams (ret_qs1, ret_ty1), Function (ret_qs2, ret_ty2) params2 isVariadic2) ->
        if isVariadic2 then
          (* TODO: this is redundant given the compatibility check *)
          Nothing
        else match make_composite ret_ty1 ret_ty2 with
          | Just ret_ty ->
              (* TODO: check the prototype thing *)
              Just (Ctype (a1++a2) (Function (ret_qs1, ret_ty) params2 isVariadic2))
          | Nothing ->
              (* TODO: this is redundant given the compatibility check *)
              Nothing
        end
    | (_, FunctionNoParams _) ->
          error "AilTypesAux.make_composite ==> FunctionNoParams (right)"
    | (Pointer ref_qs1 ref_ty1, Pointer ref_qs2 ref_ty2) ->
        (* thanks to the compatibility test we know ref_qs1 = ref_qs2  *)
        Maybe.map (fun ref_ty -> Ctype (a1++a2) (Pointer ref_qs1 ref_ty)) (make_composite ref_ty1 ref_ty2)
    | (Atomic atom_ty1, Atomic atom_ty2) ->
        Maybe.map (fun atom_ty -> Ctype (a1++a2) (Atomic atom_ty)) (make_composite atom_ty1 atom_ty2)
    | (Struct tag1, Struct tag2) ->
        if tag1 = tag2 then
          Just cty1
        else
          Nothing
    | (Union tag1, Union tag2) ->
        if tag1 = tag2 then
          Just cty1
        else
          Nothing
    | _ ->
        Nothing
  end

val        make_composite_params: list (qualifiers * ctype * bool) -> list (qualifiers * ctype * bool) -> maybe (list (qualifiers * ctype * bool))
let ~{coq} make_composite_params params1 params2 =
  make_composite_params_aux make_composite (params1, params2)


(* following (§6.3.2.1)#3 *)
val array_coercion: ctype -> ctype
let array_coercion (Ctype loc ty) =
Ctype loc $ match ty with
  | Array elem_ty _ ->
      Pointer no_qualifiers elem_ty
  | ty ->
      ty
end

(* following (§6.3.2.1)#4 *)
val function_coercion: ctype -> ctype
let function_coercion (Ctype loc ty) =
Ctype loc $ match ty with
  | Function ret_qs_ty params isVariadic ->
      Pointer no_qualifiers (Ctype [] (Function ret_qs_ty params isVariadic))
  | FunctionNoParams _ ->
      error "AilTypesAux.function_coercion ==> FunctionNoParams"
  | ty ->
      ty
end

(* following (§6.3.2.1)#2 *)
val lvalue_convertible: forall 'a. sigma 'a -> ctype -> bool
let lvalue_convertible S ty =
  not (is_array ty) && is_complete S ty

(* following (§6.3.2.1)#2 and #3 *)
val lvalue_coercion: forall 'a. sigma 'a -> ctype -> errorM ctype
let lvalue_coercion S ty =
  if lvalue_convertible S ty then
    return ty
  else if is_array ty then
    return (array_coercion ty)
  else
    undef (Loc.locOf ty) Undefined.UB020_nonarray_incomplete_lvalue_conversion

(* following (§6.3.2.1)#3 and #4 *)
val rvalue_coercion: ctype -> ctype
let rvalue_coercion ty =
  if is_array ty then
    array_coercion ty
  else if is_function ty then
    function_coercion ty
  else
    ty


val is_pointer_to_complete_object: forall 'a. sigma 'a -> ctype -> bool
let is_pointer_to_complete_object S = function
  | Ctype _ (Pointer _ ty) ->
      is_complete S ty
  | _ ->
      false
  end

val        are_pointers_to_compatible_complete_objects: forall 'a. sigma 'a -> ctype -> ctype -> bool
let ~{coq} are_pointers_to_compatible_complete_objects sigm (Ctype _ ty1) (Ctype _ ty2) =
  match (ty1, ty2) with
    | (Pointer ref_qs1 ref_ty1, Pointer ref_qs2 ref_ty2) ->
           is_complete sigm ref_ty1 && is_complete sigm ref_ty2
        && are_compatible (ref_qs1, ref_ty1) (ref_qs1, ref_ty2)
    | _ ->
        false
  end  

val        are_pointers_to_compatible_objects: ctype -> ctype -> bool
let ~{coq} are_pointers_to_compatible_objects (Ctype _ ty1) (Ctype _ ty2) =
  match (ty1, ty2) with
    | (Pointer ref_qs1 ref_ty1, Pointer ref_qs2 ref_ty2) ->
           is_object ref_ty1 && is_object ref_ty2
        && are_compatible (ref_qs1, ref_ty1) (ref_qs1, ref_ty2)
    | _ ->
        false
  end  

val is_pointer_to_object: ctype -> bool
let is_pointer_to_object (Ctype _ ty) =
match ty with
  | Pointer _ ref_ty ->
      is_object ref_ty
  | _ ->
      false
end

val is_pointer_to_void: ctype -> bool
let is_pointer_to_void (Ctype _ ty) =
match ty with
  | Pointer _ (Ctype _ Void) ->
      true
  | _ ->
      false
end

val is_pointer_to_function: ctype -> bool
let is_pointer_to_function (Ctype _ ty) =
match ty with
  | Pointer _ ref_ty ->
      is_function ref_ty
  | _ ->
      false
end


val        pointers_to_compatible_types: ctype -> ctype -> bool
let ~{coq} pointers_to_compatible_types (Ctype _ ty1) (Ctype _ ty2) =
  match (ty1, ty2) with
  | (Pointer ref_qs1 ref_ty1, Pointer ref_qs2 ref_ty2) ->
      are_compatible (ref_qs1, ref_ty1) (ref_qs1, ref_ty2)
  | _ ->
      false
  end  


(* STD §6.2.5#4, sentence 1 *)
val is_standard_signed_integer_type: ctype -> bool
let is_standard_signed_integer_type (Ctype _ ty) =
match ty with
  | Basic (Integer (Signed Ichar)) ->
      true
  | Basic (Integer (Signed Short)) ->
      true
  | Basic (Integer (Signed Int_)) ->
      true
  | Basic (Integer (Signed Long)) ->
      true
  | Basic (Integer (Signed LongLong)) ->
      true
  | _ ->
      false
end

(* TODO: no extended types for now *)
(* STD §6.2.5#4, sentence 3 *)
val is_extended_signed_integer_type: ctype -> bool
let is_extended_signed_integer_type _ =
  false

(* STD §6.2.5#4, sentence 4 *)
val is_signed_integer_type: ctype -> bool
let is_signed_integer_type (Ctype _ ty) =
  match ty with
    | Basic (Integer ity) ->
        is_signed_ity ity
    | _ ->
        false
  end

(* STD §6.2.5#6, sentences 1-2 *)
val is_standard_unsigned_integer_type: ctype -> bool
let is_standard_unsigned_integer_type (Ctype _ ty) =
match ty with
  | Basic (Integer Bool) ->
      true
  | Basic (Integer (Unsigned Ichar)) ->
      true
  | Basic (Integer (Unsigned Short)) ->
      true
  | Basic (Integer (Unsigned Int_)) ->
      true
  | Basic (Integer (Unsigned Long)) ->
      true
  | Basic (Integer (Unsigned LongLong)) ->
      true
  | Basic (Integer (Unsigned _)) ->
      true
  | _ ->
      false
end

(* TODO: no extended types for now *)
(* STD §6.2.5#6, sentence 3 *)
val is_extended_unsigned_integer_type: ctype -> bool
let is_extended_unsigned_integer_type _ =
  false


val is_unsigned_integer_type: ctype -> bool
let is_unsigned_integer_type (Ctype _ ty) =
match ty with
  | Basic (Integer ity) ->
      is_unsigned_ity ity
  | _ ->
      false
end


val variably_modified: ctype -> bool
let variably_modified _ =
  let () = Debug.warn [] (fun () -> "AilTypesAux.variably_modified is BOGUS") in
  (* TODO *)
  false


val has_unknown_size: forall 'a. sigma 'a -> ctype -> bool
let has_unknown_size sigm (Ctype _ ty_) =
  match ty_ with
    | Array _ Nothing ->
        true
    | Array elem_ty (Just _) ->
        is_incomplete sigm elem_ty
    | _ ->
        error "AilTypesAux.has_unknown_size: not called an Array"
end

val is_vla: ctype -> bool
let is_vla = function
  | _ ->
      let () = Debug.warn [] (fun () -> "AilTypesAux.is_vla is BOGUS") in
      false (* TODO !!!!!!! *)
end

val is_complete_object: forall 'a. sigma 'a -> ctype -> bool
let is_complete_object S ty =
  is_object ty && is_complete S ty


(* Adjustment for function parameter types *)
val adjust: qualifiers -> ctype -> (qualifiers * ctype)
let adjust qs (Ctype a ty) =
match ty with
  | Array elem_ty _ ->
      (* STD §6.7.6.3#7 *)
      (* TODO: now that I removed qualifiers from Array, this function doesn't
         doesn't do the right thing. Cabs_to_ail should not use it anymore
         (at least not for Array) *)
      (no_qualifiers, Ctype a (Pointer qs elem_ty))
 | Function ret_qs_ty params isVariadic ->
      (* STD §6.7.6.3#8 *)
     let () = Debug.warn [] (fun () ->
       "(unsure) AilTypesAux.Function, qualifiers"
     ) in
     (no_qualifiers, Ctype a (Pointer qs (Ctype [] (Function ret_qs_ty params isVariadic))))
 | FunctionNoParams _ ->
     error "AilTypesAux.adjust ==> FunctionNoParams"
 | ty ->
     (qs, Ctype a ty)
end



(* STD §6.3.2.1#2 *)
val lvalue_conversion: forall 'a. sigma 'a -> ctype -> errorM ctype
let lvalue_conversion S cty =
  if is_array cty then
    error "trying to do a lvalue conversion on an array type"
  
  else if is_incomplete S cty && not (is_array cty) then
    undef (Loc.locOf cty) Undefined.UB020_nonarray_incomplete_lvalue_conversion
  
  (* STD §6.3.2.1#2, sentence 2 *)
  else match cty with
    | Ctype _ (Atomic cty') ->
        return cty'
    | _ ->
        (* NOTE: since the qualifiers of ty are not passed to this function, we
           have already "unqualified" the type *)
        return cty
  end

val compatibleWithQualifiedUnqualifiedVersionOf: ctype -> list ctype -> bool
let compatibleWithQualifiedUnqualifiedVersionOf ty tys =
  List.any (fun ty' ->
    are_compatible (no_qualifiers, ty) (no_qualifiers, ty')
  ) tys


val referenced_type: ctype -> maybe ctype
let referenced_type = function
  | Ctype _ (Pointer _ ref_ty) ->
      Just ref_ty
  | _ ->
      Nothing
end


(* TODO: this is such a bad name ... *)
val     has_pointer_at_leafs: ctype -> bool
let rec has_pointer_at_leafs (Ctype _ ty) =
  match ty with
    | Void ->
        false
    | Basic _ ->
        false
    | Array elem_ty _ ->
        has_pointer_at_leafs elem_ty
    | Function _ _ _ ->
        false
    | FunctionNoParams _ ->
        false
    | Pointer _ _ ->
        true
    | Atomic ty ->
        has_pointer_at_leafs ty
    | Struct _ ->
        false
    | Union _ ->
        false
  end
