open import Pervasives Utils AilSyntax AilSyntaxAux AilWf TypingError GenTypes GenTypesAux Constraint Std Loc Ctype
import Constraint Undefined Builtins Debug Pp Cmm_csem Global

import Implementation

module Cty = Ctype
module AAux = AilTypesAux
module GAux = GenTypesAux
module E = ErrorMonad

let inline (>>=) m f = E.bind m f
let inline (>>) m f = m >>= (fun _ -> f)
let inline (<$>) = E.fmap

val lookup_tag_definition: forall 'a. sigma 'a -> ail_identifier -> maybe tag_definition
let lookup_tag_definition s sym =
  Maybe.map (fun (_, _, z) -> z) (List.lookup sym s.tag_definitions)


(* NOTE: move in_range and try_ranges inside gen_typing_type_of_constant if Lem ever allows
   recursive functions inside other functions... *)
let in_range loc (n: integer) ity =
  match Implementation.precision_ity ity with
    | Nothing ->
        E.fail loc (TError_MiscError UnableToTypeIntegerConstant)
    | Just prec ->
        let (min, max) =
          if Implementation.is_signed_ity ity then
            (* NOTE: we are assuming two's complement integer. Which will be the only allowed
               implementation in case in C2X anyways *)
            (~(2 ** prec), (2 ** prec) - 1)
          else
            (0, (2 ** prec) - 1) in
        E.return (min <= n && n <= max)
  end

let rec try_ranges loc n = function
  | [] ->
      E.fail loc (TError_MiscError (UntypableIntegerConstant n))
  | ity :: acc ->
      in_range loc n ity >>= function
        | true ->
            E.return ity
        | false ->
            try_ranges loc n acc
      end
end

val gen_typing_type_of_constant: Loc.t -> integerConstant -> E.errorM genIntegerType
let gen_typing_type_of_constant loc iCst =
  if Global.isAgnostic () then
    let () = Debug.warn [] (fun () ->
      "The typing of Ail integer constants is imprecise because of the --agnostic flag"
    ) in
    (* NOTE: in this mode, this function is trying to stay implementation agnostic,
       and therefore only performs the first check of each lists in the table
       from §6.4.4.1#5 using the miminal requirement on implementations. *)
    E.return match iCst with
      | IConstant n Decimal Nothing ->
          if AAux.in_min_integer_range n (Signed Int_) then
            Concrete (Signed Int_)
          else
            Unknown iCst
      | IConstant n _ Nothing ->
          (* Octal or Hexadecimal *)
          if AAux.in_min_integer_range n (Signed Int_) then
            Concrete (Signed Int_)
          else
            Unknown iCst
      | IConstant n _ (Just U) ->
          (* Decimal, Octal or Hexadecimal *)
          if AAux.in_min_integer_range n (Unsigned Int_) then
            Concrete (Unsigned Int_)
          else
            Unknown iCst
      | IConstant n Decimal (Just L) ->
          if AAux.in_min_integer_range n (Signed Long) then
            Concrete (Signed Long)
          else
            Unknown iCst
      | IConstant n _ (Just L) ->
          (* Octal or Hexadecimal *)
          if AAux.in_min_integer_range n (Signed Long) then
            Concrete (Signed Long)
          else
            Unknown iCst
      | IConstant n _ (Just UL) ->
          (* Decimal, Octal or Hexadecimal *)
          if AAux.in_min_integer_range n (Unsigned Long) then
            Concrete (Unsigned Long)
          else
            Unknown iCst
      | IConstant n Decimal (Just LL) ->
          if AAux.in_min_integer_range n (Signed LongLong) then
            Concrete (Signed LongLong)
          else
            Unknown iCst
      | IConstant n _ (Just LL) ->
          (* Octal or Hexadecimal *)
          if AAux.in_min_integer_range n (Signed LongLong) then
            Concrete (Signed LongLong)
          else
            Unknown iCst
      | IConstant n _ (Just ULL) ->
          (* Decimal, Octal or Hexadecimal *)
          if AAux.in_min_integer_range n (Unsigned LongLong) then
            Concrete (Unsigned LongLong)
          else
            Unknown iCst
      | IConstantMax ity ->
          Concrete ity
      | IConstantMin ity ->
          Concrete ity
    end
  else
    (* Non agnostic version *)
    match iCst with
      | IConstant n Decimal Nothing ->
          Concrete <$> try_ranges loc n [ Signed Int_; Signed Long; Signed LongLong ]
      | IConstant n _ Nothing ->
          (* Octal or Hexadecimal *)
          Concrete <$> try_ranges loc n [ Signed Int_; Unsigned Int_
                                        ; Signed Long ; Unsigned Long
                                        ; Signed LongLong; Unsigned LongLong ]
      | IConstant n _ (Just U) ->
          (* Decimal, Octal or Hexadecimal *)
          Concrete <$> try_ranges loc n [ Unsigned Int_; Unsigned Long; Unsigned LongLong ]
      | IConstant n Decimal (Just L) ->
          Concrete <$> try_ranges loc n [ Signed Long; Signed LongLong ]
      | IConstant n _ (Just L) ->
          (* Octal or Hexadecimal *)
          Concrete <$> try_ranges loc n [ Signed Long; Unsigned Long; Signed LongLong; Unsigned LongLong ]
      | IConstant n _ (Just UL) ->
          (* Decimal, Octal or Hexadecimal *)
          Concrete <$> try_ranges loc n [ Unsigned Long; Unsigned LongLong ]
      | IConstant n Decimal (Just LL) ->
          Concrete <$> try_ranges loc n [ Signed LongLong ]
      | IConstant n _ (Just LL) ->
          (* Octal or Hexadecimal *)
          Concrete <$> try_ranges loc n [ Signed LongLong; Unsigned LongLong ]
      | IConstant n _ (Just ULL) ->
          (* Decimal, Octal or Hexadecimal *)
          Concrete <$> try_ranges loc n [ Unsigned LongLong ]
      | IConstantMax ity ->
          E.return (Concrete ity)
      | IConstantMin ity ->
          E.return (Concrete ity)
  end

(* the GCC documentation says "he compound statement should be an expression followed by a semicolon", otherwise the type is void *)
val     typeof_statement_as_expression: statement genTypeCategory -> genTypeCategory
let rec typeof_statement_as_expression stmt =
  let void_gtc = GenRValueType GenVoid in
  match stmt.node with
    | AilSexpr (AnnotatedExpression gtc _ _ _) ->
        gtc
    | AilSlabel _ s _ ->
        typeof_statement_as_expression s
    | AilSmarker _ s ->
        typeof_statement_as_expression s
    | _ ->
        void_gtc
  end


(* STD §6.5.16.1#1 *)
val well_typed_assignment: sigma unit -> bool -> assignment_violation -> Loc.t -> ctype -> genType -> expression genTypeCategory -> E.errorM unit
let well_typed_assignment s is_init f loc ty1 gty2 e2 =
  let throw err =
    E.constraint_violation (with_cursor_from (locOf e2) loc) (f err ty1 gty2)
  in
  if AAux.atomic_qualified_unqualified AAux.is_arithmetic ty1 then
    if GAux.is_arithmetic gty2 then
      let () = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] OK: bullet 1") in (* DEBUG *)
      E.add "§6.5.16.1#1, bullet 1"
    else if AAux.atomic_qualified_unqualified AAux.is_Bool ty1 then
      if GAux.is_pointer gty2 then
        let _ = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] OK: bullet 6") in (* DEBUG *)
        E.add "§6.5.16.1#1, bullet 6"
      else
        throw BoolExpectsArithmeticOrPointer
    else
      throw NotArithmetic
  
  else if AAux.atomic_qualified_unqualified AAux.is_struct_or_union ty1 then
    E.add "§6.5.16.1#1, bullet 2" >>
    match (Cty.unatomic_ ty1, GenTypesAux.unatomic gty2) with
      | (Struct tag_sym1, GenStruct tag_sym2) ->
          (* TODO: this is maybe too conservative *)
          let () = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () ->
            "[well_typed_assignment] exiting with bullet 2 ==> " ^
            Pp.stringFromAil_ctype no_qualifiers ty1 ^ " -- " ^ Pp.stringFromAil_genType gty2) in
          if tag_sym1 = tag_sym2 then
            E.return ()
          else
            throw IncompatibleType
      | (Union tag_sym1, GenUnion tag_sym2) ->
          (* TODO: this is maybe too conservative *)
          let () = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () ->
            "[well_typed_assignment] exiting with bullet 2 ==> " ^
            Pp.stringFromAil_ctype no_qualifiers ty1 ^ " -- " ^ Pp.stringFromAil_genType gty2) in
          if tag_sym1 = tag_sym2 then
            E.return ()
          else
            throw IncompatibleType
      | _ ->
          throw IncompatibleType
    end
  
  else if AAux.atomic_qualified_unqualified AAux.is_pointer ty1 then
    let () = Debug.print_debug 2 [] (fun () ->
      "TODO: check the use of AAux.lvalue_conversion"
    ) in
    AAux.lvalue_conversion s ty1 >>= fun conv_ty1 ->
    let () = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () ->
      "[well_typed_assignment] before bullet 3: conv_ty1= " ^Pp.stringFromAil_ctype no_qualifiers conv_ty1  ^
      " -- gty2= " ^ Pp.stringFromAil_genType gty2) in
    match ((proj_ctype_ (unatomic ty1)), proj_ctype_ conv_ty1, gty2) with
      | (Pointer ref_qs1 _, Pointer _ conv_ref_ty1, GenPointer ref_qs2 ref_ty2) ->
          (* doing the "qualified or unqualified versions of" by checking the compatibility of
             the unqualified referenced type with no qualifiers *)
          (* NOTE: for the left operand, we are looking at the qualifiers before
             conversion (since the lvalue conversion removes the qualifiers) *)
          if    AAux.are_compatible (no_qualifiers, conv_ref_ty1) (no_qualifiers, ref_ty2)
             && AAux.sub_qualifiers ref_qs2 ref_qs1 then
            let _ = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] OK: bullet 3") in (* DEBUG *)
            let () = Debug.print_debug 2 [] (fun () ->
              (* TODO !!!! *)
              "FIXME: sub_qualifiers sees the wrong qualifiers (GenTypeCategory RValue seems to be at fault) !!!!"
            ) in
            E.add "§6.5.16.1#1, bullet 3"
          
          else if (   (AAux.is_object conv_ref_ty1 && AAux.is_void   ref_ty2)
                   || (AAux.is_void   conv_ref_ty1 && AAux.is_object ref_ty2) ) &&
                  AAux.sub_qualifiers ref_qs2 ref_qs1 then
            let _ = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] OK: bullet 4") in (* DEBUG *)
            E.add "§6.5.16.1#1, bullet 4"
          
          else if is_null_pointer_constant e2 then
            let _ = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] OK: bullet 5") in (* DEBUG *)
            E.add "§6.5.16.1#1, bullet 5"
          
          else
            let () = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () ->
              "[well_typed_assignment] KO: is_pointer ty1 && gty2 ==> (ref_qs1, conv_ref_ty1)= " ^
              Pp.stringFromAil_human_ctype ref_qs1 conv_ref_ty1 ^ ", (ref_qs2, ref_ty2)= " ^
              Pp.stringFromAil_human_ctype ref_qs2 ref_ty2
            ) in (* DEBUG *)
            if AAux.are_compatible (no_qualifiers, conv_ref_ty1) (no_qualifiers, ref_ty2) then
              throw DiscardsQualifiers
            else
              throw IncompatiblePointerType
      | _ ->
          if is_null_pointer_constant e2 then
            E.add "§6.5.16.1#1, bullet 5"
          else
            throw IncompatibleType
    end
  
  (* NOTE: bullet 6 is dealt with earlier (look for the code dealing with bullet 1) *)
  else if is_init then
    (* TODO: check *)
    match (proj_ctype_ ty1, gty2) with
      | (Array elem_ty1 n1_opt, GenArray elem_ty2 n2_opt) ->
          if AAux.are_compatible (no_qualifiers, elem_ty1) (no_qualifiers, elem_ty2) then
            match (n1_opt, n2_opt) with
              | (Just n1, Just n2) ->
                  if n1 <> n2 then
                    throw IncompatibleType
                  else
                    E.return ()
              | _ ->
                  E.return ()
            end
          else
            throw IncompatibleType
      | _ ->
          throw IncompatibleType
    end
  else
    let _ = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] KO: the end") in (* DEBUG *)
    throw IncompatibleType


(* STD §6.5.9#2 *)
val well_typed_equality: genType -> genType -> bool -> bool -> bool
let well_typed_equality gty1 gty2 is_null1 is_null2 =
     (* STD §6.5.9#2, item 1 *)
     is_arithmetic gty1 && is_arithmetic gty2
     (* STD §6.5.9#2, item 2 *)
  || are_pointers_to_qualifiedOrUnqualified_compatible_types gty1 gty2
     (* Defacto extension. TODO: make it a specific flag *)
  || (Global.isDefacto () && is_pointer_to_object gty1 && is_pointer_to_object gty2)
     (* STD §6.5.9#2, item 3 *)
  || is_pointer_to_void gty1 && is_pointer_to_object gty2
     (* STD §6.5.9#2, item 3 *)
  || is_pointer_to_object gty1 && is_pointer_to_void gty2
     (* STD §6.5.9#2, item 4 *)
  || is_pointer gty1 && is_null2
     (* STD §6.5.9#2, item 4 *)
  || is_null1 && is_pointer gty2

let guard_violation loc viol b =
  E.guard loc (TError_ConstraintViolation viol) b

let well_typed_binary_arithmetic viol loc_e1 loc_op loc_e2 gt1 aop gt2 =
  let guard bop = guard_violation (with_regions_and_cursor [loc_e1; loc_e2] (Just loc_op)) (viol bop gt1 gt2) in
  match aop with
    | Mul  -> guard MultiplicativeInvalidOperandsType (is_arithmetic gt1 && is_arithmetic gt2)
    | Div  -> guard MultiplicativeInvalidOperandsType (is_arithmetic gt1 && is_arithmetic gt2)
    | Mod  -> guard ModInvalidOperandsType            (is_integer    gt1 && is_integer    gt2)
    | Add  -> guard AdditiveOperandsArithmeticType    (is_arithmetic gt1 && is_arithmetic gt2)
    | Sub  -> guard AdditiveOperandsArithmeticType    (is_arithmetic gt1 && is_arithmetic gt2)
    | Shl  -> guard BitwiseShiftInvalidOperandsType   (is_integer    gt1 && is_integer    gt2)
    | Shr  -> guard BitwiseShiftInvalidOperandsType   (is_integer    gt1 && is_integer    gt2)
    | Band -> guard BitwiseAndInvalidOperandsType     (is_integer    gt1 && is_integer    gt2)
    | Bxor -> guard BitwiseXorInvalidOperandsType     (is_integer    gt1 && is_integer    gt2)
    | Bor  -> guard BitwiseOrInvalidOperandsType      (is_integer    gt1 && is_integer    gt2)
  end


val combine_qualifiers_left: genType -> genType -> genType
let combine_qualifiers_left gty1 gty2 =
  match (gty1, gty2) with
    | (GenPointer qs1 ty1, GenPointer qs2 _) ->
        GenPointer (combine_qualifiers qs1 qs2) ty1
    | (GenPointer _  _ , _) ->
        gty1
    | _ ->
        gty1
  end


val combine_qualifiers_right: genType -> genType -> genType
let combine_qualifiers_right gty1 gty2 =
  match (gty1, gty2) with
    | (GenPointer qs1 _, GenPointer qs2 ty2) ->
        GenPointer (combine_qualifiers qs1 qs2) ty2
    | (_, GenPointer _ _) ->
        gty2
    | _ ->
        gty2
  end

val well_typed_conditionalGNU:
    (Loc.t * Loc.t * Loc.t) ->
    genType -> genType -> E.errorM genTypeCategory
let well_typed_conditionalGNU (loc_cond, loc_e1, loc_e3) gty1 gty3 =
  if is_scalar gty1 then
    E.add "§6.5.15#2" >>
    if is_arithmetic gty3 then
      E.add "§6.5.15#3, bullet 1" >>
      E.add "§6.5.15#5, sentence 1" >>
      E.return (GenRValueType (usual_arithmetic gty3 gty3))
    
    else if GAux.is_struct_or_union gty3 then
      E.add "§6.5.15#3, bullet 2" >>
      E.add "§6.5.15#5, sentence 2" >>
      E.return (GenRValueType gty3)
    
    else if GAux.void gty3 then
      E.add "§6.5.15#3, bullet 3" >>
      E.add "§6.5.15#5, sentence 3" >>
      E.return (GenRValueType GenVoid)
    
    else if GAux.is_pointer gty3 then
      E.add "§6.5.15#3, bullet 4" >>
      E.return (GenRValueType gty3)

    else
      E.constraint_violation (with_cursor_from loc_e3 loc_cond)
        (GNUConditionalOperatorInvalidOperandType gty3)
  else
    E.constraint_violation (with_cursor_from loc_e1 loc_cond) (ConditionalOperatorControlType gty1)


val well_typed_conditional:
    (Loc.t * Loc.t * Loc.t * Loc.t) ->
    genType -> genType -> genType -> bool -> bool -> E.errorM genTypeCategory
let well_typed_conditional (loc_cond, loc_e1, loc_e2, loc_e3) gty1 gty2 gty3 is_null2 is_null3 =
  if is_scalar gty1 then
    E.add "§6.5.15#2" >>
    if is_arithmetic gty2 && is_arithmetic gty3 then
      E.add "§6.5.15#3, bullet 1" >>
      E.add "§6.5.15#5, sentence 1" >>
      E.return (GenRValueType (usual_arithmetic gty2 gty3))
    
    else if GAux.is_struct_or_union gty2 && gty2 = gty3 then
      E.add "§6.5.15#3, bullet 2" >>
      E.add "§6.5.15#5, sentence 2" >>
      E.return (GenRValueType gty2)
    
    else if GAux.void gty2 && GAux.void gty3 then
      E.add "§6.5.15#3, bullet 3" >>
      E.add "§6.5.15#5, sentence 3" >>
      E.return (GenRValueType GenVoid)
    
    else match composite_pointer gty2 gty3 with
      | Just gty ->
          E.add "§6.5.15#3, bullet 4" >>
            E.add "§6.5.15#6" >>
          E.return (GenRValueType gty)
      | Nothing ->
          if is_pointer gty2 && is_null3 then
            E.add "§6.5.15#3, bullet 5" >>
            E.add "§6.5.15#6" >>
            E.return (GenRValueType (combine_qualifiers_left gty2 gty3))
          else if is_pointer gty3 && is_null2 then
            E.add "§6.5.15#3, bullet 5" >>
            E.add "§6.5.15#6" >>
            E.return (GenRValueType (combine_qualifiers_right gty2 gty3))
          else if is_pointer_to_object gty2 && is_pointer_to_void gty3 then
            E.add "§6.5.15#3, bullet 6" >>
            E.add "§6.5.15#6" >>
            E.return (GenRValueType (combine_qualifiers_right gty2 gty3))
          else if is_pointer_to_object gty3 && is_pointer_to_void gty2 then
            E.add "§6.5.15#3, bullet 6" >>
            E.add "§6.5.15#6" >>
            E.return (GenRValueType (combine_qualifiers_left gty2 gty3))
          else
            E.constraint_violation (with_regions_and_cursor [loc_e2; loc_e3] (Just loc_cond))
                                   (ConditionalOperatorInvalidOperandTypes gty2 gty3)
    end
  else
    E.constraint_violation (with_cursor_from loc_e1 loc_cond) (ConditionalOperatorControlType gty1)


val annotate_stringLiteral: stringLiteral -> E.errorM (expression_ genTypeCategory * genTypeCategory)
let annotate_stringLiteral (pref_opt, strs) =
  let elem_ty = match pref_opt with
                  | Nothing     -> char     (* STD §6.4.5#6 sentence 3 *)
                  | Just Enc_u8 -> char     (* STD §6.4.5#6 sentence 4 *)
                  | Just Enc_u  -> char16_t (* STD §6.4.5#6 sentence 6 *)
                  | Just Enc_U  -> char32_t (* STD §6.4.5#6 sentence 6 *)
                  | Just Enc_L  -> wchar_t  (* STD §6.4.5#6 sentence 5 *)
                end in
  (* the acc is initialised with 1 to take into account the trailing '\0' *)
  let sz = List.foldl (fun acc (_, str) -> acc + List.length str) 1 strs in
  E.return
    ( AilEstr (pref_opt, strs)
    , GenLValueType no_qualifiers (Ctype [] (Array elem_ty (Just (integerFromNatural (naturalFromNat sz))))) false )


val     typecheck_constant: Loc.t -> constant -> E.errorM genType
let rec typecheck_constant loc cst =
  match cst with
    | ConstantInteger iCst ->
        gen_typing_type_of_constant loc iCst >>= fun gity ->
        E.return (GenBasic (GenInteger gity))
    | ConstantFloating ((_, suff_opt)) ->
        E.add "§6.4.4.2#4" >>
        let rfty = match suff_opt with
          | Nothing ->
              Double
          | Just Fsuf_F ->
              Float
          | Just Fsuf_L ->
              LongDouble
        end in
        E.return (GenBasic (GenFloating (RealFloating rfty)))
    | ConstantCharacter cc ->
        (* TODO: §6.4.4.4#9 *)
        match fst cc with
          | Nothing ->
              E.add "§6.4.4.4#10" >>
              E.return (GenBasic (GenInteger (Concrete (Signed Int_))))
          | Just Pref_L ->
              E.add "§6.4.4.4#11" >>
              E.return (GenBasic (GenInteger (Concrete (Wchar_t))))
          | Just Pref_u ->
              E.add "§6.4.4.4#11" >>
              E.return genChar16_t
          | Just Pref_U ->
              E.add "§6.4.4.4#11" >>
              E.return genChar32_t
        end
    | ConstantArray elem_ty csts ->
        (* TODO: this is probably too strong *)
        E.mapM (typecheck_constant loc) csts >>= function
          | [] ->
              error "typecheck_constant: empty array constant"
          | gtys ->
              (* TODO !!!! *)
              E.return (GenArray elem_ty (Just $ integerFromNat (List.length csts)))
        end
    | ConstantIndeterminate ty ->
        E.return (GenTypes.inject_type ty)
    | ConstantNull ->
        (* TODO: check *)
        E.return (GenPointer no_qualifiers (Ctype [] Void))
    | ConstantStruct tag_sym xs ->
        E.mapM (fun (memb_ident, cst) ->
          (* TODO: need to check that the members type match ... *)
          typecheck_constant loc cst >>= fun gty ->
          E.return (memb_ident, gty)
        ) xs >>= fun xs_gtys ->
        E.return (GenTypes.GenStruct tag_sym)
    | ConstantUnion tag_sym memb_ident cst ->
          (* TODO: need to check that the members type match ... *)
        typecheck_constant loc cst >>= fun gty_membr ->
        E.return (GenTypes.GenUnion tag_sym)
    | ConstantPredefined PConstantFalse ->
        (* STD C23 §6.4.4.5#3 *)
        E.return (GenTypes.GenBasic (GenTypes.GenInteger (GenTypes.Concrete Bool)))
    | ConstantPredefined PConstantTrue ->
        (* STD C23 §6.4.4.5#3 *)
        E.return (GenTypes.GenBasic (GenTypes.GenInteger (GenTypes.Concrete Bool)))
  end

val annotate_rvalue:
  (sigma unit -> gamma -> bindings -> list (statement unit) -> E.errorM (list (statement genTypeCategory))) ->
  sigma unit -> gamma -> expression unit -> E.errorM (expression genTypeCategory * genType)
val annotate_assignee:
  (sigma unit -> gamma -> bindings -> list (statement unit) -> E.errorM (list (statement genTypeCategory))) ->
  sigma unit -> gamma -> bool -> assignment_violation -> Loc.t -> ctype -> expression unit -> E.errorM (expression genTypeCategory)
val annotate_arguments:
  (sigma unit -> gamma -> bindings -> list (statement unit) -> E.errorM (list (statement genTypeCategory))) ->
  sigma unit -> gamma -> Loc.t -> bool -> list (expression unit) -> maybe (list (qualifiers * ctype * bool)) ->
  E.errorM (list (expression genTypeCategory))

(* context given to [annotate_expression] to inform it on the what the current
   expression is: *)
type annotation_context =
    (* operand of AilEsizeof_expr *)
  | CTXsizeof
    (* operand of AilEunary Address *)
  | CTXaddr
    (* operand of AilEunary PostfixIncr *)
  | CTXincr
    (* operand of AilEunary PostfixDecr *)
  | CTXdecr
    (* left operand of AilEmemberof *)
  | CTXmemberof
    (* left operand of AilEassign or AilEcompoundAssign *)
  | CTXassign
    (* array initialiser (used by AilEstr) *)
  | CTXarray_init
    (* otherwise *)
  | CTXother

val annotate_expression:
  (sigma unit -> gamma -> bindings -> list (statement unit) -> E.errorM (list (statement genTypeCategory))) ->
  sigma unit -> gamma -> annotation_context -> expression unit -> E.errorM (expression genTypeCategory)
let rec annotate_expression annotate_block sigm gamm ctx (AnnotatedExpression () std_annots loc expr_) =
  let annotate_expression = annotate_expression annotate_block sigm gamm in
  let annotate_rvalue     = annotate_rvalue annotate_block sigm gamm     in
  let annotate_assignee   = annotate_assignee annotate_block sigm gamm   in
  let annotate_arguments loc is_variadic args = function
    | Just params ->
        annotate_arguments_aux false annotate_block sigm gamm (List.length args) (List.length params) loc is_variadic args params
    | Nothing ->
        error "annotate_arguments ==> no proto"
  end in
  let annotate_and_cast_arguments loc is_variadic args = function
    | Just params ->
        annotate_arguments_aux true annotate_block sigm gamm (List.length args) (List.length params) loc is_variadic args params
    | Nothing ->
        error "annotate_and_cast_arguments ==> no proto"
  end in
  match expr_ with
    | AilEunary (Plus as uop) e ->
        (* STD §6.5.3.3#1, sentence 1 *)
        E.add "§6.5.3.3#1, sentence 1" >>
        annotate_rvalue e >>= fun (a_e, gty) ->
        if is_arithmetic gty then
          let mk_conversion =
            if is_integer gty then integer_promote else id in
          E.return (AilEunary uop a_e, GenRValueType (mk_conversion gty))
        else
          E.constraint_violation (with_cursor_from (locOf e) loc) (InvalidArgumentTypeUnaryExpression gty)
    
    | AilEunary (Minus as uop) e ->
        (* STD §6.5.3.3#1, sentence 1 *)
        E.add "§6.5.3.3#1, sentence 1" >>
        annotate_rvalue e >>= fun (a_e, gty) ->
        if is_arithmetic gty then
          let mk_conversion =
            if is_integer gty then integer_promote else id in
          E.return (AilEunary uop a_e, GenRValueType (mk_conversion gty))
        else
          E.constraint_violation (with_cursor_from (locOf e) loc) (InvalidArgumentTypeUnaryExpression gty)
    
    | AilEunary (Bnot as uop) e ->
        (* STD §6.5#4, sentence 1 *)
        (* STD §6.5.3.3#1, sentence 2 *)
        E.add "STD §6.5#4, sentence 1" >>
        E.add "STD §6.5.3.3#1, sentence 2" >>
        annotate_rvalue e >>= fun (a_e, gty) ->
        if is_integer gty then
          E.return (AilEunary uop a_e, GenRValueType (integer_promote gty))
        else
          E.constraint_violation (with_cursor_from (locOf e) loc) (InvalidArgumentTypeUnaryExpression gty)
    
    | AilEunary Address e ->
        (* STD §6.5.3.2#1 *)
        E.add "§6.5.3.2#1" >>
        annotate_expression CTXaddr e >>= fun a_e ->
        match GenTypes.genTypeCategoryOf a_e with
          | GenRValueType (GenFunction ty params isVariadic) ->
              (* e is a 'function designator' *)
              let gty' = GenPointer no_qualifiers (Ctype [] (Function ty params isVariadic)) in
              E.return (AilEunary Address a_e, GenRValueType gty')
          | GenRValueType gty ->
              E.constraint_violation (with_cursor_from (locOf e) loc) (UnaryAddressNotRvalue gty)
          | GenLValueType qs ty isRegister ->
              (* e is an 'lvalue' *)
              let () = Debug.warn [Debug.DB_ail_typing]
                 (fun () -> "(TODO) GenTyping.annotate_expression AilEunary Address, not checking for bit-field member") in
              if isRegister then
                E.constraint_violation (with_cursor_from (locOf e) loc) UnaryAddressRegisterLvalue
              else
                E.add "§6.5.3.2#3, 2nd sentence" >>
                E.return (AilEunary Address a_e, GenRValueType (GenPointer qs ty))
        end
    
    | AilEunary Indirection e ->
        annotate_rvalue e >>= fun (e', gty) ->
        match gty with
          | GenPointer ref_qs ref_ty ->
              E.add "§6.5.3.2#4, sentence 2" >>
              E.add "§6.5.3.2#4, sentence 3" >>
              if AAux.is_object ref_ty then
                (* *)
                E.return (AilEunary Indirection e', GenLValueType ref_qs ref_ty false)
              else
                (* TODO: check that it's ok to drop the qualifiers *)
                E.return (AilEunary Indirection e', GenRValueType (inject_type ref_ty))
          | _ ->
              E.constraint_violation (with_cursor_from (locOf e) loc) IndirectionNotPointer
        end
    
    | AilEunary (PostfixIncr as uop) e ->
        annotate_expression CTXincr e >>= fun e' ->
        match GenTypes.genTypeCategoryOf e' with
          | GenLValueType qs' ty' _ ->
              (* TODO(check): why are we doing an lvalue coercion here? *)
              AAux.lvalue_coercion sigm ty' >>= fun ty' ->
              (* NOTE: the STD at §6.5.3#1 doesn't directly says that pointer operand must be to
                       complete object type, but then #2 defers to §6.5.6#2 which does. *)
              if AAux.modifiable sigm qs' ty' && (AAux.atomic_qualified_unqualified AAux.is_real ty' ||
                                                  AAux.atomic_qualified_unqualified (AAux.is_pointer_to_complete_object sigm) ty') then
                E.return (AilEunary uop e', GenRValueType (inject_type ty'))
              else
                E.constraint_violation (with_cursor_from (locOf e) loc) (InvalidArgumentTypeUnaryIncrement ty')
          | _ ->
            E.constraint_violation (with_cursor_from (locOf e) loc) UnaryExpressionNotLvalue
        end
    
    | AilEunary (PostfixDecr as uop) e ->
        annotate_expression CTXdecr e >>= fun e' ->
        match GenTypes.genTypeCategoryOf e' with
          | GenLValueType qs' ty' _ ->
              (* TODO(check): why are we doing an lvalue coercion here? *)
              AAux.lvalue_coercion sigm ty' >>= fun ty' ->
              (* NOTE: the STD at §6.5.3#1 doesn't directly says that pointer operand must be to
                       complete object type, but then #2 defers to §6.5.6#2 which does. *)
              if AAux.modifiable sigm qs' ty' && (AAux.atomic_qualified_unqualified AAux.is_real ty' ||
                                                  AAux.atomic_qualified_unqualified (AAux.is_pointer_to_complete_object sigm) ty') then
                E.return (AilEunary uop e', GenRValueType (inject_type ty'))
              else
                E.constraint_violation (with_cursor_from (locOf e) loc) (InvalidArgumentTypeUnaryDecrement ty')
          | _ ->
            E.constraint_violation (with_cursor_from (locOf e) loc) UnaryExpressionNotLvalue
        end
    
    | AilEarray is_str elem_ty e_opts ->
        (* TODO: think about it *)
        E.mapM (maybe (E.return Nothing) (fun e ->
          if AilTypesAux.is_array elem_ty then
            annotate_rvalue e >>= fun (e', gty) ->
            let () = Debug.warn [] (fun () ->
              "TODO!!! Ail's typing is not properly checking AilEarray when elem_ty is an array type"
            ) in
            E.return (Just e')
          else
            E.add "§6.7.9#11" >>
            (* TODO: unqualify elem_ty? *)
            (Just <$> annotate_assignee true InitializationAsSimpleAssignment loc elem_ty e)
(*
          annotate_rvalue e >>= fun (e', gty) ->
          (* TODO: maybe this is too strict and we want to relax to only having
             the types compatibles? *)
          if inject_type elem_ty <> gty then
            let () = Debug.print_debug 2 [] (fun () ->
              "elem_ty: " ^ Pp.stringFromAil_ctype no_qualifiers elem_ty
            ) in
            let () = Debug.print_debug 2 [] (fun () ->
              "gty: " ^ Pp.stringFromAil_genType gty
            ) in
            let () = Debug.print_debug 2 [] (fun () ->
              "expr: " ^ Pp.stringFromAil_expression expr
            ) in
            E.fail loc (TError "illtyped element of an AilEarray")
          else
            E.return (Just e')
*)
        )) e_opts >>= fun xs ->
        (* TODO: checking that the types in [xs] match ty *)
        E.return ( AilEarray is_str elem_ty xs
                 , GenRValueType (GenArray elem_ty (Just (integerFromNat $ List.length xs))) )
    
    | AilEstruct tag_sym xs ->
        let struct_gty = GenStruct tag_sym in
        match lookup_tag_definition sigm tag_sym with
          | Just (StructDef membersDefs _) ->
              (* NOTE: the potential flexible array member is never prevent in the list of expressions
                       (as it cannot be initialised with an initializer) *)
              if List.length xs <> List.length membersDefs then
                error "TODO: AilEstruct not the right number of members"
              else
                E.mapM (fun (memb_ident, e_opt) ->
                  match List.lookup memb_ident membersDefs with
                    | Just (_, align_opt, memb_qs, memb_ty) ->
                        maybe (E.return (memb_ident, Nothing)) (fun e ->
                          annotate_assignee true InitializationAsSimpleAssignment loc memb_ty e >>= fun a_e ->
                          E.return (memb_ident, Just a_e)
                        ) e_opt
                    | Nothing ->
                        E.constraint_violation loc (MemberofNoMemberRvalue memb_ident struct_gty)
                  end
                ) xs >>= fun a_xs ->
                E.return (AilEstruct tag_sym a_xs, GenRValueType struct_gty)
          | _ ->
              error "annotate_expression(AilEstruct): failed to find a valid tag definition"
        end
    
    | AilEunion tag_sym memb_ident Nothing ->
        E.return (AilEunion tag_sym memb_ident Nothing, GenRValueType (GenUnion tag_sym))
    | AilEunion tag_sym memb_ident (Just e) ->
        let union_gty = GenUnion tag_sym in
        match lookup_tag_definition sigm tag_sym with
          | Just (UnionDef membersDefs) ->
              match List.lookup memb_ident membersDefs with
                | Just (_, align_opt, _, memb_ty) ->
                    annotate_assignee true InitializationAsSimpleAssignment loc memb_ty e >>= fun a_e ->
                    E.return (AilEunion tag_sym memb_ident (Just a_e), GenRValueType union_gty)
                | Nothing ->
                    E.constraint_violation loc (MemberofNoMemberRvalue memb_ident union_gty)
              end
          | _ ->
              error "annotate_expression(AilEunion): failed to find a valid tag definition"
        end
    
    | AilEcompound qs ty e ->
        (* STD §6.5.2.5#1 *)
        E.add "§6.5.2.5#1" >>
        if    (AAux.is_complete sigm ty && AAux.is_object ty)
           || (AAux.is_array_unknown_size ty && not (AAux.is_vla ty)) then
          (* TODO: check that *)
          annotate_definition_aux annotate_block sigm gamm (ty, e) >>= fun a_e ->
          E.add "§6.5.2.5#4" >>
          E.return (AilEcompound qs ty a_e, GenLValueType qs ty false)
        else
          E.constraint_violation loc InvalidTypeCompoundLiteral

    | AilEbuiltin b ->
        match b with
          | AilBatomic _ ->
              E.misc (Loc.with_cursor loc) GenericFunctionMustBeDirectlyCalled
          | AilBlinux _ ->
              E.misc (Loc.with_cursor loc) GenericFunctionMustBeDirectlyCalled
          | AilBcopy_alloc_id ->
              E.misc (Loc.with_cursor loc) GenericFunctionMustBeDirectlyCalled
          | AilBCHERI _ ->
              E.misc (Loc.with_cursor loc) GenericFunctionMustBeDirectlyCalled
          (* NOTE: other builtins might not need to be call directly *)
        end
(*

(GenBasic (GenInteger (Concrete ity))))


        (* TODO: check *)
        let ity = match str with
          | "INT8_MIN" ->
              Signed Int_
          | "INT16_MIN" ->
              Signed Int_
          | "INT32_MIN" ->
              Signed Int_ (* TODO: this might not fit in a signed int ... *)
          | "INT64_MIN" ->
              Signed Long
          | "INT8_MAX" ->
              Signed Int_
          | "INT16_MAX" ->
              Signed Int_
          | "INT32_MAX" ->
              Signed Int_ (* TODO: this might not fit in a signed int ... *)
          | "INT64_MAX" ->
              Signed Long
          | "UINT8_MAX" ->
              Unsigned Int_
          | "UINT16_MAX" ->
              Unsigned Int_
          | "UINT32_MAX" ->
              Unsigned Int_ (* TODO: this might not fit in a signed int ... *)
          | "UINT64_MAX" ->
              Unsigned Long
          | _ ->
              error ("WIP typing, AilEbuiltin: " ^ str)
        end in
        E.return (AilEbuiltin str, GenRValueType (GenBasic (GenInteger (Concrete ity))))
*)
    
    | AilEident sym ->
        match (List.lookup sym gamm, List.lookup sym sigm.declarations) with
          | (Just ((_, _, isRegister), _, qs, ty), Nothing) ->
              let () = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () ->
                "[AilEident (gamma)] " ^ show sym ^ " -- " ^ Pp.stringFromAil_ctype qs ty
              ) in
              E.return (AilEident sym, GenLValueType qs ty isRegister)
          | (Nothing, Just (_, _, Decl_object (_, isRegister) _ qs ty)) ->
              let () = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () ->
                "[AilEident (sigma)] " ^ show sym ^ " -- " ^ Pp.stringFromAil_ctype qs ty
              ) in
              E.return (AilEident sym, GenLValueType qs ty isRegister)
          | (Nothing, Just (_, _, Decl_function has_proto (ret_qs, ret_ty) params is_variadic _ (* is_inline *) _ (* is_Noreturn *))) ->
              (* TODO: is_inline, is_Noreturn *)
              (* NOTE: here sym is a 'function designator', hence it has function type. BUT
                 other part of the typechecker MUST perform the 'function_coercion' as described in
                 (§6.3.2.1#4). *)
              E.return (AilEident sym, GenRValueType (inject_type (Ctype [Annot.Aloc loc] (Function (ret_qs, ret_ty) params is_variadic))))
          | _ ->
              error ("gentpying.annotate_expression: AilEident symbol couldn't be resolved => " ^ show sym)
        end
    
    | AilEbinary e1 Comma e2 ->
        E.add "§6.5.17#3, sentence 3" >>
        annotate_rvalue e1 >>= fun (e1', _  ) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        E.return (AilEbinary e1' Comma e2', GenRValueType gty2)
    
    | AilEcall (AnnotatedExpression _ annots' loc' (AilEbuiltin b)) args ->
        let loc_cursor = Loc.with_cursor loc' in
        let memorder_ty = Ctype [] $ Basic (Integer (Signed (Int_))) (* TODO: actually memory_order enum *) in
        match (b, args) with
        | (AilBatomic AilBAstore, object_e :: desired_e :: order_e :: args) ->
            annotate_rvalue object_e >>= fun (object_e',  object_gty)  ->
            match object_gty with
              | GenPointer qs object_ty ->
                  let params_wo_ptr = [(qs, Ctype [] $ unatomic_ object_ty, false); (no_qualifiers, memorder_ty, false)] in
                  let gen_fun_ty = GenRValueType (GenFunction (qs, Ctype [] Void) ((qs, Ctype [] $ Pointer qs object_ty, false) :: params_wo_ptr) false) in
                  guard_violation loc_cursor (AtomicAddressArgumentMustBeAtomic AtomicStore object_ty) (AAux.is_atomic object_ty) >>= fun () ->
                  annotate_arguments loc_cursor false (desired_e :: order_e :: args) (Just params_wo_ptr) >>= fun es' ->
                  match memory_order_of_expr order_e with
                  | Just Cmm_csem.Acquire ->
                    E.undef loc_cursor Undefined.UB205_atomic_store_memorder
                  | Just Cmm_csem.Consume ->
                    E.undef loc_cursor Undefined.UB205_atomic_store_memorder
                  | Just Cmm_csem.Acq_rel ->
                    E.undef loc_cursor Undefined.UB205_atomic_store_memorder
                  | _ ->
                    E.return (AilEcall (AnnotatedExpression gen_fun_ty annots' loc' $ AilEbuiltin b) (object_e' :: es')
                             , GenRValueType GenVoid)
                  end
              | gty ->
                  E.constraint_violation loc_cursor $ AtomicAddressArgumentMustBePointer AtomicStore gty
            end
        
        | (AilBatomic AilBAload, object_e :: order_e :: args) ->
            annotate_rvalue object_e >>= fun (object_e', object_gty) ->
            match object_gty with
              | GenPointer qs object_ty ->
                  let ret_ty = Ctype [] (unatomic_ object_ty) in
                  let params_wo_ptr = [(no_qualifiers, memorder_ty, false)] in
                  let gen_fun_ty = GenRValueType (GenFunction (qs, ret_ty) ((qs, Ctype [] $ Pointer qs object_ty, false) :: params_wo_ptr) false) in
                  guard_violation loc_cursor (AtomicAddressArgumentMustBeAtomic AtomicLoad object_ty) (AAux.is_atomic object_ty) >>= fun () ->
                  annotate_arguments loc_cursor false (order_e :: args) (Just params_wo_ptr) >>= fun es' ->
                  match memory_order_of_expr order_e with
                  | Just Cmm_csem.Release ->
                    E.undef loc_cursor Undefined.UB206_atomic_load_memorder
                  | Just Cmm_csem.Acq_rel ->
                    E.undef loc_cursor Undefined.UB206_atomic_load_memorder
                  | _ ->
                    E.return (AilEcall (AnnotatedExpression gen_fun_ty annots' loc' $ AilEbuiltin b) (object_e' :: es')
                             , GenRValueType (inject_type ret_ty))
                  end
              | gty ->
                  E.constraint_violation loc_cursor $ AtomicAddressArgumentMustBePointer AtomicLoad gty
            end
        
        | (AilBatomic AilBAexchange, object_e :: args) ->
            annotate_rvalue object_e >>= fun (object_e', object_gty) ->
            match object_gty with
              | GenPointer qs object_ty ->
                  let ret_ty = Ctype [] (unatomic_ object_ty) in
                  let params_wo_ptr = [(qs, ret_ty, false); (no_qualifiers, memorder_ty, false)] in
                  let gen_fun_ty = GenRValueType (GenFunction (qs, ret_ty) ((qs, Ctype [] $ Pointer qs object_ty, false) :: params_wo_ptr) false) in
                  guard_violation loc_cursor (AtomicAddressArgumentMustBeAtomic AtomicExchange object_ty) (AAux.is_atomic object_ty) >>= fun () ->
                  annotate_arguments loc_cursor false args (Just params_wo_ptr) >>= fun es' ->
                  E.return (AilEcall (AnnotatedExpression gen_fun_ty annots' loc' $ AilEbuiltin b) (object_e' :: es')
                           , GenRValueType (inject_type ret_ty))
              | gty ->
                  E.constraint_violation loc_cursor $ AtomicAddressArgumentMustBePointer AtomicExchange gty
            end
        
        | (AilBatomic AilBAcompare_exchange_strong, object_e :: expected_e :: desired_e :: order_success_e :: order_failure_e :: args) ->
            annotate_rvalue object_e  >>= fun (object_e', object_gty) ->
            match object_gty with
              | GenPointer qs object_ty ->
                  let ty = Ctype [] $ unatomic_ object_ty in
                  let params_wo_ptr = [(qs, Ctype [] $ Pointer qs ty, false); (qs, ty, false);
                                       (no_qualifiers, memorder_ty, false); (no_qualifiers, memorder_ty, false)] in
                  let gen_fun_ty = GenRValueType $GenFunction (no_qualifiers, Ctype [] $ Basic (Integer Bool))
                                       ((qs, Ctype [] $ Pointer qs object_ty, false) :: params_wo_ptr) false in
                  guard_violation loc_cursor (AtomicAddressArgumentMustBeAtomic AtomicCompareExchange object_ty) (AAux.is_atomic object_ty) >>= fun () ->
                  let (params1, params2) = List.splitAt 2 params_wo_ptr in
                  annotate_and_cast_arguments loc_cursor false [expected_e; desired_e] (Just params1)             >>= fun args1 ->
                  annotate_arguments loc_cursor false (order_success_e :: order_failure_e :: args) (Just params2) >>= fun args2 ->
                  (* TODO: The failure argument shall be no stronger than the success argument. *)
                  match memory_order_of_expr order_failure_e with
                  | Just Cmm_csem.Release ->
                    E.undef loc_cursor Undefined.UB207_atomic_compare_exchange_memorder
                  | Just Cmm_csem.Acq_rel ->
                    E.undef loc_cursor Undefined.UB207_atomic_compare_exchange_memorder
                  | _ ->
                    E.return (AilEcall (AnnotatedExpression gen_fun_ty annots' loc' $ AilEbuiltin b) (object_e' :: args1 ++ args2)
                             , GenRValueType (GenBasic (GenInteger (Concrete Bool))))
                  end
              | gty ->
                  E.constraint_violation loc_cursor $ AtomicAddressArgumentMustBePointer AtomicCompareExchange gty
            end
        
        | (AilBatomic AilBAcompare_exchange_weak, object_e :: expected_e :: desired_e :: order_success_e :: order_failure_e :: args) ->
            annotate_rvalue object_e  >>= fun (object_e', object_gty) ->
            match object_gty with
              | GenPointer qs object_ty ->
                  let ty = Ctype [] $ unatomic_ object_ty in
                  let params_wo_ptr = [(qs, Ctype [] $ Pointer qs ty, false); (qs, ty, false);
                                       (no_qualifiers, memorder_ty, false); (no_qualifiers, memorder_ty, false)] in
                  let gen_fun_ty = GenRValueType $GenFunction (no_qualifiers, Ctype [] $ Basic (Integer Bool))
                                       ((qs, Ctype [] $ Pointer qs object_ty, false) :: params_wo_ptr) false in
                  guard_violation loc_cursor (AtomicAddressArgumentMustBeAtomic AtomicCompareExchange object_ty) (AAux.is_atomic object_ty) >>= fun () ->
                  let (params1, params2) = List.splitAt 2 params_wo_ptr in
                  annotate_and_cast_arguments loc_cursor false [expected_e; desired_e] (Just params1)             >>= fun args1 ->
                  annotate_arguments loc_cursor false (order_success_e :: order_failure_e :: args) (Just params2) >>= fun args2 ->
                  (* TODO: The failure argument shall be no stronger than the success argument. *)
                  match memory_order_of_expr order_failure_e with
                  | Just Cmm_csem.Release ->
                    E.undef loc_cursor Undefined.UB207_atomic_compare_exchange_memorder
                  | Just Cmm_csem.Acq_rel ->
                    E.undef loc_cursor Undefined.UB207_atomic_compare_exchange_memorder
                  | _ ->
                    E.return (AilEcall (AnnotatedExpression gen_fun_ty annots' loc' $ AilEbuiltin b) (object_e' :: args1 ++ args2)
                             , GenRValueType (GenBasic (GenInteger (Concrete Bool))))
                  end
              | gty ->
                  E.constraint_violation loc_cursor $ AtomicAddressArgumentMustBePointer AtomicCompareExchange gty
            end
        
        | (AilBlinux AilBLfence, [order_e]) ->
           annotate_rvalue order_e  >>= fun (order_e' , order_gty) ->
           E.return (AilEcall (AnnotatedExpression (GenRValueType GenVoid) annots' loc' (AilEbuiltin b)) [order_e'], GenRValueType GenVoid)
        
        | (AilBlinux AilBLread, [object_e; order_e]) ->
           annotate_rvalue object_e >>= fun (object_e', object_gty) ->
           annotate_rvalue order_e  >>= fun (order_e' , order_gty ) ->
           match (object_gty) with
             | (GenPointer qs object_ty) ->
                 E.return ( AilEcall (AnnotatedExpression ((* TODO: HACK *)GenRValueType GenVoid) annots' loc' (AilEbuiltin b)) [object_e';order_e']
                          , GenRValueType (inject_type $ Ctype [] (unatomic_ object_ty)) )
             | _ ->
                 error "WIP: typing of linux_read"
           end
        
       | (AilBlinux AilBLwrite, [object_e; desired_e; order_e]) ->
           annotate_rvalue object_e  >>= fun (object_e',  object_gty)  ->
           annotate_rvalue desired_e >>= fun (desired_e', desired_gty) ->
           annotate_rvalue order_e   >>= fun (order_e' , order_gty )   ->
           E.return (AilEcall (AnnotatedExpression (GenRValueType GenVoid) annots' loc' (AilEbuiltin b)) [object_e'; desired_e'; order_e'],
                     GenRValueType GenVoid)
        
       | (AilBlinux AilBLrmw, [object_e; desired_e; order_e]) ->
           annotate_rvalue object_e  >>= fun (object_e',  object_gty)  ->
           annotate_rvalue desired_e >>= fun (desired_e', desired_gty) ->
           annotate_rvalue order_e   >>= fun (order_e' , order_gty )   ->
           match (object_gty) with
             | (GenPointer qs object_ty) ->
                 E.return (AilEcall (AnnotatedExpression ((* TODO: HACK *)
   GenRValueType GenVoid) annots' loc' (AilEbuiltin b))
   [object_e'; desired_e'; order_e'], GenRValueType (inject_type $ Ctype [] (unatomic_ object_ty)))
             | _ ->
                 error "WIP: typing of linux_rmw"
           end
       | (AilBcopy_alloc_id, [from_e; to_e]) ->
            let ret_ty = mk_ctype_pointer no_qualifiers void in
            let params = [(no_qualifiers, uintptr_t, false); (no_qualifiers, mk_ctype_pointer no_qualifiers void, false)] in
            annotate_arguments loc_cursor false [from_e; to_e] (Just params) >>= fun es' ->
            E.return (AilEcall begin
              AnnotatedExpression (GenRValueType (GenFunction (no_qualifiers, ret_ty) params false)) annots' loc' (AilEbuiltin b)
            end es', GenRValueType (inject_type ret_ty))
       |  (AilBCHERI str, _) ->
            match Mem.get_intrinsic_type_spec str with
              | Nothing ->
                  error ("TODO(msg) unknown CHERI intrinsics '" ^ str ^ "'")
              | Just spec ->
                  let params_n = List.length (snd spec) in
                  let args_n = List.length args in
                  if params_n <> args_n then
                    error ("TODO(msg) CHERI intrinsics '" ^ str ^ "' expecting " ^ show params_n ^
                           " arguments but is given " ^ show args_n)
                  else
                    E.mapM annotate_rvalue args >>= fun xs ->
                    E.mapM (fun (e, gty) ->
                      GenTypesAux.interpret_genType loc (Implementation.integerImpl ()) gty >>= fun ty ->
                      E.return (ty, AilSyntaxAux.is_null_pointer_constant e)
                    ) xs >>= fun tys ->
                    (* let () = Debug.print_debug 0 [] (fun () ->
                      "===> tys: " ^ (stringFromList (Pp.stringFromAil_ctype no_qualifiers) tys) ^
                      "--- specs: " ^ show specs
                    ) in *)
                    match Mem_common.derive_intrinsic_signature tys spec with
                      | Right (ret_ty, args_tys) ->
                          (* let () = Debug.print_debug 0 [] (fun () ->
                            "===> args_tys: " ^ (stringFromList (Pp.stringFromAil_ctype no_qualifiers) args_tys)
                          ) in
                          let () = Debug.print_debug 0 [] (fun () ->
                            "===> args: " ^ (stringFromList (Pp.stringFromAil_expression) args)
                          ) in *)
                          let params = List.map (fun ty -> (no_qualifiers, ty, false)) args_tys in
                          annotate_arguments loc false args (Just params) >>= fun args' ->
                          let cast_args =
                            Utils.map2 (fun ty e ->
                              AnnotatedExpression (GenRValueType (inject_type ty)) [] (Loc.locOf e) (AilEcast no_qualifiers ty e)
                            ) args_tys args' in
                          E.return (AilEcall begin
                            AnnotatedExpression (GenRValueType (GenFunction (no_qualifiers, ret_ty) params false)) annots' loc' (AilEbuiltin b)
                          end cast_args, GenRValueType (inject_type ret_ty))
                      | Left msg ->
                          error ("TODO(msg) CHERI intrinsics failed to derive signature ==> " ^ msg)
                    end
              end
       | (_, _) ->
            error "WIP: typing builtin"
    end
    
    (* TODO: this is wrong in so many ways!! *)
    | AilEcall (AnnotatedExpression _ annots' loc' (AilEident (Symbol.Symbol digest s (Symbol.SD_Id "atomic_thread_fence")))) [order_e] ->
        (* TODO: do typechecking *)
        annotate_rvalue order_e >>= fun (order_e', order_gty) ->
        E.return (AilEcall (AnnotatedExpression (GenRValueType GenVoid) annots' loc' (AilEident (Symbol.Symbol digest s (Symbol.SD_Id "atomic_thread_fence")))) [order_e'], GenRValueType GenVoid)
    
    | AilEcall e es ->
        E.add "§6.5.2.2#1" >>
        let check_return_type ret_ty =
          if not (AAux.is_void ret_ty || AAux.is_complete_object sigm ret_ty) then
            if AAux.is_array ret_ty then
              E.constraint_violation loc (FunctionCallArrayReturnType ret_ty)
            else
              E.constraint_violation loc (FunctionCallIncompleteReturnType ret_ty)
            else
              E.return () in
        annotate_rvalue e >>= function
          | (e', GenPointer qs (Ctype _ (FunctionNoParams (ret_qs, ret_ty)))) ->
              check_return_type ret_ty >>= fun () ->
              if AAux.is_unqualified qs then
                match es with
                  | [] ->
                      E.return (AilEcall e' [], GenRValueType (inject_type ret_ty))
                  | _ ->
                      (* TODO: proper error message *)
                      error "passing arguments to a function without a prototype is not supported (not supported by ISO starting from C2X"
                end
              else
                error "annotate_expression(AilEcall): function decay pointer should not be qualified"
          | (e', GenPointer qs (Ctype _ (Function (ret_qs, ret_ty) params is_variadic))) ->
              check_return_type ret_ty >>= fun () ->
              (* TODO: do we need to check if qs is unqualified? *)
              if AAux.is_unqualified qs then
                annotate_arguments (locOf e) is_variadic es (Just params) >>= fun es' ->
                E.return (AilEcall e' es', GenRValueType (inject_type ret_ty))
              else
                error "annotate_expression(AilEcall): function decay pointer should not be qualified"
          | (_, gty) ->
              E.constraint_violation loc FunctionCallIncorrectType
        end
    
    | AilEassert e ->
        annotate_rvalue e >>= fun (e', gty) ->
        if is_scalar gty then
          E.add "§7.2.1.1#2" >>
          E.return (AilEassert e', GenRValueType GenVoid)
        else
          E.constraint_violation loc AssertMacroExpressionScalarType
    
    | AilEoffsetof ty ident ->
        E.return (AilEoffsetof ty ident, GenRValueType (GenBasic (GenInteger SizeT)))
    
    | AilEgeneric (* e gas *) _ _ ->
        E.fail loc (TError_NotYetSupported "C11 generic selection")
    
    | AilEmemberof e memb_ident ->
        (* TODO: factorise *)
        annotate_expression CTXmemberof e >>= fun a_e ->
        (* the value of the AilEmemberof operator is an lvalue if [e] is an lvalue *)
        match GenTypes.genTypeCategoryOf a_e with
          | GenLValueType qs ty _ ->
              (* NOTE: the member is not a "register" regardless of whether the
                 struct/union was *)
              (* NOTE: the qualifiers of the value are the combination of the ones
                of the left operand [e] and the ones in the declaration of the
                 member type (see §6.5.2.3#3 and #8) *)
              (* NOTE: we use unatomic_ here because §6.5.2.3#1 says the first operand must be
                 "atomic, qualified, or unqualified structure or union type" *)
              if AAux.is_incomplete sigm ty then
                  E.constraint_violation (locOf e) (MemberofIncompleteLvalue qs ty)
              else match unatomic_ ty with
                | Struct tag_sym ->
                    let do_fail =
                      E.constraint_violation (Loc.with_cursor_from (Loc.locOf e) (Loc.locOf memb_ident))
                        (MemberofNoMemberLvalue memb_ident qs ty) in
                    match lookup_tag_definition sigm tag_sym with
                      | Just (StructDef membersDefs flexible_opt) ->
                          match (List.lookup memb_ident membersDefs, flexible_opt) with
                            | (Just (_, align_opt, memb_qs, memb_ty), _) ->
                                E.return ( AilEmemberof a_e memb_ident
                                         , GenLValueType (combine_qualifiers qs memb_qs) memb_ty false )
                            | (Nothing, Just (FlexibleArrayMember attrs flex_ident flex_qs flex_elem_ty)) ->
                                if memb_ident = flex_ident then
                                  E.return ( AilEmemberof a_e memb_ident
                                           , GenLValueType (combine_qualifiers qs flex_qs) (Ctype [] (Array flex_elem_ty Nothing)) false )
                                else
                                  do_fail
                            | (Nothing, Nothing) ->
                                do_fail
                          end
                      | _ ->
                          error "annotate_expression(AilEmemberof struct): failed to find a valid tag definition"
                    end
                | Union tag_sym ->
                    match lookup_tag_definition sigm tag_sym with
                      | Just (UnionDef membersDefs) ->
                          match List.lookup memb_ident membersDefs with
                            | Just (_, align_opt, memb_qs, memb_ty) ->
                                E.return ( AilEmemberof a_e memb_ident
                                         , GenLValueType (combine_qualifiers qs memb_qs) memb_ty false )
                            | Nothing ->
                                E.constraint_violation (with_cursor_from (locOf e) (locOf memb_ident))
                                                       (MemberofNoMemberLvalue memb_ident qs ty)
                          end
                      | _ ->
                          error "annotate_expression(AilEmemberof union): failed to find a valid tag definition"
                    end
                | _ ->
                    E.constraint_violation (with_cursor_from (locOf e) loc) (MemberofReferenceBaseTypeLvalue qs ty)
              end
          | GenRValueType gty ->
              (* NOTE: even so we are dealing with a rvalue, the memberof operator might be
                 inside a sizeof(), and therefore not executed.
                 So the UB from §6.5.2.3#5, doesn't necessarily happens here *)
              let do_struct tag_sym =
                let do_fail =
                  E.constraint_violation (Loc.with_cursor_from (Loc.locOf e) (Loc.locOf memb_ident))
                    (MemberofNoMemberRvalue memb_ident gty) in
                match lookup_tag_definition sigm tag_sym with
                  | Just (StructDef membersDefs flexible_opt) ->
                      match (List.lookup memb_ident membersDefs, flexible_opt) with
                        | (Just (_, align_opt, _, memb_ty), _) ->
                            E.return (AilEmemberof a_e memb_ident, GenRValueType (GenTypes.inject_type memb_ty))
                        | (Nothing, Just (FlexibleArrayMember attrs flex_ident flex_qs flex_elem_ty)) ->
                            if memb_ident = flex_ident then
                              E.return ( AilEmemberof a_e memb_ident
                                       , GenRValueType (GenTypes.inject_type (Ctype [] (Array flex_elem_ty Nothing))) )
                            else
                              do_fail
                        | (Nothing, Nothing) ->
                            do_fail
                      end
                  | _ ->
                      error "annotate_expression(AilEmemberof struct): failed to find a valid tag definition"
                end in
              let do_union tag_sym =
                match lookup_tag_definition sigm tag_sym with
                  | Just (UnionDef membersDefs) ->
                      match List.lookup memb_ident membersDefs with
                        | Just (_, align_opt, _, memb_ty) ->
                            E.return (AilEmemberof a_e memb_ident, GenRValueType (GenTypes.inject_type memb_ty))
                        | Nothing ->
                            E.constraint_violation (with_cursor_from (locOf e) (locOf memb_ident))
                                                   (MemberofNoMemberRvalue memb_ident gty)
                      end
                  | _ ->
                      error "annotate_expression(AilEmemberof union): failed to find a valid tag definition"
                end in
              if GAux.is_incomplete sigm gty then
                E.constraint_violation (locOf e) (MemberofIncompleteRvalue gty)
              else match gty with
                | GenAtomic (GenStruct tag_sym) ->
                    do_struct tag_sym
                | GenAtomic (GenUnion tag_sym) ->
                    do_union tag_sym
                | GenStruct tag_sym ->
                    do_struct tag_sym
                | GenUnion tag_sym ->
                    do_union tag_sym
                | _ ->
                    E.constraint_violation (with_cursor_from (locOf e) loc) (MemberofReferenceBaseTypeRvalue gty)
              end
        end
    
    | AilEmemberofptr e memb_ident ->
      (* NOTE: the qualifiers of the value are the combination of the ones
         of the referenced type of left operand [e] and the ones in the
         declaration of the member type (see §6.5.2.3#4) *)
        annotate_rvalue e >>= function
          | (e', gty) ->
              match gty with
                | GenPointer ref_qs (Ctype _ (Struct tag_sym) as ref_ty) ->
                    E.return (ref_qs, Left tag_sym, ref_ty)
                | GenPointer ref_qs (Ctype _ (Atomic (Ctype _ (Struct tag_sym))) as ref_ty) ->
                    E.return (ref_qs, Left tag_sym, ref_ty)
                | GenPointer ref_qs (Ctype _ (Union tag_sym) as ref_ty) ->
                    E.return (ref_qs, Right tag_sym, ref_ty)
                | GenPointer ref_qs (Ctype _ (Atomic (Ctype _ (Union tag_sym))) as ref_ty) ->
                    E.return (ref_qs, Right tag_sym, ref_ty)
                | GenPointer ref_qs ref_ty ->
                    E.constraint_violation (with_cursor_from (locOf e) loc) (MemberofptrReferenceBaseType ref_qs ref_ty)
                | _ ->
                    E.constraint_violation (with_cursor_from (locOf e) loc) (MemberofptrReferenceTypeNotPointer gty)
              end >>= function
                | (ref_qs, Left tag_sym, ref_ty) ->
                    let do_fail =
                      E.constraint_violation (with_cursor_from (locOf e) (locOf memb_ident))
                        (MemberofptrNoMember memb_ident ref_qs ref_ty) in
                    if AAux.is_incomplete sigm ref_ty then
                      E.constraint_violation (locOf e) (MemberofptrIncomplete ref_qs ref_ty)
                    else match lookup_tag_definition sigm tag_sym with
                      | Just (StructDef membersDefs flexible_opt) ->
                          match (List.lookup memb_ident membersDefs, flexible_opt) with
                            | (Just (_, align_opt, memb_qs, memb_ty), _) ->
                                E.return ( AilEmemberofptr e' memb_ident
                                         , GenLValueType (combine_qualifiers ref_qs memb_qs) memb_ty false )
                            | (Nothing, Just (FlexibleArrayMember attrs flex_ident flex_qs flex_elem_ty)) ->
                                if memb_ident = flex_ident then
                                  E.return ( AilEmemberofptr e' memb_ident
                                           , GenLValueType (combine_qualifiers ref_qs flex_qs) (Ctype [] (Array flex_elem_ty Nothing)) false )
                                else
                                  do_fail
                            | (Nothing, Nothing) ->
                                do_fail
                          end
                      | _ ->
                          error "annotate_expression(AilEmemberofptr struct): failed to find a valid tag definition"
                    end
                | (ref_qs, Right tag_sym, ref_ty) ->
                    if AAux.is_incomplete sigm ref_ty then
                      E.constraint_violation (locOf e) (MemberofptrIncomplete ref_qs ref_ty)
                    else match lookup_tag_definition sigm tag_sym with
                      | Just (UnionDef membersDefs) ->
                          match List.lookup memb_ident membersDefs with
                            | Just (_, align_opt, memb_qs, memb_ty) ->
                                E.return ( AilEmemberofptr e' memb_ident
                                         , GenLValueType (combine_qualifiers ref_qs memb_qs) memb_ty false )
                            | Nothing ->
                                E.constraint_violation (with_cursor_from (locOf e) (locOf memb_ident))
                                                       (MemberofptrNoMember memb_ident ref_qs ref_ty)
                          end
                      | _ ->
                          error "annotate_expression(AilEmemberofptr union): failed to find a valid tag definition"
                    end
              end
        end
    
    | AilEassign e1 e2 ->
        annotate_expression CTXassign e1 >>= fun e1' ->
        match GenTypes.genTypeCategoryOf e1' with
          | GenLValueType qs1 ty1 _ ->
              if AAux.modifiable sigm qs1 ty1 then
                let assign_ty = AAux.rvalue_coercion ty1 in
                E.add "§6.5.16#3, sentence 3" >>
                annotate_assignee false SimpleAssignmentViolation loc assign_ty e2 >>= fun e2' -> 
                E.return (AilEassign e1' e2', GenRValueType (inject_type assign_ty))
              else
                E.constraint_violation (with_cursor_from (locOf e1) loc) AssignmentModifiableLvalue (* lvalue was not modifiable *)
          | _ ->
              E.constraint_violation (with_cursor_from (locOf e1) loc) AssignmentModifiableLvalue (* was not a lvalue *)
        end
    
    | AilEbinary e1 (Arithmetic (Mul  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 aop gty2 >>
        E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
    
    | AilEbinary e1 (Arithmetic (Div  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 aop gty2 >>
        E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
    
    | AilEbinary e1 (Arithmetic (Mod  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 aop gty2 >>
        E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
    
    | AilEbinary e1 (Arithmetic (Band as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 aop gty2 >>
        E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
    
    | AilEbinary e1 (Arithmetic (Bxor  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 aop gty2 >>
        E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
    
    | AilEbinary e1 (Arithmetic (Bor  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 aop gty2 >>
        E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
    
    | AilEbinary e1 (Arithmetic (Shl  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 aop gty2 >>
        E.return (AilEbinary e1' bop e2', GenRValueType (integer_promote gty1))
    
    | AilEbinary e1 (Arithmetic (Shr  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 aop gty2 >>
        E.return (AilEbinary e1' bop e2', GenRValueType (integer_promote gty1))
    
    | AilEbinary e1 (Arithmetic Add as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        (* NOTE: TODO: this is also relates to §6.5.2.1#1 *)
        (* STD §6.5.6#2 *)
        if is_pointer_to_complete_object sigm gty1 && is_integer gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType gty1)
        else if is_pointer_to_complete_object sigm gty2 && is_integer gty1 then
          E.return (AilEbinary e1' bop e2', GenRValueType gty2)
        else
          well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 Add gty2 >>
          E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
    
    | AilEbinary e1 (Arithmetic Sub as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if are_pointers_to_qualifiedOrUnqualified_compatible_complete_objects sigm gty1 gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger PtrdiffT)))
        else if is_pointer_to_complete_object sigm gty1 && is_integer gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType gty1)
        else
          well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 Sub gty2 >>
          E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
    
    | AilEbinary e1 (And as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if is_scalar gty1 && is_scalar gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc)) (AndInvalidOperandsType gty1 gty2)
    
    | AilEbinary e1 (Or  as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if is_scalar gty1 && is_scalar gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc)) (OrInvalidOperandsType gty1 gty2)
    
    | AilEbinary e1 (Lt as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if are_pointers_to_qualifiedOrUnqualified_compatible_types gty1 gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else if is_real gty1 && is_real gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc)) (RelationalInvalidOperandsType gty1 gty2)
    
    | AilEbinary e1 (Gt as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if are_pointers_to_qualifiedOrUnqualified_compatible_types gty1 gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else if is_real gty1 && is_real gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc)) (RelationalInvalidOperandsType gty1 gty2)
    
    | AilEbinary e1 (Le as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if are_pointers_to_qualifiedOrUnqualified_compatible_types gty1 gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else if is_real gty1 && is_real gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc)) (RelationalInvalidOperandsType gty1 gty2)
    
    | AilEbinary e1 (Ge as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if are_pointers_to_qualifiedOrUnqualified_compatible_types gty1 gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else if is_real gty1 && is_real gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc)) (RelationalInvalidOperandsType gty1 gty2)
    
    | AilEbinary e1 (Eq as bop) e2 ->
        (* STD §6.5.9#2 *)
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if well_typed_equality gty1 gty2 (is_null_pointer_constant e1') (is_null_pointer_constant e2') then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc)) (EqualityInvalidOperandsType gty1 gty2)
    
    | AilEbinary e1 (Ne as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if well_typed_equality gty1 gty2 (is_null_pointer_constant e1') (is_null_pointer_constant e2') then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          let () = Debug.print_debug 2 [] (fun () ->
            "gty1: " ^ Pp.stringFromAil_genType gty1 ^
            " <--> gty2: " ^ Pp.stringFromAil_genType gty2 ^
            " , are_pointers_to_compatible_types: " ^
            if are_pointers_to_compatible_types gty1 gty2 then "true" else "false"
          ) in
          E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc)) (EqualityInvalidOperandsType gty1 gty2)
    
    | AilEsizeof qs ty ->
        wf_lvalue sigm qs ty >>
        E.add "§6.5.3.4#1, sentence 1" >>
        if AAux.is_function ty || AAux.is_incomplete sigm ty then
          E.constraint_violation (with_cursor_from (locOf ty) loc) (SizeofInvalidApplication (inject_type ty))
        else
          E.add "§6.5.3.4#5" >>
          E.return (AilEsizeof qs ty, GenRValueType (GenBasic (GenInteger SizeT)))
    
    | AilEsizeof_expr e ->
        let () = Debug.warn [Debug.DB_ail_typing]
          (fun () -> "(TODO) GenTyping.annotate_expression AilEsizeof_expr, not checking for bit-field member") in
        (* because we are dealing with the operand of sizeof(), we do not call
           any of the conversion/decay functions (see §6.3.2.1#2-4) *)
        annotate_expression CTXsizeof e >>= fun a_e ->
        let gty = match GenTypes.genTypeCategoryOf a_e with
          | GenRValueType gty ->
              gty
          | GenLValueType _ ty _ ->
              inject_type ty
        end in
        E.add "§6.5.3.4#1, sentence 1" >>
        if GAux.is_function gty || GAux.is_incomplete sigm gty then
          E.constraint_violation (with_cursor_from (locOf e) loc) (SizeofInvalidApplication gty)
        else
          E.add "§6.5.3.4#5" >>
          E.return (AilEsizeof_expr a_e, GenRValueType (GenBasic (GenInteger SizeT)))
    
    | AilEalignof qs ty ->
        wf_lvalue sigm qs ty >>
        E.add "§6.5.3.4#1, sentence 1" >>
        if AAux.is_function ty || AAux.is_incomplete sigm ty then
          E.constraint_violation (with_cursor_from (locOf ty) loc) (AlignofInvalidApplication qs ty)
        else
          E.add "§6.5.3.4#5" >>
          E.return (AilEalignof qs ty, GenRValueType (GenBasic (GenInteger SizeT)))
    
    | AilEcast qs (Ctype _ Void as cty) e ->
        wf_lvalue sigm qs cty >>
        annotate_rvalue e >>= fun (e', _) ->
        E.return (AilEcast qs cty e', GenRValueType GenVoid)
    
    | AilEcast qs ty e ->
        wf_lvalue sigm qs ty >>
        annotate_rvalue e >>= fun (e', gty) ->
        if not (is_scalar gty && AAux.atomic_qualified_unqualified AAux.is_scalar ty) then
          E.constraint_violation (with_cursor_from (locOf e) loc) (CastInvalidType qs ty)
        else if is_pointer gty && AAux.is_floating ty then
          E.constraint_violation (with_cursor_from (locOf e) loc) CastPointerToFloat
        else if is_floating gty && AAux.is_pointer ty then
          E.constraint_violation (with_cursor_from (locOf e) loc) CastFloatToPointer
        else
          E.return (AilEcast qs ty e', GenRValueType (inject_type ty))
    
    | AilEcond e1 Nothing e3 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e3 >>= fun (e3', gty3) ->
        well_typed_conditionalGNU (loc, locOf e1, locOf e3) gty1 gty3 >>= fun genCat ->
        E.return (AilEcond e1' Nothing e3', genCat)
    | AilEcond e1 (Just e2) e3 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        annotate_rvalue e3 >>= fun (e3', gty3) ->
        well_typed_conditional (loc, locOf e1, locOf e2, locOf e3)
          gty1 gty2 gty3 (is_null_pointer_constant e2') (is_null_pointer_constant e3') >>= fun genCat ->
        E.return (AilEcond e1' (Just e2') e3', genCat)
    
    | AilEcompoundAssign e1 (Add as aop) e2 ->
        annotate_expression CTXassign e1 >>= fun e1'         ->
        annotate_rvalue e2               >>= fun (e2', gty2) ->
        match GenTypes.genTypeCategoryOf e1' with
          | GenLValueType qs ty _ -> 
              AAux.lvalue_coercion sigm ty >>= fun ty1 ->
                if    AAux.modifiable sigm qs ty
                   && (AAux.is_arithmetic ty1 && is_arithmetic gty2 || AAux.is_pointer_to_complete_object sigm ty && is_integer gty2) then
                  E.return (AilEcompoundAssign e1' aop e2', GenRValueType (inject_type ty1))
                else
                  E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc))
                                         (CompoundAssignmentAddSubOperandTypes (inject_type ty1) gty2)
          | _ ->
              E.constraint_violation (with_cursor_from (locOf e1) loc) AssignmentModifiableLvalue
        end
    
    | AilEcompoundAssign e1 (Sub as aop) e2 ->
        annotate_expression CTXassign e1 >>= fun e1'         ->
        annotate_rvalue e2     >>= fun (e2', gty2) ->
        match GenTypes.genTypeCategoryOf e1' with
          | GenLValueType qs ty _ -> 
              AAux.lvalue_coercion sigm ty >>= fun ty1 ->
                if    AAux.modifiable sigm qs ty
                   && (AAux.is_arithmetic ty1 && is_arithmetic gty2 || AAux.is_pointer_to_complete_object sigm ty && is_integer gty2) then
                  E.return (AilEcompoundAssign e1' aop e2', GenRValueType (inject_type ty1))
                else
                  E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc))
                                         (CompoundAssignmentAddSubOperandTypes (inject_type ty1) gty2)
          | _ ->
              E.constraint_violation (with_cursor_from (locOf e1) loc) AssignmentModifiableLvalue
        end
    
    | AilEcompoundAssign e1 aop e2 ->
        annotate_expression CTXassign e1 >>= fun e1'         ->
        annotate_rvalue e2     >>= fun (e2', gty2) ->
        match GenTypes.genTypeCategoryOf e1' with
          | GenLValueType qs ty _ ->
              inject_type <$> AAux.lvalue_coercion sigm ty >>= fun gty1 ->
              if AAux.modifiable sigm qs ty then
                well_typed_binary_arithmetic CompoundAssignmentOthersOperandTypes (locOf e1) loc (locOf e2) gty1 aop gty2 >>
                E.return (AilEcompoundAssign e1' aop e2', GenRValueType gty1)
              else
                E.constraint_violation (with_cursor_from (locOf e1) loc) AssignmentModifiableLvalue
          | _ ->
              E.constraint_violation (with_cursor_from (locOf e1) loc) AssignmentModifiableLvalue
        end
    
    | AilEconst cst ->
        (* STD §6.5.1#3 *)
        E.add "§6.5.1#3" >>
(*
        annotate_constant cst >>= fun (cst', gty) ->
        E.return (AilEconst cst', gty)
*)
        typecheck_constant loc cst >>= fun gty ->
        E.return (AilEconst cst, GenRValueType gty)
    
    (* TODO: check *)
    | AilEstr lit ->
        (* STD §6.5.1#4 *)
        E.add "§6.5.1#4" >>
        annotate_stringLiteral lit
    
    (* TODO: maybe look at the type of inside? *)
    | AilEannot ty e ->
        annotate_expression ctx e >>= function
          | AnnotatedExpression (GenLValueType qs _ isRegister) _ _ e' ->
              E.return (e', GenLValueType qs ty isRegister)
          | AnnotatedExpression (GenRValueType _) annots loc e' ->
              E.return (e', GenRValueType (inject_type ty))
        end
    
    | AilEva_start e sym ->
        annotate_rvalue e >>= fun (e', _) ->
        E.return (AilEva_start e' sym, GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        (* TODO: add this check later
        annotate_rvalue e >>= function
          | (e', GenBuiltin "va_list") ->
              E.return (AilEva_start e' sym, GenRValueType GenVoid)
          | _ ->
              E.misc (locOf e) VaStartArgumentType
        end
        *)
    
    | AilEva_copy e1 e2 ->
        annotate_rvalue e1 >>= fun (e1', _) ->
        annotate_rvalue e2 >>= fun (e2', _) ->
        E.return (AilEva_copy e1' e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
    
    | AilEva_arg e ty ->
        annotate_rvalue e >>= fun (e', _) ->
        E.return (AilEva_arg e' ty, GenRValueType (inject_type ty))
        (* TODO: add this check later
        annotate_rvalue e >>= function
          | (e', GenBuiltin "va_list") ->
              E.return (AilEva_arg e' ty, GenRValueType (inject_type ty))
          | _ ->
              E.misc (locOf e) VaArgArgumentType
        end
        *)

    | AilEva_end e ->
        annotate_rvalue e >>= fun (e', _) ->
        E.return (AilEva_end e', GenRValueType GenVoid)
    
    | AilEprint_type e ->
        annotate_expression ctx e >>= fun a_e ->
        E.return (AilEprint_type a_e, genTypeCategoryOf a_e)
    | AilEbmc_assume e ->
        annotate_rvalue e >>= fun (e', gty) ->
        E.return (AilEbmc_assume e', GenRValueType GenVoid)
    | AilEreg_load r ->
        E.return (AilEreg_load r, GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_))))) (* NOTE: assuming registers are always of type int *)
    | AilErvalue _ ->
        (* This should be impossible because the desugaring doesn't emit any AilErvalue *)
        error "annotate_expression(AilErvalue)"
    | AilEarray_decay _ ->
        (* This should be impossible because the Desugaring doesn't emit any AilEarray_decay *)
        error "annotate_expression(AilEarray_decay)"
    | AilEfunction_decay _ ->
        (* This should be impossible because the Desugaring doesn't emit any AilEfunction_decay *)
        error "annotate_expression(AilEfunction_decay)"
    | AilEatomic _ ->
        (* This should be impossible because the desugaring doesn't emit any AilEatomic *)
        error "annotate_expression(AilEatomic)"
    | AilEgcc_statement bs ss ->
      AilTyping.well_formed_bindings loc sigm bs >>= fun () ->
        if sigma_fresh_bindings bs sigm then
          annotate_block sigm gamm bs ss >>= fun ss' ->
          match List.dest_init ss' with
            | Nothing ->
                E.return (AilEgcc_statement bs [], GenRValueType GenVoid)
            | Just (ss', last_s') ->
                (* if last_s is of the form l1: ... ln: E; then we use the type of E otherwise void *)
                  let gtc = typeof_statement_as_expression last_s' in
                E.return (AilEgcc_statement bs (ss' ++ [last_s']), gtc)
          end
        else
          error "annotate_statement: sigma_fresh bindings failed in a AilSblock"
    | AilEinvalid ty reason ->
        E.return (AilEinvalid ty reason, GenRValueType (inject_type ty))
  end
  >>= fun (expr_', gtc) ->
  E.unpack >>= fun annots ->
  let annots = List.append std_annots  $ List.map Annot.Astd annots in
  perform_decays sigm ctx (AnnotatedExpression gtc annots loc expr_')






(*
(* Must NOT BE CALLED for:
     - the operand of the AilEsizeof_expr
     - the operand of the AilEunary Address
     - the operand of the AilEunary PostIncr
     - the operand of the AilEunary PostDecr
     - the left operand of AilEmemberof
     - the left operand of AilEassign and AilEcompoundAssign *)
(* STD §6.3.2.1#2 *)
(* TYPE: sigma unit -> expression genTypeCategory -> E.errorM (expression genTypeCategory) *)
and nonarray_lvalue_conversion sigm a_expr =
  match genTypeCategoryOf a_expr with
    | GenLValueType qs ty isRegister ->
        if not (AAux.is_array ty) then
          let rvalue_ty = unatomic_ (AAux.unqualify ty) in
          if AAux.is_incomplete sigm ty then
            error "TODO: nonarray_lvalue_conversion ==> undefined behaviour"
          else
            E.return (
              AnnotatedExpression (GenRValueType (inject_type rvalue_ty))
                (Loc.locOf a_expr) (AilErvalue a_expr)
            )
        else
          E.return a_expr
    | GenRValueType gty ->
        error "WIP: nonarray_lvalue_conversion, GenRValueType"
  end

(* Must NOT BE CALLED for:
     - the operand of AilEsizeof_expr
     - the operand of AilEunary Address
     - a AilEstr used to initialize an array *)
(* STD §6.3.2.1#3 *)
(* TYPE: sigma unit -> expression genTypeCategory -> E.errorM (expression genTypeCategory) *)
and array_decay sigm a_expr =
  (* TODO: DEAD CODE *)
  match genTypeCategoryOf a_expr with
    | GenLValueType qs ty isRegister ->
        if AAux.is_array ty then
          if isRegister then
            error "TODO: array_decay ==> undefined behaviour"
          else
            (* TODO: qualifiers?? *)
            let () = begin
              if not (AAux.is_unqualified qs) then
                Debug.warn [Debug.DB_ail_typing] (fun () -> "(UNSURE) GenTyping.array_decay, qs <> {}")
              else
              ()
            end in
            E.return (
              AnnotatedExpression (GenRValueType (inject_type (AAux.array_coercion ty)))
                (Loc.locOf a_expr) (AilEarray_decay a_expr)
            )
        else
          E.return a_expr
    | GenRValueType gty ->
        error "WIP: array_decay, GenRValueType"
  end

(* Must NOT BE CALLED for:
     - the operand of AilEsizeof_expr
     - the operand of AilEunary Address *)
(* STD §6.3.2.1#4 *)
(* TYPE: sigma unit -> expression genTypeCategory -> E.errorM (expression genTypeCategory) *)
and function_decay sigm a_expr =
  (* TODO: DEAD CODE *)
  error "WIP: function_decay"
*)

and perform_decays sigm ctx a_expr =
  let is_literal = match a_expr with
    | AnnotatedExpression _ _ _ (AilEarray true _ _) ->
        true
    | AnnotatedExpression _ _ _ (AilEconst (ConstantArray _ _)) ->
        true
    | AnnotatedExpression _ _ _ (AilEstr _) -> (* TODO: this is probably dead now *)
        true
    | _ ->
        false
  end in
  match annotations a_expr with
    | (std_annots, GenLValueType qs ty isRegister) ->
        let () = Debug.print_debug 2 [] (fun () ->
          "GenLValueType ==>" ^ Pp.stringFromAil_ctype qs ty
        ) in
        if    not (AAux.is_array ty)
           && not (List.elem ctx [CTXsizeof; CTXaddr; CTXincr; CTXdecr; CTXmemberof; CTXassign]) then
          (* STD §6.3.2.1#2 *)
          (* performing the lvalue conversion *)
          let rvalue_ty = Ctype [] (unatomic_ ty) in
          if AAux.is_incomplete sigm ty then
            (* STD §6.3.2.1#2, sentence 3 *)
            E.undef (Loc.locOf ty) Undefined.UB020_nonarray_incomplete_lvalue_conversion
          else
            E.return (
              AnnotatedExpression (GenRValueType (inject_type rvalue_ty))
                std_annots (Loc.locOf a_expr) (AilErvalue a_expr)
            )
        else if    AAux.is_array ty
                && not (List.elem ctx [CTXsizeof; CTXaddr])
                && not (List.elem ctx [CTXarray_init] && is_literal) then
          (* STD §6.3.2.1#3 *)
          (* performing the array decay *)
          if isRegister then
            E.undef Loc.unknown Undefined.UB022_register_array_decay
          else
            (* TODO: qualifiers?? *)
            let () = begin
              if not (AAux.is_unqualified qs) then
                Debug.warn [Debug.DB_ail_typing] (fun () -> "(UNSURE) GenTyping.array_decay, qs <> {}")
              else
                ()
            end in
            E.return (
              AnnotatedExpression (GenRValueType (inject_type (AAux.array_coercion ty)))
                std_annots (Loc.locOf a_expr) (AilEarray_decay a_expr)
            )
        else
          E.return a_expr
    | (std_annots, GenRValueType gty) ->
        if not (List.elem ctx [CTXsizeof; CTXaddr]) then
          (* STD §6.3.2.1#4 *)
          (* performing the function decay *)
          E.return match gty with
            | GenFunction ty params isVariadic ->
                AnnotatedExpression
                  (GenRValueType (GenPointer no_qualifiers (Ctype [] (Function ty params isVariadic))))
                  std_annots (Loc.locOf a_expr) (AilEfunction_decay a_expr)
            | GenArray elem_ty sz_opt ->
              match a_expr with
                | AnnotatedExpression _ _ _ (AilEconst (ConstantIndeterminate _)) ->
                    a_expr
                | AnnotatedExpression _ _ _ (AilEarray false _ _) ->
                    (* NOTE: this case doesn't syntactically exist in C, since
                       array values don't exist *)
                    a_expr
                | AnnotatedExpression _ _ _ (AilEinvalid _ _) ->
                    (* We need invalid nodes kept as is *)
                    a_expr
                | _ ->
                    if not (List.elem ctx [CTXarray_init] && is_literal) then
                      let ty = Ctype [] (Array elem_ty sz_opt) in
                      (* STD §6.3.2.1#3 *)
                      (* performing the array decay *)
                      AnnotatedExpression (GenRValueType (inject_type (AAux.array_coercion ty)))
                        std_annots (Loc.locOf a_expr) (AilEarray_decay a_expr)
                    else
                      a_expr
              end
            | _ ->
                a_expr
          end
        else
          E.return a_expr
  end













and annotate_rvalue annotate_block sigm gamm expr =
  annotate_expression annotate_block sigm gamm CTXother expr >>= fun (AnnotatedExpression gtc std_annots loc expr_) ->
   E.return match gtc with
     | GenRValueType gty ->
         (AnnotatedExpression (GenRValueType gty) std_annots loc expr_, gty)
     | GenLValueType qs ty isRegister ->
         (AnnotatedExpression (GenLValueType qs ty isRegister) std_annots loc expr_, inject_type ty)
   end


and annotate_assignee annotate_block sigm gamm is_init a_ctxt loc ty1 e2 =
  annotate_rvalue annotate_block sigm gamm e2 >>= fun (e2, gty2) ->
  well_typed_assignment sigm is_init a_ctxt loc ty1 gty2 e2 >>
  if AilTypesAux.is_atomic ty1 && not (GenTypesAux.is_atomic gty2) then
    E.return (AnnotatedExpression (GenRValueType (GenAtomic gty2)) [] loc (AilEatomic e2))
  else
    E.return e2


and annotate_arguments_aux add_casts annotate_block sigm gamm n_args n_params loc is_variadic args params =
  let annotate_expression = annotate_expression annotate_block sigm gamm CTXother in
  let annotate_assignee   = annotate_assignee annotate_block sigm gamm false FunctionParameterAsSimpleAssignment in
  let annotate_arguments_aux = annotate_arguments_aux add_casts annotate_block sigm gamm n_args n_params loc is_variadic in
  match (args, params) with
    | ([], []) ->
        let () = Debug.print_debug 2 [] (fun () ->
          "WTF []"
        ) in
        E.return []
    | ([], [(_, Ctype _ Void, _)]) ->
        (* TODO: document this case *)
        E.return []
    | (arg_e :: args', (_, param_ty1, isRegister) :: params') ->

(*
        if has_proto then
*)
          (* NOTE: we use 'unknown' location here because the location of the
             argument argment is used in the end *)
          let rvalue_ty = (AAux.rvalue_coercion param_ty1) in
          annotate_assignee Loc.unknown rvalue_ty arg_e >>= fun a_arg_e ->
          annotate_arguments_aux  args' params'         >>= fun a_args' ->
          let a_arg_e' =
            if add_casts then
              AnnotatedExpression (GenRValueType (GenTypes.inject_type rvalue_ty)) [] (Loc.locOf a_arg_e)
                (AilEcast no_qualifiers rvalue_ty a_arg_e)
            else
                a_arg_e
          in
          E.return (a_arg_e' :: a_args')
(*
        else
          (* the called function has a type that does not include a prototype *)
          (* STD §6.5.2.2#6 *)
          let ty1' = KKKK
*)


    | (_, []) ->
        (* This case must correspond to a call to a variadic function *)
        if not is_variadic then
          E.constraint_violation loc (FunctionCallTooManyArguments n_params n_args)
        else
          (* following (§6.5.2.2#7) *)
          (* TODO: default argument promotion + checks (at least that there are no void-expression, though this might already be done by the promotion) *)
          E.mapM annotate_expression args
(*
          E.mapM annotate_expression args >>= fun a_args ->
          if List.any (fun z -> type_of annot z = Void) a_args then
            E.fail Loc.unknown (TError "called a variadic function with a void expression")
          else
            E.return a_args
*)
    | (_, _) ->
        E.constraint_violation loc (FunctionCallTooFewArguments n_params n_args)
  end







(*
(* returns both the annotated intializer and the infered type (used for arrays) *)
and annotate_initialization sigm gamm ty e =
  (* §6.7.9#3 *)
  E.guard (TError "failed §6.7.9#3")
    (   AAux.is_array_unknown_size ty
     || AAux.is_complete_object sigm ty && not (AAux.is_vla ty)) >>
  
  if AAux.is_scalar ty then
    (* STD §6.7.9#11, sentence 3 *)
    annotate_assignee sigm gamm (AAux.unqualify ty) e >>= fun a_e ->
    E.return (a_e, ty)
  
  (* TODO: "(...) that has automatic storage duration" *)
  (* STD §6.7.9#13 *)
  else if AAux.is_struct_or_union ty then
    (* TODO: check *)
    annotate_rvalue sigm gamm e >>= fun (a_e, gty) ->
    (* TODO: need to make sure that gty is compatible with ty *)
    E.return (a_e, ty)
  
  (* STD §6.7.9#14 *)
  else if AAux.is_array_of_character ty then
    error ("WIP: annotate_initialization, is_array_of_character ty ==> " ^ Pp.stringFromAil_ctype ty)
  
  (* STD §6.7.9#15 *)
  else if AAux.compatibleWithQualifiedUnqualifiedVersionOf ty [Builtin "wchar_t"; char16_t; char32_t] then
    error "WIP: annotate_initialization, compatibleWithQualifiedUnqualifiedVersionOf ty [Builtin \"wchar_t\"; char16_t; char32_t]"
  
  (* STD §6.7.9#16 *)
(*          else if  then *) (* KKK *)
  (* TODO: at this point we should now have a non character array *)
  else if AAux.is_array ty then
    (* TODO: check the std. (not that it says anything useful here ...) *)
    annotate_expression sigm gamm e >>= fun a_e ->
    match (ty, GenTypes.genTypeCategoryOf a_e) with
      | (Array elem_qs1 elem_ty1 Nothing, GenRValueType (GenArray _ elem_ty2 (Just n2))) ->
          (* TODO: check, but I don't think we need to do anything regarding qualifiers here *)
          if AAux.compatible elem_ty1 elem_ty2 then
            E.return (a_e, Array elem_ty1 (Just n2))
          else
            error ("TODO(annotate_initialisation, 1): error message: array object definition, types didn't match ==> " ^
                   Pp.stringFromAil_ctype elem_ty1 ^ " <-> " ^ Pp.stringFromAil_ctype elem_ty2)
     | (Array _ elem_ty1 (Just n1), GenRValueType (GenArray _ elem_ty2 (Just n2))) ->
          (* TODO: check, but I don't think we need to do anything regarding qualifiers here *)
         if AAux.compatible elem_ty1 elem_ty2 && n1 = n2 then
           E.return (a_e, Array elem_ty1 (Just n1))
         else
            error ("TODO(annotate_initialisation, 2): error message: array object definition, types didn't match ==> " ^
                   Pp.stringFromAil_ctype elem_ty1 ^ " <-> " ^ Pp.stringFromAil_ctype elem_ty2)
     | _ ->
         error "WIP: annotate_initialization, not(is_scalar ty), not array (or had no size)"
    end
  else
    error "WIP: annotate_initialization, final case"

*)














and annotate_definition_aux annotate_block sigm gamm (ty, e) =
  if    (AAux.is_array ty --> AAux.has_unknown_size sigm ty)
     || (AAux.is_complete_object sigm ty --> not (AAux.is_vla ty)) then
    if AAux.atomic_qualified_unqualified AAux.is_scalar ty then
      E.add "§6.7.9#11, sentence 3" >>
      (* NOTE: since we are not passing a `qs' with `ty' to annotate_assignee,
         we are indeed unqualifying the scalar type *)
      (* TODO: add location *)
      annotate_assignee annotate_block sigm gamm true InitializationAsSimpleAssignment Loc.unknown ty e
      
    (* TODO: "(...) that has automatic storage duration" *)
    else if AAux.atomic_qualified_unqualified AAux.is_struct_or_union ty then
      (* TODO: check *)
      E.add "§6.7.9#13" >>
      annotate_assignee annotate_block sigm gamm true InitializationAsSimpleAssignment Loc.unknown ty e
      (* annotate_rvalue sigm gamm e >>= fun (a_e, gty) ->
      AilEassign
      (* TODO: need to make sure that gty is compatible with ty *)
      E.return a_e *)
      
    (* STD §6.7.9#15 *)
    else if AAux.compatibleWithQualifiedUnqualifiedVersionOf ty [wchar_t; char16_t; char32_t] then
      error "WIP: annotate_definition_aux, compatibleWithQualifiedUnqualifiedVersionOf ty [wchar_t; char16_t; char32_t]"
      
          (* STD §6.7.9#16 *)
(*          else if  then *) (* KKK *)

      (* TODO: at this point we should now have a non character array *)
    else if AAux.is_array ty then
      (* TODO: check the std. (not that it says anything useful here ...) *)
      let ctx =
(*          if AAux.is_array_of_character ty then *)
        if AAux.is_array ty then
          CTXarray_init
        else
          CTXother in
      annotate_expression annotate_block sigm gamm ctx e >>= fun a_e ->
        let () = Debug.warn [Debug.DB_ail_typing]
          (fun () -> "(UNSURE) for the definition of arrays the compatilibity of types is checked for they unqualified versions and ignoring the elem_qs") in
      match (ty, GenTypes.genTypeCategoryOf a_e) with
        | (Ctype _ (Array elem_ty1 Nothing), GenRValueType (GenArray elem_ty2 (Just n))) ->
            if AAux.are_compatible (no_qualifiers, elem_ty1) (no_qualifiers, elem_ty2) then
              E.return a_e (* (e', GenArray elem_ty1 (Just n)) *)
            else
              error ("TODO(annotate_definition_aux, 1): error message: array object definition, types didn't match ==> " ^
                      Pp.stringFromAil_ctype no_qualifiers elem_ty1 ^ " <-> " ^ Pp.stringFromAil_ctype no_qualifiers elem_ty2)
        | (Ctype _ (Array elem_ty1 (Just n1)), GenRValueType (GenArray elem_ty2 (Just n2))) ->
            if AAux.are_compatible (no_qualifiers, elem_ty1) (no_qualifiers, elem_ty2) && n1 = n2 then
              E.return a_e (* (e', GenArray elem_ty1 (Just n1)) *)
            else
              error ("TODO(annotate_definition_aux, 2): error message: array object definition, types didn't match ==> " ^
                      Pp.stringFromAil_ctype no_qualifiers elem_ty1 ^ " <-> " ^ Pp.stringFromAil_ctype no_qualifiers elem_ty2)

        | (Ctype _ (Array elem_ty1 (Just n1)), GenLValueType qs2 (Ctype _ (Array elem_ty2 (Just n2))) _) ->
            (* TODO: isRegister? *)
            (* TODO: what if n1 < n2? *)
            (* TODO: check std *)
            if AAux.are_compatible (no_qualifiers, elem_ty1) (no_qualifiers, elem_ty2) && n1 >= n2 then
              E.return a_e
            else
              error ("TODO(annotate_definition_aux, 3): error message: array object definition, types didn't match ==> " ^
                      Pp.stringFromAil_ctype no_qualifiers elem_ty1 ^ "[" ^ show n1 ^ "] <-> " ^
                      Pp.stringFromAil_ctype no_qualifiers elem_ty2 ^ "[" ^ show n2 ^ "]")
        | _ ->
            (* STD §6.7.9#14 *)
            if AAux.is_array_of_character ty then
              error ("WIP: annotate_definition_aux, is_array_of_character ty ==> " ^
                    Pp.stringFromAil_ctype no_qualifiers ty ^ " <===> " ^ Pp.stringFromAil_expression a_e)
            else
              let () = Debug.print_debug 0 [] (fun () ->
                "a_e: " ^ Pp.stringFromAil_expression a_e
              ) in
              let () = Debug.print_debug 0 [] (fun () ->
                "ty: " ^ Pp.stringFromAil_ctype no_qualifiers ty ^ " <--> gty: " ^
                match GenTypes.genTypeCategoryOf a_e with
                  | GenLValueType qs' ty' _ ->
                      "lvalue " ^ Pp.stringFromAil_ctype qs' ty'
                  | GenRValueType gty ->
                      "rvalue " ^ Pp.stringFromAil_genType gty
                end
              ) in
              error "WIP: annotate_definition, not(is_scalar ty), not array (or had no size)"
      end
    else
      error "WIP: annotate_definition_aux, final case"
  else
    (* STD §6.7.9#3 *)
    let kind =
      if AilTypesAux.is_vla ty then
        InitialisedVLA
      else
        InitialisedIncomplete ty in
    E.constraint_violation (Loc.locOf e) (IllegalInitialisation kind)

val annotate_definition:
  (sigma unit -> gamma -> bindings -> list (statement unit) -> E.errorM (list (statement genTypeCategory))) ->
  sigma unit -> gamma -> (Symbol.sym * maybe (expression unit)) -> E.errorM (Symbol.sym * maybe (expression genTypeCategory))
let annotate_definition annotate_block sigm gamm (sym, e_opt) =
  match (e_opt, List.lookup sym gamm) with
    | (Nothing, Just _) ->
        E.return (sym, Nothing)
    | (Just e, Just (_, _, sym_qs, sym_ty)) ->
        annotate_definition_aux annotate_block sigm gamm (sym_ty, e) >>= fun a_e ->
        E.return (sym, Just a_e)
    | (_, Nothing) ->
        error "annotate_definition: symbol not found in the context"
  end


val annotate_definitions:
  (sigma unit -> gamma -> bindings -> list (statement unit) -> E.errorM (list (statement genTypeCategory))) ->
  sigma unit -> gamma -> list (Symbol.sym * maybe (expression unit)) -> E.errorM (list (Symbol.sym * maybe (expression genTypeCategory)))
let rec annotate_definitions annotate_block sigm gamm = function
  | [] ->
      E.return []
  | d :: ds ->
      annotate_definition  annotate_block sigm gamm d  >>= fun d  ->
      annotate_definitions annotate_block sigm gamm ds >>= fun ds ->
      E.return (d :: ds)
end


val     annotate_statement_: Loc.t -> sigma unit -> gamma -> ctype -> statement_ unit -> E.errorM (statement_ genTypeCategory)
let rec annotate_statement_ loc sigm gamm ty stmt =
  let annotate_block = annotate_block (Just ty) in
  let annotate_expression = annotate_expression annotate_block sigm gamm CTXother in
  let annotate_rvalue     = annotate_rvalue annotate_block sigm gamm in
  let annotate_statement  = annotate_statement sigm gamm ty in
  
  match stmt with
    | AilSskip ->
        E.return AilSskip
    | AilSexpr e ->
        annotate_expression e >>= fun e' ->
        E.return (AilSexpr e')
    | AilSblock bindings ss ->
        AilTyping.well_formed_bindings loc sigm bindings >>
        if sigma_fresh_bindings bindings sigm then
          annotate_block sigm gamm bindings ss >>= fun ss' ->
          E.return (AilSblock bindings ss')
        else
          error "annotate_statement: sigma_fresh bindings failed in a AilSblock"
    | AilSif e s1 s2 ->
        annotate_rvalue e >>= fun (e', gty) ->
        E.add "§6.8.4.1#1" >>
        if is_scalar gty then
          annotate_statement s1 >>= fun s1' ->
          annotate_statement s2 >>= fun s2' ->
          E.return (AilSif e' s1' s2')
        else
          E.constraint_violation (Loc.locOf e) IfStatementControllingExpressionNotScalar
    | AilSwhile e s id ->
        annotate_rvalue e >>= fun (e', gty) ->
        E.add "§6.8.5#2" >>
        if is_scalar gty then
          annotate_statement s >>= fun s' ->
          E.return (AilSwhile e' s' id)
        else
          E.constraint_violation (Loc.locOf e) IterationStatementControllingExpressionNotScalar
    | AilSdo s e id ->
        annotate_rvalue e >>= fun (e', gty) ->
        E.add "§6.8.5#2" >>
        if is_scalar gty then
          annotate_statement s >>= fun s' ->
          E.return (AilSdo s' e' id)
        else
          E.constraint_violation (Loc.locOf e) IterationStatementControllingExpressionNotScalar
    | AilSbreak ->
        E.return AilSbreak
    | AilScontinue ->
        E.return AilScontinue
    | AilSreturnVoid ->
        if AAux.is_void ty then
          E.return AilSreturnVoid
        else
          E.constraint_violation loc NonVoidReturnVoidFunction
    | AilSreturn e ->
        annotate_assignee annotate_block sigm gamm false ReturnAsSimpleAssignment (with_cursor_from (locOf e) loc) ty e >>= fun e' ->
        E.return (AilSreturn e')
    | AilSswitch e s ->
        annotate_rvalue e >>= fun (e', gty) ->
        E.add "§6.8.4.2#1" >>
        if is_integer gty then
          annotate_statement s >>= fun s' ->
          E.return (AilSswitch e' s')
        else
          E.constraint_violation (Loc.locOf e) SwitchStatementControllingExpressionNotInteger
    | AilScase n s ->
        annotate_statement s >>= fun s' ->
        E.return (AilScase n s')
    | AilScase_rangeGNU n1 n2 s ->
        annotate_statement s >>= fun s' ->
        E.return (AilScase_rangeGNU n1 n2 s')
    | AilSdefault s ->
        annotate_statement s >>= fun s' ->
        E.return (AilSdefault s')
    | AilSlabel sym s la ->
        annotate_statement s >>= fun s' ->
        E.return (AilSlabel sym s' la)
    | AilSgoto sym ->
        E.return (AilSgoto sym)
    | AilSdeclaration sym_es ->
        annotate_definitions annotate_block sigm gamm sym_es >>= fun sym_es' ->
        E.return (AilSdeclaration sym_es')
    | AilSpar ss ->
        E.mapM annotate_statement ss >>= fun ss' ->
        E.return (AilSpar ss')
    | AilSreg_store r e ->
        annotate_rvalue e >>= fun (e', _) ->
        E.return (AilSreg_store r e')
    | AilSmarker id s ->
        annotate_statement s >>= fun s' ->
        E.return (AilSmarker id s')
  end

and annotate_statement sigm gamm ty stmt =
  annotate_statement_ stmt.loc sigm gamm ty stmt.node >>= fun node' ->
  E.return (mk_statement_full stmt.loc stmt.is_forloop stmt.attrs node')

(* ty_opt should be Nothing if the annotate_block is passed to a function
   annotating outside of the body of a function *)
and annotate_block ty_opt sigm gamm bs ss =
  (* WIP *)
  let add_bindings z acc = foldl (fun acc b -> b :: acc) z acc in
  match ty_opt with
    | Nothing ->
        (* TODO: this should already be caught by the desugaring, but better create a proper constraint violation variant *)
        error "TODO msg: Statement expressions are only allowed inside functions"
    | Just ty ->
        E.mapM (annotate_statement sigm (add_bindings bs gamm) ty) ss
  end



(* val annotate_block:
      sigma unit -> gamma -> ctype -> list (statement unit) -> E.errorM (list (statement genTypeCategory))
let annotate_block sigm gamm ty stmts =
  E.mapM (annotate_statement sigm gamm ty) stmts *)

val annotate_sigma: sigma unit -> E.errorM (sigma genTypeCategory)
let annotate_sigma sigm =
  (* TODO: morally we want a "mapP_" here *)
  (* Checking that declarations are well-formed *)
  E.mapM (fun (ident, decl) ->
    match decl with
    | (_, _, (Decl_object dur_opt _ qs ty as decl)) ->
        wf_lvalue sigm qs ty >>
        E.return (ident, decl)
    | (_, _, (Decl_function hasProto ret_ty params isVariadic _ (* isInline *) _ (* isNoreturn *) as decl)) ->
        (* TODO?   ==> AilTyping.well_formed_bindings bs && *)
        wf_type sigm (Ctype [] (Function ret_ty params isVariadic)) >>
        E.return (ident, decl)
    end
  ) sigm.declarations >>
  
  (* Typechecking of external objects that have a definition *)
  E.mapM (fun (ident, e) ->
    match List.lookup ident sigm.declarations with
      | Just (loc, _, Decl_object _ _ _ (* qs *) ty) ->
          (* TODO: qualifiers?; storage duration? *)
          annotate_definition_aux (annotate_block Nothing) sigm [] (ty, e) >>= fun def ->
          E.return (ident, def)
      | _ ->
          error "annotate_sigma: object definition must have a declaration"
    end
  ) sigm.object_definitions >>= fun object_defs' ->
  
  (* Typechecking of functions that have a definition *)
  E.mapM (fun (ident, (loc, marker_id, attr, param_idents, s)) ->
    match List.lookup ident sigm.declarations with
      | Just (_, _, Decl_function hasProto (ret_qs, ret_ty) params _ (* isVariadic *) _ (* isInline *) _ (* isNoreturn *)) ->
          (* TODO: qualifiers *)
          let () = Debug.warn [] (fun () ->
            "(unsure) annotate_sigma doesn't look at [ret_qs]"
           ) in
          let bindings = List.map (fun (ident, (qs, ty, isRegister)) ->
            (* STD §6.9.1#9, first sentence *)
            (ident, ((loc, Automatic, isRegister), Nothing, qs, ty))
          ) (List.zip param_idents params) in
          if sigma_fresh_bindings bindings sigm then
            let add_bindings bs acc = foldl (fun acc b -> b :: acc) bs acc in
            annotate_statement sigm (add_bindings bindings []) ret_ty s >>= fun s' ->
              E.return (ident, (loc, marker_id, attr, param_idents, s'))
          else
            error "annotate_sigma: parameter ail_identifiers are not fresh"
      | _ ->
          error "annotate_sigma: function definition must have a declaration"
    end
  ) sigm.function_definitions >>= fun function_defs' ->
  
  let check_member is_struct (ident, (_, _, qs, ty)) =
    E.add "§6.7.2.1#3" >>
    if is_struct && AilTypesAux.has_flexible_array_member sigm ty then
      E.constraint_violation (Loc.locOf ident) StructMemberFlexibleArray
    else if AilTypesAux.is_function ty then
      E.constraint_violation (Loc.locOf ident) (StructMemberFunctionType ident)
    else if AilTypesAux.is_incomplete sigm ty then
      E.constraint_violation (Loc.locOf ident) (StructMemberIncompleteType qs ty)
    else
      E.return () in
  E.mapM (function
    | (_, (_, _, StructDef xs flexible_opt)) ->
        E.mapM_ (check_member true) xs >>= fun () ->
        E.mapM_ (fun (_, (_, _, qs, ty)) ->
          (* TODO: check that it is ok to use wf_lvalue (instead of just wf_type) *)
          wf_lvalue sigm qs ty
        ) xs >>= fun () ->
        match flexible_opt with
          | Nothing ->
              E.return ()
          | Just (FlexibleArrayMember _ _ flex_qs flex_elem_ty) ->
              wf_lvalue sigm flex_qs (Ctype [] (Array flex_elem_ty Nothing))
        end
    | (_, (_, _, UnionDef xs)) ->
        E.mapM (check_member false) xs >>
        E.mapM_ (fun (_, (_, _, qs, ty)) ->
          (* TODO: check that it is ok to use wf_lvalue (instead of just wf_type) *)
          wf_lvalue sigm qs ty
        ) xs
  end) sigm.tag_definitions >>

  
  E.return <|
    declarations=         sigm.declarations;
    object_definitions=   object_defs';
    function_definitions= function_defs';
    (* TODO: hack *)
    static_assertions= [];
    tag_definitions= sigm.tag_definitions;
    extern_idmap= sigm.extern_idmap;
    typedef_attributes= sigm.typedef_attributes;
    loop_attributes= sigm.loop_attributes;
    cn_predicates=  sigm.cn_predicates;
    cn_functions=  sigm.cn_functions;
    cn_lemmata=  sigm.cn_lemmata;
    cn_datatypes=  sigm.cn_datatypes;
    cn_decl_specs=  sigm.cn_decl_specs;
    cn_idents=  sigm.cn_idents;
  |>


(* NOTE: this is the only thing this module exports *)
val annotate_program: ail_program unit -> E.errorM (ail_program genTypeCategory)
let annotate_program (startup_opt, sigm) =
  match startup_opt with
    | Nothing ->
        annotate_sigma sigm >>= fun sigm' ->
        E.return (startup_opt, sigm')
    | Just startup ->
        match List.lookup startup sigm.declarations with
          | Just (loc, _, Decl_function hasProto (ret_qs, ret_ty) params (* bs *) _ (* isVariadic *) _ (* isInline *) _ (* isNoreturn *)) ->
              (* STD §5.1.2.2.1 *)
              (* TODO: "... or equivalent;10) or in some other implementation-defined manner." *)
              match params with
                | [] ->
                    (* TODO: not sure if really allowed by the std, clearly used a lot *)
                    E.return ()
                | [(<| const= false; restrict= false; volatile= false(*; atomic= false*) |>, Ctype _ Void, _)] ->
                    E.return ()
                | [(<| const= false; restrict= false; volatile= false(*; atomic= false*) |>, Ctype _ (Basic (Integer (Signed Int_))), _);
                   (<| const= false; restrict= false; volatile= false(*; atomic= false*) |>,
                    Ctype _ (Pointer <| const= false; restrict= false; volatile= false(*; atomic= false*) |>
                      (Ctype _ (Pointer <| const= false; restrict= false; volatile= false(*; atomic= false*) |> (Ctype _ (Basic (Integer Char)))))), _)] ->
                    E.return ()
                    (* TODO: can the parameters be qualified with const or volatile? *)
                | ((<| const= false; restrict= false; volatile= false(*; atomic= false*) |>, Ctype _ (Basic (Integer (Signed Int_))), _)::
                  (_, aty2, _)::_) ->
                    E.undef (Loc.with_cursor_from (Loc.locOf aty2) loc) Undefined.UB004c_incorrect_main_argument2
                | ((_, aty1, _)::_) ->
                    E.undef (Loc.with_cursor_from (Loc.locOf aty1) loc) Undefined.UB004b_incorrect_main_argument1
              end >>
              (* TODO: check arguments *)
              if ret_qs = no_qualifiers && proj_ctype_ ret_ty = Basic (Integer (Signed Int_)) then
                annotate_sigma sigm >>= fun sigm' ->
                E.return (startup_opt, sigm')
              else
                E.undef (Loc.with_cursor_from (Loc.locOf ret_ty) loc) Undefined.UB004a_incorrect_main_return_type
          | Just (loc, _, _) ->
              E.undef loc Undefined.UB004d_main_not_function
          | Nothing ->
              error ("Startup function " ^ show startup ^ " not found in AIL declarations.")
        end
  end
