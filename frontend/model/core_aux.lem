open import Pervasives Utils Show Core Ctype Annot Map Map_extra
import AilSyntax Ctype_aux 
import Product Exception Mem Mem_common Mem_aux

open import Errors

import Debug Pp

import Nondeterminism
module ND = Nondeterminism


val strip: forall 'ty 'sym. generic_pexpr 'ty 'sym -> generic_pexpr_ 'ty 'sym
let strip (Pexpr _ _ pexpr_) =
  pexpr_

val strip_expr: forall 'a 'bty 'sym. generic_expr 'a 'bty 'sym -> generic_expr_ 'a 'bty 'sym
let strip_expr (Expr _ expr_) =
  expr_


val     core_object_type_of_ctype: ctype -> maybe core_object_type
let rec core_object_type_of_ctype (Ctype _ ty) =
  match ty with
   | Void ->
       Nothing
   | Basic (Integer _) ->
       Just OTy_integer
   | Basic (Floating _) ->
       Just OTy_floating
   | Array ty _ ->
       match core_object_type_of_ctype ty with
         | Just oTy ->
             Just (OTy_array oTy)
         | Nothing ->
             error "Core_aux.core_object_type_of_ctype: Array found a Nothing"
       end
   | Function (_, ret_ty) xs isVariadic ->
       error "core_object_type_of_ctype: not core function object"
   | FunctionNoParams _ ->
       error "core_object_type_of_ctype: not core function (no params) object"
   | Pointer _ _ ->
       Just OTy_pointer
   | Atomic ty ->
       core_object_type_of_ctype ty
   | Struct tag_sym ->
       Just (OTy_struct tag_sym)
   | Union tag_sym ->
       Just (OTy_union tag_sym)
  end

val oTy_of_bTy: core_base_type -> maybe core_object_type
let oTy_of_bTy = function
 | BTy_unit ->
      Nothing
 | BTy_boolean ->
      Nothing
 | BTy_ctype ->
      Nothing
 | BTy_list _ ->
      Nothing
 | BTy_tuple _ ->
      Nothing
 | BTy_object oTy ->
     Just oTy
 | BTy_loaded oTy ->
     Just oTy
 | BTy_storable ->
     Nothing
end

val     objectValueFromMemValue: Mem.mem_value -> core_object_type * object_value
let rec objectValueFromMemValue mem_val =
  let () = Debug.print_debug 6 [] (fun () ->
    "objectValueFromMemValue ==> " ^ Mem.stringFromMem_value mem_val
  ) in
  Mem.case_mem_value mem_val
    (fun ty                -> error"[Core_aux.objectValueFromMemValue] FOUND AN UNSPECIFIED MVAL")
    (fun _ _               -> error "[Core_aux.objectValueFromMemValue] concurrency read")
    (fun _ ival            -> (OTy_integer, OVinteger ival))
    (fun _ fval            -> (OTy_floating, OVfloating fval))
    (fun _ ptr_val         -> (OTy_pointer, OVpointer ptr_val))
    (fun mem_vals          -> error "[Core_aux.objectValueFromMemValue] Vspecified (OVarray (List.map objectValueFromMemValue mem_vals))")
    (fun sym xs            -> (OTy_struct sym, OVstruct sym xs))
    (fun sym ident mem_val -> (OTy_union sym, OVunion sym ident mem_val))

and loadedValueFromMemValue mem_val : core_object_type * loaded_value =
  let () = Debug.print_debug 6 [] (fun () ->
    "loadedValueFromMemValue ==> " ^ Mem.stringFromMem_value mem_val
  ) in
  Mem.case_mem_value mem_val
    (fun ty                -> (fromJust "loadedValueFromMemValue" (core_object_type_of_ctype ty), LVunspecified ty))
    (fun _ _               -> error "[Core_aux.loadedValueFromMemValue] concurrency read")
    (fun _ ival            -> (OTy_integer, LVspecified (OVinteger ival)))
    (fun _ fval            -> (OTy_floating, LVspecified (OVfloating fval)))
    (fun _ ptr_val         -> (OTy_pointer, LVspecified (OVpointer ptr_val)))
    (fun mem_vals          ->
      match List.map loadedValueFromMemValue mem_vals with
        | [] ->
            error "[Core_aux.loadedValueFromMemValue] empty array"
        | (oTy, lval) :: oTy_lvals ->
            if List.any (fun (oTy', _) -> oTy <> oTy') oTy_lvals then
              error "[Core_aux.loadedValueFromMemValue] heterogenous array"
            else
              (OTy_array oTy, LVspecified (OVarray (lval :: List.map snd oTy_lvals)))
      end)
    (fun sym xs            -> (OTy_struct sym, LVspecified (OVstruct sym xs)))
    (fun sym ident mem_val -> (OTy_union sym, LVspecified (OVunion sym ident mem_val)))


val valueFromMemValue: Mem.mem_value -> core_object_type * value
let valueFromMemValue mem_val =
  let () = Debug.print_debug 6 [] (fun () ->
    "valueFromMemValue ==> " ^ Mem.stringFromMem_value mem_val
  ) in
  Mem.case_mem_value mem_val
    (fun ty                -> (fromJust "Core_aux.valueFromMemValue" (core_object_type_of_ctype ty), Vloaded (LVunspecified ty)))
    (fun _ _               -> error "[Core_aux.valueFromMemValue] concurrency read")
    (fun _ ival            -> (OTy_integer, Vloaded (LVspecified (OVinteger ival))))
    (fun _ fval            -> (OTy_floating, Vloaded (LVspecified (OVfloating fval))))
    (fun _ ptr_val         -> (OTy_pointer, Vloaded (LVspecified (OVpointer ptr_val))))
    (fun mem_vals          -> let (oTys, lvals) = List.unzip (List.map loadedValueFromMemValue mem_vals) in
                              let oTy = match oTys with
                                | [] ->
                                    (* Something went wrong in the MLM *)
                                    error "Core_aux.valueFromMemValue ==> empty array"
                                | oTy :: _ ->
                                    oTy
                              end in
                              (OTy_array oTy, Vloaded (LVspecified (OVarray lvals))))
    (fun sym xs            -> (OTy_struct sym, Vloaded (LVspecified (OVstruct sym xs))))
    (fun sym ident mem_val -> (OTy_union sym, Vloaded (LVspecified (OVunion sym ident mem_val))))

val     memValueFromValue: ctype -> value -> maybe Mem.mem_value
let rec memValueFromValue ty cval =
  let (Ctype annots ty_) = unatomic ty in
  match (ty_, cval) with
    | (_, Vunit) ->
        Nothing
    | (_, Vtrue) ->
        Nothing
    | (_, Vfalse) ->
        Nothing
    | (_, Vlist _ _) ->
        Nothing
    | (_, Vtuple _) ->
        Nothing
    | (_, Vctype _) ->
        Nothing
    | (_, Vloaded (LVunspecified ty')) ->
        Just (Mem.unspecified_mval ty') (* TODO: check ty = ty'? *)
    | (Basic (Integer ity), Vobject (OVinteger ival)) ->
        Just (Mem.integer_value_mval ity ival)
    | (Basic (Integer ity), Vloaded (LVspecified (OVinteger ival))) ->
        Just (Mem.integer_value_mval ity ival)
    | (Basic (Floating fty), Vloaded (LVspecified (OVfloating fval))) ->
        Just (Mem.floating_value_mval fty fval)
    | (Basic (Floating fty), Vobject (OVfloating fval)) ->
        Just (Mem.floating_value_mval fty fval)
    | (Pointer _ ref_ty, Vobject (OVpointer ptr_val)) -> (* TODO: not sure about this *)
        Just (Mem.pointer_mval ref_ty ptr_val)
    | (Pointer _ ref_ty, Vloaded (LVspecified (OVpointer ptr_val))) ->
        Just (Mem.pointer_mval ref_ty ptr_val)
    | (Array elem_ty _, Vloaded (LVspecified (OVarray lvals))) ->
        (* TODO: check that the sizes match? *)
        maybe Nothing (fun z -> Just (Mem.array_mval z)) $
          List.foldr (fun lval acc_opt ->
            match (memValueFromValue elem_ty (Vloaded lval), acc_opt) with
              | (Just mem_val, Just acc) ->
                  Just (mem_val :: acc)
              | _ ->
                  Nothing
            end
          ) (Just []) lvals
    | (Struct tag_sym1, Vloaded (LVspecified (OVstruct tag_sym2 xs))) ->
        let () = Debug.print_debug 2 [] (fun () -> "Comparing struct tag symbols: " ^ Symbol.show_raw tag_sym1 ^ " = " ^ Symbol.show_raw tag_sym2) in
        if Ctype_aux.are_compatible
          (no_qualifiers, Ctype [] (Struct tag_sym1))
          (no_qualifiers, Ctype [] (Struct tag_sym2))
        then
          Just (Mem.struct_mval tag_sym1 xs)
        else
          Nothing
    | (Union tag_sym1, Vloaded (LVspecified (OVunion tag_sym2 ident mem_val))) ->
        if tag_sym1 = tag_sym2 then
          Just (Mem.union_mval tag_sym1 ident mem_val)
        else
          Nothing
    | _ ->
        let () = Debug.print_debug 5 [] (fun () -> "memValueFromValue("
                 ^ Pp.stringFromCore_ctype (Ctype [] ty_) ^ ", " ^  Pp.stringFromCore_value cval ^ ")") in
        Nothing
  end




(* Core pattern builders **************************************************** *)

val mk_empty_pat: core_base_type -> pattern
let mk_empty_pat bTy =
  Pattern [] (CaseBase (Nothing, bTy))

val mk_sym_pat_: forall 'sym. list Annot.annot -> maybe 'sym -> core_base_type -> generic_pattern 'sym
let mk_sym_pat_ annots msym bTy =
  Pattern annots (CaseBase (msym, bTy))

val mk_sym_pat: Symbol.sym -> core_base_type -> pattern
let mk_sym_pat sym bty = mk_sym_pat_ [] (Just sym) bty

val mk_tuple_pat: list pattern -> pattern
let mk_tuple_pat = function
  | [] ->
      error "[Core_aux.mk_tuple_pat] called with |pats| = 0"
  | [pat] ->
      pat
  | pats ->
      Pattern [] (CaseCtor Ctuple pats)
end

val mk_specified_pat_: forall 'bty 'sym. list Annot.annot -> generic_pattern 'sym -> generic_pattern 'sym
let mk_specified_pat_ annots pat =
  Pattern annots (CaseCtor Cspecified [pat])

val mk_specified_pat: pattern -> pattern
let mk_specified_pat pat = mk_specified_pat_ [] pat

val mk_unspecified_pat_: forall 'bty 'sym. list Annot.annot -> generic_pattern 'sym -> generic_pattern 'sym
let mk_unspecified_pat_ annots pat =
  Pattern annots (CaseCtor Cunspecified [pat])

val mk_unspecified_pat: pattern -> pattern
let mk_unspecified_pat pat = mk_unspecified_pat_ [] pat

let rec mk_list_pat (bTy : core_base_type) pats = 
  match pats with
  | [] ->
      Pattern [] (CaseCtor (Cnil bTy) [])
  | _pat::_pats ->
      Pattern [] (CaseCtor Ccons [_pat; mk_list_pat bTy _pats])
  end


(* Core pexpr builders  ***************************************************** *)
val mk_sym_pe_ : forall 'bty. list Annot.annot -> 'bty -> Symbol.sym -> generic_pexpr 'bty Symbol.sym
let mk_sym_pe_ annots bty sym =
  Pexpr annots bty (PEsym sym)

val mk_sym_pe: Symbol.sym -> pexpr
let mk_sym_pe sym =
  Pexpr [] () (PEsym sym)

(* TODO: mk_impl_pe *)

(* TODO: PEval Vconstrained, Vobject *)

val mk_integer_pe: integer -> pexpr
let mk_integer_pe n =
  Pexpr [] () (PEval (Vobject (OVinteger (Mem.integer_ival n))))

val mk_floating_value_pe: Mem.floating_value -> pexpr
let mk_floating_value_pe fval =
  Pexpr [] () (PEval (Vobject (OVfloating fval)))

val mk_nullptr_pe: ctype -> pexpr
let mk_nullptr_pe ref_ty =
  Pexpr [] () (PEval (Vobject (OVpointer (Mem.null_ptrval ref_ty))))

val mk_specified_pe: pexpr -> pexpr
let mk_specified_pe pe =
    Pexpr [] () (PEctor Cspecified [pe])

val mk_unspecified_pe: ctype -> pexpr
let mk_unspecified_pe ty =
  Pexpr [] () (PEval (Vloaded (LVunspecified ty)))

val mk_array_pe: list pexpr -> pexpr
let mk_array_pe pes =
  Pexpr [] () (PEctor Carray pes)

val mk_unit_pe: pexpr
let mk_unit_pe =
  Pexpr [] () (PEval Vunit)


let mk_boolean_v = function
  | true -> Vtrue
  | false -> Vfalse
  end

val mk_boolean_pe: bool -> pexpr
let mk_boolean_pe b =
  Pexpr [] () (PEval (mk_boolean_v b))

(* TODO: PEval Vtrue, Vfalse *)

val mk_ail_ctype_pe: ctype -> pexpr
let mk_ail_ctype_pe ty =
  Pexpr [] () (PEval (Vctype ty))

val mk_ctype_pe: ctype -> pexpr
let mk_ctype_pe ty =
  Pexpr [] () (PEval (Vctype ty))

val     mk_list_pe: core_base_type -> list pexpr -> pexpr
let rec mk_list_pe bTy pes =
  Pexpr [] () match pes with
    | [] ->
        PEctor (Cnil bTy) []
    | pe :: pes' ->
        PEctor Ccons [pe; mk_list_pe bTy pes']
  end

val mk_tuple_pe: list pexpr -> pexpr
let mk_tuple_pe = function
  | [] ->
      error "Core_aux.mk_tuple_pe []"
  | [pe] ->
      pe
  | pes ->
      Pexpr [] () (PEctor Ctuple pes)
end

val mk_ivmax_pe: pexpr -> pexpr
let mk_ivmax_pe pe =
  Pexpr [] () (PEctor Civmax [pe])

val mk_ivmin_pe: pexpr -> pexpr
let mk_ivmin_pe pe =
  Pexpr [] () (PEctor Civmin [pe])

val mk_sizeof_pe: pexpr -> pexpr
let mk_sizeof_pe pe =
  Pexpr [] () (PEctor Civsizeof [pe])

val mk_alignof_pe: pexpr -> pexpr
let mk_alignof_pe pe =
  Pexpr [] () (PEctor Civalignof [pe])

val mk_nullcap_pe: bool -> pexpr
let mk_nullcap_pe is_signed =
  Pexpr [] () (PEctor (CivNULLcap is_signed) [])

(* TODO: PEconstrained *)

val mk_undef_pe: Loc.t -> Undefined.undefined_behaviour -> pexpr
let mk_undef_pe loc ub =
  Pexpr [] () (PEundef loc ub)

val mk_error_pe: string -> pexpr -> pexpr
let mk_error_pe str pe =
  Pexpr [] () (PEerror str pe)

val mk_not_pe: pexpr -> pexpr
let mk_not_pe pe =
  Pexpr [] () (PEnot pe)

val mk_op_pe: binop -> pexpr -> pexpr -> pexpr
let mk_op_pe bop pe1 pe2 =
  Pexpr [] () (PEop bop pe1 pe2)

val mk_conv_int_pe: integerType -> pexpr -> pexpr
let mk_conv_int_pe ity pe =
  Pexpr [] () (PEconv_int ity pe)

val mk_wrapI_pe: integerType -> iop -> pexpr -> pexpr -> pexpr
let mk_wrapI_pe ity iop pe1 pe2 =
  Pexpr [] () (PEwrapI ity iop pe1 pe2)

val mk_catch_exceptional_condition_pe: integerType -> iop -> pexpr -> pexpr -> pexpr
let mk_catch_exceptional_condition_pe ity iop pe1 pe2 =
  Pexpr [] () (PEcatch_exceptional_condition ity iop pe1 pe2)

val mk_let_pe: pattern -> pexpr -> pexpr -> pexpr
let mk_let_pe pat pe1 pe2 =
  Pexpr [] () (PElet pat pe1 pe2)

val mk_if_pe_: list annot -> pexpr -> pexpr -> pexpr -> pexpr
let mk_if_pe_ annots pe1 pe2 pe3 =
  Pexpr annots () (PEif pe1 pe2 pe3)


val mk_if_pe: pexpr -> pexpr -> pexpr -> pexpr
let mk_if_pe pe1 pe2 pe3 =
  Pexpr [] () (PEif pe1 pe2 pe3)

val mk_array_shift: pexpr -> ctype -> pexpr -> pexpr
let mk_array_shift pe1 ty pe2 =
  Pexpr [] () (PEarray_shift pe1 ty pe2)

val mk_member_shift_pe: pexpr -> Symbol.sym -> Symbol.identifier -> pexpr
let mk_member_shift_pe pe1 tag_sym member_ident =
  Pexpr [] () (PEmember_shift pe1 tag_sym member_ident)

val mk_memop_pe: Mem_common.pure_memop -> list pexpr -> pexpr
let mk_memop_pe mop pes =
  Pexpr [] () (PEmemop mop pes)

val mk_case_pe: pexpr -> list (pattern * pexpr) -> pexpr
let mk_case_pe pe pat_pes =
  Pexpr [] () (PEcase pe pat_pes)

val mk_neg_pe: pexpr -> pexpr
let mk_neg_pe pe =
  Pexpr [] () (PEop OpSub (mk_integer_pe 0) pe)

val mk_struct_pe: Symbol.sym -> list (Symbol.identifier * pexpr) -> pexpr
let mk_struct_pe tag_sym xs =
  Pexpr [] () (PEstruct tag_sym xs)

val mk_union_pe: Symbol.sym -> Symbol.identifier -> pexpr -> pexpr
let mk_union_pe tag_sym memb_ident pe =
  Pexpr [] () (PEunion tag_sym memb_ident pe)

val mk_memberof_pe: Symbol.sym -> Symbol.identifier -> pexpr -> pexpr
let mk_memberof_pe tag_sym memb_ident pe =
  Pexpr [] () (PEmemberof tag_sym memb_ident pe)

val mk_value_pe: value -> pexpr
let mk_value_pe cval =
  Pexpr [] () (PEval cval)

val mk_cfunction_pe: pexpr -> pexpr
let mk_cfunction_pe pe =
  Pexpr [] () (PEcfunction pe)

val mk_std_pe: string -> pexpr -> pexpr
let mk_std_pe std (Pexpr annot bty pe_) =
  Pexpr ((Astd std)::annot) bty pe_

val mk_std_undef_pe: Loc.t -> string -> Undefined.undefined_behaviour -> pexpr
let mk_std_undef_pe loc std ub =
  mk_std_pe std $ mk_undef_pe loc ub

val mk_std_pair_pe: string -> pexpr * pexpr -> pexpr * pexpr
let mk_std_pair_pe std (pe1, pe2) =
  (mk_std_pe std pe1, mk_std_pe std pe2)


val mk_call_pe: name -> list pexpr -> pexpr
let mk_call_pe nm pes =
  Pexpr [] () (PEcall nm pes)

val mk_are_compatible: pexpr -> pexpr -> pexpr
let mk_are_compatible pe1 pe2 =
  Pexpr [] () (PEare_compatible pe1 pe2)




(* Some common undef *)

val mk_undef_exceptional_condition: Loc.t -> pexpr
let mk_undef_exceptional_condition loc =
  mk_std_undef_pe loc "ยง6.5#5" Undefined.UB036_exceptional_condition












val bitwise_complement_pe: pexpr -> pexpr -> pexpr
(*
val integer_encode_pe:     pexpr -> pexpr -> pexpr
val integer_decode_pe:     pexpr -> pexpr -> pexpr
*)

let bitwise_complement_pe pe1 pe2 =
  Pexpr [] () (PEctor CivCOMPL [pe1; pe2])
(*
  Pexpr [] () (PEcall (Impl Implementation.Bitwise_complement) [pe1; pe2])
*)
(*
let integer_encode_pe pe1 pe2 =
  Pexpr [] () (PEcall (Impl Implementation.Integer__encode) [pe1; pe2])
let integer_decode_pe pe1 pe2 =
  Pexpr [] () (PEcall (Impl Implementation.Integer__decode) [pe1; pe2])
*)

(* Some aliases for positive actions *)
let pcreate loc al ty pref =
  Expr [] (Eaction (Paction Pos (Action loc default (Create al ty pref))))
let pcreate_readonly loc al ty init pref =
  Expr [] (Eaction (Paction Pos (Action loc default (CreateReadOnly  al ty init pref))))
let palloc loc al e pref =
  Expr [] (Eaction (Paction Pos (Action loc default (Alloc al e pref))))
let pkill loc kind x =
  Expr [] (Eaction (Paction Pos (Action loc default (Kill kind x))))
let pstore loc ty x n mo =
  Expr [] (Eaction (Paction Pos (Action loc default (Store false ty x n mo))))
let pstore_lock loc ty x n mo =
  Expr [] (Eaction (Paction Pos (Action loc default (Store true ty x n mo))))
let pload loc ty x mo =
  Expr [] (Eaction (Paction Pos (Action loc default (Load ty x mo))))
let prmw loc ty x n1 n2 mo1 mo2 =
  Expr [] (Eaction (Paction Pos (Action loc default (RMW ty x n1 n2 mo1 mo2))))
let pcompare_exchange_strong loc ty x n1 n2 mo1 mo2 =
  Expr [] (Eaction (Paction Pos (
        Action loc default (CompareExchangeStrong ty x n1 n2 mo1 mo2))))
let pcompare_exchange_weak loc ty x n1 n2 mo1 mo2 =
  Expr [] (Eaction (Paction Pos (
        Action loc default (CompareExchangeWeak ty x n1 n2 mo1 mo2))))
let plinux_load loc ty x mo =
  Expr [] (Eaction (Paction Pos (Action loc default (LinuxLoad ty x mo))))
let plinux_store loc ty x n mo =
  Expr [] (Eaction (Paction Pos (Action loc default (LinuxStore ty x n mo))))
let plinux_rmw loc ty x n mo =
  Expr [] (Eaction (Paction Pos (Action loc default (LinuxRMW ty x n mo))))

import Global Cmm_csem
let seq_rmw loc with_forward ty oTy x sym upd =
  let backend = Global.backend_name () in
  if backend = "Cn" || backend = "Bmc" then
    (* TODO: compatibility mode for Cn, until SeqRMW is supported *)
    if with_forward then
      error "TODO: Core_aux.seq_rmw (comptability mode) with_forward"
    else
      Expr [] (Ewseq (mk_sym_pat sym (*TODO*)(BTy_loaded oTy))
                    (pload loc ty x Cmm_csem.NA)
                    (Expr [] (Ewseq (mk_empty_pat BTy_unit)
                                    (pstore loc ty x upd Cmm_csem.NA)
                                    (Expr [] (Epure (mk_sym_pe sym))))))
  else
    Expr [] (Eaction (Paction Pos (Action loc default (SeqRMW with_forward ty x sym upd))))





(* for a given Ctype returns the corresponding "zero" value *)
(*val     zeros: AilSyntax.tag_definition -> ctype -> pexpr *)
(* see ยง6.7.9#10 *)
let rec zeros_aux tagDefs (Ctype _ ty) =
  let zero_ival = Mem.integer_ival 0 in
  match ty with
    | Basic (Integer ity) ->
        Mem.integer_value_mval ity zero_ival
    | Basic (Floating fty) ->
        Mem.floating_value_mval fty Mem.zero_fval
    | Array elem_ty (Just n) ->
        Mem.array_mval (List.replicate (natFromInteger n) (zeros_aux tagDefs elem_ty))
(*
  Mem.array_mval (List.replicate (natFromInteger n) (Mem.integer_value_mval zero_ival))
*)
    | Pointer _ ref_ty ->
        Mem.pointer_mval ref_ty (Mem.null_ptrval ref_ty)
    | Atomic ty' ->
        zeros_aux tagDefs ty'
    | Struct tag ->
        match Map.lookup tag tagDefs with
          | Just (_, StructDef ident_tys Nothing) ->
              Mem.struct_mval tag (List.map (fun (ident, (_, _, _, ty)) -> (ident, ty, zeros_aux tagDefs ty)) ident_tys)
          | Just (_, StructDef ident_tys (Just (FlexibleArrayMember _ flex_ident flex_qs flex_elem_ty))) ->
              let () = Debug.print_debug 0 [] (fun () ->
                "TODO: check Core_aux.zeros_aux for flexible array member"
              ) in
              Mem.struct_mval tag (List.map (fun (ident, (_, _, _, ty)) -> (ident, ty, zeros_aux tagDefs ty)) ident_tys)
          | _ ->
              error "Core_aux.zeros_aux, not StructDef"
        end
    | Union tag ->
        match Map.lookup tag tagDefs with
          | Just (_, UnionDef ((ident, (_, _, _, ty'))::_)) ->
              Mem.union_mval tag ident (zeros_aux tagDefs ty')
          | _ ->
              error "Core_aux.zeros_aux, not UnionDef"
        end
   | _ ->
       error "Core_aux.zeros should only be called on complete types"
  end

val zeros: core_tag_definitions -> ctype -> pexpr
let zeros tagDefs ty =
  (* TODO: yucky *)
  Pexpr [] ()
(*
    (PEval (Vobject (snd $ objectValueFromMemValue (zeros_aux ty))))
*)
    (PEval (snd $ valueFromMemValue (zeros_aux tagDefs ty)))


(*


(*

TODO: bring back structs/unions

  let proj_member = function
    | Ail.MEMBER ty               -> MEMBER (proj_ctype ty)
    | Ail.BITFIELD ty w is_packed -> BITFIELD (proj_ctype ty) w is_packed
  end in
*)
  match ty with
    | Ctype.Void             -> Void
    | Ctype.Basic bt         -> Basic bt
    | Ctype.Array ty n       -> Array (proj_ctype ty) n
    | Ctype.Function ty ps b -> Function (proj_ctype ty) (List.map (proj_ctype -| snd) ps) b
    | Ctype.Pointer _ ty    -> Pointer (proj_ctype ty)
    | Ctype.Atomic ty        -> Atomic (proj_ctype ty)
(*
    | Ail.STRUCT _ tag members -> STRUCT tag (List.map (fun (a, m) -> (a, proj_member m)) members)
    | Ail.UNION  _ tag members -> UNION  tag (List.map (fun (a, m) -> (a, proj_member m)) members)
    | Ail.ENUM id              -> ENUM id
    | Ail.ATOMIC ty            -> ATOMIC (proj_ctype ty)
    | Ail.TYPEDEF _            -> error "[Core_aux.proj_ctype] found a A.TYPEDEF"
    | Ail.SIZE_T               -> SIZE_T
    | Ail.INTPTR_T             -> INTPTR_T
    | Ail.WCHAR_T              -> WCHAR_T
    | Ail.CHAR16_T             -> CHAR16_T
    | Ail.CHAR32_T             -> CHAR32_T
*)
end
*)

(*
(* Bring back a Core.ctype into a Ail.ctype (with loss of qualifiers if coming from proj_ctype) *)
let rec unproj_ctype ty =
  Ctype.Ctype [] (match ty with
    | Void ->
        Ctype.Void
    | Basic bty ->
        Ctype.Basic bty
    | Array ty n_opt ->
        Ctype.Array (unproj_ctype ty) n_opt
    | Function (qs, ty) qs_tys is_variadic ->
        (* NOTE: there is a potential loss of information here for hasProto and
           inside the parameters with isRegister. But this shouldn't matter to
           the dynamics *)
        Ctype.Function false (qs, unproj_ctype ty) (
          List.map (fun (qs,ty) ->
            (qs, unproj_ctype ty, false)
          ) qs_tys
        ) is_variadic
    | Pointer qs ty ->
        Ctype.Pointer qs (unproj_ctype ty)
    | Atomic ty ->
        Ctype.Atomic (unproj_ctype ty)
    | Struct tag ->
        Ctype.Struct tag
    | Union tag ->
        Ctype.Union tag
  end)
*)

(*
(*
  let unproj_member = function
    | MEMBER ty               -> Ail.MEMBER (unproj_ctype ty)
    | BITFIELD ty w is_packed -> Ail.BITFIELD (unproj_ctype ty) w is_packed
  end in
*)
  match ty with
    | Void              -> Ctype.Void
    | Basic bt          -> Ctype.Basic bt
    | Array ty n        -> Ctype.Array (unproj_ctype ty) n
    | Function ty tys b -> Ctype.Function (unproj_ctype ty) (List.map (Product.make Ctype.no_qualifiers -| unproj_ctype) tys) b
    | Pointer ty        -> Ctype.Pointer Ctype.no_qualifiers (unproj_ctype ty)
    | Atomic ty         -> Ctype.Atomic (unproj_ctype ty)
(*
    | STRUCT tag members -> Ail.STRUCT Ail.no_qualifiers tag (List.map (fun (a, m) -> (a, unproj_member m)) members)
    | UNION  tag members -> Ail.UNION  Ail.no_qualifiers tag (List.map (fun (a, m) -> (a, unproj_member m)) members)
    | ENUM id            -> Ail.ENUM id
    | ATOMIC ty          -> Ail.ATOMIC (unproj_ctype ty)
    | SIZE_T             -> Ail.SIZE_T
    | INTPTR_T           -> Ail.INTPTR_T
    | WCHAR_T            -> Ail.WCHAR_T
    | CHAR16_T           -> Ail.CHAR16_T
    | CHAR32_T           -> Ail.CHAR32_T
*)
end
*)




(*
let rec mk_wseqs_aux end_e pat_es =
  match pat_es with
    | []               -> end_e
    | (pat, e) :: pat_es' -> Ewseq pat e (mk_wseqs_aux end_e pat_es')
end

val mk_wseqs: expr unit -> list (pattern * expr unit) -> expr unit
let mk_wseqs end_e = function
  | [] ->
      end_e
  | [(_, e)] ->
      e
  | pat_es ->
      mk_wseqs_aux end_e pat_es
end
*)

val     mk_sseqs: list (pattern * expr unit) -> (expr unit -> expr unit)
let rec mk_sseqs pat_es =
  fun z ->
  match pat_es with
    | [] ->
        z
    | (pat, e) :: pat_es' ->
        Expr [] (Esseq pat e (mk_sseqs pat_es' z))
  end



(*
(* val     mk_sseq: forall 'a. list (pattern * expr 'a) -> expr 'a *)
let rec mk_sseq a_opts_es =
  match a_opts_es with
    | []               -> Eskip
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Esseq a_opts e (mk_sseq es')
end

(* val     mk_sseq': forall 'a. list (pattern * expr 'a) -> expr 'a -> expr 'a *)
let rec mk_sseq' a_opts_es z =
  match a_opts_es with
    | []               -> z
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Esseq a_opts e (mk_sseq' es' z)
end
*)


let mk_unseq = function
  | []  -> Expr [] (Epure (Pexpr [] () (PEval Vunit)))
  | [e] -> e
  | es  -> Expr [] (Eunseq es)
end

val     mk_unit_sseq: list (expr unit) -> (expr unit -> expr unit)
let rec mk_unit_sseq es =
  fun z ->
    match es with
      | [] ->
          z
(*
      | [e] ->
          e
*)
      | e::es' ->
          Expr [] (Esseq (mk_empty_pat BTy_unit) e (mk_unit_sseq es' z))
    end

val     mk_bTy_sseqs: list (core_base_type * expr unit) -> expr unit
let rec mk_bTy_sseqs bTy_es =
  match bTy_es with
    | [] ->
        Expr [] (Epure (Pexpr [] () (PEval Vunit)))
    | [(_, e)] ->
        e
    | (bTy, e) :: bTy_es' ->
        Expr [] (Esseq (mk_empty_pat bTy) e (mk_bTy_sseqs bTy_es'))
  end

let rec concat_sseq ((Expr annot e_) as e) e' =
   match e_ with
     | Esseq pat e1 e2                 -> Expr annot (Esseq pat e1 (concat_sseq e2 e'))
     | Epure (Pexpr _ _ (PEval Vunit)) -> e'
     | _                               -> Expr [] (Esseq (mk_empty_pat BTy_unit) e e')
  end

let is_negative = function
  | Expr _ (Eaction (Paction Neg _)) ->
      true
  | _ ->
      false
end

let is_negative_action = function
  | (Paction Neg _) ->
      true
  | _ ->
      false
end


(* TODO: rewrite this in bottom-up *)
(*
val     flatten_constrained_value: value -> value
let rec flatten_constrained_value v =
  match v with
    | Vconstrained xs ->
        Vconstrained $ List.concatMap (fun (cs, v') ->
          match flatten_constrained_value v' with
            | Vconstrained ys ->
                List.map (fun (cs', v'') ->
                  (ND.concat cs cs', v'')
                ) ys
            | v'' ->
                [(cs, v'')]
          end
        ) xs
    | _ ->
        v
  end
*)

val valueFromPexpr: pexpr -> maybe value
let valueFromPexpr = function
  | Pexpr _ () (PEval cval) ->
      Just ((*flatten_constrained_value*) cval)
  | _ ->
      Nothing
  end

val valueFromPexprs: list pexpr -> maybe (list value)
let valueFromPexprs pes =
  List.foldr (fun pe acc_opt ->
    match (valueFromPexpr pe, acc_opt) with
      | (Just cval, Just acc) ->
          Just (cval :: acc)
      | _ ->
          Nothing
    end) (Just []) pes

val valueOrPEconstrainedFromPexpr: pexpr -> maybe (either value pexpr)
let valueOrPEconstrainedFromPexpr pe =
  match pe with
    | Pexpr _ () (PEval cval) ->
        Just (Left cval)
    | Pexpr _ () (PEconstrained _) ->
        Just (Right pe)
    | _ ->
        Nothing
  end

val valueOrPEconstrainedFromPexprs: list pexpr -> maybe (either (list value) ((nat * (list (Mem.mem_iv_constraint  * pexpr))) * (list pexpr)))
let valueOrPEconstrainedFromPexprs pes =
  snd (List.foldr (fun pe (i, acc) ->
      (i+1, match (valueOrPEconstrainedFromPexpr pe, acc) with
        | (Just (Left cval), Just (Left cvals)) ->
            Just (Left (cval :: cvals))
        | (Just (Right (Pexpr _ () (PEconstrained xs) as pe)), Just (Left cvals)) ->
            Just (Right ((i, xs), pe :: (List.map (fun v -> Pexpr [] () (PEval v)) cvals)))
        | (Just (Right pe), Just (Right (i_xs, pes))) ->
            Just (Right (i_xs, pe :: pes))
        | _ ->
            Nothing
      end)) (0, Just (Left [])) pes)


val to_integer: pexpr -> maybe integer
let core_aux_to_integer pe =
  match valueFromPexpr pe with
    | Just (Vobject (OVinteger ival)) ->
        Mem_aux.integerFromIntegerValue ival
    | _ ->
        Nothing
  end
let inline to_integer = core_aux_to_integer










(* check if a symbolic names is part of a pattern *)
val in_pattern: Symbol.sym -> pattern -> bool
let rec in_pattern sym (Pattern _ pat) =
  match pat with
    | CaseBase (sym_opt, _) ->
        maybe false (fun sym' -> sym = sym') sym_opt
    | CaseCtor _ pats' ->
        List.any (in_pattern sym) pats'
  end





val     subst_sym_pexpr: Symbol.sym -> value -> pexpr -> pexpr
let rec subst_sym_pexpr sym cval (Pexpr annot bty pexpr_) =
  Pexpr annot bty match pexpr_ with
    | PEsym sym' ->
        if sym = sym' then PEval cval else pexpr_
    | PEimpl _ ->
        pexpr_
    | PEval _ ->
        pexpr_
    | PEconstrained xs ->
        PEconstrained $
          List.map (fun (constrs, pe) -> (constrs, subst_sym_pexpr sym cval pe)) xs
    | PEundef _ _ ->
        pexpr_
    | PEerror str pe ->
        PEerror str (subst_sym_pexpr sym cval pe)
    | PEctor ctor pes ->
        PEctor ctor (List.map (subst_sym_pexpr sym cval) pes)
    | PEcase pe xs ->
        PEcase (subst_sym_pexpr sym cval pe) (List.map (fun (pat, pe) ->
          (pat, if in_pattern sym pat then pe else subst_sym_pexpr sym cval pe)
        ) xs)
    | PEarray_shift pe1 ty pe2 ->
        PEarray_shift (subst_sym_pexpr sym cval pe1) ty (subst_sym_pexpr sym cval pe2)
    | PEmember_shift pe tag_sym memb_ident ->
        PEmember_shift (subst_sym_pexpr sym cval pe) tag_sym memb_ident
    | PEmemop mop pes ->
        PEmemop mop (List.map (subst_sym_pexpr sym cval) pes)
    | PEnot pe ->
        PEnot (subst_sym_pexpr sym cval pe)
    | PEop bop pe1 pe2 ->
        PEop bop (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2)
    | PEconv_int ty pe ->
        PEconv_int ty (subst_sym_pexpr sym cval pe)
    | PEwrapI ty iop pe1 pe2 ->
        PEwrapI ty iop (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2)
    | PEcatch_exceptional_condition ty iop pe1 pe2 ->
        PEcatch_exceptional_condition ty iop (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2)
    | PEstruct tag_sym xs ->
        PEstruct tag_sym (List.map (fun (ident, pe) -> (ident, subst_sym_pexpr sym cval pe)) xs)
    | PEunion tag_sym ident pe ->
        PEunion tag_sym ident (subst_sym_pexpr sym cval pe)
    | PEcfunction pe ->
        PEcfunction (subst_sym_pexpr sym cval pe)
    | PEmemberof tag_sym memb_ident pe ->
        PEmemberof tag_sym memb_ident (subst_sym_pexpr sym cval pe)
    | PEcall nm pes ->
        PEcall nm (List.map (subst_sym_pexpr sym cval) pes)
    | PElet pat pe1 pe2 ->
        PElet pat (subst_sym_pexpr sym cval pe1) (if in_pattern sym pat then pe2 else subst_sym_pexpr sym cval pe2)
    | PEif pe1 pe2 pe3 ->
        PEif (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2) (subst_sym_pexpr sym cval pe3)
    | PEis_scalar pe ->
        PEis_scalar (subst_sym_pexpr sym cval pe)
    | PEis_integer pe ->
        PEis_integer (subst_sym_pexpr sym cval pe)
    | PEis_signed pe ->
        PEis_signed (subst_sym_pexpr sym cval pe)
    | PEis_unsigned pe ->
        PEis_unsigned (subst_sym_pexpr sym cval pe)
    | PEbmc_assume pe ->
        PEbmc_assume (subst_sym_pexpr sym cval pe)
    | PEare_compatible pe1 pe2 ->
        PEare_compatible (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2)
end


val     subst_sym_expr: forall 'a. Symbol.sym -> value -> expr 'a -> expr 'a
let rec subst_sym_expr sym cval (Expr annot expr_) =
  Expr annot match expr_ with
    | Epure pe ->
        Epure (subst_sym_pexpr sym cval pe)
    | Ememop memop pes ->
        Ememop memop (List.map (subst_sym_pexpr sym cval) pes)
    | Elet pat pe1 e2 ->
        Elet pat (subst_sym_pexpr sym cval pe1)
          (if in_pattern sym pat then e2 else subst_sym_expr sym cval e2)
    | Eif pe1 e2 e3 ->
        Eif (subst_sym_pexpr sym cval pe1)
          (subst_sym_expr sym cval e2) (subst_sym_expr sym cval e3)
    | Ecase pe pat_es ->
        Ecase (subst_sym_pexpr sym cval pe) (List.map (fun (pat, e) ->
          (pat, if in_pattern sym pat then e else subst_sym_expr sym cval e)
        ) pat_es)
    | Eccall annot pe1 pe2 pes ->
        Eccall annot (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2)
          (List.map (subst_sym_pexpr sym cval) pes)
    | Eproc annot nm pes ->
        Eproc annot nm (List.map (subst_sym_pexpr sym cval) pes)
    | Eaction pact ->
        Eaction (subst_sym_paction sym cval pact)
    | Eunseq es ->
        Eunseq (List.map (subst_sym_expr sym cval) es)
    | Ewseq pat e1 e2 ->
        Ewseq pat (subst_sym_expr sym cval e1)
          (if in_pattern sym pat then e2 else subst_sym_expr sym cval e2)
    | Esseq pat e1 e2 ->
        Esseq pat (subst_sym_expr sym cval e1)
          (if in_pattern sym pat then e2 else subst_sym_expr sym cval e2)
    | Ebound e ->
        Ebound (subst_sym_expr sym cval e)
    | Esave lab_sym sym_bTy_pes e ->
        let sym_bTy_pes' = List.map (fun (z, (bTy, pe)) ->
          (z, (bTy, subst_sym_pexpr sym cval pe))
        ) sym_bTy_pes in
        if List.any (fun (z, _) -> sym = z) sym_bTy_pes then
          let () = Debug.warn [] (fun () -> "subst, Esave ==> shadowing") in
          (* TODO: check *)
          Esave lab_sym sym_bTy_pes' e 
        else
          Esave lab_sym sym_bTy_pes' (subst_sym_expr sym cval e)
    | Erun annot lab_sym pes ->
        Erun annot lab_sym (List.map (subst_sym_pexpr sym cval) pes)
    | End es ->
        End (List.map (subst_sym_expr sym cval) es)
    | Epar es ->
        Epar (List.map (subst_sym_expr sym cval) es)
    | Ewait _ ->
      expr_
    | Eannot xs e ->
        Eannot xs (subst_sym_expr sym cval e)
    | Eexcluded n act ->
        Eexcluded n (subst_sym_action sym cval act)
(*
    | Eloc loc e ->
        Eloc loc (subst_sym_expr sym cval e)
    | Estd str e ->
        Estd str (subst_sym_expr sym cval e)
*)
  end

and subst_sym_action_ sym cval = function
  | Create pe1 pe2 pref ->
      Create (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2) pref
  | CreateReadOnly pe1 pe2 pe3 pref ->
      CreateReadOnly (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2) (subst_sym_pexpr sym cval pe3) pref
  | Alloc pe1 pe2 pref ->
      Alloc (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2) pref
  | Kill kind pe ->
      Kill kind (subst_sym_pexpr sym cval pe)
  | Store b pe1 pe2 pe3 mo ->
      Store b (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2)
        (subst_sym_pexpr sym cval pe3) mo
  | Load pe1 pe2 mo ->
      Load (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2) mo
  | SeqRMW b pe1 pe2 sym' pe3 ->
      SeqRMW b (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2) sym'
        begin
          if sym = sym' then pe3 else subst_sym_pexpr sym cval pe3
        end
  | RMW pe1 pe2 pe3 pe4 mo1 mo2 ->
      RMW (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2)
        (subst_sym_pexpr sym cval pe3) (subst_sym_pexpr sym cval pe4) mo1 mo2
  | Fence mo ->
      Fence mo
  | CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 ->
      CompareExchangeStrong (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2)
        (subst_sym_pexpr sym cval pe3) (subst_sym_pexpr sym cval pe4) mo1 mo2
  | CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 ->
      CompareExchangeWeak (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2)
        (subst_sym_pexpr sym cval pe3) (subst_sym_pexpr sym cval pe4) mo1 mo2
  | LinuxFence mo ->
      LinuxFence mo
  | LinuxStore pe1 pe2 pe3 mo ->
      LinuxStore (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2)
        (subst_sym_pexpr sym cval pe3) mo
  | LinuxLoad pe1 pe2 mo ->
      LinuxLoad (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2) mo
  | LinuxRMW pe1 pe2 pe3 mo ->
      LinuxRMW (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2)
        (subst_sym_pexpr sym cval pe3) mo
end
and subst_sym_action sym cval (Action loc bs act_) =
  Action loc bs (subst_sym_action_ sym cval act_)
and subst_sym_paction sym cval (Paction p act) =
  Paction p (subst_sym_action sym cval act)



val     subst_pattern_val: forall 'a. pattern -> value -> expr 'a -> expr 'a
let rec subst_pattern_val (Pattern _ pat) cval expr =
  (* TODO (maybe), Carray, Civmax, Civmin, Civsizeof, Civalignof *)
  match (pat, cval) with
    | (CaseBase (Nothing, _), _) ->
        (* e[_ \ v] = e *)
        expr
    | (CaseBase (Just sym, _), _) ->
        (* e[sym \ v] *)
        subst_sym_expr sym cval expr
    | (CaseCtor (Cnil _) [], Vlist _ []) ->
        (* empty list (value) *)
        expr
    | (CaseCtor Ccons [pat1; pat2], Vlist bTy_elem (cval1::cvals)) ->
        (* populated list (value) *)
        subst_pattern_val pat1 cval1 $
          subst_pattern_val pat2 (Vlist bTy_elem cvals) expr
    | (CaseCtor Ctuple pats', Vtuple cvals) ->
        List.foldr (fun (pat', cval') acc ->
          subst_pattern_val pat' cval' acc
        ) expr (List.zip pats' cvals)
    | (CaseCtor Cspecified [pat'], Vloaded (LVspecified oval)) ->
        subst_pattern_val pat' (Vobject oval) expr
    | (CaseCtor Cunspecified [pat'], Vloaded (LVunspecified ty)) ->
        subst_pattern_val pat' (Vctype ty) expr
    | (CaseCtor ctor pats, _) ->
        let str_ctor = match ctor with
          | Cnil _ ->
              "nil"
          | Ccons ->
              "cons"
          | Ctuple ->
              "tuple"
          | Carray ->
              "array"
          | Civmax ->
              "ivmax"
          | Civmin ->
              "ivmin"
          | Civsizeof ->
              "ivsizeof"
          | Civalignof ->
              "ivalignof"
          | CivCOMPL ->
              "ivCOMPL"
          | CivAND ->
              "ivAND"
          | CivOR ->
              "ivOR"
          | CivXOR ->
              "ivXOR"
          | Cspecified ->
              "specified"
          | Cunspecified ->
              "unspecified"
          | Cfvfromint ->
              "fvfromint"
          | Civfromfloat ->
              "ivfromfloat"
          | CivNULLcap is_signed ->
              "ivNULLcap(" ^ if is_signed then "signed" else "unsigned" ^ ")"
        end in
        error ("WIP: Core_aux.subst_pattern_val ==> ctor= " ^ str_ctor ^ ", |pats|= "
               ^ (show (List.length pats)) ^ " -- " ^ Pp.stringFromCore_value cval)
  end


























(* substitute in an expression a symbolic name with a (pure) expression *)
(* NOTE: this is usually unsound to use if pe' doesn't evaluate to a defined value or generates memory constraints *)
val     unsafe_subst_sym_pexpr: Symbol.sym -> pexpr -> pexpr -> pexpr
let rec unsafe_subst_sym_pexpr sym (Pexpr annot bty pe_' as pe') (Pexpr _ _ pe_) =
  Pexpr annot bty match pe_ with
    | PEsym sym' ->
        if sym = sym' then pe_' else pe_
    | PEimpl _ ->
        pe_
    | PEval _ ->
        pe_
    | PEconstrained xs ->
        PEconstrained $
          List.map (fun (constrs, pe) -> (constrs, unsafe_subst_sym_pexpr sym pe' pe)) xs
    | PEundef _ _ ->
        pe_
    | PEerror str pe ->
        PEerror str (unsafe_subst_sym_pexpr sym pe' pe)
    | PEctor ctor pes ->
        PEctor ctor (List.map (unsafe_subst_sym_pexpr sym pe') pes)
    | PEcase pe xs ->
        PEcase (unsafe_subst_sym_pexpr sym pe' pe) (List.map (fun (pat, pe) ->
          (pat, if in_pattern sym pat then pe else unsafe_subst_sym_pexpr sym pe' pe)
        ) xs)
    | PEarray_shift pe1 ty pe2 ->
        PEarray_shift (unsafe_subst_sym_pexpr sym pe' pe1) ty (unsafe_subst_sym_pexpr sym pe' pe2)
    | PEmember_shift pe tag_sym memb_ident ->
        PEmember_shift (unsafe_subst_sym_pexpr sym pe' pe) tag_sym memb_ident
    | PEmemop mop pes ->
        PEmemop mop (List.map (unsafe_subst_sym_pexpr sym pe') pes)
    | PEnot pe ->
        PEnot (unsafe_subst_sym_pexpr sym pe' pe)
    | PEop bop pe1 pe2 ->
        PEop bop (unsafe_subst_sym_pexpr sym pe' pe1) (unsafe_subst_sym_pexpr sym pe' pe2)
    | PEconv_int ty pe ->
        PEconv_int ty (unsafe_subst_sym_pexpr sym pe' pe)
    | PEwrapI ty iop pe1 pe2 ->
        PEwrapI ty iop (unsafe_subst_sym_pexpr sym pe' pe1) (unsafe_subst_sym_pexpr sym pe' pe2)
    | PEcatch_exceptional_condition ty iop pe1 pe2 ->
        PEcatch_exceptional_condition ty iop (unsafe_subst_sym_pexpr sym pe' pe1) (unsafe_subst_sym_pexpr sym pe' pe2)
    | PEstruct tag_sym xs ->
        PEstruct tag_sym (List.map (fun (ident, pe) -> (ident, unsafe_subst_sym_pexpr sym pe' pe)) xs)
    | PEunion tag_sym ident pe ->
        PEunion tag_sym ident (unsafe_subst_sym_pexpr sym pe' pe)
    | PEcfunction pe ->
        PEcfunction (unsafe_subst_sym_pexpr sym pe' pe)
    | PEmemberof tag_sym memb_ident pe ->
        PEmemberof tag_sym memb_ident (unsafe_subst_sym_pexpr sym pe' pe)
    | PEcall nm pes ->
        PEcall nm (List.map (unsafe_subst_sym_pexpr sym pe') pes)
    | PElet pat pe1 pe2 ->
        PElet pat (unsafe_subst_sym_pexpr sym pe' pe1) (if in_pattern sym pat then pe2 else unsafe_subst_sym_pexpr sym pe' pe2)
    | PEif pe1 pe2 pe3 ->
        PEif (unsafe_subst_sym_pexpr sym pe' pe1) (unsafe_subst_sym_pexpr sym pe' pe2) (unsafe_subst_sym_pexpr sym pe' pe3)
    | PEis_scalar pe ->
        PEis_scalar (unsafe_subst_sym_pexpr sym pe' pe)
    | PEis_integer pe ->
        PEis_integer (unsafe_subst_sym_pexpr sym pe' pe)
    | PEis_signed pe ->
        PEis_signed (unsafe_subst_sym_pexpr sym pe' pe)
    | PEis_unsigned pe ->
        PEis_unsigned (unsafe_subst_sym_pexpr sym pe' pe)
    | PEbmc_assume pe ->
        PEbmc_assume (unsafe_subst_sym_pexpr sym pe' pe)
    | PEare_compatible pe1 pe2 ->
        PEare_compatible (unsafe_subst_sym_pexpr sym pe' pe1) (unsafe_subst_sym_pexpr sym pe' pe2)
end


(* NOTE: this is usually unsound to use if pe' doesn't evaluate to a defined value or generates memory constraints *)
val     unsafe_subst_sym_expr: forall 'a. Symbol.sym -> pexpr -> expr 'a -> expr 'a
let rec unsafe_subst_sym_expr sym pe' (Expr annot expr_) =
  Expr annot match expr_ with
    | Epure pe ->
        Epure (unsafe_subst_sym_pexpr sym pe' pe)
    | Ememop memop pes ->
        Ememop memop (List.map (unsafe_subst_sym_pexpr sym pe') pes)
    | Elet pat pe1 e2 ->
        Elet pat (unsafe_subst_sym_pexpr sym pe' pe1) (if in_pattern sym pat then e2 else unsafe_subst_sym_expr sym pe' e2)
    | Eif pe1 e2 e3 ->
        Eif (unsafe_subst_sym_pexpr sym pe' pe1) (unsafe_subst_sym_expr sym pe' e2) (unsafe_subst_sym_expr sym pe' e3)
    | Ecase pe pat_es ->
        Ecase (unsafe_subst_sym_pexpr sym pe' pe) (List.map (fun (pat, e) ->
          (pat, if in_pattern sym pat then e else unsafe_subst_sym_expr sym pe' e)
        ) pat_es)
    | Eccall annot pe1 pe2 pes ->
        Eccall annot (unsafe_subst_sym_pexpr sym pe' pe1) (unsafe_subst_sym_pexpr sym pe' pe2)
          (List.map (unsafe_subst_sym_pexpr sym pe') pes)
    | Eproc annot nm pes ->
        Eproc annot nm (List.map (unsafe_subst_sym_pexpr sym pe') pes)
    | Eaction pact ->
        Eaction (unsafe_subst_sym_paction sym pe' pact)
    | Eunseq es ->
        Eunseq (List.map (unsafe_subst_sym_expr sym pe') es)
    | Ewseq pat e1 e2 ->
        Ewseq pat (unsafe_subst_sym_expr sym pe' e1) (if in_pattern sym pat then e2 else unsafe_subst_sym_expr sym pe' e2)
    | Esseq pat e1 e2 ->
        Esseq pat (unsafe_subst_sym_expr sym pe' e1) (if in_pattern sym pat then e2 else unsafe_subst_sym_expr sym pe' e2)
    | Ebound e ->
        Ebound (unsafe_subst_sym_expr sym pe' e)
    | Esave lab_sym sym_bTy_pes e ->
        let sym_bTy_pes' = List.map (fun (z, (bTy, pe)) ->
          (z, (bTy, unsafe_subst_sym_pexpr sym pe' pe))
        ) sym_bTy_pes in
        if List.any (fun (z, _) -> sym = z) sym_bTy_pes then
          let () = Debug.warn [] (fun () -> "unsafe_subst, Esave ==> shadowing") in
          (* TODO: check *)
          Esave lab_sym sym_bTy_pes' e 
        else
          Esave lab_sym sym_bTy_pes' (unsafe_subst_sym_expr sym pe' e)
    | Erun annot lab_sym pes ->
        Erun annot lab_sym (List.map (unsafe_subst_sym_pexpr sym pe') pes)
    | End es ->
        End (List.map (unsafe_subst_sym_expr sym pe') es)
    | Epar es ->
        Epar (List.map (unsafe_subst_sym_expr sym pe') es)
    | Ewait _ ->
        expr_
    | Eannot xs e ->
        Eannot xs (unsafe_subst_sym_expr sym pe' e)
    | Eexcluded n act ->
        Eexcluded n (unsafe_subst_sym_action sym pe' act)

(*
    | Eloc loc e ->
        Eloc loc (unsafe_subst_sym_expr sym pe' e)
    | Estd s e ->
        Estd s (unsafe_subst_sym_expr sym pe' e)
*)
  end


(* NOTE: this is usually unsound to use if pe' doesn't evaluate to a defined value or generates memory constraints *)
and unsafe_subst_sym_action_ a pe' = function
  | Create pe1 pe2 pref ->
      Create (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2) pref
  | CreateReadOnly pe1 pe2 pe3 pref ->
      CreateReadOnly (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2) (unsafe_subst_sym_pexpr a pe' pe3) pref
  | Alloc pe1 pe2 pref ->
      Alloc (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2) pref
  | Kill kind pe ->
      Kill kind (unsafe_subst_sym_pexpr a pe' pe)
  | Store b pe1 pe2 pe3 mo ->
      Store b (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2)
        (unsafe_subst_sym_pexpr a pe' pe3) mo
  | Load pe1 pe2 mo ->
      Load (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2) mo
  | SeqRMW b pe1 pe2 sym' pe3 ->
      SeqRMW b (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2) sym'
        begin
          if a = sym' then pe3 else unsafe_subst_sym_pexpr a pe' pe3
        end
  | RMW pe1 pe2 pe3 pe4 mo1 mo2 ->
      RMW (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2)
        (unsafe_subst_sym_pexpr a pe' pe3) (unsafe_subst_sym_pexpr a pe' pe4) mo1 mo2
  | Fence mo ->
      Fence mo
  | CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 ->
      CompareExchangeStrong (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2) (unsafe_subst_sym_pexpr a pe' pe3) (unsafe_subst_sym_pexpr a pe' pe4) mo1 mo2
  | CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 ->
      CompareExchangeWeak (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2) (unsafe_subst_sym_pexpr a pe' pe3) (unsafe_subst_sym_pexpr a pe' pe4) mo1 mo2
  | LinuxFence mo ->
      LinuxFence mo
  | LinuxStore pe1 pe2 pe3 mo ->
      LinuxStore (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2)
        (unsafe_subst_sym_pexpr a pe' pe3) mo
  | LinuxLoad pe1 pe2 mo ->
      LinuxLoad (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2) mo
  | LinuxRMW pe1 pe2 pe3 mo ->
      LinuxRMW (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2)
        (unsafe_subst_sym_pexpr a pe' pe3) mo


(*
  | CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 ->
        CompareExchangeWeak (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2) (unsafe_subst_sym_pexpr a pe' pe3) (unsafe_subst_sym_pexpr a pe' pe4) mo1 mo2
*)
  end
and unsafe_subst_sym_action a pe' (Action loc bs act_) =
  Action loc bs (unsafe_subst_sym_action_ a pe' act_)
and unsafe_subst_sym_paction a pe' (Paction p act) =
  Paction p (unsafe_subst_sym_action a pe' act)

(* TODO: [unsafe_subst_pattern _as v e] substitute the symbols _as with the corresponding
   of the value expression [v] in the expression [e]. This function leads
   to a crash if [v] is not a value or its type doesn't match the symbolic
   pattern *)
(* NOTE: this is usually unsound to use if pe' doesn't evaluate to a defined value or generates memory constraints *)
val     unsafe_subst_pattern: forall 'a. pattern -> pexpr -> expr 'a -> expr 'a
let rec unsafe_subst_pattern (Pattern _ pat) pe' expr =
  
  match (pat, pe') with
    | (CaseBase (Nothing, _), _) ->
        expr
    | (CaseBase (Just sym, _), _) ->
        unsafe_subst_sym_expr sym pe' expr
    | (CaseCtor (Cnil _) [], Pexpr _ _ (PEval (Vlist _ []))) ->
        (* empty list (value) *)
        expr
    | (CaseCtor (Cnil _) [], Pexpr _ _ (PEctor (Cnil _) [])) ->
        (* empty list (pure expr) *)
        expr
    | (CaseCtor Ccons [pat1; pat2], Pexpr _ () (PEval (Vlist bTy_elem (cval::cvals)))) ->
        (* populated list (value) *)
        subst_pattern_val pat1 cval $
          subst_pattern_val pat2 (Vlist bTy_elem cvals) expr
    | (CaseCtor Ccons [pat1; pat2], Pexpr _ _ (PEctor Ccons [pe1; pe2])) ->
        (* populated list (pure expr) *)
        unsafe_subst_pattern pat1 pe1 $
          unsafe_subst_pattern pat2 pe2 expr
    | (CaseCtor Ctuple pats', Pexpr _ () (PEval (Vtuple cvals))) ->
        List.foldr (fun (pat', cval) acc ->
          subst_pattern_val pat' cval acc
        ) expr (List.zip pats' cvals)
    | (CaseCtor Ctuple pats', Pexpr _ _ (PEctor Ctuple pes)) ->
        List.foldr (fun (pat', pe) acc ->
          unsafe_subst_pattern pat' pe acc
        ) expr (List.zip pats' pes)
    (* TODO (maybe), Carray, Civmax, Civmin, Civsizeof, Civalignof *)
    
    | (CaseCtor Cspecified [pat'], Pexpr _ () (PEval (Vloaded (LVspecified oval)))) ->
        subst_pattern_val pat' (Vobject oval) expr
    | (CaseCtor Cspecified [pat'], Pexpr _ () (PEctor Cspecified [pe''])) ->
        unsafe_subst_pattern pat' pe'' expr
    | (CaseCtor Cunspecified [pat'], Pexpr _ () (PEval (Vloaded (LVunspecified ty)))) ->
        subst_pattern_val pat' (Vctype ty) expr
    | (CaseCtor Cunspecified [pat'], Pexpr _ () (PEctor Cunspecified [pe''])) ->
        unsafe_subst_pattern pat' pe'' expr
    | (CaseCtor ctor pats, _) ->
        let str_ctor = match ctor with
          | Cnil _ ->
              "nil"
          | Ccons ->
              "cons"
          | Ctuple ->
              "tuple"
          | Carray ->
              "array"
          | Civmax ->
              "ivmax"
          | Civmin ->
              "ivmin"
          | Civsizeof ->
              "ivsizeof"
          | Civalignof ->
              "ivalignof"
          | CivCOMPL ->
              "ivCOMPL"
          | CivAND ->
              "ivAND"
          | CivOR ->
              "ivOR"
          | CivXOR ->
              "ivXOR"
          | Cspecified ->
              "specified"
          | Cunspecified ->
              "unspecified"
          | Cfvfromint ->
              "fvfromint"
          | Civfromfloat ->
              "ivfromfloat"
          | CivNULLcap is_signed ->
              "ivNULLcap(" ^ if is_signed then "signed" else "unsigned" ^ ")"  
        end in
        error ("WIP: Core_aux.unsafe_subst_pattern ==> ctor= " ^ str_ctor ^ ", |pats|= "
               ^ (show (List.length pats)) ^ " -- " ^ Pp.stringFromCore_pexpr pe')
  end

val     subst_pattern: forall 'a. pattern -> pexpr -> expr 'a -> maybe (expr 'a)
let rec subst_pattern (Pattern _ pat) pe' expr =
  
  match (pat, pe') with
    | (CaseBase (Nothing, _), _) ->
        Just expr
    | (CaseBase (Just sym, _), _) ->
        Just $ unsafe_subst_sym_expr sym pe' expr
    | (CaseCtor (Cnil _) [], Pexpr _ _ (PEval (Vlist _ []))) ->
        (* empty list (value) *)
        Just expr
    | (CaseCtor (Cnil _) [], Pexpr _ _ (PEctor (Cnil _) [])) ->
        (* empty list (pure expr) *)
        Just expr
    | (CaseCtor Ccons [pat1; pat2], Pexpr _ () (PEval (Vlist bTy_elem (cval::cvals)))) ->
        (* populated list (value) *)
        Just (subst_pattern_val pat1 cval $
          subst_pattern_val pat2 (Vlist bTy_elem cvals) expr)
    | (CaseCtor Ccons [pat1; pat2], Pexpr _ _ (PEctor Ccons [pe1; pe2])) ->
        (* populated list (pure expr) *)
        match subst_pattern pat2 pe2 expr with
          | Just e -> subst_pattern pat1 pe1 e
          | Nothing -> Nothing
        end
    | (CaseCtor Ctuple pats', Pexpr _ () (PEval (Vtuple cvals))) ->
        Just $ List.foldr (fun (pat', cval) acc ->
          subst_pattern_val pat' cval acc
        ) expr (List.zip pats' cvals)
    | (CaseCtor Ctuple pats', Pexpr _ _ (PEctor Ctuple pes)) ->
        List.foldr (fun (pat', pe) acc ->
          match acc with
            | Just e -> subst_pattern pat' pe e
            | Nothing -> Nothing
          end
        ) (Just expr) (List.zip pats' pes)
    (* TODO (maybe), Carray, Civmax, Civmin, Civsizeof, Civalignof *)
    
    | (CaseCtor Cspecified [pat'], Pexpr _ () (PEval (Vloaded (LVspecified oval)))) ->
        Just $ subst_pattern_val pat' (Vobject oval) expr
    | (CaseCtor Cspecified [pat'], Pexpr _ () (PEctor Cspecified [pe''])) ->
        subst_pattern pat' pe'' expr
    | (CaseCtor Cunspecified [pat'], Pexpr _ () (PEval (Vloaded (LVunspecified ty)))) ->
        Just $ subst_pattern_val pat' (Vctype ty) expr
    | (CaseCtor Cunspecified [pat'], Pexpr _ () (PEctor Cunspecified [pe''])) ->
        subst_pattern pat' pe'' expr
    | (CaseCtor ctor pats, _) ->
        Nothing
  end



val     to_pure: forall 'a. expr 'a -> maybe pexpr
let rec to_pure (Expr annot expr_) (*(expr : expr 'a)*) =
  let to_pure_aux pat pe1 e2 =
    match subst_pattern pat pe1 e2 with
      | Just e -> to_pure e
      | Nothing ->
          match to_pure e2 with
            | Nothing ->
                Nothing
            | Just pe2 ->
                Just (Pexpr [] () (PElet pat pe1 pe2))
          end
    end
  in
  match expr_ with
    | Epure pe ->
        Just pe
    | Ememop _ _ ->
        Nothing
    | Elet pat pe1 e2 ->
        match to_pure e2 with
          | Just (Pexpr annot bTy _ as pe2) ->
              Just (Pexpr annot bTy (PElet pat pe1 pe2))
          | _ ->
              Nothing
        end
    | Eif pe1 e2 e3 ->
        match (to_pure e2, to_pure e3) with
          | (Just (Pexpr annot bTy _ as pe2), Just pe3) ->
              Just (Pexpr annot bTy (PEif pe1 pe2 pe3))
          | _ ->
              Nothing
        end
    | Eccall _ _ _ _ ->
        Nothing
    | Eproc _ _ _ ->
        Nothing
    | Eaction _ ->
        Nothing
    | Eunseq es ->
        match to_pures es with
          | Just pes ->
              Just (Pexpr [] () (PEctor Ctuple pes))
          | Nothing ->
              Nothing
        end
    | Ewseq pat e1 e2 ->
        match to_pure e1 with
          | Just pe1 ->
              to_pure_aux pat pe1 e2
          | Nothing ->
              Nothing
        end
    | Esseq pat e1 e2 ->
        match to_pure e1 with
          | Just pe1 ->
              to_pure_aux pat pe1 e2
          | Nothing ->
              Nothing
        end
    | Ebound e ->
        (* TODO: check *)
        to_pure e
    | Esave _ _ _ ->
        Nothing
    | Erun _ _ _ ->
        Nothing
    | End _ ->
        Nothing
    | Epar _ ->
        Nothing
    | Ewait _ ->
        Nothing
    | Eannot _ _ ->
        error "to_pure Eannot"
    | Eexcluded _ _ ->
        error "to_pure Eexcluded"
(*
    | Eloc _ e ->
        to_pure e
    | Estd _ e ->
        to_pure e
*)
    | Ecase pe pat_es ->
       let (pats, es) = List.unzip pat_es in
        match to_pures es with
          | Just ((Pexpr annot bTy _ :: _) as pes) ->
              Just (Pexpr annot bTy (PEcase pe (List.zip pats pes)))
          | _ ->
            Nothing
        end
end

(* val     to_pures: forall 'a. list (expr 'a) -> maybe (list pexpr)*)
and to_pures (es: list (expr 'a)) =
  List.foldr (fun e acc_opt ->
    match (to_pure e, acc_opt) with
      | (Just pe, Just acc) ->
          Just (pe :: acc)
      | _ ->
          Nothing
    end) (Just []) es



val subst_wait: forall 'a. Mem_common.thread_id -> value -> expr 'a -> expr 'a
let rec subst_wait tid v (Expr annot expr_) =
  Expr annot match expr_ with
  | Epure _ ->
      expr_
  | Ememop _ _ ->
      expr_
  | Elet sym pe1 e2 ->
      Elet sym pe1 (subst_wait tid v e2)
  | Eif pe1 e2 e3 ->
      Eif pe1 (subst_wait tid v e2) (subst_wait tid v e3)
  | Ecase pe pat_es ->
      Ecase pe (List.map (fun (pat, e) -> (pat, subst_wait tid v e)) pat_es)
  | Eccall _ _ _ _ ->
      expr_
  | Eproc _ _ _ ->
      expr_
  | Eaction _ ->
      expr_
  | Eunseq es ->
      Eunseq (List.map (subst_wait tid v) es)
   | Ewseq _as e1 e2 ->
       Ewseq _as (subst_wait tid v e1) (subst_wait tid v e2)
   | Esseq _as e1 e2 ->
       Esseq _as (subst_wait tid v e1) (subst_wait tid v e2)
   | Ebound e ->
       Ebound (subst_wait tid v e)
(*
   | Esave ksym sym_tys e ->
       Esave ksym sym_tys (subst_wait tid v e)
   | (Erun _ _ _ as expr) ->
       expr
*)
   | Esave sym sym_bTys e ->
       Esave sym sym_bTys (subst_wait tid v e)
   | Erun _ _ _ ->
       expr_
   | End es ->
       End (List.map (subst_wait tid v) es)
   | Epar es ->
       Epar (List.map (subst_wait tid v) es)
   | Ewait tid' ->
       if tid = tid' then
         match v with
           | Vunit ->
               Epure (Pexpr [] () (PEval Vunit))
           | _ ->
               Epure (Pexpr [] () (PEval v))
         end
       else
         Ewait tid'
   | Eannot xs e ->
       Eannot xs (subst_wait tid v e)
   | Eexcluded _ _ ->
       expr_
(*
   | Eloc loc e ->
       Eloc loc (subst_wait tid v e)
   | Estd s e ->
       Estd s (subst_wait tid v e)
*)
end





let rec find_labeled_continuation sym (Expr annot expr_) =
  match expr_ with
    | Epure _ ->
        Nothing
    | Ememop _ _ ->
        Nothing
    | Eaction _ ->
        Nothing
    | Ecase _ pat_es ->
        let () = Debug.warn [] (fun () -> "Core_aux.find_labeled_continuation assumes there is atmost single match inside a Ecase") in
        List.foldl (fun acc (_, e) ->
          match acc with
            | Just _ ->
                acc
            | Nothing ->
                match find_labeled_continuation sym e with
                  | Nothing ->
                      Nothing
                  | Just ret ->
                      Just ret
                end
          end
        ) Nothing pat_es
    | Elet _ _ e2 ->
        find_labeled_continuation sym e2
    | Eif _ e2 e3 ->
        (* NOTE: in a well formed Core expr, [sym] cannot be bound in both e2 and e3. *)
        match find_labeled_continuation sym e2 with
          | Just z ->
              Just z
          | Nothing ->
              find_labeled_continuation sym e3
        end
    | Eccall _ _ _ _ ->
        Nothing
    | Eproc _ _ _ ->
        Nothing
    | Eunseq _ ->
        (* NOTE: Typing forbids labeled continuation bindings inside unseq() *)
        Nothing
    | Ewseq pat e1 e2 ->
        let () = Debug.warn [] (fun () -> "Core_aux.find_labeled_continuation assumes the bindings of an Esave inside a Ewseq don't clash") in
        match find_labeled_continuation sym e1 with
          | Just (syms, cont_expr) ->
              Just (syms, Expr annot (Ewseq pat cont_expr e2))
          | Nothing ->
              find_labeled_continuation sym e2
        end
    | Esseq pat e1 e2 ->
        let () = Debug.warn [] (fun () -> "Core_aux.find_labeled_continuation assumes the bindings of an Esave inside a Esseq don't clash") in
        match find_labeled_continuation sym e1 with
          | Just (syms, cont_expr) ->
              Just (syms, Expr annot (Esseq pat cont_expr e2))
          | Nothing ->
              find_labeled_continuation sym e2
        end
    | Ebound _ ->
        (* NOTE: Typing forbids labeled continuation bindings inside bound() *)
        Nothing
    | End _ ->
        (* NOTE: Typing forbids labeled continuation bindings in inside nd() *)
        Nothing
    | Esave (sym', _) sym_bTys e ->
        if sym = sym' then
          Just (List.map fst sym_bTys, e)
        else
          find_labeled_continuation sym e
    | Erun annot sym pes ->
        Nothing
    | Epar es ->
        let () = Debug.warn [] (fun () -> "Core_aux.find_labeled_continuation assumes there are no Esave inside par()") in
        Nothing
    | Ewait _ ->
        Nothing
    | Eannot _ _ ->
        (* NOTE: Eannot only appear at runtime, and inside an Ebound, where
                 typing forbids labeled continuation bindings. *)
        Nothing
    | Eexcluded _ _ ->
        (* NOTE: Eexcluded only appear at runtime, and inside an Eexcluded, where
                 typing forbids labeled continuation bindings. *)
        Nothing

(*
    | Eloc _ e ->
        find_labeled_continuation sym e
    | Estd _ e ->
        find_labeled_continuation sym e
*)
  end


val find_labeled_continuation2_aux: forall 'a.
  map Symbol.sym (list Symbol.sym * expr 'a) -> Symbol.sym -> expr 'a ->
(*  maybe ((list Symbol.sym * expr 'a) * map Symbol.sym (list Symbol.sym * expr 'a)) *)
  map Symbol.sym (list Symbol.sym * expr 'a)
let rec find_labeled_continuation2_aux acc sym (Expr annot expr_) =
  match expr_ with
    | Epure _ ->
        acc
    | Ememop _ _ ->
        acc
    | Eaction _ ->
        acc
    | Ecase _ pat_es ->
        let () = Debug.warn [] (fun () -> "Core_aux.find_labeled_continuation2_aux assumes there is atmost single match inside a Ecase") in
        List.foldl (fun acc' (_, e) ->
          find_labeled_continuation2_aux acc' sym e
        ) acc pat_es
    | Elet _ _ e2 ->
        find_labeled_continuation2_aux acc sym e2
    | Eif _ e2 e3 ->
        let acc' = find_labeled_continuation2_aux acc sym e2 in
        find_labeled_continuation2_aux acc' sym e3
    | Eccall _ _ _ _ ->
        acc
    | Eproc _ _ _ ->
        acc
    | Eunseq _ ->
        (* NOTE: Typing forbids labeled continuation bindings inside unseq() *)
        acc
    | Ewseq pat e1 e2 ->
        let () = Debug.warn [] (fun () ->
          "Core_aux.find_labeled_continuation2_aux assumes the bindings of an Esave inside a Ewseq don't clash") in
        let acc' = Map.map (fun (syms, z) ->
                     (syms, Expr annot (Ewseq pat z e2))
                   ) (find_labeled_continuation2_aux Map.empty sym e1) in
        find_labeled_continuation2_aux (Map.(union) acc acc') sym e2
    | Esseq pat e1 e2 ->
        let () = Debug.warn [] (fun () ->
          "Core_aux.find_labeled_continuation2_aux assumes the bindings of an Esave inside a Esseq don't clash") in
        let acc' = Map.map (fun (syms, z) ->
                     (syms, Expr annot (Esseq pat z e2))
                   ) (find_labeled_continuation2_aux Map.empty sym e1) in
        find_labeled_continuation2_aux (Map.(union) acc acc') sym e2
    | Ebound _ ->
        (* NOTE: Typing forbids labeled continuation bindings inside bound() *)
        acc
    | End _ ->
        (* NOTE: Typing forbids labeled continuation bindings in inside nd() *)
        acc
    | Esave (sym', _) sym_bTys e ->
        if sym = sym' then
          Map.insert sym (List.map fst sym_bTys, e) acc
        else
          find_labeled_continuation2_aux (Map.insert sym' (List.map fst sym_bTys, e) acc) sym e
    | Erun annot sym pes ->
        acc
    | Epar es ->
        let () = Debug.warn [] (fun () -> "Core_aux.find_labeled_continuation2_aux assumes there are no Esave inside par()") in
        acc
    | Ewait _ ->
        acc
    | Eannot _ _ ->
        (* NOTE: Typing forbids labeled continuation bindings inside annot() *)
        acc
    | Eexcluded _ _ ->
        (* NOTE: Typing forbids labeled continuation bindings inside excluded() *)
        acc

(*
    | Eloc _ e ->
        find_labeled_continuation2_aux acc sym e
    | Estd _ e ->
        find_labeled_continuation2_aux acc sym e
*)
end

let find_labeled_continuation2 sym e =
  let lconts = find_labeled_continuation2_aux Map.empty sym e in
  match Map.lookup sym lconts  with
    | Just cont ->
        Just (cont, lconts)
    | Nothing ->
        Nothing
  end









val unsafe_subst_sym_fun_map: forall 'a. Symbol.sym -> pexpr -> fun_map 'a -> fun_map 'a
let unsafe_subst_sym_fun_map sym pe' funs =
  Map.map (function
    | Fun bTy params pe ->
        Fun bTy params (unsafe_subst_sym_pexpr sym pe' pe)
    | ProcDecl loc bTy params ->
        ProcDecl loc bTy params
    | BuiltinDecl loc bTy params ->
        BuiltinDecl loc bTy params
    | Proc loc mrk bTy params e ->
        Proc loc mrk bTy params (unsafe_subst_sym_expr sym pe' e)
  end) funs


val     collect_labeled_continuations: forall 'a. expr 'a -> map Symbol.sym (list (Symbol.sym (* * core_base_type*)) * expr 'a)
let rec collect_labeled_continuations (Expr annot expr_) =
  match expr_ with
    | Epure _ ->
        Map.empty
    | Ememop _ _ ->
        Map.empty
    | Elet _ _ e2 ->
        collect_labeled_continuations e2
    | Eif pe1 e2 e3 ->
        Map.(union) (collect_labeled_continuations e2) (collect_labeled_continuations e3)
    | Ecase pe pat_es ->
        Map.empty (* TODO THIS IS WRONG!!!!! *)
    | Eproc _ _ _ ->
        Map.empty
    | Eccall _ _ _ _ ->
        Map.empty
    | Eaction _ ->
        Map.empty
    | Eunseq _ ->
        Map.empty
    | Ewseq _as e1 e2 ->
        Map.(union) (Map.map (fun (a_tys, e) -> (a_tys, Expr annot (Ewseq _as e e2))) $ collect_labeled_continuations e1)
                    (collect_labeled_continuations e2)
    | Esseq _as e1 e2 ->
        Map.(union) (Map.map (fun (a_tys, e) -> (a_tys, Expr annot (Esseq _as e e2))) $ collect_labeled_continuations e1)
                    (collect_labeled_continuations e2)
    | Ebound _ ->
        Map.empty
    | Esave (sym_lab, _) sym_bTys e ->
        Map.insert sym_lab (List.map fst sym_bTys, e) $ collect_labeled_continuations e
    | Erun _ _ _ ->
        Map.empty
    | End _ ->
        (* TODO: check *)
        Map.empty
    | Epar _ ->
        (* TODO: check *)
        Map.empty
    | Ewait _ ->
        Map.empty
    | Eannot _ _ ->
        Map.empty
    | Eexcluded _ _ ->
        Map.empty
(*
    | Eloc loc e ->
        collect_labeled_continuations e
    | Estd _ e ->
        collect_labeled_continuations e
*)
  end



val is_unseq_with_negative: forall 'a. expr 'a -> bool
let is_unseq_with_negative = function
  | Expr _ (Eunseq es) ->
      List.any is_negative es
  | _ ->
      false
end


(*
val     has_sseqs: forall 'a. expr 'a -> bool
let rec has_sseqs expr =
  match expr with
    | Epure _ ->
        false
    | Ememop _ _ ->
        false
    | Eaction p ->
        false
    | Ecase _ pat_es ->
        List.any (fun (_, e) -> has_sseqs e) pat_es
    | Elet _ _ e2 ->
        has_sseqs e2
    | Eif _ e2 e3 ->
        has_sseqs e2 || has_sseqs e3
    | Eskip ->
        false
    | Eccall _ _ _ ->
        (* TODO: look into the called body *)
        false
    | Eproc _ _ _ ->
        (* TODO: look into the called body *)
        false
    | Eunseq es ->
        List.any has_sseqs es
    | Ewseq _ e1 e2 ->
        has_sseqs e1 || has_sseqs e2
    | Esseq _ _ _ ->
        true
    | Ebound e ->
        has_sseqs e
    | Esave _ _ e ->
        has_sseqs e
    | Erun _ _ _ ->
        false
    | End es ->
        List.any has_sseqs es
    | Epar _ ->
        (* TODO: I think *)
        false
    | Ewait _ ->
        false
    | Eloc _ e ->
        has_sseqs e
  end
*)



val     match_pattern: pattern -> value -> maybe (list (Symbol.sym * value))
let rec match_pattern (Pattern _ pat) cval =
  match (pat, cval) with
    | (CaseBase (Nothing, _), _) ->
        Just []
    | (CaseBase (Just sym, _), _) ->
        Just [(sym, cval)]
(*      | Vobject of (generic_object_value 'sym) *)
    | (CaseCtor Cspecified [pat'], Vloaded (LVspecified oval)) ->
        match_pattern pat' (Vobject oval)
    | (CaseCtor Cunspecified [pat'], Vloaded (LVunspecified ty)) ->
        match_pattern pat' (Vctype ty)
(*      | Vlist of core_base_type * list (generic_value 'sym) *)
    | (CaseCtor Ctuple pats', Vtuple cvals') -> 
        List.foldr (fun (pat', cval') acc ->
          Maybe.bind acc (fun xs ->
            Maybe.bind (match_pattern pat' cval') (fun x ->
              Just (x++xs)
            )
          )
        ) (Just []) (List.zip pats' cvals')
    | (CaseCtor (Cnil _) [], Vlist _ []) ->
        let () = Debug.warn [] (fun () -> "Pattern matching nil without checking types!") in
        Just []
    | (CaseCtor Ccons [pat_x; pat_xs], Vlist ty (x::xs)) ->
        Maybe.bind (match_pattern pat_x x) (fun x ->
          Maybe.bind (match_pattern pat_xs (Vlist ty xs)) (fun xs ->
            Just (x++xs)
          )
        )
    | _ ->
        Nothing
  end

val     select_case: forall 'a. (Symbol.sym -> value -> 'a -> 'a) -> value -> list (pattern * 'a) -> maybe 'a
let rec select_case subst_sym cval = function
  | [] ->
      Nothing
  | (pat, pe) :: pat_pes' ->
      match match_pattern pat cval with
        | Nothing ->
            (* trying the next branch *)
            select_case subst_sym cval pat_pes'
        | Just (sym_cvals) ->
            Just $ List.foldr (fun (sym, cval') acc ->
              subst_sym sym cval' acc
            ) pe sym_cvals
      end
end


(*
val isConstrainedValue: value -> bool
let isConstrainedValue cval =
  match flatten_constrained_value cval with
    | Vconstrained _ ->
        true
    | _ ->
        false
  end
*)

val mk_pure_e: forall 'a. pexpr -> expr 'a
let mk_pure_e pe =
  Expr [] (Epure pe)

val mk_value_e: forall 'a. value -> expr 'a
let mk_value_e cval =
  mk_pure_e (mk_value_pe cval)

val mk_skip_e: expr unit
let mk_skip_e =
  Expr [] (Epure (Pexpr [] () (PEval Vunit)))


val mk_unseq_e: forall 'a. list (expr 'a) -> expr 'a
let mk_unseq_e es =
  Expr [] (Eunseq es)

val mk_case_e: pexpr -> list (pattern * expr unit) -> expr unit
let mk_case_e pe pat_es =
  Expr [] (Ecase pe pat_es)

val mk_wseq_e: forall 'a. pattern -> expr 'a -> expr 'a -> expr 'a
let mk_wseq_e pat e1 e2 =
  Expr [] (Ewseq pat e1 e2)

val mk_sseq_e: forall 'a. pattern -> expr 'a -> expr 'a -> expr 'a
let mk_sseq_e pat e1 e2 =
  Expr [] (Esseq pat e1 e2)

val mk_save_e_: list annot -> (Symbol.sym * core_base_type) -> list (Symbol.sym * ((core_base_type * maybe (Ctype.ctype * pass_by_value_or_pointer)) * pexpr)) -> expr unit -> expr unit
let mk_save_e_ annots sym_ty sym_ty_pes e =
  Expr annots (Esave sym_ty sym_ty_pes e)

val mk_save_e: (Symbol.sym * core_base_type) -> list (Symbol.sym * ((core_base_type * maybe (Ctype.ctype * pass_by_value_or_pointer)) * pexpr)) -> expr unit -> expr unit
let mk_save_e sym_ty sym_ty_pes e =
  Expr [] (Esave sym_ty sym_ty_pes e)

val mk_run_e: Symbol.sym -> list pexpr -> expr unit
let mk_run_e sym pes =
  Expr [] (Erun () sym pes)

val mk_nd_e: list (expr unit) -> expr unit
let mk_nd_e es =
  Expr [] (End es)

val mk_if_e_: list annot -> pexpr -> expr unit -> expr unit -> expr unit
let mk_if_e_ annots pe e1 e2 =
  Expr annots (Eif pe e1 e2)

val mk_if_e: pexpr -> expr unit -> expr unit -> expr unit
let mk_if_e pe e1 e2 =
  Expr [] (Eif pe e1 e2)

val mk_let_e: pattern -> pexpr -> expr unit -> expr unit
let mk_let_e pat pe e =
  Expr [] (Elet pat pe e)

val mk_ccall_e: pexpr -> pexpr -> list pexpr -> expr unit
let mk_ccall_e cty pe pes =
  Expr [] (Eccall default cty pe pes)

val mk_memop_e: Mem_common.memop -> list pexpr -> expr unit
let mk_memop_e mop pes =
  Expr [] (Ememop mop pes)

val mk_wait_e: forall 'a. Mem_common.thread_id -> expr 'a
let mk_wait_e tid =
  Expr [] (Ewait tid)


let inline update_annot pred x xs =
  match List.deleteFirst pred xs with
    | Nothing ->
        x :: xs
    | Just xs' ->
        x :: xs'
  end

val add_loc: Loc.t -> expr unit -> expr unit
let add_loc loc (Expr annot expr_) =
  let pred = function
    | Aloc _ -> true
    | _ -> false
  end in
  Expr (update_annot pred (Aloc loc) annot) expr_

val add_stmt_loc: Loc.t -> expr unit -> expr unit
let add_stmt_loc loc (Expr annot expr_) =
  Expr (Astmt loc :: annot) expr_

val add_expr_loc: Loc.t -> expr unit -> expr unit
let add_expr_loc loc (Expr annot expr_) =
  Expr (Aexpr loc :: annot) expr_


val annotate_integer_type_pexpr : integerType -> pexpr -> pexpr
let annotate_integer_type_pexpr ity (Pexpr annot bty expr_) =
  let annot = (Avalue (Ainteger ity)) :: annot in
  Pexpr annot bty expr_


val maybe_annotate_integer_type_pexpr : ctype -> pexpr -> pexpr
let maybe_annotate_integer_type_pexpr (Ctype _ ctype_) pe =
  match ctype_ with
    | Basic (Integer ity) -> annotate_integer_type_pexpr ity pe
    | _ -> pe
  end


val annotate_integer_type_expr : integerType -> expr unit -> expr unit
let annotate_integer_type_expr ity (Expr annot expr_) =
  let annot = (Avalue (Ainteger ity)) :: annot in
  Expr annot expr_


val maybe_annotate_integer_type : ctype -> expr unit -> expr unit
let maybe_annotate_integer_type (Ctype _ ctype_) (Expr annot expr_) =
  let annot = match ctype_ with
    | Basic (Integer ity) -> (Avalue (Ainteger ity)) :: annot
    | _ -> annot
  end in
  Expr annot expr_



val add_std: string -> expr unit -> expr unit
let add_std str (Expr annot expr_) =
  Expr (Astd str :: annot) expr_

val add_stds: list string -> expr unit -> expr unit
let add_stds strs (Expr annot expr_) =
  Expr (List.map (fun z -> Astd z) strs ++ annot) expr_

val add_attrs: Annot.attributes -> expr unit -> expr unit
let add_attrs attrs (Expr annot expr_ as expr) =
  match attrs with
    | Attrs [] ->
        expr
    | _ ->
        Expr (Aattrs attrs :: annot) expr_
  end

val add_annot: Annot.annot -> expr unit -> expr unit
let add_annot annot (Expr annots expr_) =
  Expr (annot :: annots) expr_

val add_annots: list Annot.annot -> expr unit -> expr unit
let add_annots annots1 (Expr annots2 expr_) =
  Expr (annots1 ++ annots2) expr_

type collect_saves_state 'a = <|
  tmp_acc:    map Symbol.sym (list (Symbol.sym * core_base_type) * Core.expr 'a); (*Core.labeled_continuations 'a; *)
  closed_acc: map Symbol.sym (list (Symbol.sym * core_base_type) * Core.expr 'a); (*Core.labeled_continuations 'a; *)
|>

let empty_saves = <| tmp_acc= Map.empty; closed_acc= Map.empty |>

let union_saves st1 st2 =
  <| tmp_acc= Map.(union) st1.tmp_acc st2.tmp_acc;
     closed_acc= Map.(union) st1.closed_acc st2.closed_acc |>

(* NOTE: assumes the expression is well formed/typed *)
val     collect_saves_aux: forall 'a. collect_saves_state 'a -> expr 'a -> collect_saves_state 'a
let rec collect_saves_aux st (Expr annots expr_) =
  match expr_ with
    | Epure _ ->
        st
    | Ememop _ _ ->
        st
    | Eaction _ ->
        st
    | Ecase _ pat_es ->
        List.foldl (fun acc (_, e) ->
          collect_saves_aux acc e
        ) st pat_es
    | Elet _ _ e ->
        collect_saves_aux st e
    | Eif _ e1 e2 ->
        collect_saves_aux (collect_saves_aux st e1) e2
    | Eccall _ _ _ _ ->
        st
    | Eproc _ _ _ ->
        st
    | Eunseq es ->
        List.foldl collect_saves_aux st es
    | Ewseq pat e1 e2 ->
        let st1 = collect_saves_aux empty_saves e1 in
        let st2 = collect_saves_aux empty_saves e2 in
        union_saves st begin
          union_saves
            <| st1 with
              tmp_acc= Map.map (fun (syms, e) -> (syms, Expr annots (Ewseq pat e e2))) st1.tmp_acc
            |>
            st2
        end
    | Esseq pat e1 e2 ->
        let st1 = collect_saves_aux empty_saves e1 in
        let st2 = collect_saves_aux empty_saves e2 in
        union_saves st begin
          union_saves
            <| st1 with
              tmp_acc= Map.map (fun (syms, e) -> (syms, Expr annots (Esseq pat e e2))) st1.tmp_acc
            |>
            st2
        end
    | Ebound _ ->
        (* typing forbids "saves" inside a "bound()" *)
        st
    | End _ ->
        (* typing forbids "saves" inside a "nd()" *)
        st
    | Esave (sym, _) params e ->
        collect_saves_aux
          <| st with tmp_acc= Map.insert sym (List.map (fun (x, ((y, _), _)) -> (x, y)) params, e) st.tmp_acc |>
          e
    | Erun _ _ _ ->
        st
    | Epar es ->
        let acc = List.foldl collect_saves_aux
          empty_saves es in
        <| st with closed_acc=
          Map.(union) (Map.(union) acc.tmp_acc acc.closed_acc)
                      st.closed_acc |>
    | Ewait _ ->
        st
    | Eannot _ _ ->
        (* typing forbids "saves" inside a "annot()" *)
        st
    | Eexcluded _ _ ->
        (* typing forbids "saves" inside a "excluded()" *)
        st
  end

val collect_saves: forall 'a. expr 'a -> map Symbol.sym (list (Symbol.sym * core_base_type) * expr 'a) (*Core.labeled_continuations 'a *)
let collect_saves expr =
  let st = collect_saves_aux <| tmp_acc= Map.empty; closed_acc= Map.empty |> expr in
  Map.(union) st.tmp_acc st.closed_acc






(* The same again, now collecting more information about the
   esave. The above could be defined in terms of the below, but I
   didn't want to mess that up, so leaving for now. *)

type m_labeled_continuation 'a = 
  (core_base_type * list (Symbol.sym * ((core_base_type * maybe (Ctype.ctype * pass_by_value_or_pointer)) * pexpr)) * (expr 'a) * list Annot.annot)

type m_labeled_continuations 'a = 
  map Symbol.sym (m_labeled_continuation 'a)

type m_collect_saves_state 'a = <|
  m_tmp_acc:    m_labeled_continuations 'a;
  m_closed_acc: m_labeled_continuations 'a;
|>

let m_empty_saves = <| m_tmp_acc= Map.empty; m_closed_acc= Map.empty |>

let m_union_saves st1 st2 =
  <| m_tmp_acc= Map.(union) st1.m_tmp_acc st2.m_tmp_acc;
     m_closed_acc= Map.(union) st1.m_closed_acc st2.m_closed_acc |>

(* NOTE: assumes the expression is well formed/typed *)
val     m_collect_saves_aux: forall 'a. m_collect_saves_state 'a -> expr 'a -> m_collect_saves_state 'a
let rec m_collect_saves_aux st (Expr annots expr_) =
  match expr_ with
    | Epure _ ->
        st
    | Ememop _ _ ->
        st
    | Eaction _ ->
        st
    | Ecase _ pat_es ->
        List.foldl (fun acc (_, e) ->
          m_collect_saves_aux acc e
        ) st pat_es
    | Elet _ _ e ->
        m_collect_saves_aux st e
    | Eif _ e1 e2 ->
        m_collect_saves_aux (m_collect_saves_aux st e1) e2
    | Eccall _ _ _ _ ->
        st
    | Eproc _ _ _ ->
        st
    | Eunseq es ->
        List.foldl m_collect_saves_aux st es
    | Ewseq pat e1 e2 ->
        let st1 = m_collect_saves_aux m_empty_saves e1 in
        let st2 = m_collect_saves_aux m_empty_saves e2 in
        m_union_saves st begin
          m_union_saves
            <| st1 with
              m_tmp_acc= Map.map (fun (cbt,args,body,annots') -> 
                             (cbt, args, Expr annots (Ewseq pat body e2), annots') )
                               st1.m_tmp_acc
            |>
            st2
        end
    | Esseq pat e1 e2 ->
        let st1 = m_collect_saves_aux m_empty_saves e1 in
        let st2 = m_collect_saves_aux m_empty_saves e2 in
        m_union_saves st begin
          m_union_saves
            <| st1 with
              m_tmp_acc= Map.map (fun (cbt,args,body,annots') -> 
                             (cbt, args, Expr annots (Esseq pat body e2), annots') )
                               st1.m_tmp_acc
            |>
            st2
        end
    | Ebound _ ->
        (* typing forbids "saves" inside a "bound()" *)
        st
    | End _ ->
        (* typing forbids "saves" inside a "nd()" *)
        st
    | Esave (sym, ty) params e ->
	   let oloc = Annot.get_loc annots in
	   let () = match oloc with 
	     | Just _ -> () 
		 | _ -> Debug.print_debug 0 [] (fun () -> "label " ^ show sym ^ "missing label location")
		end in
        m_collect_saves_aux
          <| st with m_tmp_acc= Map.insert sym (ty,params,e,annots) st.m_tmp_acc |>
          e
    | Erun _ _ _ ->
        st
    | Epar es ->
        let acc = List.foldl m_collect_saves_aux
          m_empty_saves es in
        <| st with m_closed_acc=
          Map.(union) (Map.(union) acc.m_tmp_acc acc.m_closed_acc)
                      st.m_closed_acc |>
    | Ewait _ ->
        st
    | Eannot _ _ ->
        st
    | Eexcluded _ _ ->
        st
  end

val m_collect_saves: forall 'a. expr 'a -> m_labeled_continuations 'a
let m_collect_saves expr =
  let st = m_collect_saves_aux <| m_tmp_acc= Map.empty; m_closed_acc= Map.empty |> expr in
  Map.(union) st.m_tmp_acc st.m_closed_acc





import Map_extra

val collect_labeled_continuations_NEW: forall 'a. file 'a -> map Symbol.sym (map Symbol.sym (list (Symbol.sym * core_base_type) * expr 'a) (*Core.labeled_continuations 'a *))
let collect_labeled_continuations_NEW file =
(*  let xs =  *)
  Map_extra.fold (fun fun_sym decl acc ->
    match decl with
      | Fun _ _ _ ->
          acc
      | ProcDecl _ _ _ ->
          acc
      | BuiltinDecl _ _ _ ->
          acc
      | Proc _ _ _ _ e ->
          Map.insert fun_sym (collect_saves e) acc
    end
  ) (Map.(union) file.stdlib file.funs) Map.empty
(*
in
  let _ = Map.mapi (fun sym labs ->
    Debug.print_debug 2 [] (fun () ->
      "PROC " ^ show sym ^ " ==>\n" ^
      List.foldl (fun acc (sym, (_, e)) -> show sym ^ " ==> " ^ Pp.stringFromCore_expr e) "" (Map_extra.toList labs) 
    )
  ) xs in
  xs
*)


val     update_env: pattern -> value -> list (map Symbol.sym value) -> list (map Symbol.sym value)
let rec update_env_aux (Pattern _ pat) cval env =
  (* TODO (maybe), Carray, Civmax, Civmin, Civsizeof, Civalignof *)
  match (pat, cval) with
    | (CaseBase (Nothing, _), _) ->
        (* e[_ \ v] = e *)
        env
    | (CaseBase (Just sym, _), _) ->
        (* e[sym \ v] *)
        Map.insert sym cval env
    | (CaseCtor (Cnil _) [], Vlist _ []) ->
        (* empty list (value) *)
        env
    | (CaseCtor Ccons [pat1; pat2], Vlist bTy_elem (cval1::cvals)) ->
        (* populated list (value) *)
        update_env_aux pat1 cval1 $
          update_env_aux pat2 (Vlist bTy_elem cvals) env
    | (CaseCtor Ctuple pats', Vtuple cvals) ->
        List.foldr (fun (pat', cval') acc ->
          update_env_aux pat' cval' acc
        ) env (List.zip pats' cvals)
    | (CaseCtor Cspecified [pat'], Vloaded (LVspecified oval)) ->
        update_env_aux pat' (Vobject oval) env
    | (CaseCtor Cunspecified [pat'], Vloaded (LVunspecified ty)) ->
        update_env_aux pat' (Vctype ty) env
    | (CaseCtor ctor pats, _) ->
        let str_ctor = match ctor with
          | Cnil _ ->
              "nil"
          | Ccons ->
              "cons"
          | Ctuple ->
              "tuple"
          | Carray ->
              "array"
          | Civmax ->
              "ivmax"
          | Civmin ->
              "ivmin"
          | Civsizeof ->
              "ivsizeof"
          | Civalignof ->
              "ivalignof"
          | CivCOMPL ->
              "ivCOMPL"
          | CivAND ->
              "ivAND"
          | CivOR ->
              "ivOR"
          | CivXOR ->
              "ivXOR"
          | Cspecified ->
              "specified"
          | Cunspecified ->
              "unspecified"
          | Cfvfromint ->
              "fvfromint"
          | Civfromfloat ->
              "ivfromfloat"
          | CivNULLcap is_signed ->
              "ivNULLcap(" ^ if is_signed then "signed" else "unsigned" ^ ")"  
        end in
        error ("WIP: Core_aux.update_env_aux ==> ctor= " ^ str_ctor ^ ", |pats|= "
               ^ (show (List.length pats)) ^ " -- " ^ Pp.stringFromCore_value cval)
  end

let update_env pat cval = function
  | [] ->
      error "Core_aux.update_env: found empty env"
  | env::xs ->
      update_env_aux pat cval  env :: xs
end


let rec lookup_env sym = function
  | [] ->
      Nothing
  | env :: xs ->
      match Map.lookup sym env with
        | Nothing ->
            lookup_env sym xs
        | Just ret ->
            Just ret
      end
end

