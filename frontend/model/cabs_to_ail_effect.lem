open import Pervasives Utils Cabs Std Show Show_extra Set
import Global Debug Pp Loc Errors Scope_table State_exception Symbol

open import Cabs_to_ail_aux

import AilSyntax AilTypesAux

import Map_extra Ctype

import Mem Implementation

open import Cn_desugaring Cn

module A      = AilSyntax


type tag_kind =
  (* TODO: we may be able to merge struct and union *)
  | Kind_struct
  | Kind_union
  | Kind_enum

(* STD ยง6.2.1#1, sentence 1 *)
type ordinary_kind = (* the ones that can have a linkage *)
  (* the boolean is true iff we are dealing with a function parameter (needed to determinate the linkage ...) *)
    (* TODO: should be a different ctor, but using a bool for now to make sure all the occurences
             of the normal Kind_object also apply to Kind_parameter_object *)
  | OK_object of bool
  | OK_function
  | OK_enum_constant
  | OK_typedef

type identifier_kind =
  | Kind_ordinary of ordinary_kind
  | Kind_tag of tag_kind
  | Kind_label
  | Kind_member of tag_kind
(*
  | Kind_macro_name
  | Kind_macro_parameter
*)

instance (Eq identifier_kind)
  let (=)  = unsafe_structural_equality
  let (<>) = unsafe_structural_inequality
end

instance (Show identifier_kind)
  let show = function
    | Kind_ordinary (OK_object false) ->
        "object"
    | Kind_ordinary (OK_object true) ->
        "parameter"
    | Kind_ordinary OK_function ->
        "function"
    | Kind_member Kind_struct ->
        "struct_member"
    | Kind_member Kind_union ->
        "union_member"
    | Kind_member Kind_enum ->
        "enum_member (TODO: this is invalid)"
    | Kind_ordinary OK_enum_constant ->
        "enum_constant"
    | Kind_tag Kind_struct ->
        "struct tag"
    | Kind_tag Kind_union ->
        "union tag"
    | Kind_tag Kind_enum ->
        "enum tag"
    | Kind_ordinary OK_typedef ->
        "typedef"
    | Kind_label ->
        "label"
  end
end

instance (SetType identifier_kind)
  let setElemCompare = defaultCompare
end


val is_object_kind: ordinary_kind -> bool
let is_object_kind = function
  | OK_object _ -> true
  | _           -> false
end

val is_parameter_object_kind: ordinary_kind -> bool
let is_parameter_object_kind = function
  | OK_object true -> true
  | _              -> false
end




(* STD ยง6.2.1#2 *)
type scope_id = nat
type scope =
  | Scope_function
  | Scope_file
  | Scope_block of scope_id
  | Scope_prototype of scope_id

let scopeEqual sc1 sc2 =
  match (sc1, sc2) with
    | (Scope_function, Scope_function) ->
        true
    | (Scope_file, Scope_file) ->
        true
    | (Scope_block id1, Scope_block id2) ->
        id1 = id2
    | (Scope_prototype id1, Scope_prototype id2) ->
        id1 = id2
    | _ ->
        false
  end

instance (Eq scope)
  let (=)  = scopeEqual
  let (<>) = fun x y -> not (scopeEqual x y)
end


(* TODO DEBUG *)
let string_of_scope = function
  | Scope_function ->
      "function"
  | Scope_file ->
      "file"
  | Scope_block n ->
      "block(" ^ show n ^ ")"
  | Scope_prototype n ->
      "prototype(" ^ show n ^ ")"
end

let is_block_scope = function
  | Scope_block _ ->
      true
  | _ ->
      false
end




(* STD ยง6.2.3#1 *)
type namespace =
  | Namespace_label
  | Namespace_tag
  | Namespace_member of Symbol.identifier (* NOTE: theses are only struct/union members *)
  | Namespace_ordinary (* NOTE: enumeration constants go here *)

instance (Show namespace)
  let show = function
    | Namespace_label ->
        "label"
    | Namespace_tag ->
        "tag"
    | Namespace_member ident ->
        "member{" ^ show ident ^ "}"
    | Namespace_ordinary ->
        "ordinary"
  end
end

instance (SetType namespace)
  let setElemCompare ns1 ns2 =
    let ord = function
      | Namespace_label ->
          (0 : nat)
      | Namespace_tag ->
          1
      | Namespace_member _ ->
          2
      | Namespace_ordinary ->
          3
    end in
    match (ns1, ns2) with
      | (Namespace_member ident1, Namespace_member ident2) ->
          setElemCompare ident1 ident2
      | _ ->
          setElemCompare (ord ns1) (ord ns2)
    end
end

type function_declaration =
  | FDeclPrototype of
        Loc.t
      * (Ctype.qualifiers * Ctype.ctype)
      * list (Ctype.qualifiers * Ctype.ctype * bool)
      * bool (* isVariadic *)
      * bool (* isInline *)
      * bool (* isNoReturn *)
  | FDeclEmptyParentheses of
        Loc.t
      * (Ctype.qualifiers * Ctype.ctype)
      * bool (* isVariadic *)
      * bool (* isInline *)
      * bool (* isNoReturn *)

type registration =
  | Internal of A.ail_identifier * identifier_kind * maybe linkage
  | External

type global_definition =
  | Tentative of Loc.t * Ctype.ctype
  | Definition of A.expression unit
  | ExternalDefinition of A.expression unit


type case_selector =
  | CaseSelectConst of integer
  | CaseSelectRange of integer * integer (* INVARIAN: n1 < n2 *)

type switch_info = <|
  cases_info: list (Loc.t * case_selector);
  default_info: maybe Loc.t;
|>

type state = <|
  (* Counter used to generate fresh cabs label names (see the desugaring of do-while statements) *)
  aux_supply: nat;
  scope_id_supply: nat;
  (* table (with stacked scopes) associating C identifiers to symbols *)
  
  registered_external_identifiers: map (Symbol.identifier * namespace) (scope * (A.ail_identifier * identifier_kind * maybe linkage));
  registered_identifiers: Scope_table.t scope (Symbol.identifier * namespace) registration;
  
  (* TODO: this type of too large, maybe separate the namespaces into different maps under the scope table *)
(*
  registered_identifiers: Scope_table.t scope (cabs_identifier * namespace) (A.ail_identifier * identifier_kind * maybe linkage);
*)
  
  tag_definitions: map A.ail_identifier tag_definition;
  
  (* return type; parameters types; is_variadic; is_inline; is_Noreturn *)
  (* the first boolean records whether the function has a prototype *)
  (* the boolean in the parameters list tells whether there was a register storage-class *)
  function_declarations: map A.ail_identifier (
    (*hasProto*)bool * Loc.t * Annot.attributes *
    ( (Ctype.qualifiers * Ctype.ctype)                     (* qualifier and return type *)
    * maybe (list (Ctype.qualifiers * Ctype.ctype * bool)) (* Nothing if there was no parameter type list,
                                                                the boolean is the isRegister flag *)
    * bool * bool * bool )                                   (* isVariadic, isInline, isNoReturn flags *)
   );
  external_object_declarations: map A.ail_identifier  ((* isTentative *)bool * Loc.t * Annot.attributes * A.storageDuration * (* isRegister *) bool * maybe Ctype.alignment * Ctype.qualifiers * Ctype.ctype);
  internal_object_declarations: map A.ail_identifier  (Loc.t * A.storageDuration * (* isRegister *) bool * maybe Ctype.alignment * Ctype.qualifiers * Ctype.ctype);
  
  function_definitions: map A.ail_identifier (Loc.t * nat * Annot.attributes * list A.ail_identifier * A.statement unit);
  global_object_definitions: map A.ail_identifier global_definition;
  
  (* TODO: I really don't like the potential lack of sync between the next field and registered_identifiers *)
  typedef_definitions: map A.ail_identifier (Annot.attributes * Ctype.qualifiers * Ctype.ctype);
  
  static_assertions: list (A.expression unit * A.stringLiteral);
  
  (* STD ยง6.2.1#1, sentence 2 *)
  enumeration_constants: map A.ail_identifier (A.expression_ unit);

  (* information regarding the case/default statements already seen for a stack
     of switch statements being desugared *)
  switch_context: list switch_info;
  
  (* TODO: this is idiotically inefficient, should store here the converse *)
  (* list the object/functions actually used, so that we can forget everything else that is declared/defined.
     This is particularly useful when stdlib headers are included *)
  used_identifier: list A.ail_identifier;
  current_return_type: maybe Ctype.ctype;
  
  loop_attributes: Annot.loop_attributes;

  (* BEGIN CN *)
  toplevel_magic_statements: list (Loc.t * string);

  cn_state: Cn_desugaring.cn_desugaring_state;
  (* END CN *)

  (* TODO TODO TODO *)
  core_eval_stuff: (map string Symbol.sym) * Core.fun_map unit * Core.impl;
|>

type markers_env =
  map nat state

type fin_markers_env = (nat * markers_env)

type state_with_markers = <|
  inner: state;
  markers_env: markers_env;
|>

type desugM 'a = State_exception.stExceptM 'a state_with_markers Errors.error

val return: forall 'a. 'a -> desugM 'a
let inline return = State_exception.return

val bind: forall 'a 'b. desugM 'a -> ('a -> desugM 'b) -> desugM 'b
let inline bind = State_exception.bind


val fail: forall 'a. Loc.t -> Errors.desugar_cause -> desugM 'a
let inline fail loc dcause = State_exception.fail (loc, Errors.DESUGAR dcause)

let inline fail_ailtyping loc tcause = State_exception.fail (loc, Errors.AIL_TYPING tcause)

val contraint_violation: forall 'a. Loc.t -> Constraint.violation -> desugM 'a
let inline constraint_violation loc v =
  State_exception.fail (loc, Errors.DESUGAR (Errors.Desugar_ConstraintViolation v))

val undef: forall 'a. Loc.t -> Undefined.undefined_behaviour -> desugM 'a
let inline undef loc ub =
  State_exception.fail (loc, Errors.DESUGAR (Errors.Desugar_UndefinedBehaviour ub))

val mapM: forall 'a 'b. ('a -> desugM 'b) -> list 'a -> desugM (list 'b)
val mapM_: forall 'a 'b. ('a -> desugM 'b) -> list 'a -> desugM unit
let inline mapM = State_exception.mapM
let inline mapM_ = State_exception.mapM_

let inline foldlM = State_exception.foldlM
let inline foldrM = State_exception.foldrM

let inline iter = State_exception.iter

val tryWith: forall 'a. Errors.error -> desugM 'a -> desugM 'a
let inline tryWith = State_exception.tryWith

val fmap: forall 'a 'b. ('a -> 'b) -> desugM 'a -> desugM 'b
let inline fmap = State_exception.fmap

val app: forall 'a 'b. desugM ('a -> 'b) -> desugM 'a -> desugM 'b
let inline app  = State_exception.app


let inline (>>=)    = bind
let inline (>>) m f = m >>= fun _ -> f (* NOTE: the inline is important *)
let inline (<$>)    = fmap
let inline (<*>)    = app


let get_inner =
  State_exception.get >>= fun st ->
  State_exception.return st.inner

let put_inner inner_st =
  State_exception.update (fun st ->
    <| st with inner= inner_st |>
  )

let read_inner f =
  State_exception.read (fun st ->
    f st.inner
  )

let update_inner f =
  State_exception.update (fun st ->
    <| st with inner= f st.inner |>
  )

let modify_inner f =
  State_exception.modify (fun st ->
    let (a, inner_st') = f st.inner in
    (a, <| st with inner= inner_st' |>)
  )


val void: forall 'a. desugM 'a -> desugM unit
let cabs_to_ail_effect_void m =
  fmap (const ()) m
let inline void = cabs_to_ail_effect_void


val guard: forall 'a. desugM bool -> string -> desugM 'a -> desugM 'a
let cabs_to_ail_effect_guard m_pred err_msg m =
  m_pred >>= function
    | true  -> m
    | false -> error ("[Cabs_to_ail_effect] failed guard: " ^ err_msg ^ ".")
  end
let inline guard = cabs_to_ail_effect_guard

val liftException: forall 'a. Exception.exceptM 'a Errors.error -> desugM 'a
let inline liftException = State_exception.liftException

(* ========================================================================== *)
val current_scope_is: scope -> desugM bool
let cabs_to_ail_effect_current_scope_is scope =
  (* NOTE: it would be equivalent to use [registered_tag_declarations] *)
  read_inner (fun st -> Scope_table.current_scope_is st.registered_identifiers = scope)
let inline current_scope_is = cabs_to_ail_effect_current_scope_is

val scope_is_visible: scope -> desugM bool
let cabs_to_ail_effect_scope_is_visible scope =
  read_inner (fun st ->
    Scope_table.scope_is_visible scope st.registered_identifiers
  )
let inline scope_is_visible = cabs_to_ail_effect_scope_is_visible

val get_scope: desugM scope
let get_scope =
  (* NOTE: it would be equivalent to use [registered_tag_declarations] *)
  read_inner (fun st -> Scope_table.current_scope_is st.registered_identifiers)


let create_new_scope scope st =
  <| st with inner= <| st.inner with registered_identifiers= Scope_table.create_scope scope st.inner.registered_identifiers; |> |>

val under_scope: forall 'a. scope -> desugM 'a -> desugM 'a
let under_scope scope m =
  State_exception.update (fun st ->
    let () = Debug.print_debug 3 [Debug.DB_desugaring] (fun () ->
      "ENTERING Scope: " ^ string_of_scope scope
    ) in
    create_new_scope scope st
  ) >>
  m >>= fun res ->
  update_inner (fun st ->
    let (_, ident_table') = Scope_table.destroy_scope st.registered_identifiers in
    let () = Debug.print_debug 3 [Debug.DB_desugaring] (fun () ->
      "EXITING Scope: " ^ string_of_scope scope
    ) in
    <| st with registered_identifiers= ident_table'; |> 
  ) >>
  return res


(* This is similar to 'under_scope', but also returns the internal
   declarations that where declared while evaluating 'm' *)
(* NOTE: this only collects INTERNAL declarations, not the extern, static or
   _Thread_local ones *)
val collect_with_scope: forall 'a. scope -> desugM 'a -> desugM (A.bindings * 'a)
let collect_with_scope scope m =
  update_inner (fun st ->
    let () = Debug.print_debug 3 [Debug.DB_desugaring] (fun () ->
      "ENTERING Scope: " ^ string_of_scope scope
    ) in
    <| st with registered_identifiers= Scope_table.create_scope scope st.registered_identifiers; |>
  ) >>
  m >>= fun res ->
  modify_inner (fun st ->
    let (idents_map, ident_table') = Scope_table.destroy_scope st.registered_identifiers in
    let () = Debug.print_debug 3 [Debug.DB_desugaring] (fun () ->
      "EXITING Scope: " ^ string_of_scope scope
    ) in
    ( Set_helpers.fold (fun reg acc ->
      match reg with
        | Internal sym kind _ ->
            match kind with
              | Kind_ordinary (OK_object false) ->
                  match Map.lookup sym st.external_object_declarations with
                    | Just (isTentative, loc, _, dur, isRegister, align_opt, qs, ty) ->
                        (sym, ((loc, dur, isRegister), align_opt, qs, ty)) :: acc
                    | Nothing ->
                        match Map.lookup sym st.internal_object_declarations with
                          | Just (_, A.Static, _, _, _, _) ->
                              acc
                          | Just (_, A.Thread, _, _, _, _) ->
                              acc
                          | Just (loc, dur, isRegister, align_opt, qs, ty) ->
                              (sym, ((loc, dur, isRegister), align_opt, qs, ty)) :: acc
                          | Nothing ->
                              (* TODO: check *)
                              acc
                       end
                  end
              | _ ->
                  (* TODO: functions *)
                  acc
            end
        | External ->
            let () = Debug.print_debug 2 [] (fun () ->
              "KKK: check this"
            ) in
            acc
       end) (Map.range idents_map) []
    ,  <| st with registered_identifiers= ident_table'; |> )
  ) >>= fun bs ->
  return (List.reverse bs, res)


(* TODO: rename *)
val with_scope2: forall 'a. scope -> desugM 'a -> desugM (Map.map (Symbol.identifier * namespace) registration * 'a)
let with_scope2 scope m =
  update_inner (fun st ->
    let () = Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      "ENTERING Scope(2): " ^ string_of_scope scope
    ) in
    <| st with registered_identifiers= Scope_table.create_scope scope st.registered_identifiers; |>
  ) >>
  m >>= fun res ->
  modify_inner (fun st ->
    let (idents_map, ident_table') = Scope_table.destroy_scope st.registered_identifiers in
    let () = Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      "EXITING Scope(2): " ^ string_of_scope scope
    ) in
    (idents_map, <| st with registered_identifiers= ident_table'; |>)
  ) >>= fun idents_map ->
  return (idents_map, res)

let bindings_of_idents_map idents_map =
  read_inner (fun st ->
    List.reverse begin
      Set_helpers.fold (fun decl acc ->
        match decl with
          | External ->
              (* KKK, TODO: check *)
              acc
          | Internal sym kind _ ->
              match kind with
                | Kind_ordinary (OK_object _) ->
                    match Map.lookup sym st.external_object_declarations with
                      | Just (isTentative, _, _, dur, isRegister, align_opt, qs, ty) ->
                          (sym, ((dur, isRegister), align_opt, qs, ty)) :: acc
                      | Nothing ->
                          match Map.lookup sym st.internal_object_declarations with
                            | Just (_, dur, isRegister, align_opt, qs, ty) ->
                                (sym, ((dur, isRegister), align_opt, qs, ty)) :: acc
                            | Nothing ->
                                (* TODO: check *)
                                acc
                          end
                    end
                | _ ->
                    (* TODO: functions *)
                    acc
              end
        end) (Map.range idents_map) []
    end
  )

(* TODO: this is a massive hack (see desugar_and_register_function_definition). MUST DO BETTER *)
val hack_inject_idents_map: Map.map (Symbol.identifier * namespace) registration -> desugM unit
let hack_inject_idents_map idents_map =
  update_inner (fun st ->
    <| st with registered_identifiers=
      Map_extra.fold (fun cabs_ident reg acc ->
        Scope_table.register cabs_ident reg acc
      ) idents_map st.registered_identifiers; |>
  )


let empty_switch_info =
  <| cases_info= []; default_info= Nothing |>


(* ========================================================================== *)
val initial_state: (map string Symbol.sym) * Core.fun_map unit * Core.impl -> Cn_desugaring.init_scope -> state_with_markers
let initial_state core_eval_stuff cn_eval_stuff = <|
  inner= <|
    aux_supply=      0;
    scope_id_supply= 0;
    
    registered_external_identifiers= Map.empty;
    registered_identifiers=      Scope_table.empty;
    
    tag_definitions= Map.empty;
    
    enumeration_constants= Map.empty;
    switch_context= [];
    
    function_declarations=        Map.empty;
    external_object_declarations= Map.empty;
    internal_object_declarations= Map.empty;
    
    function_definitions=        Map.empty;
    global_object_definitions=   Map.empty;
    typedef_definitions=         Map.empty;
    static_assertions=           [];
    
    used_identifier= [];
    current_return_type= Nothing;
    
    loop_attributes= Map.empty;
    toplevel_magic_statements= [];
    cn_state= Cn_desugaring.initial_cn_desugaring_state cn_eval_stuff;
    
    core_eval_stuff= core_eval_stuff;
  |>;
  markers_env= Map.empty;
|>

(* val further_cn_desugaring_state: *)
(*   (map (Cn.cn_namespace * Symbol.identifier) Symbol.sym) -> *)
(*   (map A.ail_identifier tag_definition) -> state_with_markers *)
(* let further_cn_desugaring_state idents tags = *)
(*   let init_st = initial_state (Map.empty, Map.empty, Map.empty) in *)
(*   let cn_state = Cn_desugaring.state_with_idents idents in *)
(*   <| init_st with inner= <| init_st.inner with tag_definitions = tags; cn_state = cn_state |> |> *)

(* val set_cn_c_identifier_env: *)
(*   A.identifier_env -> state_with_markers -> state_with_markers *)
(* let set_cn_c_identifier_env env st = *)
(*   let cn_state = Cn_desugaring.set_c_identifier_env env st.inner.cn_state in *)
(*   <| st with inner= <| st.inner with cn_state = cn_state |> |> *)

val record_marker: unit -> desugM nat
let record_marker () =
  let id = Symbol.fresh_int () in
  begin if Global.backend_name () = "Cn" then
    get_inner >>= fun inner ->
    State_exception.update (fun old_state -> <| old_state with markers_env= Map.insert id inner old_state.markers_env |>)
  else
    State_exception.return ()
  end >>= fun () ->
  State_exception.return id

val fin_markers_env: unit -> desugM fin_markers_env
let fin_markers_env () =
  record_marker () >>= fun id ->
  State_exception.get >>= fun st ->
  State_exception.return (id, st.markers_env)


val eval: forall 'a. (map string Symbol.sym) * Core.fun_map unit * Core.impl -> Cn_desugaring.init_scope -> desugM 'a -> Exception.exceptM (fin_markers_env * 'a) Errors.error
let cabs_to_ail_effect_eval core_eval_stuff cn_eval_stuff m =
  State_exception.eval begin
    m >>= fun res ->
    fin_markers_env () >>= fun markers ->
    State_exception.return (markers, res)
  end (initial_state core_eval_stuff cn_eval_stuff)
let inline eval = cabs_to_ail_effect_eval



val freshify: Symbol.identifier -> desugM Symbol.identifier
let freshify (Symbol.Identifier loc str) =
  modify_inner (fun st ->
    let n = st.aux_supply in
    (Symbol.Identifier loc (str ^ show n), <| st with aux_supply= n+1 |>)
  )

val fresh_block_scope: desugM scope
let fresh_block_scope =
  modify_inner (fun st ->
    let n = st.scope_id_supply in
    (Scope_block n, <| st with scope_id_supply= n+1 |>)
  )

val fresh_prototype_scope: desugM scope
let fresh_prototype_scope =
  modify_inner (fun st ->
    let n = st.scope_id_supply in
    (Scope_prototype n, <| st with scope_id_supply= n+1 |>)
  )


(* ========================================================================== *)
val ident_is_in_scope: Symbol.identifier -> namespace -> desugM bool
let ident_is_in_scope ident namespace =
  read_inner (fun st ->
    Scope_table.is_in_scope (ident, namespace) (Scope_table.return_scope st.registered_identifiers)
  )


val ident_is_in_current_scope: Symbol.identifier -> namespace -> desugM bool
let ident_is_in_current_scope ident namespace =
  read_inner (fun st ->
    Scope_table.is_in_current_scope (ident, namespace) (Scope_table.return_scope st.registered_identifiers)
  )


(* NOTE: this function shouldn't be called outside of the current module *)
val internal_register_identifier:
  (scope * (A.ail_identifier * identifier_kind * maybe linkage) -> (unit -> desugM A.ail_identifier) -> desugM A.ail_identifier) ->
  Symbol.identifier -> namespace -> identifier_kind -> maybe linkage -> desugM A.ail_identifier
let internal_register_identifier if_found ident namespace kind link_opt =
  get_scope >>= fun sc ->
  let () =
    Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      "attempting to register identifier `" ^ show ident ^
       "' with scope= " ^ string_of_scope sc ^
       " with namespace= " ^ show namespace ^
       ", kind= " ^ show kind ^
       match link_opt with
         | Nothing -> ""
         | Just _  -> ", linkage= " ^ show link_opt
       end
    ) in
  (* TODO: we should use a smaller type in the state to avoid having to do these
     checks ... *)
  match (namespace, kind, link_opt) with
    | (Namespace_label, Kind_label, Nothing) ->
        return ()
    | (Namespace_tag, Kind_tag _, Nothing) ->
        return ()
    | (Namespace_member _, Kind_member _, Nothing) ->
        return ()
    | (Namespace_ordinary, Kind_ordinary OK_enum_constant, Nothing) ->
        return ()
    | (Namespace_ordinary, Kind_ordinary OK_typedef, Nothing) ->
        return ()
    | (Namespace_ordinary, Kind_ordinary _, Just _) ->
        return ()
    | _ ->
        (* internal_register_indentifier was improperly called *)
        error (Loc.stringFromLocation (Loc.locOf ident) ^ "cabs_to_ail_effect.internal_register_identifier")
  end >>
  let do_fresh () =
    (* generates a fresh symbol *)
    let Symbol.Identifier loc str = ident in
    let sym = match kind with
      | Kind_ordinary (OK_object _) ->
         Symbol.fresh_object_address str
      | _ -> Symbol.fresh_pretty str 
    end in
    (* associates it to the identifier *)
    update_inner (fun st ->
      match link_opt with
        | Just Linkage_external ->
            (* registering a new identifier WITH external linkage *)
            <| st with
              registered_external_identifiers=
                Map.insert (ident, namespace) (sc, (sym, kind, link_opt)) st.registered_external_identifiers;
              registered_identifiers=
                Scope_table.register (ident, namespace) External st.registered_identifiers;
            |>
        | _ ->
            (* registering a new identifier (without external linkage) *)
            <| st with registered_identifiers=
              Scope_table.register (ident, namespace) (Internal sym kind link_opt) st.registered_identifiers
            |>
      end
    ) >>
    return sym in
  
  match link_opt with
    | Just Linkage_external ->
        let () = Debug.print_debug 2 [] (fun () ->
          "internal_register_identifier ==> link_opt = Just Linkage_external"
        ) in
        (* when registering an identifier with external linkage, we only care
           about previous EXTERNAL registrations *)
           read_inner (fun st ->
          Map.lookup (ident, namespace) st.registered_external_identifiers
        ) >>= function
          | Nothing ->
              let () = Debug.print_debug 2 [] (fun () ->
                "lookup external ==> Nothing"
              ) in
              do_fresh ()
          | Just (scope, decl) ->
              let () = Debug.print_debug 2 [] (fun () ->
                "lookup external ==> Just"
              ) in
              if_found (scope, decl) do_fresh
        end
    | _ ->
        let () = Debug.print_debug 2 [] (fun () ->
          "internal_register_identifier ==> link_opt <> Just Linkage_external"
        ) in
        (* TODO: check this is correct for link = Linkage_internal *)
        read_inner (fun st ->
          Scope_table.resolve (ident, namespace) st.registered_identifiers
        ) >>= function
          | Just (scope, External) ->
              let () = Debug.print_debug 2 [] (fun () ->
                "lookup registered ==> Just External"
              ) in
              read_inner (fun st ->
                Map.lookup (ident, namespace) st.registered_external_identifiers
              ) >>= function
                | Nothing ->
                    error "[Cabs_to_ail_effect.internal_register_identifier] - internal ERROR"
                | Just (_, decl) ->
                    let () = Debug.print_debug 2 [] (fun () ->
                      "lookup external ==> Just"
                    ) in
                    if_found (scope, decl) do_fresh
              end
          | Just (scope, Internal sym kind link_opt) ->
              let () = Debug.print_debug 2 [] (fun () ->
                "lookup registered ==> Just Internal"
              ) in
              if_found (scope, (sym, kind, link_opt)) do_fresh
          | Nothing ->
              (* KKK *)
              let () = Debug.print_debug 2 [] (fun () ->
                "lookup registered ==> Nothing"
              ) in
              read_inner (fun st ->
                Map.lookup (ident, namespace) st.registered_external_identifiers
              ) >>= function
                | Nothing ->
                    let () = Debug.print_debug 2 [] (fun () ->
                      "lookup external ==> Nothing"
                    ) in
                    do_fresh ()
                | Just (scope, decl) ->
                    let () = Debug.print_debug 2 [] (fun () ->
                      "lookup external ==> Just"
                    ) in
                    if_found (scope, decl) do_fresh
              end
        end
  end

val register_typedef: Symbol.identifier -> Annot.attributes * Ctype.qualifiers * Ctype.ctype -> desugM unit
let register_typedef ident (attrs, qs, ty) =
  let loc = Loc.locOf ident in
  let () = Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
    "registering typedef identifier: " ^ show ident ^
    " with (qs, ty) = " ^ Pp.stringFromAil_ctype qs ty
  ) in
  (* if the identifier is already declared we reuse that existing declaration *)
  internal_register_identifier
    (fun (_, (sym, _, _)) _ -> return sym)
    ident Namespace_ordinary (Kind_ordinary OK_typedef) Nothing >>= fun sym ->
  get_inner >>= fun st ->
  match Map.lookup sym st.typedef_definitions with
    | Just (attrs', qs', ty') ->
        (* STD ยง6.7#3, first bullet *)
        if AilTypesAux.variably_modified ty then
          constraint_violation loc Constraint.TypedefRedefinitionVariablyModifiedType
        else if qs <> qs' || ty <> ty' then
          constraint_violation loc Constraint.TypedefRedefinition
        else
          (* TODO: we combine the attributes, not sure this is right thing to do *)
          put_inner (<| st with
            typedef_definitions= Map.insert sym (Annot.combine_attributes attrs attrs', qs', ty') st.typedef_definitions
          |>)
          (* return () *)
    | Nothing ->
        put_inner (<| st with
          typedef_definitions= Map.insert sym (attrs, qs, ty) st.typedef_definitions
        |>)
  end


val resolve_typedef: A.ail_identifier -> desugM (Annot.attributes * Ctype.qualifiers * Ctype.ctype)
let resolve_typedef sym =
  read_inner (fun st ->
    match Map.lookup sym st.typedef_definitions with
      | Just attrs_qs_ty -> attrs_qs_ty
      | _ -> error "TODO(msg) Cabs_to_ail_effect.resolve_typedef"
    end
  )


val register_case: Loc.t -> case_selector -> desugM unit
let register_case loc case_sel =
  get_inner >>= fun st ->
  match st.switch_context with
    | [] ->
        constraint_violation loc Constraint.LabelStatementOutsideSwitch
    | x :: xs ->
        let ctx' = <| x with cases_info= (loc, case_sel) :: x.cases_info |> :: xs in
        put_inner <| st with switch_context= ctx' |>
  end

val register_default: Loc.t -> desugM unit
let register_default loc =
  get_inner >>= fun st ->
  match st.switch_context with
    | [] ->
        constraint_violation loc Constraint.LabelStatementOutsideSwitch
    | x :: xs ->
        match x.default_info with
          | Just prev_loc ->
              constraint_violation loc (Constraint.MutipleDefaultStatement prev_loc)
          | Nothing ->
              let ctx' = <| x with default_info= Just loc |> :: xs in
              put_inner <| st with switch_context= ctx' |>
        end
  end

let rec check_case_overlap new_case = function
  | [] ->
      Nothing
  | (loc, prev_case) :: xs ->
      if match (new_case, prev_case) with
        | (CaseSelectConst new_n, CaseSelectConst prev_n) ->
            new_n = prev_n
        | (CaseSelectConst new_n, CaseSelectRange prev_n1 prev_n2) ->
            prev_n1 <= new_n && new_n <= prev_n2
        | (CaseSelectRange new_n1 new_n2, CaseSelectConst prev_n) ->
            new_n1 <= prev_n && prev_n <= new_n2
        | (CaseSelectRange new_n1 new_n2, CaseSelectRange prev_n1 prev_n2) ->
            (* NOTE: we are assuming the case_selectors  are well-formed *)
            prev_n1 <= new_n2 && new_n1 <= prev_n2
      end then
        Just  loc
      else
        check_case_overlap new_case xs
end

let rec check_case_overlaps_aux acc = function
  | [] ->
        Nothing
  | (loc, x) :: xs ->
      match check_case_overlap x acc with
        | Nothing ->
            check_case_overlaps_aux ((loc, x) :: acc) xs
        | Just prev_loc ->
            Just (loc, prev_loc)
      end
end
let check_case_overlaps xs =
  check_case_overlaps_aux [] xs

val is_in_switch : desugM bool
let is_in_switch =
  read_inner (fun st ->
    match st.switch_context with
      | []     -> false
      | _ :: _ -> true
    end
  )

val as_switch_body: forall 'a. desugM 'a -> desugM 'a
let as_switch_body m =
  update_inner (fun st ->
    <| st with switch_context= empty_switch_info :: st.switch_context |>
  ) >>= fun () ->
  m >>= fun ret ->
  get_inner >>= fun st ->
  match st.switch_context with
    | [] ->
        error "Cabs_to_ail.as_switch_body: switch_context = []"
    | switch_info :: xs ->
        put_inner <| st with switch_context= xs |> >>= fun () ->
        match check_case_overlaps switch_info.cases_info with
          | Nothing ->
              return ret
          | Just (loc, prev_loc) ->
              constraint_violation loc (Constraint.CaseStatementOverlap prev_loc)
        end
  end

(* BEGIN CN *)
(* val liftCnDesug: forall 'a. Cn_desugaring.cn_desugM 'a -> desugM 'a *)
(* let liftCnDesug mk = *)
(*   begin fun st -> *)
(*     Exception.bind (State_exception.run mk st.inner.cn_state) *)
(*       (fun (ret, cn_st') -> Exception.return (ret, <| st with inner= <| st.inner with cn_state= cn_st' |> |>)) *)
(*   end >>= fun ret -> (\* (ret, st') -> *\) *)
(*   (\* put_inner st' >>= fun () -> *\) *)
(*   return ret *)



val check_cn_ident: Cn.cn_namespace -> Symbol.identifier -> desugM bool
let check_cn_ident ns _ident =
  match ns with
  | Cn.CN_predicate ->
    return true (* global *)
  | Cn.CN_function ->
    return true (* global *)
  | Cn.CN_lemma ->
    return true (* global *)
  | Cn.CN_vars ->
    return false (* local *)
  | Cn.CN_oarg ->
    return false (* local *)
  | _ ->
    return true
  end


let update_cn_state f =
  update_inner (fun inner ->
      <| inner with cn_state = f inner.cn_state |>
    )

let get_cn_state =
  get_inner >>= fun inner -> return inner.cn_state



let assert_cn_bottom_scope = 
  get_cn_state >>= fun st ->
  match st.Cn_desugaring.cn_scopes with
  | [] -> Assert_extra.failwith "cn_scopes is empty but should never be empty"
  | [sc] -> return ()
  | _ -> Assert_extra.failwith "cn_scopes should be a singleton but is not"
  end


let current_cn_scope s =
  List_extra.head s.cn_scopes

let push_cn_scope =
  update_cn_state (fun s ->
      <| s with cn_scopes = current_cn_scope s :: s.cn_scopes |>
    )

let pop_cn_scope = 
  update_cn_state (fun s ->
      <| s with cn_scopes = List_extra.tail s.cn_scopes |>
    )


let update_current_cn_scope f =
  update_cn_state (fun s ->
      let cur = List_extra.head s.cn_scopes in
      let rest = List_extra.tail s.cn_scopes in
      <| s with cn_scopes = f cur :: rest |>
    )


(* CN variables cannot shadow CN variables or C variables.  It would
   be good to make the same true the other way round (C variables not
   shadowing CN variables), but with the current pipeline shape that's
   not trivia. So, instead, this function makes C variables take
   precedence over CN variables, as suggested by Kayvan. *)

let cn_resolve_ordinary inner ident =
   match Scope_table.resolve (ident, Namespace_ordinary) inner.registered_identifiers with
   | Nothing ->
      Nothing
   | Just (_, Internal sym kind _linkage) ->
      Just (sym, kind)
   | Just (_, External) ->
      match Map.lookup (ident, Namespace_ordinary) inner.registered_external_identifiers with
      | Nothing -> Nothing
      | Just (_scope, (sym, kind, _linkage)) ->
         Just (sym, kind)
      end
   end

val resolve_cn_ident_opt: forall 'ty. Cn.cn_namespace -> Symbol.identifier -> desugM (maybe (Symbol.sym * Cn.cn_var_kind))
let resolve_cn_ident_opt ns ident =

  get_inner >>= fun inner ->
  let st = inner.cn_state in

  let c_var_kind (kind : identifier_kind) = match kind with
     | Kind_ordinary OK_enum_constant -> Cn.Var_kind_c Cn.C_kind_enum
     | Kind_ordinary _ -> Cn.Var_kind_c Cn.C_kind_var
     | _ -> error "resolve_cn_ident_opt: not Kind_ordinary"
     end
  in

  let lookup_in_c_desugaring_state () = match cn_resolve_ordinary inner ident with
    | Just (sym, kind) -> Just (sym, c_var_kind kind)
    | Nothing -> Nothing
    end
  in

  (* based on earlier Cabs_to_ail_effect code  *)
  let lookup_in_cn_desugaring_state () =
    match Map.lookup (ns, ident) (current_cn_scope st) with
      | Just sym ->
          Just (sym, Cn.Var_kind_cn)
      | Nothing ->
          match Map.lookup (ns, ident) st.cn_idents with
            | Just sym ->
                Just (sym, Cn.Var_kind_cn)
            | Nothing ->
               Nothing
          end
    end
  in

  let result = match ns with
    | Cn.CN_vars ->
       match lookup_in_c_desugaring_state () with
       | Nothing -> lookup_in_cn_desugaring_state ()
       | Just r -> Just r
       end
    | _ ->
      lookup_in_cn_desugaring_state ()
  end in
  return result



let resolve_cn_ident ns ident =
  resolve_cn_ident_opt ns ident >>= function
  | Nothing ->
     get_inner >>= fun inner ->
     let st = inner.cn_state in
     let same_ns xs = List.concat (List.map (fun (ns2, sym) -> if ns2 = ns then [sym] else []) xs) in
     let () = Debug.print_debug 8 []
                (fun () -> "available CN identifiers in ns (" ^ show ns ^ ") in local scope:") in
     (* let () = Debug.print_debug 8 [] *)
     (*            (fun () -> show (same_ns (Set_extra.toList (Map.domain st.cn_current_scope)))) in *)
     let () = Debug.print_debug 8 [] (fun () -> "and in global scope:") in
     let () = Debug.print_debug 8 []
                (fun () -> show (same_ns (Set_extra.toList (Map.domain st.cn_idents)))) in
     fail (Loc.locOf ident) (Errors.Desugar_CN (Cn.CNErr_unknown_identifier ns ident)) 
  | Just (s, kind) -> 
     return (s, kind)
  end



val register_cn_ident: Cn.cn_namespace -> Symbol.identifier -> desugM Symbol.sym
let register_cn_ident ns ((Symbol.Identifier loc str) as ident) =
  resolve_cn_ident_opt ns ident >>= function
  | Just (s, kind) ->
     fail (Loc.locOf ident) (Errors.Desugar_CN (CNErr_redeclaration ns))
  | Nothing ->
    let sym = Symbol.fresh_cn str in
    let () = Debug.print_debug 4 [] (fun () ->
        "adding a CN identifier: " ^ str ^ "(" ^ show ns ^ ")") in
    check_cn_ident ns ident >>= function
    | true ->
      update_cn_state (fun st ->
        <| st with cn_idents= Map.insert (ns, ident) sym st.cn_idents |>
      ) >>= fun () ->
      return sym
    | false ->
      update_current_cn_scope (fun sc ->
          Map.insert (ns, ident) sym sc
      ) >>= fun () ->
      return sym
    end
  end

let resolve_cn_user_type_name ident =
  get_inner >>= fun inner ->
  get_cn_state >>= fun st ->
  match cn_resolve_ordinary inner ident with
    | Just (sym, Kind_ordinary OK_typedef) ->
      return (Cn.CN_c_typedef_name sym)
    | _ -> match Map.lookup ident st.Cn_desugaring.cn_type_synonyms with
      | Nothing -> fail (Loc.locOf ident) (Errors.Desugar_CN
            (Cn.CNErr_unknown_identifier Cn.CN_type_nm ident))
      | Just basety -> return basety
      end
    end


let rec fetch_oarg acc ident = function
  | [] ->
      (Nothing, acc)
  | (((Cn.CN_oarg, ident'), sym) as x) :: xs' ->
      if ident = ident' then
        (Just sym, acc ++ xs')
      else
        fetch_oarg (x :: acc) ident xs'
  | x :: xs' ->
      fetch_oarg (x :: acc) ident xs'
end





(* let inline register_cn_ident ns ident     = liftCnDesug (Cn_desugaring.register_cn_ident ns ident) *)
(* let inline resolve_cn_ident ns ident      = liftCnDesug (Cn_desugaring.resolve_cn_ident ns ident) *)
(* (\* let inline  fetch_oarg acc ident = function *\) *)


val lookup_cn_function: Symbol.identifier -> desugM Symbol.sym
let lookup_cn_function id =
  resolve_cn_ident Cn.CN_function id >>= fun (sym, _) ->
  return sym

(* copied and adjusted from lookup_cn_function *)
val lookup_cn_lemma: Symbol.identifier -> desugM Symbol.sym
let lookup_cn_lemma id =
  resolve_cn_ident Cn.CN_lemma id >>= fun (sym, _) ->
  return sym

val add_toplevel_magic: (Loc.t * string) -> desugM unit
let add_toplevel_magic str =
  update_inner (fun st -> <| st with
    toplevel_magic_statements = str :: st.toplevel_magic_statements |>)

let register_cn_function magic_loc ident loc mk =
  get_inner >>= fun st ->
  match List.lookup ident st.cn_state.Cn_desugaring.cn_functions with
    | Nothing ->
        resolve_cn_ident Cn.CN_function ident >>= fun sym_resolved ->
        let sym = Cn.ensure_not_c_variable sym_resolved in
        push_cn_scope >>= fun () ->
        mk >>= fun (attrs, return_bty, args, body) ->
        let func = <|
          Cn.cn_func_magic_loc= magic_loc;
          Cn.cn_func_loc= loc;
          Cn.cn_func_name= sym;
          Cn.cn_func_attrs= attrs;
          Cn.cn_func_args= args;
          Cn.cn_func_return_bty= return_bty;
          Cn.cn_func_body= body;
        |> in
        (* liftCnDesug *) begin
          pop_cn_scope >>= fun () ->
          assert_cn_bottom_scope >>= fun () -> 
          update_cn_state (fun cn_st' ->
            <| cn_st' with Cn_desugaring.cn_functions= (ident, (sym, func)) :: cn_st'.Cn_desugaring.cn_functions; |>
          )
        end
    | Just _ ->
        fail loc (Errors.Desugar_CN (Cn.CNErr_redeclaration Cn.CN_function))
  end

(* copied and adjusted from register_cn_function *)
let register_cn_lemma magic_loc ident mk =
  get_inner >>= fun st ->
  match List.lookup ident st.cn_state.Cn_desugaring.cn_lemmata with
    | Nothing ->
        register_cn_ident Cn.CN_lemma ident >>= fun sym ->
        push_cn_scope >>= fun () ->
        mk >>= fun (args, requires, ensures) ->
        let lmma = <|
          Cn.cn_lemma_magic_loc= magic_loc;
          Cn.cn_lemma_loc= Loc.locOf ident;
          Cn.cn_lemma_name= sym;
          Cn.cn_lemma_args= args;
          Cn.cn_lemma_requires= requires;
          Cn.cn_lemma_ensures= ensures;
        |> in
        (* liftCnDesug *) begin
          pop_cn_scope >>= fun () ->
          assert_cn_bottom_scope >>= fun () -> 
          update_cn_state (fun cn_st' ->
            <| cn_st' with Cn_desugaring.cn_lemmata= (ident, (sym, lmma)) :: cn_st'.Cn_desugaring.cn_lemmata; |>
          )
        end
    | Just _ ->
        fail (Loc.locOf ident) (Errors.Desugar_CN (Cn.CNErr_redeclaration Cn.CN_lemma))
  end

(* copied and adjusted from register_cn_function *)
let register_cn_fun_spec magic_loc loc (ident : Symbol.sym) (marker_id : nat) mk =
  push_cn_scope >>= fun () ->
  mk >>= fun (args, requires, ensures, rsym) ->
  let spec = <|
    Cn.cn_spec_magic_loc= magic_loc;
    Cn.cn_spec_loc= loc;
    Cn.cn_spec_name= ident;
    Cn.cn_spec_args= args;
    Cn.cn_spec_requires= requires;
    Cn.cn_spec_ret_name= rsym;
    Cn.cn_spec_ensures= ensures;
  |> in
  (* liftCnDesug *) begin
    pop_cn_scope >>= fun () ->
    assert_cn_bottom_scope >>= fun () ->
    update_cn_state (fun cn_st' ->
      <| cn_st' with Cn_desugaring.cn_fun_specs =
          (marker_id, spec) :: cn_st'.Cn_desugaring.cn_fun_specs; |>
    )
  end

let register_cn_predicate magic_loc ident loc mk =
  get_inner >>= fun st ->
  match List.lookup ident st.cn_state.Cn_desugaring.cn_predicates with
    | Nothing ->
        resolve_cn_ident Cn.CN_predicate ident >>= fun sym_resolved ->
        let sym = Cn.ensure_not_c_variable sym_resolved in
        push_cn_scope >>= fun () ->
        mk >>= fun (attrs, output, iargs, clauses) ->
        let pred = <|
          Cn.cn_pred_magic_loc= magic_loc;
          Cn.cn_pred_loc= loc;
          Cn.cn_pred_name= sym;
          Cn.cn_pred_attrs = attrs;
          Cn.cn_pred_output= output;
          Cn.cn_pred_iargs= iargs;
          Cn.cn_pred_clauses= clauses;
        |> in
        (* liftCnDesug *) begin
          pop_cn_scope >>= fun () ->
          assert_cn_bottom_scope >>= fun () -> 
          update_cn_state (fun cn_st' ->
            <| cn_st' with Cn_desugaring.cn_predicates= (ident, (sym, pred)) :: cn_st'.Cn_desugaring.cn_predicates; |>
          )
        end
    | Just _ ->
        fail loc (Errors.Desugar_CN (Cn.CNErr_redeclaration Cn.CN_predicate))
  end

let register_cn_type_synonym name basety =
  update_cn_state (fun st -> <| st with
    Cn_desugaring.cn_type_synonyms= Map.insert name basety
      st.Cn_desugaring.cn_type_synonyms |>)

let register_cn_datatype magic_loc ident loc mk_cases =
  get_inner >>= fun st ->
  match List.lookup ident st.cn_state.Cn_desugaring.cn_datatypes with
    | Nothing ->
        resolve_cn_ident Cn.CN_datatype_nm ident >>= fun sym_resolved ->
        let sym = Cn.ensure_not_c_variable sym_resolved in
        register_cn_type_synonym ident (Cn.CN_datatype sym) >>= fun () ->
        push_cn_scope >>= fun () ->
        mk_cases >>= fun cases ->
        let dt = <|
          Cn.cn_dt_magic_loc= magic_loc;
          Cn.cn_dt_loc= loc;
          Cn.cn_dt_name= sym;
          Cn.cn_dt_cases= cases;
        |> in
        (* liftCnDesug *) begin
          pop_cn_scope >>= fun () ->
          assert_cn_bottom_scope >>= fun () -> 
          update_cn_state (fun cn_st' ->
            <| cn_st' with Cn_desugaring.cn_datatypes = (ident, dt) :: cn_st'.Cn_desugaring.cn_datatypes; |>
          )
        end
    | Just _ ->
        fail loc (Errors.Desugar_CN (Cn.CNErr_redeclaration Cn.CN_datatype_nm))
  end


(* END CN *)







val record_loop_attribute: Annot.loop_id -> Annot.attributes -> desugM unit
let record_loop_attribute id attr = 
  record_marker () >>= fun marker_id ->
  get_inner >>= fun st ->
  put_inner <|st with loop_attributes = (Map.insert id (marker_id, attr) st.loop_attributes) |>

val get_loop_attributes: unit -> desugM Annot.loop_attributes
let get_loop_attributes () = 
  get_inner >>= fun st ->
  State_exception.return st.loop_attributes



(*
(* NOTE: this function shouldn't be called outside of the current module *)
val register_identifier_: Symbol.identifier -> namespace -> identifier_kind -> maybe linkage -> desugM A.ail_identifier
let register_identifier_ ident namespace kind link_opt =
  get_scope >>= fun sc ->
  let () =
    Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      "attempting to register identifier `" ^ show ident ^
       "' with scope= " ^ string_of_scope sc ^
       " with namespace= " ^ show namespace ^
       ", kind= " ^ show kind ^
       match link_opt with
         | Nothing -> ""
         | Just link -> ", linkage= " ^ show link_opt
       end
    ) in
  
  let do_fresh =
    (* generates a fresh symbol *)
    modify_inner (fun st ->
      let Symbol.Identifier _ str = ident in
      let (sym, symbol_supply) = Symbol.fresh_pretty str st.symbol_supply in
      (sym, <| st with symbol_supply = symbol_supply |>)
    ) >>= fun sym ->
    (* associates it to the identifier *)
    update_inner (fun st ->
      <| st with registered_identifiers=
        Scope_table.register (ident, namespace) (sym, kind, link_opt) st.registered_identifiers
      |>
    ) >>
    return sym in
  
  read_inner (fun st ->
    Scope_table.resolve (ident, namespace) st.registered_identifiers
  ) >>= function
    | Just (scope, (sym, kind', link_opt')) ->
        match kind with
          | Kind_tag _ ->
              current_scope_is scope >>= function
                | true ->
                    return sym
                | false ->
                    do_fresh
             end
          | _ ->
              (* TODO: need to check that the kind/link match up *)
              if link_opt = Just Linkage_none then
                (* ยง6.7#3 "except that ..." *)
                (* TODO: this should be dead code now *)
                if kind = Kind_typedef then
                  (* NOTE: the "except that ..." is deal with by the call to [register_typedef] that should be done just after *)
                  return sym
(*
          else if kind = Kind_tag then
            (* TODO: multiple definition are not allowed *)
            return sym
*)
                else
                  (* TODO: check *)
                  current_scope_is scope >>= function
                    | true ->
                        fail (Loc.locOf ident) (Constraint.Desugar_MultipleDeclaration ident)
                    | false ->
                        do_fresh
                  end
              else
                if kind <> kind' then
                  error "TODO: Cabs_to_ail_effect.register_identifier_, kind <> kind'"
                else
                  if link_opt <> link_opt' then
                    (* STD ยง6.2.2#7 *)
                    fail (Loc.locOf ident) (Constraint.Desugar_UndefinedBehaviour Undefined.UB008_multiple_linkage)
                  else
                    return sym
        end
    | Nothing ->
        do_fresh
  end
*)


(* Ordinary identifiers are those declared by ordinary declarators (i.e. object
    or functions) or enumeration constants *)

type ordinary_registration =
  | OReg_enum_constant of A.ail_identifier
  | OReg_typedef of A.ail_identifier
  | OReg_other of A.ail_identifier * ordinary_kind * linkage

val resolve_ordinary_identifier: Loc.t -> Symbol.identifier -> desugM (maybe (scope * ordinary_registration))
let resolve_ordinary_identifier loc ident =
  return (
    Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      "attempting to resolve ordinary identifier `" ^ show ident
    )
  ) >>
  
  read_inner (fun st ->
    let reg_opt = match Scope_table.resolve (ident, Namespace_ordinary) st.registered_identifiers with
      | Nothing ->
          match Map.lookup (ident, Namespace_ordinary) st.registered_external_identifiers with
            | Nothing ->
                Nothing
            | Just (scope, decl) ->
                Just (scope, decl)
          end
      | Just (scope, External) ->
          match Map.lookup (ident, Namespace_ordinary) st.registered_external_identifiers with
            | Nothing ->
                error "[Cabs_to_ail_effect.resolve_ordinary_identifier] - internal ERROR"
            | Just (_, decl) ->
                Just (scope, decl)
          end
      | Just (scope, Internal sym kind link_opt) ->
          Just (scope, (sym, kind, link_opt))
    end in
    match reg_opt with
      | Nothing ->
          Nothing
      | Just (scope, (sym, Kind_ordinary OK_enum_constant, Nothing)) ->
          Just (scope, OReg_enum_constant sym)
      | Just (scope, (sym, Kind_ordinary OK_typedef, Nothing)) ->
          Just (scope, OReg_typedef sym)
      | Just (scope, (sym, Kind_ordinary okind, Just link)) ->
          Just (scope, OReg_other sym okind link)
      | Just (_, (sym, kind, _)) ->
          error ("Cabs_to_ail_effect.resolve_ordinary_identifier ==> [" ^ Loc.stringFromLocation loc ^ "]" ^ show ident ^
                 ", found INVALID: " ^ show sym ^ " with kind: " ^ show kind)
    end
  )


val resolve_extraordinary_identifier:
  Symbol.identifier -> namespace -> desugM (maybe (scope * (A.ail_identifier * identifier_kind)))
let resolve_extraordinary_identifier ident namespace =
  read_inner (fun st ->
    match Scope_table.resolve (ident, namespace) st.registered_identifiers with
      | Nothing ->
          Nothing
      | Just (_, External) ->
          error "Cabs_to_ail_effect.resolve_extraordinary_identifier (1)"
      | Just (_, Internal _ (Kind_ordinary _) _) ->
          error "Cabs_to_ail_effect.resolve_extraordinary_identifier (2)"
      | Just (_, Internal _ _ (Just _)) ->
          error "Cabs_to_ail_effect.resolve_extraordinary_identifier (3)"
      | Just (scope, Internal ident kind Nothing) ->
          Just (scope, (ident, kind))
    end
  )


val internal_resolve_identifier: Symbol.identifier -> namespace -> desugM (maybe (scope * registration))
let internal_resolve_identifier ident namespace =
  read_inner (fun st ->
    Scope_table.resolve (ident, namespace) st.registered_identifiers
  )


val     determinate_linkage: Symbol.identifier -> namespace -> ordinary_kind -> list storage_class_specifier -> desugM linkage
let rec determinate_linkage ident namespace kind storage_classes =
  get_scope >>= fun scope ->
  let scs = List.delete SC_Thread_local storage_classes in
  if    scope = Scope_file
     && (kind = OK_object false || kind = OK_function)
     && List.elem SC_static scs then
STD_ "ยง6.2.2#3" $
      return Linkage_internal
  
  else if List.elem SC_extern scs then
STD_ "ยง6.2.2#4" $
    internal_resolve_identifier ident namespace >>= function
      | Just (_, External) ->
          return Linkage_external
      | Just (_, Internal _ _ (Just Linkage_internal)) ->
          return Linkage_internal
      | Just (_, Internal _ _ (Just _)) ->
          return Linkage_external
      | Just _ ->
          error "determinate_linkage ==> resolved an previous registration with Nothing as linkage"
      | Nothing ->
          return Linkage_external
    end
  
  else if kind = OK_function && List.null scs then
STD_ "ยง6.2.2#5, sentence 1" $
        determinate_linkage ident namespace kind [SC_extern]
  
  else if    scope = Scope_file
          && kind = OK_object false
          && List.null scs then
STD_ "ยง6.2.2#5, sentence 2" $
    return Linkage_external
    
    else
STD_ "ยง6.2.2#6" $
    if    not (is_object_kind kind || kind = OK_function)
       || is_parameter_object_kind kind (* identifier declared to be a function parameter *)
       || is_block_scope scope && is_object_kind kind && scs <> [SC_extern] then
      return Linkage_none
    else
      error "[Cabs_to_ail_effect.determinate_linkage] unknown case"
(* TODO: we need when-patterns in Lem *)
(*
  match (scope, kind, List.delete SC_Thread_local storage_classes) with
    | (Scope_file, Kind_object false, [SC_static]) ->
STD_ "ยง6.2.2#3" $
        return Linkage_internal
    
    | (Scope_file, Kind_function, [SC_static]) ->
STD_ "ยง6.2.2#3" $
        return Linkage_internal
    
    | (_, _, [SC_extern]) ->
STD_ "ยง6.2.2#4" $
        internal_resolve_identifier ident namespace >>= function
          | Just (_, (_, _, link)) ->
              if link = Linkage_internal || link = Linkage_external then
                return link
              else
                return Linkage_external
          | Nothing ->
              return Linkage_external
        end
    
    | (_, Kind_function, []) ->
STD_ "ยง6.2.2#5, sentence 1" $
        determinate_linkage ident namespace kind [SC_extern]
    
    | (Scope_file, Kind_object false, []) ->
STD_ "ยง6.2.2#5, sentence 2" $
        return Linkage_external
    
    | (_, _, storage_class) ->
STD_ "ยง6.2.2#6" $
        if    not (is_object_kind kind || kind = Kind_function)
           || is_parameter_object_kind kind (* identifier declared to be a function parameter *)
           || is_block_scope scope && is_object_kind kind && storage_class <> [SC_extern] then
          return Linkage_none
        else
          error "[Cabs_to_ail_effect.determinate_linkage] unknown case"
  end
*)


(* NOTE: don't call this on typedef identifier *)
val register_ordinary_identifier:
  Symbol.identifier -> ordinary_kind -> list storage_class_specifier -> desugM (linkage * A.ail_identifier)
let register_ordinary_identifier ident kind storage_classes =
  match kind with
    | OK_enum_constant ->
        (* internal_register_indentifier was improperly called *)
        error (Loc.stringFromLocation (Loc.locOf ident) ^ "cabs_to_ail_effect.register_ordinary_identifier")
    | _ ->
        return ()
  end >>
  determinate_linkage ident Namespace_ordinary kind storage_classes >>= fun link ->
  internal_register_identifier (fun (scope, (sym, prev_kind, prev_link_opt)) do_fresh ->
    match link with
      | Linkage_external ->
          (* STD ยง6.2.2#7 *)
          match prev_link_opt with
            | Just Linkage_none ->
                do_fresh ()
            | Just Linkage_internal ->
                undef (Loc.locOf ident) Undefined.UB008_multiple_linkage
            | Just Linkage_external ->
                update_inner (fun st ->
                  <| st with registered_identifiers= 
                    Scope_table.register (ident, Namespace_ordinary) External st.registered_identifiers;
                  |>
                ) >>
                return sym
            | Nothing ->
                error "TODO: is this possible? (register_ordinary_identifer, prev_link_opt = Nothing)"
          end
        (* TODO: need to check that the kind/link match up *)
      | Linkage_none ->
          current_scope_is scope >>= function
            | true ->
                constraint_violation (Loc.locOf ident) (Constraint.NoLinkageMultipleDeclaration ident)
            | false ->
                do_fresh ()
          end
      | Linkage_internal ->
          if Kind_ordinary kind <> prev_kind then
            error "TODO: Cabs_to_ail_effect.register_ordinary_identifier, kind <> kind'"
          else if Just link <> prev_link_opt then
            (* STD ยง6.2.2#7 *)
            undef (Loc.locOf ident) Undefined.UB008_multiple_linkage
          else
            return sym
    end
(*
    if link = Linkage_external then
      (* STD ยง6.2.2#7 *)
      if link_opt' = Just Linkage_internal then
        fail (Loc.locOf ident) (Constraint.Desugar_UndefinedBehaviour Undefined.UB008_multiple_linkage)
      else
        return sym
    (* TODO: need to check that the kind/link match up *)
    else if link = Linkage_none then
      current_scope_is scope >>= function
        | true ->
            fail (Loc.locOf ident) (Constraint.Desugar_MultipleDeclaration ident)
        | false ->
            do_fresh
      end
    else if Kind_ordinary kind <> kind' then
      error "TODO: Cabs_to_ail_effect.register_ordinary_identifier, kind <> kind'"
    else if Just link <> link_opt' then
      (* STD ยง6.2.2#7 *)
      fail (Loc.locOf ident) (Constraint.Desugar_UndefinedBehaviour Undefined.UB008_multiple_linkage)
    else
      return sym
*)
  ) ident Namespace_ordinary (Kind_ordinary kind) (Just link) >>= fun sym ->
  return (link, sym)


val register_tag: Loc.t -> tag_kind -> maybe Symbol.identifier -> desugM A.ail_identifier
let register_tag loc kind = function
  | Nothing ->
      (* unnamed struct/union *)
      return (Symbol.fresh_description (Symbol.SD_unnamed_tag loc))
  | Just tag_ident ->
      internal_register_identifier (fun (scope, (sym, prev_kind, _)) do_fresh ->
        current_scope_is scope >>= function
          | true ->
              if Kind_tag kind = prev_kind then
                return sym
              else
                constraint_violation (Loc.locOf tag_ident) (Constraint.TagRedeclaration sym)
          | false ->
              do_fresh ()
        end
      ) tag_ident Namespace_tag (Kind_tag kind) Nothing 
end


val register_tag_definition: Loc.t -> A.ail_identifier -> tag_definition -> desugM unit
let register_tag_definition loc tag_sym tag_decl =
  let () = Debug.print_debug 5 [Debug.DB_desugaring] (fun () -> "REGISTERING TAG DEFINITION: " ^ show tag_sym) in
  read_inner (fun st ->
    Map.member tag_sym st.tag_definitions
  ) >>= function
    | true ->
        constraint_violation (Loc.with_cursor loc) (Constraint.TagRedefinition tag_sym)
    | false ->
        return ()
  end >>
  match tag_decl with
    | Enum_definition ns_rev ->
        (* NOTE: this function doesn't care about the order of the integers *)
        (* NOTE2: this function is effectful but by its use this shouldn't be observable *)
        if Implementation.register_enum tag_sym ns_rev then
          return ()
        else
          (* NOTE: this should have been caught as redefinition just earlier *)
          error "cabs_to_ail_effect: register_tag_definition"
    | _ ->
        return ()
  end >>
  update_inner (fun st ->
    <| st with tag_definitions= Map.insert tag_sym tag_decl st.tag_definitions |>
  )


val resolve_tag_definition: A.ail_identifier -> desugM (maybe tag_definition)
let resolve_tag_definition tag_sym =
  read_inner (fun st ->
    Map.lookup tag_sym st.tag_definitions
  ) 
(*
>>= function
    | Just tag_decl ->
        return tag_decl
    | Nothing ->
        (* TODO: I think this can only happen when seeing a tentative struct/union
           with a member (or recursive...) whose type is the struct/union itself.
           If this is indeed the case, we should give a better error message *)
        fail Loc.unknown (Constraint.Desugar_OtherViolation ("unregistered tag: " ^ show tag_sym ^
          " (this may be from a violation of (ยง6.7.2.1#3, 1st sentence)"))
  end
*)


val get_tag_definitions: desugM (map A.ail_identifier tag_definition)
let get_tag_definitions =
  read_inner (fun st ->
    st.tag_definitions
  )



val get_anonymous_struct_or_union:
  Ctype.ctype -> desugM (maybe (list (Symbol.identifier * (Annot.attributes * maybe Ctype.alignment * Ctype.qualifiers * Ctype.ctype))))
let get_anonymous_struct_or_union ty =
  (* TODO: the unatomic is commented because clang doesn't consider an atomic
     struct/union an anonymous (regardless of the absence of tag). So we do
     the same for now, but need to check further the STD... *)
  match (* Ctype.unatomic_ *) ty with
    | Ctype.Ctype _ (Ctype.Struct tag_sym) ->
        resolve_tag_definition tag_sym >>= function
          | Just (Struct_definition _ _ _ _ (Just _)) ->
              fail (Loc.unknown) (Errors.Desugar_ConstraintViolation Constraint.StructMemberFlexibleArray)
          | Just (Struct_definition _ _ isAnonymous membrs Nothing) ->
              return begin
                if isAnonymous then Just membrs else Nothing
              end
          | _ ->
              error "Cabs_to_ail_effect.is_anonymous_struct_or_union, Struct -- Union_definition"
        end
    | Ctype.Ctype _ (Ctype.Union tag_sym) ->
        resolve_tag_definition tag_sym >>= function
          | Just (Union_definition _ _ isAnonymous membrs) ->
              return begin
                if isAnonymous then Just membrs else Nothing
              end
          | _ ->
              error "Cabs_to_ail_effect.is_anonymous_struct_or_union, Union -- Struct_definition"
        end
    | _ ->
        return Nothing
  end



(*
KKK

type tag_declaration =
  | Struct_declaration of list (Symbol.identifier * Ctype.ctype)



  registered_tag_declarations: Scope_table.t scope A.ail_identifier tag_declaration;
*)



(*
  match tag_ident_opt with
    | Just sym ->
        return sym
    | Nothing ->
        modify_inner (fun st ->
          let (sym, symbol_supply) = Symbol.fresh st.symbol_supply in
          (sym, <| st with symbol_supply = symbol_supply |>)
        )
  end >>= fun tag_sym ->
  
  



  (* associates it to the identifier *)
  update_inner (fun st ->
    <| st with registered_identifiers= Scope_table.register (tag_sym, Namespace_tag) (tag_sym, kind, link) st.registered_identifiers |>
  ) >>
  return sym
*)

















(*
val resolve_identifier: Symbol.identifier -> t (A.ail_identifier * identifier_kind * linkage)
let resolve_identifier name =
  bind (read_inner (fun st -> Scope_table.lookup name st.registered_identifiers))
    function
      | Just x  -> return x
      | Nothing -> fail (Constraint.CABS_TO_AIL_UNDECLARED_IDENTIFIER name)
    end
*)








(* TODO: move somewhere else *)
(* 
TODO: HIP


val     sigma_declarations_insert: forall 'a 'b. A.sigma_declaration 'a 'b -> A.sigma 'a 'b -> A.sigma 'a 'b
let rec sigma_declarations_insert decl decls =
  match (decl, decls) with
    | (_, []) ->
        []
    | (A.SDecl_fun ident fun_decl, [A.SDecl_fun ident' fun_decl']

 function
  | [] ->
      []
  | ((ident', _) as  :: xs ->
      if ident = ident' then
        (ident, decl) :: xs
      else
        (ident', decl') :: sigma_declarations_insert k v xs
end
*)


(*
val register_declaration: A.sigma_declaration Loc.t unit -> t unit
let register_declaration decl =
  let ident = match decl with
    | A.SDecl_fun ident _ ->
        ident
    | A.SDecl_global ident _ ->
        ident
    | _ ->
        error "register_declaration: found a static_assert"
  end in
  
  (* TODO: detect multiple definitions *)
  
  update_inner (fun st ->
    <| st with registered_declarations= (* assoc_insert ident decl *) decl :: st.registered_declarations |>
  )

val resolve_declarations: t (list (A.sigma_declaration Loc.t unit))
let resolve_declarations =
  read_inner (fun st ->
    st.registered_declarations
  )
*)

(* TODO: maybe have an error when the identifier is not even registered for a function *)
val is_static_object_identifier: A.ail_identifier -> desugM bool
let is_static_object_identifier sym =
  read_inner (fun st ->
    (st.external_object_declarations, st.internal_object_declarations)
  ) >>= fun (ext_decls, int_decls) ->
  return match Map.lookup sym ext_decls with
    | Just (_, _, _, A.Static, _, _, _, _) ->
        true
    | _ ->
        match Map.lookup sym int_decls with
          | Just (_, A.Static, _, _, _, _) ->
              true
          | _ ->
              false
        end
  end


val fetch_object_declaration: A.ail_identifier -> desugM (bool * Loc.t * A.storageDuration * bool * maybe Ctype.alignment * Ctype.qualifiers * Ctype.ctype)
let fetch_object_declaration sym =
  read_inner (fun st ->
    (st.external_object_declarations, st.internal_object_declarations)
  ) >>= fun (ext_decls, int_decls) ->
  match Map.lookup sym ext_decls with
    | Just (isTentative, loc, _, dur, isRegister, align_opt, qs, ty) ->
        return (isTentative, loc, dur, isRegister, align_opt, qs, ty)
    | _ ->
        match Map.lookup sym int_decls with
          | Just (loc, dur, isRegister, align_opt, qs, ty) ->
              return (false, loc, dur, isRegister, align_opt, qs, ty)
          | _ ->
            error ("TODO: failed to fetch object declaration ==> " ^ show sym)
        end
  end


val register_global_object_definition2: Loc.t -> A.ail_identifier -> linkage -> global_definition -> desugM unit
let register_global_object_definition2 loc sym link gdef =
  get_inner >>= fun st ->
  let do_update new_gdef =
    put_inner <| st with global_object_definitions=
      Map.insert sym new_gdef st.global_object_definitions
    |> in
  match Map.lookup sym st.global_object_definitions with
    | Nothing ->
        do_update gdef
    | Just prev_gdef ->
        match (prev_gdef, gdef) with
          | (Tentative _ prev_ty, Tentative loc_def ty) ->
              (* TODO: this function is not correct for desugaring *)
              match AilTypesAux.make_composite prev_ty ty with
                | Nothing ->
                    let () = Debug.print_debug 0 [] (fun () ->
                      "  prev_ty: " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers prev_ty ^ "\n" ^
                      "  ty:      " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers ty
                    ) in
                    error "[register_global_object_definition2] make_composite failed"
                | Just ty' ->
                    do_update (Tentative loc_def ty')
              end
          | (_, Tentative _ _) ->
              (* NOTE: new tentative definitions do not override previous
                 external or "internal" definitions *)
              return ()
          | (Tentative _ _, _) ->
              (* NOTE: but new external or "internal" definitions do override
                 tentative ones *)
              do_update gdef
          | (Definition _, _) ->
              error "[Cabs_to_ail_effect.register_global_object_definition] - internal ERROR 1"
          | (ExternalDefinition _, ExternalDefinition _) ->
              match link with
                | Linkage_internal ->
                    (* STD ยง6.9#3, sentence 1 *)
                    constraint_violation loc (Constraint.ExternalRedefinition sym)
                | Linkage_external ->
                    (* STD ยง6.9#5, sentence 2 *)
                    let () = Debug.print_debug 2 [] (fun () ->
                      "register_global_object_definition2"
                    ) in
                    undef loc Undefined.UB084
                | Linkage_none ->
                    error "[Cabs_to_ail_effect.register_global_object_definition] - internal ERROR 2"
              end
          | (ExternalDefinition _, Definition _) ->
              error "[Cabs_to_ail_effect.register_global_object_definition] - internal ERROR 3"
        end
  end


(* NOTE: no check for redefinition is made here *)
val register_global_object_definition: A.ail_identifier -> global_definition -> desugM unit
let register_global_object_definition sym gdef =
(*
  (* this guard makes sure we are indeed registering the definition of an
     external object (ยง6.9.2#1) *)
  guard (current_scope_is Scope_file) "register_static_object_definition not in File scope" $
*)
  (* NOTE: previously this function was only used for external object
     definitions, now we also use it for static object with no linkage
     (i.e. declared inside functions) or thread local objects *)
  guard begin
    fetch_object_declaration sym >>= function
      | (_, _, A.Static, _, _, _, _) ->
          return true
      | (_, _, A.Thread, _, _, _, _) ->
          return true
      | _ ->
          return false
    end
  end ("register_static_global_definition must only be called for object with static storage duration ==> " ^ show sym) $
    update_inner (fun st ->
      <| st with global_object_definitions= Map.insert sym gdef st.global_object_definitions |>
    )


(* NOTE: no check for redefinition is made here *)
val register_function_definition: A.ail_identifier -> (Loc.t * nat * Annot.attributes * list A.ail_identifier * A.statement unit) -> desugM unit
let register_function_definition sym fdef =
  (* NOTE: unlike for external objects, we don't need to check the scope here,
     because the parse won't allow block scoped function definitions anyway. *)
  update_inner (fun st ->
    let () = Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      let (_, _, _, xs, _) = fdef in
      "registering function definition of '" ^ show sym ^ "' with params: " ^ stringFromList show xs
    ) in
    <| st with function_definitions= Map.insert sym fdef st.function_definitions |>
  )


val global_object_is_defined: A.ail_identifier -> desugM bool
let global_object_is_defined sym =
  read_inner (fun st ->
    Map.member sym st.global_object_definitions
  )

val is_function_designator: A.ail_identifier -> desugM bool
let is_function_designator sym =
  read_inner (fun st->
    Map.member sym st.function_declarations
  )

val function_is_defined: A.ail_identifier -> desugM bool
let function_is_defined sym =
  read_inner (fun st ->
    Map.member sym st.function_definitions
  )


val register_function_declaration:
  Loc.t -> Annot.attributes -> A.ail_identifier -> bool -> ((Ctype.qualifiers * Ctype.ctype) * maybe (list (Ctype.qualifiers * Ctype.ctype * bool)) * bool * bool * bool) -> desugM unit
let register_function_declaration loc attrs sym is_proto decl =
  (* DEBUG *)
  let string_of_decl ((ret_qs, ret_ty), params_opt, isVariadic, _, _) =
    let fun_ty = match params_opt with
      | Nothing ->
        Ctype.Ctype [Annot.Aloc loc] (Ctype.FunctionNoParams (ret_qs, ret_ty))
      | Just params ->
          Ctype.Ctype [Annot.Aloc loc] (Ctype.Function (ret_qs, ret_ty) params isVariadic)
    end in
    Pp.stringFromAil_ctype Ctype.no_qualifiers fun_ty ^
    (if Maybe.isNothing params_opt && isVariadic then " WARNING: isVariadic when NOPARAMS" else "")
  in
(*
    Pp.stringFromAil_ctype ret_qs ret_ty ^ "(" ^ stringFromList (
      fun (qs, ty, isRegister) ->
        (if isRegister then "register " else "") ^ Pp.stringFromAil_ctype qs ty
    ) params ^ ")" in
*)
  
read_inner (fun st ->
    Map.lookup sym st.function_declarations
  ) >>= function
    | Just (prev_has_proto, prev_loc, prev_attrs, prev_decl) ->
        match make_composite_fdecl prev_decl decl with
          | Nothing ->
              (* TODO: check that we are indeed only dealing with same scope redefinition here *)
              constraint_violation loc Constraint.SameScopeIncompatibleDeclarations
          | Just decl' ->
              (* NOTE: we concat the attributes from the previous declartion with the new ones *)
              (* TODO: is it right to only use prev_has_proto? *)
              let () = Debug.print_debug 2 [] (fun () -> "[register_function_declaration] - had prev, valid composite") in
              update_inner (fun st ->
                <| st with function_declarations= Map.insert sym (prev_has_proto, prev_loc, Annot.combine_attributes prev_attrs attrs, decl') st.function_declarations |>
              )
        end
(*
        if decl <> prev_decl then
          let () = Debug.print_debug 0 [] (fun () ->
            "decl: " ^ string_of_decl decl ^ "\n" ^
            "prev_decl: " ^ string_of_decl prev_decl
          ) in
          match make_composite_fdecl prev_decl decl with
            | Nothing ->
                (* TODO: check that we are indeed only dealing with same scope redefinition here *)
                constraint_violation loc Constraint.SameScopeIncompatibleDeclarations
            | Just decl' ->
                (* NOTE: we concat the attributes from the previous declartion with the new ones *)
                (* TODO: is it right to only use prev_has_proto? *)
                update_inner (fun st ->
                  <| st with function_declarations= Map.insert sym (prev_has_proto, prev_loc, Annot.combine_attributes prev_attrs attrs, decl') st.function_declarations |>
                )
          end
        else
          let () = Debug.print_debug 2 [] (fun () -> "HELLO: decl == prev_decl") in
          (* NOTE: we concat the attributes from the previous declartion with the new ones *)
          update_inner (fun st ->
            <| st with function_declarations= Map.insert sym (prev_has_proto, prev_loc, Annot.combine_attributes prev_attrs attrs, prev_decl) st.function_declarations |>
          )
*)
    | Nothing ->
        update_inner (fun st ->
          let () = Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
            "registering function declaration of '" ^ show sym ^ (if is_proto then "' with PROTOTYPE" else "'") ^ " with decl= " ^
           string_of_decl decl) in
          <| st with function_declarations= Map.insert sym (is_proto, loc, attrs, decl) st.function_declarations |>
        )
  end

let get_alignof =
  get_tag_definitions >>= fun tagDefs ->
  let pseudo_tagDefs =
    Map.map function
      | Struct_definition _ _ _ membrs flex_opt ->
          List.map (fun (_, (_, align_opt, _, ty)) -> (align_opt, ty)) membrs ++
          match flex_opt with
            | Nothing ->
                []
            | Just (Ctype.FlexibleArrayMember _ _ _ ty) ->
                [(Nothing, Ctype.Ctype [] (Ctype.Array ty Nothing))]
          end
      | Union_definition _ _ _ membrs ->
          List.map (fun (_, (_, align_opt, _, ty)) -> (Nothing, ty)) membrs
      | Enum_definition _ ->
          [(* dummy, this won't be called *)]
    end tagDefs in
  return (fun z -> Implementation.alignof_ty pseudo_tagDefs z)

(* STD ยง6.7.5#7 *)
let get_compatible_alignment_requirements loc new_align_opt prev_align_opt =
  get_alignof >>= fun alignof_ty ->
  let common new_n prev_n =
    if new_n = prev_n then
      return prev_align_opt
    else
      undef loc Undefined.UB072_incompatible_alignment_specifiers in
  match (new_align_opt, prev_align_opt) with
    | (Nothing, Nothing) ->
        return Nothing
    | (Just _, Nothing) ->
        (* STD ยง6.7.5#7, sentence 2 *)
        undef loc Undefined.UB072_incompatible_alignment_specifiers
    | (Nothing, Just _) ->
        return prev_align_opt
    | (Just (Ctype.AlignInteger new_n), Just (Ctype.AlignInteger prev_n)) ->
        common new_n prev_n
    | (Just (Ctype.AlignType new_ty), Just (Ctype.AlignType prev_ty)) ->
        if Global.isAgnostic () then
          fail loc (Errors.Desugar_agnosticFailure "redeclaration with alignment specifiers is too complicated")
        else
          match (alignof_ty new_ty, alignof_ty prev_ty) with
            | (Just new_n, Just prev_n) ->
                common (integerFromNat new_n) (integerFromNat prev_n)
            | _ ->
                fail loc (Errors.Desugar_TODO "error msg: need a better implementation")
          end
    | (Just (Ctype.AlignType new_ty), Just (Ctype.AlignInteger prev_n)) ->
        if Global.isAgnostic () then
          fail loc (Errors.Desugar_agnosticFailure "redeclaration with alignment specifiers is too complicated")
        else
          match alignof_ty new_ty with
            | Just new_n ->
                common (integerFromNat new_n) prev_n
            | Nothing ->
                fail loc (Errors.Desugar_TODO "error msg: need a better implementation")
          end
    | (Just (Ctype.AlignInteger new_n), Just (Ctype.AlignType prev_ty)) ->
        if Global.isAgnostic () then
          fail loc (Errors.Desugar_agnosticFailure "redeclaration with alignment specifiers is too complicated")
        else
          match alignof_ty prev_ty with
            | Just prev_n ->
                common new_n (integerFromNat prev_n)
            | Nothing ->
                fail loc (Errors.Desugar_TODO "error msg: need a better implementation")
          end
  end

(* TODO: the redeclaration check don't mix external/internal declarations *)
val register_external_object_declaration: A.ail_identifier -> (bool * Loc.t * Annot.attributes * A.storageDuration * bool * maybe Ctype.alignment * Ctype.qualifiers * Ctype.ctype) -> desugM unit
let register_external_object_declaration sym ((isTentative, loc, attrs, new_dur, isRegister, new_align_opt, new_qs, new_ty) as new_decl) =
  return (
    Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      "attempting to register external object declaration of `" ^ show sym ^
      "' with dur: " ^ string_of_storageDuration new_dur ^ " qs, ty: " ^ Pp.stringFromAil_ctype new_qs new_ty)
  ) >>
  
  read_inner (fun st ->
    Map.lookup sym st.external_object_declarations
  ) >>= function
    | Just (_, _, _, prev_dur, _, prev_align_opt, prev_qs, prev_ty) ->
        let () = Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
          "has previous decl ==> with dur: " ^ string_of_storageDuration prev_dur ^
          " qs, ty: " ^ Pp.stringFromAil_ctype prev_qs prev_ty ^
          " are_compatible ?= " ^
          (if AilTypesAux.are_compatible (new_qs, new_ty) (prev_qs, prev_ty)
           then "true" else "false")
        ) in
    
        if not (prev_dur = A.Thread --> new_dur = A.Thread) then
          constraint_violation loc Constraint.ThreadLocalShouldAppearInEveryDeclaration
        
        (* TODO: what about the storage duration and isRegister?? *)
        else if not (AilTypesAux.are_compatible (new_qs, new_ty) (prev_qs, prev_ty)) then

(*
(Ctype.storageDuration * (* isRegister *) bool * Ctype.qualifiers * Ctype.ctype)
*)


(*        if decl <> decl' then *)
          (* TODO: there is also ยง6.7#4 which requires (nearly) the same an failure is a
             constraint violation, not UB. Which own should we report ???? *)
          (* STD ยง6.2.7#2 *)
          undef loc Undefined.UB015_incompatible_redeclaration
        else 
          get_compatible_alignment_requirements loc new_align_opt prev_align_opt >>= fun align_opt ->
          let () = Debug.print_debug 3 [Debug.DB_desugaring] (fun () -> "found a valid redeclaration of `" ^ show sym ^ "'") in
          (* TODO: check that is ok to use AilTypesAux.make_composite for object types (see comment in AilTypesAux) *)
          (* TODO: what about qualifiers? *)
          if true (* AilTypesAux.is_array prev_ty && AilTypesAux.is_array new_ty *) then
            match AilTypesAux.make_composite prev_ty new_ty with
              | Just ty' ->
                  (* TODO: what about ty' ?? *)
                  let decl = (isTentative, loc, attrs, new_dur, isRegister, align_opt, new_qs, new_ty) in
                  update_inner (fun st ->
                    <| st with external_object_declarations= Map.insert sym decl st.external_object_declarations |>
                  )
              | Nothing ->
                  let () = Debug.print_debug 0 [] (fun () ->
                    "prev_ty= " ^ Pp.stringFromAil_ctype prev_qs prev_ty ^ "\n" ^
                    "new_ty= " ^ Pp.stringFromAil_ctype new_qs new_ty
                  ) in
                  error "WIP: register_external_object_declaration, make_composite failed"
            end
          else
            return ()
    | Nothing ->
        update_inner (fun st ->
          <| st with external_object_declarations= Map.insert sym new_decl st.external_object_declarations |>
        )
  end

val update_external_object_type: A.ail_identifier -> Ctype.ctype -> desugM unit
let update_external_object_type sym ty =
  return (
    Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      "updating external object type of `" ^ show sym ^
      "' with ty= " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers ty)
  ) >>
  update_inner (fun st ->
    match Map.lookup sym st.external_object_declarations with
      | Nothing ->
          error "[Cabs_to_ail_effect.update_external_object_type] called on an unregistered symbol"
      | Just (isTentative, loc, attrs, dur, is_register, align_opt, qs, _) ->
          <| st with external_object_declarations=
            Map.insert sym (isTentative, loc, attrs, dur, is_register, align_opt, qs, ty) st.external_object_declarations
          |>
    end
  )

(* TODO: factorize *)
val register_internal_object_declaration:
  A.ail_identifier -> (Loc.t * A.storageDuration * bool * maybe Ctype.alignment * Ctype.qualifiers * Ctype.ctype) -> desugM unit
let register_internal_object_declaration sym ((loc, _, _, _, _, _) as decl) =
  return (
    Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      let (_, _, _, _, new_qs, new_ty) = decl in
      "attempting to register internal object declaration of `" ^ show sym ^
      "' with qs, ty= " ^ Pp.stringFromAil_ctype new_qs new_ty)
  ) >>
  
  read_inner (fun st ->
    Map.lookup sym st.internal_object_declarations
  ) >>= function
    | Just decl' ->
        (* TODO: this should be non accessible code, since redeclaration of internal objects is forbidden and caugh earlier *)
        if decl <> decl' then
          (* STD ยง6.2.7#2 *)
          undef loc Undefined.UB015_incompatible_redeclaration
        else
          return ()
    | Nothing ->
        update_inner (fun st ->
          <| st with internal_object_declarations= Map.insert sym decl st.internal_object_declarations |>
        )
  end

val update_internal_object_type: A.ail_identifier -> Ctype.ctype -> desugM unit
let update_internal_object_type sym ty =
  return (
    Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      "updating internal object type of `" ^ show sym ^
      "' with ty= " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers ty)
  ) >>
  update_inner (fun st ->
    match Map.lookup sym st.internal_object_declarations with
      | Nothing ->
          error "[Cabs_to_ail_effect.update_internal_object_type] called on an unregistered symbol"
      | Just (loc, dur, is_register, align_opt, qs, _) ->
          <| st with internal_object_declarations=
            Map.insert sym (loc, dur, is_register, align_opt, qs, ty) st.internal_object_declarations
          |>
    end
  )



val register_static_assertion: A.expression unit -> A.stringLiteral -> desugM unit
let register_static_assertion e strCst =
  update_inner (fun st ->
    <| st with static_assertions= (e, strCst) :: st.static_assertions |>
  )


val register_label: Symbol.identifier -> desugM unit
let register_label ident =
  void $ internal_register_identifier (fun _ _ ->
    constraint_violation (Loc.locOf ident) (Constraint.LabelRedefinition ident)
  ) ident Namespace_label Kind_label Nothing


val resolve_label: Symbol.identifier -> desugM A.ail_identifier
let resolve_label ident =
  (* TODO: ยง6.8.6.1#1 *)
  internal_resolve_identifier ident Namespace_label >>= function
    | Just (_, Internal sym _ _) ->
        return sym
    | _ (*Nothing*) ->
        constraint_violation (Loc.locOf ident) (Constraint.UndeclaredLabel ident)
  end


(* Returns the return type of the function currently being desugared *)
let get_current_return_type: desugM Ctype.ctype =
  read_inner (fun st ->
    match st.current_return_type with
      | Just ty ->
          ty
      | Nothing ->
          error "Cabs_to_ail_effect.get_current_return_type Nothing"
    end
  )

let set_current_return_type (ty_opt: maybe Ctype.ctype) : desugM unit =
  update_inner (fun st ->
    <| st with current_return_type= ty_opt |>
  )

let inside_function (return_ty: Ctype.ctype) m =
  (* NOTE: doing this in case we ever add support for nested functions *)
  read_inner (fun st -> st.current_return_type) >>= fun saved ->
  set_current_return_type (Just return_ty)      >>= fun ()    ->
  m                                             >>= fun res   ->
  set_current_return_type saved                 >>= fun ()    ->
  return res

let is_inside_function =
  isJust <$> read_inner (fun st -> st.current_return_type)



(* TODO: would be more efficient to store in the state the list of unused functions *)
val add_used_identifier: A.ail_identifier -> desugM unit
let add_used_identifier sym =
  update_inner (fun st ->
    let () = Debug.print_debug 2 [Debug.DB_desugaring] (fun () -> "USED IDENTIFIER") in
    <| st with used_identifier= Utils.list_insert sym st.used_identifier |>
  )

val get_used_identifier: desugM (list A.ail_identifier)
let get_used_identifier =
  read_inner (fun st ->
    st.used_identifier
  )






val register_enum_constant: Symbol.identifier -> A.expression_ unit -> desugM unit
let register_enum_constant ident expr =
  let () = Debug.print_debug 2 [] (fun () -> 
    "register_enum_constant: " ^ show ident
  ) in
  internal_register_identifier (fun (scope, _) do_fresh ->
    current_scope_is scope >>= function
      | true ->
          (* STD footnote 127 *)
          fail (Loc.locOf ident) (Errors.Desugar_MiscViolation (Errors.MultipleEnumDeclaration ident))
      | false ->
          (* a previous registration from a different scope gets shadowed *)
          do_fresh ()
    end
  ) ident Namespace_ordinary (Kind_ordinary OK_enum_constant) Nothing >>= fun sym ->
  update_inner (fun st ->
    <| st with enumeration_constants= Map.insert sym expr st.enumeration_constants |>
  )

val resolve_enum_constant: A.ail_identifier -> desugM (A.expression_ unit)
let resolve_enum_constant sym =
  read_inner (fun st ->
    st.enumeration_constants
  ) >>= fun enumeration_constants ->
  match Map.lookup sym enumeration_constants with
    | Just e ->
        return e
    | Nothing ->
        error "cabs_to_ail_effect.resolve_enum_constant"
  end


(* TODO: hackish, uber inefficient *)
val remove_unused_identifiers: forall 'a. state -> A.ail_identifier -> list (A.ail_identifier * 'a) -> list (A.ail_identifier * 'a)
let remove_unused_identifiers st startup_sym xs =
  List.filter (fun (sym, _) -> sym = startup_sym || List.elem sym st.used_identifier) xs

(*
val remove_block_scoped_identifiers: forall 'a. state -> list (A.ail_identifier * 'a) -> list (A.ail_identifier * 'a)
let remove_block_scoped_identifiers st xs =
  List.filter (fun (sym, _) ->
    match Scope_table.resolve (sym, Namespace_ordinary) st.registered_identifiers with
      | Just (Scope_file, _) ->
          true
      | _ ->
          false
    end
  ) xs
*)

val mk_current_ail_sigma : desugM (A.sigma unit)
let mk_current_ail_sigma =
  get_tag_definitions >>= fun ident_tagDefs ->
  return
    <|  A.declarations= [];
        A.object_definitions= [];
        A.function_definitions= [];
        A.static_assertions= [];
        A.tag_definitions=
          List.reverse begin
            List.foldl (fun acc (ident, tagDef) ->
              match tagDef with
                | Struct_definition loc attrs _ xs flexible_opt ->
                    (ident, (loc, attrs, Ctype.StructDef xs flexible_opt)) :: acc
                | Union_definition loc attrs _ xs ->
                    (ident, (loc, attrs, Ctype.UnionDef xs)) :: acc
                | Enum_definition _ ->
                    acc
              end
            ) [] (Map_extra.toList ident_tagDefs)
          end;
        A.extern_idmap= Map.empty;
        A.typedef_attributes= Map.empty;
        A.loop_attributes= Map.empty;
        A.cn_functions= [];
        A.cn_lemmata= [];
        A.cn_predicates= [];
        A.cn_datatypes= [];
        A.cn_fun_specs= [];
        A.cn_idents= Map.empty; |>

val is_complete_object: Ctype.ctype -> desugM bool
let cabs_to_ail_is_complete_object ty =
  mk_current_ail_sigma >>= fun sigm ->
  return (AilTypesAux.is_complete_object sigm ty)
let inline is_complete_object = cabs_to_ail_is_complete_object

val is_incomplete: Ctype.ctype -> desugM bool
let cabs_to_ail_effect_is_incomplete ty =
  mk_current_ail_sigma >>= fun sigm ->
  return (AilTypesAux.is_incomplete sigm ty)
let inline is_incomplete = cabs_to_ail_effect_is_incomplete





(* TODO: ... *)
let map_union = Map.(union)

val extract_program: string -> desugM (A.ail_program unit)
let extract_program startup_str =
  get_inner >>= fun st ->
  let startup_sym_opt =
    match Map.lookup (Symbol.Identifier Loc.unknown startup_str, Namespace_ordinary)
            st.registered_external_identifiers with
      | Nothing ->
          Nothing
      | Just (_, (sym, _, _)) ->
          Just sym
    end in
  
  let decls = Map_extra.toList (
    map_union
      begin map_union
        begin
          Map.map (fun (hasProto, loc, attrs, (ret_qs_ty, params_opt, isVariadic, isInline, isNoreturn)) ->
            let () = Debug.print_debug 2 [] (fun () ->
              "KKK: check + find STD quote"
            ) in
            let params = match params_opt with
              | Nothing -> []
              | Just z  -> z
            end in
            (loc, attrs, A.Decl_function hasProto ret_qs_ty params isVariadic isInline isNoreturn)
          ) st.function_declarations
        end
        begin
          Map.map (fun (isTentative, loc, attrs, dur, isRegister, align_opt, qs, ty) ->
            let ty' =
              if isTentative then
                match ty with
                  | Ctype.Ctype annots (Ctype.Array elem_ty Nothing) ->
                      (* TODO: check *)
                      (* STD ยง6.9.2#5 EXAMPLE 2 *)
                      Ctype.Ctype annots (Ctype.Array elem_ty (Just 1))
                  | _ ->
                      ty
                end
              else
                ty in
            (loc, attrs, A.Decl_object (dur, isRegister) align_opt qs ty')
          ) st.external_object_declarations
        end
      end
      begin
        (* Adding internals object with static or thread storage duration *)
        Map_extra.fold (fun ident (loc, dur, isRegister, align_opt, qs, ty) acc ->
          match dur with
            | A.Static ->
                Map.insert ident (loc, Annot.no_attributes, A.Decl_object (dur, isRegister) align_opt qs ty) acc
            | A.Thread ->
                Map.insert ident (loc, Annot.no_attributes, A.Decl_object (dur, isRegister) align_opt qs ty) acc
            | _ ->
                acc
          end
        ) st.internal_object_declarations Map.empty
      end
  ) in
  
  let extern_idmap =
    let fundef_syms = Map.domain st.function_definitions in
    Map_extra.fold (fun (cid, namespace) (scope, (sym, id_kind, m_link)) acc ->
    match (namespace, scope, id_kind, m_link) with
      | (Namespace_ordinary, Scope_file, Kind_ordinary, Just Linkage_external) ->
        let kind = match Map.lookup sym st.global_object_definitions with
          | Just (Tentative _ _) -> A.IK_tentative
          | Just (Definition _) -> A.IK_definition
          | Just (ExternalDefinition _) -> A.IK_definition
          | Nothing ->
            if sym IN fundef_syms then A.IK_definition
            else A.IK_declaration
        end in
        Map.insert cid (sym, kind) acc
      | (_, _, _, _) ->
        acc
    end) st.registered_external_identifiers Map.empty in
  
  mapM (function
  | (sym, Tentative loc (Ctype.Ctype _ (Ctype.Array elem_ty Nothing))) ->
      (* TODO: check *)
      (* STD ยง6.9.2#5 EXAMPLE 2 *)
      return (sym, A.AnnotatedExpression () [] loc (A.AilEconst (A.ConstantArray elem_ty [mk_zeroInit_aux st.tag_definitions elem_ty])))
  | (sym, Tentative loc ty) ->
      is_incomplete ty >>= function
        | true ->
            fail loc (Errors.Desugar_ConstraintViolation (Constraint.TentativeNotCompleted ty))
        | false ->
            return (sym, mk_zeroInit st.tag_definitions ty)
      end
    | (sym, Definition e) ->
        return (sym, e)
    | (sym, ExternalDefinition e) ->
      return  (sym, e)
  end) (Map_extra.toList st.global_object_definitions) >>= fun object_defs ->
  
  mapM (fun ((ident, _), (_, (sym, kind, link_opt))) ->
    (* TODO: the errors should only be for when the identifiers are used in an
       evaluated expression (i.e. "other than as part of the operand of a sizeof
       or _Alignof operator whose result is an integer constant") *)
    match link_opt with
      | Just Linkage_internal ->
          if    List.elem sym st.used_identifier
             && (kind = Kind_ordinary (OK_object false) || kind = Kind_ordinary OK_function)
             && List.lookup sym object_defs = Nothing
             && not (Map.member sym st.function_definitions) then
            (* STD ยง6.9#3, sentence 2 *)
            constraint_violation (Loc.locOf ident) (Constraint.ExternalRedefinition sym)
          else
            return ()
      (*
      | Just Linkage_external ->
          (* TODO: the error is desactivated for functions for now. We need to have a way of telling the desugaring that
             some function are implemented in Core (i.e. printf()) *)
          if    List.elem sym st.used_identifier
             && kind = Kind_ordinary (OK_object false)
             && List.lookup sym object_defs = Nothing
             && not (Map.member sym st.function_definitions) then
            (* STD ยง6.9#5, sentence 2 *)
            let () = Debug.print_debug 2 [] (fun () ->
              "extract_program"
            ) in
            undef (Loc.locOf ident) Undefined.UB084
          else
            return ()
      *)
      | Just Linkage_external ->
          if kind = Kind_ordinary OK_function && not (Map.member sym st.function_definitions) then
            match List.lookup sym decls with
              | Just (loc, _, A.Decl_function _ _ _ _ true(* is_inline *) _) ->
                  undef loc Undefined.UB070_inline_not_defined
              | _ ->
                  return ()
            end
          else
            return ()
      | _ ->
          return ()
    end
  ) (Map_extra.toList st.registered_external_identifiers) >>
  
  return (startup_sym_opt, <|
     A.declarations=         (* remove_unused_identifiers st startup_sym *) decls;
     A.object_definitions=   (* remove_unused_identifiers st startup_sym $ *) object_defs;
     A.function_definitions= (* remove_unused_identifiers st startup_sym $ *) Map_extra.toList st.function_definitions;
     A.static_assertions=    st.static_assertions;
     
     A.tag_definitions= List.foldr (fun (sym, def) acc ->
                          match def with
                           | Struct_definition loc attrs _ membersDefs flexible_opt ->
                               (sym, (loc, attrs, Ctype.StructDef membersDefs flexible_opt)) :: acc
                           | Union_definition loc attrs _ membersDefs ->
                               (sym, (loc, attrs, Ctype.UnionDef membersDefs)) :: acc
                           | Enum_definition _ ->
                               acc
                           end
                        ) [] $ Map_extra.toList st.tag_definitions;
    A.extern_idmap= extern_idmap;
    A.typedef_attributes= Map.map (fun (z, _, _) -> z) st.typedef_definitions;
    A.loop_attributes = st.loop_attributes;
    A.cn_predicates=  List.reverse (List.map (fun (_, (_, z)) -> z) (st.cn_state.Cn_desugaring.cn_predicates));
    A.cn_functions=  List.reverse (List.map (fun (_, (_, z)) -> z) (st.cn_state.Cn_desugaring.cn_functions));
    A.cn_lemmata=  List.reverse (List.map (fun (_, (_, z)) -> z) (st.cn_state.Cn_desugaring.cn_lemmata));
    A.cn_datatypes=  List.reverse (List.map (fun (_, z) -> z) (st.cn_state.Cn_desugaring.cn_datatypes));
    A.cn_fun_specs=  List.reverse st.cn_state.Cn_desugaring.cn_fun_specs;
    A.cn_idents=  st.cn_state.Cn_desugaring.cn_idents;
   |>)



val print_debugM: nat -> (unit -> string) -> desugM unit
let inline print_debugM n msg =
  return (Debug.print_debug n [Debug.DB_desugaring] msg)

val warnM: (unit -> string) -> desugM unit
let inline warnM msg =
  return (Debug.warn [Debug.DB_desugaring] msg)


(* TODO *)
import Core
val get_core_eval_stuff: desugM ((map string Symbol.sym) * Core.fun_map unit * Core.impl)
let get_core_eval_stuff =
  read_inner (fun st -> st.core_eval_stuff)


val get_gamma_sofar: desugM A.gamma
let get_gamma_sofar =
  read_inner (fun st ->
    (* TODO: this is putting too much in gamma (i.e. things which are not in the
       current scope). But since we are dealing with fresh symbols, this
       shouldn't be observable? *)
    List.map (fun (sym, (loc, dur, b, align_opt, qs, ty)) ->
      (sym, ((loc, dur, b), align_opt, qs, ty))
    ) (Map_extra.toList st.internal_object_declarations)
  )


(* Returns what would the Ail sigma be so far *)
(* TODO: factorise with extract_program *)
val get_sigma_sofar: desugM (A.sigma unit)
let get_sigma_sofar =
  read_inner (fun st ->
    let decls = Map_extra.toList (
      map_union
        begin
          Map.map (fun (hasProto, loc, attrs, (ty, params_opt, isVariadic, isInline, isNoreturn)) ->
            let () = Debug.print_debug 2 [] (fun () ->
              "KKK: check + find STD quote"
            ) in
            (* TODO: is it correct "complete" the params like that ? *)
            let params = match params_opt with
              | Nothing -> []
              | Just z  -> z
            end in
            (loc, attrs, A.Decl_function hasProto ty params isVariadic isInline isNoreturn)
          ) st.function_declarations
        end
        begin
          Map.map (fun (_, loc, attrs, dur, isRegister, _, qs, ty) ->
            (loc, attrs, A.Decl_object ((dur, isRegister)) Nothing qs ty)
          ) st.external_object_declarations
        end
    ) in
    
    <|
       A.declarations=         (* remove_unused_identifiers st startup_sym *) decls;
       A.object_definitions=   (* remove_unused_identifiers st startup_sym $ *) [(*TODO:check, but this shouldn't be used*)]
(*Map_extra.toList st.global_object_definitions*);
       A.function_definitions= (* remove_unused_identifiers st startup_sym $ *) Map_extra.toList st.function_definitions;
       A.static_assertions=    st.static_assertions;
       
       A.tag_definitions= List.foldr (fun (sym, def) acc ->
                            match def with
                             | Struct_definition loc attrs _ membersDefs flexible_opt ->
                                 (sym, (loc, attrs, Ctype.StructDef membersDefs flexible_opt)) :: acc
                             | Union_definition loc attrs _ membersDefs ->
                                 (sym, (loc, attrs, Ctype.UnionDef membersDefs)) :: acc
                             | Enum_definition _ ->
                                 acc
                             end
                          ) [] $ Map_extra.toList st.tag_definitions;
       A.extern_idmap= Map.empty;
       A.typedef_attributes= Map.map (fun (z, _, _) -> z) st.typedef_definitions;
       A.loop_attributes= st.loop_attributes;
       A.cn_predicates=  List.reverse (List.map (fun (_, (_, z)) -> z) (st.cn_state.Cn_desugaring.cn_predicates));
       A.cn_functions= List.reverse (List.map (fun (_, (_, z)) -> z) (st.cn_state.Cn_desugaring.cn_functions));
       A.cn_lemmata= List.reverse (List.map (fun (_, (_, z)) -> z) (st.cn_state.Cn_desugaring.cn_lemmata));
       A.cn_datatypes= List.reverse (List.map (fun (_, z) -> z) (st.cn_state.Cn_desugaring.cn_datatypes));
       A.cn_fun_specs=  List.reverse st.cn_state.Cn_desugaring.cn_fun_specs;
       A.cn_idents=  st.cn_state.Cn_desugaring.cn_idents;
       |>
   )
