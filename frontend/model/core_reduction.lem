open import Pervasives
open import Utils
open import Core Core_aux Core_run_aux

import State
import Core_eval Cmm_aux Cmm_csem

(* TODO *)
import Core_run

module Cmm = struct
  include Cmm_aux
  include Cmm_csem
end

module Caux = Core_aux


let combine_dyn_annotation xs1 xs2 =
  xs1 ++ xs2

(* TODO: use to_pure? *)
val get_pure: expr core_run_annotation -> maybe (list Annot.annot * pexpr)
let get_pure (Expr annots expr_) =
  match expr_ with
    | Epure pe ->
        Just (annots, pe)
    | Eannot _ (Expr _ (Epure pe)) ->
        Nothing (* Just (annots, pe) *)
    | _ ->
        Nothing
  end

(*
val is_pure: Core.expr core_run_annotation -> bool
let is_pure expr =
  match get_pure expr with
    | Nothing ->
        false
    | Just _ ->
        true
  end
*)

type one_step =
  | TAU of string * list (map Symbol.sym value) * Core.expr core_run_annotation
  | EVAL of string * core_runM (Core.expr core_run_annotation)
  | MEMOP of Mem_common.memop * list Core.value
  | UNSEQUENCED_RACE
  | ILLTYPED of string




module EU  = Exception_undefined
module SEU = State_exception_undefined

(* TODO: duplicate from Core_run *)
module E = struct
  let inline return = SEU.return
  let inline undef  = SEU.undef
  let inline mapM   = SEU.mapM
  
  let fresh_excluded_id =
    SEU.runS (fun run_st ->
    let n = run_st.excluded_supply in
    (n, <| run_st with excluded_supply= n+1 |>)
  )
  
  
  let eval_pexpr2 th_st core_extern mem_st file pe =
    let () = Debug.print_debug 5 [] (fun () -> "CALLING Core_run.eval_pexpr2" ) in
    SEU.runEU (Core_eval.eval_pexpr_aux2 th_st.current_loc core_extern th_st.env (Just mem_st) file pe)
end

let inline (>>=) = SEU.bind
let inline (<$>) = SEU.fmap

let rec full_eval_pexpr th_st core_extern mem_st file pe =
  E.eval_pexpr2 th_st core_extern mem_st file pe >>= (function
    | Left pe' ->
        full_eval_pexpr th_st core_extern mem_st file pe'
    | Right cval ->
        E.return cval
  end)




(* ********************************************************************************************** *)

let is_irreducible = function
    (* annot(..., annot(..., _)) ==> NOTE THE _ may be a value *)
  | Expr _ (Eannot _ (Expr _ (Eannot _ (Expr _ (Epure (Pexpr _ _ (PEval _))))))) ->
      (* TODO: this makes the function misnamed, but this has a one step reduction *)
      false
    (* v *)
  | Expr _ (Epure (Pexpr _ _ (PEval _))) ->
      true
    (* annot(..., v) *)
  | Expr _ (Eannot _ (Expr _ (Epure (Pexpr _ _ (PEval _))))) ->
      true
  | _ ->
      false
end


import Debug


val do_race: Core.dyn_annotations -> Core.dyn_annotations -> bool
let do_race xs1 xs2 =
  List.any (function
    | DA_neg id1 exclusion1 fp1 ->
        List.any (function
          | DA_neg id2 exclusion2 fp2 ->
              if List.elem id1 exclusion2 || List.elem id2 exclusion1 then
                false
              else
                Mem.do_overlap fp1 fp2
          | DA_pos exclusion2 fp2 ->
              if List.elem id1 exclusion2 then
                false
              else
                Mem.do_overlap fp1 fp2
        end) xs2
    | DA_pos exclusion1 fp1 ->
        List.any (function
          | DA_neg id2 _ fp2 ->
              if List.elem id2 exclusion1 then
                false
              else
                Mem.do_overlap fp1 fp2
          | DA_pos _ fp2 ->
                Mem.do_overlap fp1 fp2
        end) xs2
  end) xs1


val combine_dyn_annotations: Core.dyn_annotations -> Core.dyn_annotations -> Core.dyn_annotations
let combine_dyn_annotations xs1 xs2 =
  xs1 ++ xs2

let pp_dyn_annotations fps =
  let pp_dyn_annotation = function
    | DA_neg n excl fp ->
        "DA_neg(" ^ show n ^ ", " ^ show excl ^ ")"
    | DA_pos excl fp ->
        "DA_pos(" ^ show excl ^ ")"
  end in
  stringFromList pp_dyn_annotation fps

let rec one_step_unseq_aux (fps_acc, cvals_acc) = function
  | [] ->
      Just (fps_acc, List.reverse cvals_acc)
  | Expr _ (Epure (Pexpr _ _ (PEval cval))) :: xs ->
      one_step_unseq_aux (fps_acc, cval::cvals_acc) xs
  | Expr _ (Eannot fps (Expr _ (Epure (Pexpr _ _ (PEval cval))))) :: xs ->
      let () = Debug.print_debug 3 [] (fun () ->
        "CHECKING FOR RACE"
      ) in
(*      if List.any (fun z -> List.any (fun z' -> Mem.do_overlap z z') fps_acc) fps then *)
      if do_race fps fps_acc then
        (* found an unsequenced race *)
        let () = Debug.print_debug 1 [] (fun () ->
          "FOUND RACE: " ^ pp_dyn_annotations fps ^ " <---> " ^ pp_dyn_annotations fps_acc
        ) in
        Nothing
      else
        one_step_unseq_aux (combine_dyn_annotations fps fps_acc, cval :: cvals_acc) xs
  | e :: _ ->
      (* all the operand of the unseq() must have already been reduced to values *)
      error ("Core_run.one_step_unseq_aux ==> " ^ Pp.stringFromCore_expr e)
  end

(* NOTE: for performance, we use scoped environment instead of substitutions for bound variables *)
val one_step:
  (Core.pexpr -> core_runM Core.pexpr) ->
  list (map Symbol.sym value) -> Core.expr core_run_annotation -> maybe one_step
let one_step eval_pexpr env (Expr annots expr_ as expr) =
  if is_irreducible expr then
    Nothing
  else match expr_ with
    (* {A_1} {A_2} E --> {A_1 union A_2} E *)
    | Eannot xs1 (Expr annots2 (Eannot xs2 e)) ->
        Just (TAU "Eannot" env (Expr (annots ++ annots2) (Eannot (combine_dyn_annotation xs1 xs2) e)))
    
    | Ememop memop pes ->
        Just match valueFromPexprs pes with
          | Just cvals ->
              MEMOP memop cvals
          | Nothing ->
              EVAL "Ememop" begin
                E.mapM eval_pexpr pes >>= fun pes' ->
                E.return (Expr annots (Ememop memop pes'))
              end
        end
    
    | Ecase (Pexpr _ () (PEconstrained xs)) _ ->
        error "TODO: Core_reduction.one_step, Ecase PEconstrained"
    | Ecase pe pat_es ->
        Just match valueFromPexpr pe with
          | Just cval ->
              (* TODO: stop using subst? *)
              match select_case subst_sym_expr cval pat_es with
                | Just e' ->
                    TAU "Ecase" env e'
                | Nothing ->
                    ILLTYPED ("Ecase, mismatched ==> " ^ Pp.stringFromCore_expr expr)
              end

          | Nothing ->
              EVAL "Ecase" begin
                eval_pexpr pe >>= fun pe' ->
                E.return (Expr annots (Ecase pe' pat_es))
              end
        end
    | Elet pat pe1 e2 ->
        match valueFromPexpr pe1 with
          | Just cval ->
              (* let pat = v in E2 --> { v / pat } E2 *)
              Just (TAU "Elet" (update_env pat cval env) e2)
          | Nothing ->
              Just begin
                EVAL "Elet" begin
                  eval_pexpr pe1 >>= fun pe1' ->
                  let () = Debug.print_debug 4 [] (fun () ->
                    "Elet ==> " ^ Pp.stringFromCore_pexpr pe1 ^
                    " --> " ^ Pp.stringFromCore_pexpr pe1'
                  ) in
                  E.return (Expr annots (Elet pat pe1' e2))
                end
              end
        end
    
    | Eif pe1 e2 e3 ->
        Just match valueFromPexpr pe1 with
          | Just Vtrue ->
              (* if true the E2 else E3 --> E2 *)
              TAU "Eif (true)" env e2
          | Just Vfalse ->
              (* if false the E2 else E3 --> E3 *)
              TAU "Eif (false)" env e3
          | Just _ ->
              ILLTYPED "the first operand of an Eif didn't evaluated to a boolean"
          | Nothing ->
              EVAL "Eif" begin
                eval_pexpr pe1 >>= fun pe1' ->
                E.return (Expr annots (Eif pe1' e2 e3))
              end
        end
    
    | Eunseq es ->
        (* assert: List.all is_irreducible es *)
        match one_step_unseq_aux ([], []) es with
          | Nothing ->
              Just UNSEQUENCED_RACE
          | Just (fps, cvals) ->
              (* unseq({A_1}?v1, ..., {A_n}?vn) -->
                 {A_1 ...union... A_n}(v1, ..., v2)    (in the absence of race) *)
              Just (TAU "Eunseq" env (Expr annots (Eannot fps (Expr [] (Epure (Pexpr [] () (PEval (Vtuple cvals))))))))
        end
    
    | Ewseq pat (Expr pe1_annots (Epure pe1)) e2 ->
        Just match valueFromPexpr pe1 with
          | Just cval ->
              (* letw pat = v in E2 --> { v / pat } E2 *)
              TAU "Ewseq" (update_env pat cval env) e2
          | Nothing ->
              let mk_wseq z =
                Expr annots (Ewseq pat (Expr pe1_annots (Epure z)) e2) in
              EVAL "Ewseq" (mk_wseq <$> eval_pexpr pe1)
        end
    | Esseq pat (Expr pe1_annots (Epure pe1)) e2 ->
        Just match valueFromPexpr pe1 with
          | Just cval ->
              (* lets pat = v in E2 --> { v / pat } E2 *)
              TAU "Esseq" (update_env pat cval env) e2
          | Nothing ->
              let mk_sseq z =
                Expr annots (Esseq pat (Expr pe1_annots (Epure z)) e2) in
              EVAL "Esseq" (mk_sseq <$> eval_pexpr pe1)
        end
    
    | Ewseq pat (Expr annots1 (Eannot xs (Expr annots2 (Epure pe1)))) e2 ->
        Just match valueFromPexpr pe1 with
          | Just cval ->
              (* letw pat = {A}v in E2 --> {A} { v / pat } E2 *)
              TAU "Ewseq Eannot" (update_env pat cval env) (Expr [] (Eannot xs e2))
          | Nothing ->
              let mk_wseq z =
                Expr annots (Ewseq pat (Expr annots1 (Eannot xs (Expr annots2 (Epure z)))) e2) in
              EVAL "Ewseq Eannot" (mk_wseq <$> eval_pexpr pe1)
        end
    | Esseq pat (Expr annots1 (Eannot xs (Expr annots2 (Epure pe1)))) e2 ->
        Just match valueFromPexpr pe1 with
          | Just cval ->
              (* lets pat = {A}v in E2 --> {A} { v / pat } E2 *)
              TAU "Esseq Eannot" (update_env pat cval env) (Expr [] (Eannot xs e2))
          | Nothing ->
              let mk_sseq z =
                Expr annots (Esseq pat (Expr annots1 (Eannot xs (Expr annots2 (Epure z)))) e2) in
              EVAL "Esseq Eannot" (mk_sseq <$> eval_pexpr pe1)
        end
    
    | Esave sym_bTy sym_bTy_pes e ->
        Just match valueFromPexprs (List.map (fun (_, (_, z)) -> z) sym_bTy_pes) with
          | Just cvals ->
              TAU "Esave"
                begin
                  List.foldl (fun acc ((sym, ((bTy , _) , _)), cval) ->
                    update_env (Caux.mk_sym_pat sym bTy) cval acc
                 ) env (List.zip sym_bTy_pes cvals)
                end
                e
          | Nothing ->
              EVAL "Esave" begin
                E.mapM (fun (sym, (bTy, pe)) ->
                  eval_pexpr pe >>= fun pe' ->
                  E.return (sym, (bTy, pe'))
                ) sym_bTy_pes >>= fun sym_bTy_pes' ->
                E.return (Expr annots (Esave sym_bTy sym_bTy_pes' e))
              end
        end
    | _ ->
        Nothing
  end



let rec stringFromContext ctx =
  match ctx with
    | CTX ->
        "CTX"
    | Cunseq _ _ ctx' _ ->
        "Cunseq[" ^ stringFromContext ctx' ^ "]"
    | Cwseq _ _ ctx' _ ->
        "Cwseq[" ^ stringFromContext ctx' ^ "]"
    | Csseq _ _ ctx' _ ->
        "Csseq[" ^ stringFromContext ctx' ^ "]"
    | Cannot _ _ ctx' ->
        "Cannot[" ^ stringFromContext ctx' ^ "]"
    | Cbound _ ctx' ->
        "Cbound[" ^ stringFromContext ctx' ^ "]"
  end


val     get_ctx: Core.expr core_run_annotation -> list (context * Core.expr core_run_annotation)
let rec get_ctx (Expr annot expr_ as expr) =
  if is_irreducible expr then
    [(CTX, expr)]
  else match expr_ with
    | Epure _ ->
        [(CTX, expr)]
    | Ememop  _ _ ->
        [(CTX, expr)]
    | Eaction _ ->
        [(CTX, expr)]
    | Ecase _ _ ->
        [(CTX, expr)]
    | Elet _ _ _ ->
        [(CTX, expr)]
    | Eif _ _ _ ->
        [(CTX, expr)]
    | Eccall _ _ _ _ ->
        [(CTX, expr)]
    | Eproc _ _ _ ->
        [(CTX, expr)]
    | Eunseq es ->
        if List.all is_irreducible es then
          [(CTX, expr)]
        else
          get_ctx_unseq_aux annot [] [] es
    | Ewseq pat e1 e2 ->
        if is_irreducible e1 then
          [(CTX, expr)]
        else
          List.map (fun (ctx, e) ->
            (Cwseq annot pat ctx e2, e)
          ) (get_ctx e1)
    | Esseq pat e1 e2 ->
        if is_irreducible e1 then
          [(CTX, expr)]
        else
          List.map (fun (ctx, e) ->
            (Csseq annot pat ctx e2, e)
          ) (get_ctx e1)
    | Easeq _ _ _ ->
        error "WIP: [get_ctx] REMOVE Easeq"
    | Ebound _ e ->
        if is_irreducible e then
          [(CTX, expr)]
        else
          List.map (fun (ctx, e) ->
            (Cbound annot ctx, e)
          ) (get_ctx e)
    | End _ ->
        [(CTX, expr)]
    | Esave _ _ _ ->
        [(CTX, expr)]
    | Erun _ _ _ ->
        [(CTX, expr)]
    | Epar _ ->
        [(CTX, expr)]
    | Ewait _ ->
        [(CTX, expr)]
    | Epack _ _ ->
        error "TODO: Epack"
    | Eunpack _ _ ->
        error "TODO: Eunpack"
    | Ehave _ _ ->
        error "TODO: Ehave"
    | Eshow _ _ ->
        error "TODO: Eshow"
    | Eannot _ (Expr _ (Eannot _ e)) ->
        [(CTX, expr)]
    | Eannot xs e ->
        List.map (fun (ctx, e) ->
          (Cannot annot xs ctx, e)
        ) (get_ctx e)
    | Eexcluded _ _ ->
        [(CTX, expr)]
  end

and get_ctx_unseq_aux annot acc es1 = function
  | [] ->
      acc
  | e :: es2 ->
      if is_irreducible e then
        get_ctx_unseq_aux annot acc (es1 ++ [e]) es2
      else
        let zs =
          List.map (fun (ctx, e) ->
            (Cunseq annot es1 ctx es2, e)
          ) (get_ctx e) in
        get_ctx_unseq_aux annot (zs ++ acc) (es1 ++ [e]) es2
(*
  | Eannot xs (Expr annot' (Epure pe)) :: es2 ->
      get_ctx_unseq_aux annot acc (es1 ++ [Eannot xs (Expr annot' (Epure pe))]) es2
  | (Expr annot' (Epure pe)) :: es2 ->
      get_ctx_unseq_aux annot acc (es1 ++ [Expr annot' (Epure pe)]) es2
  | e :: es2 ->
      let zs =
        List.map (fun (ctx, e) ->
          (Cunseq annot es1 ctx es2, e)
        ) (get_ctx e) in
      get_ctx_unseq_aux annot (zs ++ acc) (es1 ++ [e]) es2
*)
end


val     apply_ctx: context -> Core.expr core_run_annotation -> Core.expr core_run_annotation
let rec apply_ctx ctx expr =
  match ctx with
    | CTX ->
        expr
    | Cunseq annot es1 ctx' es2 ->
        Expr annot (Eunseq (es1 ++ (apply_ctx ctx' expr :: es2)))
    | Cwseq annot pat ctx' e2 ->
        Expr annot (Ewseq pat (apply_ctx ctx' expr) e2)
    | Csseq annot pat ctx' e2 ->
        Expr annot (Esseq pat (apply_ctx ctx' expr) e2)
    | Cannot annot xs ctx' ->
        Expr annot (Eannot xs (apply_ctx ctx' expr))
    | Cbound annot ctx' ->
        Expr annot (Ebound 0(*TODO*) (apply_ctx ctx' expr))
  end


type action_request2 'a =
  (* RequestName  of location * sbBefore * ddBefore * aswBefore
                     parameters of request *
                     the new state or a callback *)
  | AllocRequest2 of Symbol.prefix * Mem.integer_value * Mem.integer_value *
                    (Cmm.aid -> Mem.pointer_value -> 'a)
  
  | CreateRequest2 of Symbol.prefix * Mem.integer_value * Ctype.ctype * maybe Mem.mem_value *
                     (Cmm.aid -> Mem.pointer_value -> 'a)
  
  | StoreRequest2 of Cmm.memory_order * Ctype.ctype * (* is_locking *)bool * Mem.pointer_value * Mem.mem_value *
                     (Cmm.aid -> Mem.footprint -> 'a)
  
  | LoadRequest2 of (* the request provide a fresh symbolic name to be used by the concurrency if needed *)
                    Cmm.memory_order * Ctype.ctype * Mem.pointer_value * Symbol.sym *
                   (* the argument of the callback is either a concrete value if the memory model
                      is able to give one right away, or is equal to the symbolic value provided by the
                      present LoadRequest *)
                   (Cmm.aid -> Mem.footprint -> Mem.mem_value -> 'a)
  
  (* TODO: RMW, Fence *)
  | KillRequest2 of (* is_dynamic *)bool * Mem.pointer_value * (Cmm.aid -> 'a)


type runstate_step_kind =
  | RSK_eval
  | RSK_tau

type core_step2 =
  | Step_with_runstate2 of string * core_runM thread_state

  | Step_eval2 of string * core_runM thread_state
  | Step_tau2 of string * Core_run.core_tau_step_kind * thread_state
  | Step_action_request2 of string * Loc.t * (* set Cmm.aid * set Cmm.aid * set Cmm.aid * *)
                            Mem_common.thread_id *
                            action_request2 thread_state
  | Step_blocked2
  | Step_error2 of string
  | Step_thread_done2 of Mem_common.thread_id * Core.value
  | Step_done2 of Core.value
  | Step_memop_request2 of Loc.t * Mem_common.memop * list Core.value * Mem_common.thread_id * (Core.value -> thread_state)



(*
  | Step_memop_request of Mem_common.memop * list Core.value * Mem_common.thread_id * (Core.value -> thread_state)
  | Step_constrained of string * list (Mem.mem_iv_constraint * core_runM thread_state)

  | Step_spawn_threads of (Core.expr core_run_annotation -> thread_state) * list thread_state (* initial states for the children *)
  
  | Step_fs of thread_state * fs_oper
  
  | Step_bound of core_runM thread_state
*)


let act_valueFromPexpr = function
  | Pexpr _ _ (PEconstrained _) ->
      error "Core_reduction.step_action => PEconstrained"
  | z ->
      valueFromPexpr z
end

type action_step =
  | ACTION_REQUEST of string * Loc.t * action_request2 (Core.expr core_run_annotation)
  | ACTION_EVAL of string * core_runM (Core.action core_run_annotation)
  | ACTION_ILLTYPED of string

val step_action: (Core.pexpr -> core_runM Core.pexpr) -> maybe nat -> Core.action core_run_annotation -> action_step
let step_action eval_pexpr is_excluded (Action loc act_annots act) =
  let wrap z =
    Action loc act_annots z in
  match act with
    | Create pe1 pe2 pref ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2) with
          | (Just (Vobject (OVinteger ival)), Just (Vctype ty)) ->
              ACTION_REQUEST
                "CreateRequest"
                loc
                begin
                  CreateRequest2 pref ival ty Nothing (fun aid ptrval ->
                    Expr [] (Epure (Pexpr [] () (PEval (Vobject (OVpointer ptrval)))))
                  )
                end
          | (Just _, Just _) ->
              ACTION_ILLTYPED "Create"
          | (Nothing, _) ->
              ACTION_EVAL "first operand of Create" begin
                eval_pexpr pe1 >>= fun pe1' ->
                E.return (wrap (Create pe1' pe2 pref))
              end
          | (_, Nothing) ->
              ACTION_EVAL "second operand of Create" begin
                eval_pexpr pe2 >>= fun pe2' ->
                E.return (wrap (Create pe1 pe2' pref))
              end
        end
    | CreateReadOnly pe1 pe2 pe3 pref ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2, act_valueFromPexpr pe3) with
          | (Just (Vobject (OVinteger ival)), Just (Vctype ty), Just cval3) ->
              match memValueFromValue (Ctype.Ctype [] (Ctype.unatomic_ ty)) cval3 with
                | Just mval ->
                    ACTION_REQUEST
                      "CreateRequest"
                      loc
                      begin
                        CreateRequest2 pref ival ty (Just mval) (fun aid ptrval ->
                          Expr [] (Epure (Pexpr [] () (PEval (Vobject (OVpointer ptrval)))))
                        )
                      end
                | Nothing ->
                    ACTION_ILLTYPED begin
                      (Loc.stringFromLocation loc) ^ "the value of a create_readonly(" ^
                      Pp.stringFromCore_ctype (Ctype.Ctype [] (Ctype.unatomic_ ty)) ^
                      ") didn't match the lvalue type: " ^ Pp.stringFromCore_value cval3
                    end
              end
          | (Just _, Just _, Just _) ->
              ACTION_ILLTYPED "CreateReadOnly"
          | (Nothing, _, _) ->
              ACTION_EVAL "first operand of CreateReadOnly" begin
                eval_pexpr pe1 >>= fun pe1' ->
                E.return (wrap (CreateReadOnly pe1' pe2 pe3 pref))
              end
          | (_, Nothing, _) ->
              ACTION_EVAL "second operand of CreateReadOnly" begin
                eval_pexpr pe2 >>= fun pe2' ->
                E.return (wrap (CreateReadOnly pe1 pe2' pe3 pref))
              end
          | (_, _, Nothing) ->
              ACTION_EVAL "third operand of CreateReadOnly" begin
                eval_pexpr pe3 >>= fun pe3' ->
                E.return (wrap (CreateReadOnly pe1 pe2 pe3' pref))
              end
        end
    | Store is_locking pe1 pe2 (Pexpr _ () (PEconstrained xs3)) mo ->
        error "WIP: Core_reduction.step_action => Store pe1 pe2 PEconstrained"
    | Store is_locking pe1 pe2 pe3 mo ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2, act_valueFromPexpr pe3) with
          | (Just (Vctype ty), Just (Vobject (OVpointer ptrval)), Just cval) ->
              match memValueFromValue (Ctype.Ctype [] (Ctype.unatomic_ ty)) cval with
                | Just mval ->
                    ACTION_REQUEST
                      "StoreRequest"
                      loc
                      begin
                        StoreRequest2 mo ty is_locking ptrval mval (fun aid fp ->
                          let dyn_annots =
                            match is_excluded with
                              | Nothing ->
                                  [DA_pos [] fp]
                              | Just excl_id ->
                                  [DA_neg excl_id [] fp]
                            end in
                          Expr [] (Eannot dyn_annots (Expr [] (Epure (Pexpr [] () (PEval Vunit)))))
                        )
                      end
                | Nothing ->
                    ACTION_ILLTYPED begin
                      (Loc.stringFromLocation loc) ^ "the value of a store(" ^
                      Pp.stringFromCore_ctype (Ctype.Ctype [] (Ctype.unatomic_ ty)) ^
                      ") didn't match the lvalue type: " ^ Pp.stringFromCore_value cval
                    end
              end
          | (Just _, Just _, Just _) ->
              ACTION_ILLTYPED "Store"
          | (Nothing, _, _) ->
              ACTION_EVAL "first operand of Store" begin
                eval_pexpr pe1 >>= fun pe1' ->
                E.return (wrap (Store is_locking pe1' pe2 pe3 mo))
              end
          | (_, Nothing, _) ->
              ACTION_EVAL "second operand of Store" begin
                eval_pexpr pe2 >>= fun pe2' ->
                E.return (wrap (Store is_locking pe1 pe2' pe3 mo))
              end
          | (_, _, Nothing) ->
              ACTION_EVAL "third operand of Store" begin
                eval_pexpr pe3 >>= fun pe3' ->
                E.return (wrap (Store is_locking pe1 pe2 pe3' mo))
              end
        end
    | Load pe1 pe2 mo ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2) with
          | (Just (Vctype ty), Just (Vobject (OVpointer ptrval)))  ->
              ACTION_REQUEST
                "LoadRequest"
                loc
                begin
                  let val_sym = Symbol.fresh () in
                  LoadRequest2 mo ty ptrval val_sym (fun aid fp mval ->
                    let dyn_annots =
                      match is_excluded with
                        | Nothing ->
                            [DA_pos [] fp]
                        | Just excl_id ->
                            [DA_neg excl_id [] fp]
                      end in
                    let (oTy, cval) = valueFromMemValue mval in
                    Expr [] (Eannot dyn_annots (Expr [] (Epure (Pexpr [] () (PEval cval)))))
                  )
                end
          | (Just _, Just _) ->
              ACTION_ILLTYPED "Load"
          | (Nothing, _) ->
              ACTION_EVAL "first operand of Load" begin
                eval_pexpr pe1 >>= fun pe1' ->
                E.return (wrap (Load pe1' pe2 mo))
              end
          | (_, Nothing) ->
              ACTION_EVAL "second operand of Load" begin
                eval_pexpr pe2 >>= fun pe2' ->
                E.return (wrap (Load pe1 pe2' mo))
              end
        end
    | Alloc pe1 pe2 pref ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2) with
          | (Just (Vobject (OVinteger ival1)), Just (Vobject (OVinteger ival2))) ->
              ACTION_REQUEST
                "AllocRequest"
                loc
                begin
                  AllocRequest2 pref ival1 ival2 (fun aid ptrval ->
                    Expr [] (Epure (Pexpr [] () (PEval (Vobject (OVpointer ptrval)))))
                  )
                end
          | (Just _, Just _) ->
              ACTION_ILLTYPED "Alloc"
          | (Nothing, _) ->
              ACTION_EVAL "first operand of Alloc" begin
                eval_pexpr pe1 >>= fun pe1' ->
                E.return (wrap (Alloc pe1' pe2 pref))
              end
          | (_, Nothing) ->
              ACTION_EVAL "second operand of Alloc" begin
                eval_pexpr pe2 >>= fun pe2' ->
                E.return (wrap (Alloc pe1 pe2' pref))
              end
        end
    | Kill kind pe ->
        match act_valueFromPexpr pe with
          | Just (Vobject (OVpointer ptrval)) ->
              ACTION_REQUEST
                "KillRequest"
                loc
                begin
                  KillRequest2 (is_dynamic kind) ptrval(fun aid ->
                    Expr [] (Epure (Pexpr [] () (PEval Vunit)))
                  )
                end
          | Just _ ->
              ACTION_ILLTYPED "Kill"
          | Nothing ->
              ACTION_EVAL "operand of Kill" begin
                eval_pexpr pe >>= fun pe' ->
                E.return (wrap (Kill kind pe'))
              end
        end
    | RMW _ _ _ _ _ _ ->
        error "TODO[Core_reduction]: RMW"
    | Fence _ ->
        error "TODO[Core_reduction]: Fence"
    | CompareExchangeStrong _ _ _ _ _ _ ->
        error "TODO[Core_reduction]: CompareExchangeStrong"
    | CompareExchangeWeak _ _ _ _ _ _ ->
        error "TODO[Core_reduction]: CompareExchangeWeak"
    | LinuxFence _ ->
        error "TODO[Core_reduction]: LinuxFence"
    | LinuxLoad _ _ _ ->
        error "TODO[Core_reduction]: LinuxLoad"
    | LinuxStore _ _ _ _ ->
        error "TODO[Core_reduction]: LinuxStore"
    | LinuxRMW _ _ _ _ ->
        error "TODO[Core_reduction]: LinuxRMW"
end


val break_at_sseq:
  context -> maybe (context * Core.pattern * context * Core.expr core_run_annotation)
(*
  | CTX
  | Cunseq of list Annot.annot * list (Core.expr core_run_annotation) * context * list (Core.expr core_run_annotation)
  | Cwseq of list Annot.annot * Core.pattern * context * Core.expr core_run_annotation
  | Csseq of list Annot.annot * Core.pattern * context * Core.expr core_run_annotation
  | Cannot of list Annot.annot * Core.dyn_annotation * context
  | Cbound of list Annot.annot * context
*)

let rec break_at_sseq ctx =
  match ctx with
    | CTX ->
        Nothing
    | Cwseq annots pat ctx' e2 ->
        match break_at_sseq ctx' with
          | Nothing ->
              Nothing
          | Just (ctxA, sseq_pat, ctxB, sseq_e2) ->
              Just (Cwseq annots pat ctxA e2, sseq_pat, ctxB, sseq_e2)
        end
    | Csseq annots pat ctx' e2 ->
        match break_at_sseq ctx' with
          | Nothing ->
              Just (CTX, pat, ctx', e2)
          | Just (in_ctxA, in_pat, in_ctxB, in_e2) ->
              Just (Csseq annots pat in_ctxA e2, in_pat, in_ctxB, in_e2)
      end
    | Cunseq annots es1 ctx' es2 ->
        match break_at_sseq ctx' with
          | Nothing ->
              Nothing
          | Just (ctxA, sseq_pat, ctxB, sseq_e2) ->
              Just (Cunseq annots es1 ctxA es2, sseq_pat, ctxB, sseq_e2)
        end
    | Cannot annots xs ctx' ->
        match break_at_sseq ctx' with
          | Nothing ->
              Nothing
          | Just (ctxA, sseq_pat, ctxB, sseq_e2) ->
              Just (Cannot annots xs ctxA, sseq_pat, ctxB, sseq_e2)
        end
    | Cbound annots ctx' ->
        error "break_at_sseq, Cbound"
(*
        match break_at_sseq ctx' with
          | Nothing ->
              Nothing
          | Just (ctxA, sseq_pat, ctxB, sseq_e2) ->
              Just (Cbound annots ctxA, sseq_pat, ctxB, sseq_e2)
        end
*)
  end

type break =
  | NO_BOUND
  | BOUND_NO_SSEQ of context * context
  | BOUND_WITH_SSEQ of context * context * Core.pattern * context * Core.expr core_run_annotation

let rec break_at_bound_and_sseq ctx =
  match ctx with
    | CTX ->
        NO_BOUND
    | Cwseq annots pat ctx' e2 ->
        match break_at_bound_and_sseq ctx' with
          | NO_BOUND ->
              NO_BOUND
          | BOUND_NO_SSEQ ctxA ctxB ->
              BOUND_NO_SSEQ (Cwseq annots pat ctxA e2) ctxB
          | BOUND_WITH_SSEQ ctxA ctxB sseq_pat ctxC e2_sseq ->
              BOUND_WITH_SSEQ (Cwseq annots pat ctxA e2) ctxB sseq_pat ctxC e2_sseq
        end
    | Csseq annots pat ctx' e2 ->
        match break_at_bound_and_sseq ctx' with
          | NO_BOUND ->
              NO_BOUND
          | BOUND_NO_SSEQ ctxA ctxB ->
              BOUND_NO_SSEQ (Csseq annots pat ctxA e2) ctxB
          | BOUND_WITH_SSEQ ctxA ctxB sseq_pat ctxC e2_sseq ->
              BOUND_WITH_SSEQ (Csseq annots pat ctxA e2) ctxB sseq_pat ctxC e2_sseq
      end
    | Cunseq annots es1 ctx' es2 ->
        match break_at_bound_and_sseq ctx' with
          | NO_BOUND ->
              NO_BOUND
          | BOUND_NO_SSEQ ctxA ctxB ->
              BOUND_NO_SSEQ (Cunseq annots es1 ctxA es2) ctxB
          | BOUND_WITH_SSEQ ctxA ctxB sseq_pat ctxC e2_sseq ->
              BOUND_WITH_SSEQ (Cunseq annots es1 ctxA es2) ctxB sseq_pat ctxC e2_sseq
        end
    | Cannot annots xs ctx' ->
        match break_at_bound_and_sseq ctx' with
          | NO_BOUND ->
              NO_BOUND
          | BOUND_NO_SSEQ ctxA ctxB ->
              BOUND_NO_SSEQ (Cannot annots xs ctxA) ctxB
          | BOUND_WITH_SSEQ ctxA ctxB sseq_pat ctxC e2_sseq ->
              BOUND_WITH_SSEQ (Cannot annots xs ctxA) ctxB sseq_pat ctxC e2_sseq
        end
    | Cbound annots ctx' ->
        match break_at_sseq ctx' with
          | Nothing ->
              BOUND_NO_SSEQ (Cbound annots CTX) ctx'
          | Just (ctxA, sseq_pat, ctxB, sseq_e2) ->
              BOUND_WITH_SSEQ (Cbound annots CTX) ctxA sseq_pat ctxB sseq_e2
        end
  end


let rec pull_dyn_annotations z =
  match z with
    | CTX ->
        ([], CTX)
    | Cunseq annots es1 ctx es2 ->
        let (acc, ctx') = pull_dyn_annotations ctx in
        (acc, Cunseq annots es1 ctx' es2)
    | Cwseq annots pat ctx e2 ->
        let (acc, ctx') = pull_dyn_annotations ctx in
        (acc, Cwseq annots pat ctx' e2)
    | Csseq annots pat ctx e2 ->
        let (acc, ctx') = pull_dyn_annotations ctx in
        (acc, Csseq annots pat ctx' e2)
    | Cannot annots xs ctx ->
        let (acc, ctx') = pull_dyn_annotations ctx in
        (xs :: acc, ctx')
    | Cbound annots ctx ->
        let (acc, ctx') = pull_dyn_annotations ctx in
        (acc, Cbound annots ctx')
  end

let rec add_exclusion n = function
  | CTX ->
      CTX
  | Cunseq annots es1 ctx' es2 ->
      Cunseq annots es1 (add_exclusion n ctx') es2
  | Cwseq annots pat ctx' e2 ->
      Cwseq annots pat (add_exclusion n ctx') e2
  | Csseq annots pat ctx' e2 ->
      Csseq annots pat (add_exclusion n ctx') e2
  | Cannot annots xs ctx' ->
      let xs' = List.map (function
        | DA_neg id excl fp ->
            DA_neg id (n::excl) fp
        | DA_pos excl fp ->
            DA_pos (n::excl) fp
      end) xs in
      Cannot annots xs' (add_exclusion n ctx')
  | Cbound annots ctx' ->
      Cbound annots (add_exclusion n ctx')
end
(*
                            let dyn_annots = List.foldl (fun acc xs ->
                              let xs' = List.map (function
                                  | (DA_neg _ _ as z) ->
                                      (* TODO CHECK *)
                                      z
                                  | DA_pos ns fp ->
                                      DA_pos (n::ns) fp
                              end) xs in
                              combine_dyn_annotations xs' acc
                            ) [] xss in
*)



val step_ctx:
  Mem.mem_state -> Core.file core_run_annotation -> map Symbol.sym Symbol.sym ->
  Mem_common.thread_id -> (maybe Mem_common.thread_id * thread_state) ->
  list core_step2
let step_ctx mem_st file core_extern current_tid (parent_tid_opt, th_st) =
  let eval_pexpr pe =
    E.eval_pexpr2 th_st core_extern mem_st file pe >>= function
      | Left pe' ->
          E.return pe'
      | Right cval ->
          E.return (Caux.mk_value_pe cval)
    end in
  let full_eval_pexpr pe =
    full_eval_pexpr th_st core_extern mem_st file pe in
  List.map (function
    | (CTX, Expr e_annots (Epure (Pexpr _ _ (PEval cval)))) ->
        match th_st.stack with
          | Stack_empty ->
              (*error "impossible ==> step_ctx ctx = CTX and stack = Stack_empty"*)
              (* TODO: this indirection is silly... *)
              Step_done2 cval
          | Stack_cons2 _ CTX Stack_empty ->
              (* reached the end of the execution of a thread. *)
              match parent_tid_opt with
                | Just parent_tid ->
                    let () = Debug.print_debug 3 [] (fun () ->
                      "TODO: end of normal thread"
                    ) in
                    Step_thread_done2 parent_tid cval
                | Nothing ->
                    let () = Debug.print_debug 3 [] (fun () ->
                      "TODO: end of startup thread"
                    ) in
                    (* this was the startup thread *)
                    Step_done2 cval
              end
          | Stack_cons2 current_proc_opt CTX (Stack_cons2 parent_proc_opt caller_ctx sk') ->
              let () = Debug.print_debug 3 [] (fun () ->
                "TODO: end of procedure"
              ) in
              (* reached the end of the execution of a procedure. *)
              let tsk =
                match current_proc_opt with
                  | Just psym ->
                      match Map.lookup psym file.funinfo with
                        | Just (_, _, ret_ty, _, _, _) ->
                            Core_run.TSK_Return psym $ Core_aux.memValueFromValue ret_ty cval
                        | Nothing ->
                            Core_run.TSK_Misc
                      end
                  | Nothing ->
                      Core_run.TSK_Misc
                end in
              Step_tau2 "end of procedure" tsk begin
                match th_st.env with
                  | [] ->
                      error "end of proc, found an empty Core_run env"
                  | _ :: env' ->
                      <| th_st with
                        arena= apply_ctx caller_ctx (Expr e_annots (Epure (Caux.mk_value_pe cval)));
                        stack= Stack_cons2 parent_proc_opt CTX sk';
                        env= env' |>
                end
              end
          | _ ->
              Step_tau2 "value in CTX" Core_run.TSK_Misc begin
                <| th_st with arena= (*apply_ctx ctx*) (Expr e_annots (Epure (Caux.mk_value_pe cval))) |>
              end
        end
    
    | (CTX, (Expr _ (Eannot _ (Expr _ (Epure (Pexpr _ _ (PEval _))) as expr')))) ->
        (* {A}v -> v   (in empty context) *)
        Step_tau2 "CTX, Eannot(value)" Core_run.TSK_Misc begin
          <| th_st with arena= expr' |>
        end
    
    | (ctx, expr) ->
        let Expr e_annots expr_ = expr in
        let wrap_expr z = <| th_st with arena= apply_ctx ctx z |> in
        let process_action is_excluded wrap_act z =
          match step_action eval_pexpr is_excluded z with
            | ACTION_REQUEST debug_str loc _request ->
                Step_action_request2 debug_str loc current_tid
                  match _request with
                    | CreateRequest2 pref ival ty mval_opt mk_expr' ->
                        CreateRequest2 pref ival ty mval_opt (fun aid ptrval ->
                          wrap_expr (mk_expr' aid ptrval)
                        )
                    | AllocRequest2 pref ival1 ival2 mk_expr' ->
                        AllocRequest2 pref ival1 ival2 (fun aid ptrval ->
                          wrap_expr (mk_expr' aid ptrval)
                        )
                    | LoadRequest2 mo ty ptrval sym mk_expr' ->
                        LoadRequest2 mo ty ptrval sym (fun aid fp mval ->
                          wrap_expr (mk_expr' aid fp mval)
                        )
                    | StoreRequest2 mk ty is_locking ptrval mval mk_expr' ->
                        StoreRequest2 mk ty is_locking ptrval mval (fun aid fp ->
                          wrap_expr (mk_expr' aid fp)
                        )
                    | KillRequest2 is_dynamic ptrval mk_expr' ->
                        KillRequest2 is_dynamic ptrval (fun aid ->
                          wrap_expr (mk_expr' aid)
                        )
                  end
            | ACTION_EVAL debug_str eval_m ->
                Step_eval2 debug_str begin
                  eval_m >>= fun act' ->
                  E.return (wrap_expr (Expr e_annots (wrap_act act')))
                end
            | ACTION_ILLTYPED str ->
                Step_error2 str
          end in
        match expr_ with
          | Epure (Pexpr _ _ (PEval _)) ->
              error ("Core_run.step_ctx ==> found a value with ctx <> CTX ==> " ^
                     Pp.stringFromCore_expr expr ^ " <--> " ^ stringFromContext ctx)
          
          | Epure pe ->
              (* pe is NOT a value *)
              Step_eval2 "Epure" begin
                eval_pexpr pe >>= fun pe' ->
                  E.return (wrap_expr (Expr e_annots (Epure pe')))
              end
          
          | Ebound _ (Expr _ (Eannot _ (Expr _ (Epure (Pexpr _ _ (PEval _))) as expr'))) ->
              (* bound({A}v)-> v *)
              Step_tau2 "CTX, Ebound Eannot(value)" Core_run.TSK_Misc begin
                wrap_expr expr'
              end
          
          | Ebound _ (Expr _ (Epure (Pexpr _ _ (PEval _))) as expr') ->
              (* bound(v)-> v *)
              Step_tau2 "CTX, Ebound(value)" Core_run.TSK_Misc begin
                wrap_expr expr'
              end
          
          | Eaction (Paction p act) ->
              let Action loc _ _ = act in (* DEBUG *)
              match p with
                | Pos ->
                    process_action Nothing(*not excluded*) (fun z -> Eaction (Paction p z)) act
                | Neg ->
                    match break_at_bound_and_sseq ctx with
                      | NO_BOUND ->
                          error "NO_BOUND"
                      | BOUND_NO_SSEQ ctx_bound ctxA ->
                          (* TODO: using Step_eval2 because we need access to the run state... *)
                          Step_eval2 ("Neg Action, no break ==> " ^ Loc.stringFromLocation loc) begin
                            E.fresh_excluded_id >>= fun n ->
(*
                            let (xss, ctx') = pull_dyn_annotations ctx in
                            let dyn_annots = List.foldl (fun acc xs ->
                              let xs' = List.map (function
                                  | (DA_neg _ _ as z) ->
                                      (* TODO CHECK *)
                                      z
                                  | DA_pos ns fp ->
                                      DA_pos (n::ns) fp
                              end) xs in
                              combine_dyn_annotations xs' acc
                            ) [] xss in
*)
                            let ctxA' = add_exclusion n ctxA in
                            let sym = Symbol.fresh () in
                            let expr' =
(*                              Expr [] (Eannot dyn_annots *)
                                (Expr [] (Ewseq (Caux.mk_tuple_pat [ Caux.mk_empty_pat BTy_unit(*TODO:HACKHACK*)
                                                                   ; Caux.mk_sym_pat sym BTy_unit(*TODO:HACKHACK*) ])
                                                (Caux.mk_unseq_e [ Expr [] (Eexcluded n act)
                                                                 ; apply_ctx ctxA' (Caux.mk_pure_e Caux.mk_unit_pe) ])
                                                (Caux.mk_pure_e (Caux.mk_sym_pe sym)))) (* ) *) in
                            E.return <| th_st with arena= apply_ctx ctx_bound expr' |>
                          end
                      | BOUND_WITH_SSEQ ctx_bound ctxA sseq_pat CTX sseq_e2 ->
                          (* TODO: check *)
                          (* Empty inner context, so no need to pull and annotate for exclusion *)
                          Step_tau2 "Neg Action, CTX" Core_run.TSK_Misc begin
                            <| th_st with arena= apply_ctx ctx_bound
                                                   (apply_ctx ctxA (Expr [] (Esseq sseq_pat (Expr [] (Eaction (Paction Pos act))) sseq_e2))) |>
                          end
                          
                      | BOUND_WITH_SSEQ ctx_bound ctxA sseq_pat ctxB sseq_e2 ->
                          (* TODO: using Step_eval2 because we need access to the run state... *)
                          Step_eval2 ("Neg Action, with break" ^ Loc.stringFromLocation loc) begin
                            E.fresh_excluded_id >>= fun n ->
(*
                            let (xss, ctxB') = pull_dyn_annotations ctxB in
                            let dyn_annots = List.foldl (fun acc xs ->
                              let xs' = List.map (function
                                  | (DA_neg _ _ as z) ->
                                      (* TODO CHECK *)
                                      z
                                  | DA_pos ns fp ->
                                      DA_pos (n::ns) fp
                              end) xs in
                              combine_dyn_annotations xs' acc
                            ) [] xss in
*)
                            let ctxB' = add_exclusion n ctxB in
                            let sym = Symbol.fresh () in
                            let expr' =
(*                              Expr [] (Eannot dyn_annots *)
                                (Expr [] (Esseq (Caux.mk_tuple_pat [ Caux.mk_empty_pat BTy_unit(*TODO:HACKHACK*)
                                                                   ; Caux.mk_sym_pat sym BTy_unit(*TODO:HACKHACK*) ])
                                                (Caux.mk_unseq_e [ Expr [] (Eexcluded n act)
                                                                 ; apply_ctx ctxB' (Caux.mk_pure_e Caux.mk_unit_pe) ])
                                                (*(Caux.mk_pure_e (Caux.mk_sym_pe sym))*) sseq_e2    )) (* ) *) in
                            E.return <| th_st with arena= apply_ctx ctx_bound (apply_ctx ctxA expr') |>
                          end
                    end
              end
          | Eexcluded n act ->
              process_action (Just n)(*excluded*) (fun z -> Eexcluded n z) act
          | Eccall call_annots ty pe pes ->
              Step_eval2 "Eccall" begin
                full_eval_pexpr pe >>= function
                  | Vloaded (LVspecified (OVpointer pv)) ->
                      E.mapM full_eval_pexpr pes >>= fun cvals ->
                      let case_funptrval psym =
                        let mem_values =
                          match Map.lookup psym file.funinfo with
                            | Just (_, _, _, param_tys, _, _) ->
                                List.map (fun (ty, cval) ->
                                  match Core_aux.memValueFromValue (Ctype.Ctype [] (Ctype.Pointer Ctype.no_qualifiers ty)) cval with
                                    | Just mval -> mval
                                    | Nothing -> error "Eccall memvalue"
                                  end) $ List.zip (List.map snd param_tys) cvals
                            | Nothing ->
                                error $ "Eccall : function " ^ show psym ^ " not found"
                          end in
                        SEU.runEU (
                          Exception.bind (Core_run.call_proc core_extern file psym cvals)
                            EU.return
                        ) >>= fun (proc_env, expr) ->
                        E.return <| th_st with
                          arena= expr;
(* KKK                          stack= push_empty_continuation (Just psym) th_st.stack; *)
                          stack= Stack_cons2 (Just psym) CTX (match th_st.stack with Stack_cons2 sym_opt CTX sk' -> Stack_cons2 sym_opt ctx sk' end);
                          exec_loc= push_exec_loc psym th_st.exec_loc;
                          env= proc_env :: th_st.env
                        |>
(*
                      Step_tau "Eccall" (TSK_Ccall psym mem_values) (
                        SEU.runEU (
                          Exception.bind (call_proc core_extern file psym cvals)
                            EU.return
                        ) >>= fun (proc_env, expr) ->
                        (* TODO: HACK here we always annotate the action as being positive, I'm pretty sure this is wrong *)
                        let a_expr = add_to_sb (Set.map (fun z -> (Pos, z)) annots.sb_before) (* TODO: remove for sequential !!! *) expr in

                        E.return <| th_st with
                          arena= a_expr;
                          stack= push_empty_continuation (Just psym) sk;
                          exec_loc= push_exec_loc psym th_st.exec_loc;
                          env= proc_env :: th_st.env
                        |>
                      )
*)
                      in
                      Mem.case_ptrval pv
                        (fun _ -> error "null function pointer")
                        case_funptrval
                      (fun _ addr ->
                        (* TODO: not sure about this case! it happens when calling a function pointer casted to void* via: ((void ( * )(void))p)(); *)
                        match Mem.case_funsym_opt mem_st pv with
                          | Just sym ->
                              case_funptrval sym
                          | None ->
                              error (show addr ^ " does not point to a function (Eccall)")
                        end)
                      (fun _ -> error "function pointer has an unspecified value")




                  | _ ->
                      error "Eccall illtyped first operand"
                end
              end
                
(*
              match valueFromPexpr pe with
                | Just (Vloaded (LVspecified (OVpointer pv))) ->
(*
                    let case_funptrval psym =
                      match valueFromPexprs pes with
                        | Just cvals ->
                            
                        | Nothing ->
                            Step_eval2 "Eccall" begin
                              E.mapM evE.step_eval_pexprs th_st core_extern mem_st file pes >>= fun pes' ->
                        E.return <| th_st with arena= Expr arena_annots (Eccall annots ty pe pes') |>
                            end
                      end in
*)
                    error "WIP: CCALL"
                | Just cval ->
                    Step_error2 begin
                      Loc.stringFromLocation th_st.current_loc ^
                      " the first argument of pcall() must evaluate to a cfunction, found: " ^
                      Pp.stringFromCore_value cval
                    end
                | Nothing ->
                    Step_eval2 "Eccall" begin
                      eval_pexpr pe >>= fun pe' ->
                      E.return (wrap_expr (Expr e_annots (Eccall call_annots ty pe pes)))
                    end
              end
*)
          | Eproc _ _ _ ->
              error "WIP: PROC"
          | End es ->
              error "WIP: ND"
          | Erun run_annots sym pes ->
              let Stack_cons2 (Just current_proc) _ _ = th_st.stack in
              Step_eval2 "Erun" begin
                SEU.read (fun st ->
                  let proc_sym = match Map.lookup current_proc core_extern with
                    | Just proc_sym -> proc_sym
                    | Nothing -> current_proc
                  end in
                  Maybe.bind (Map.lookup proc_sym st.labeled) (Map.lookup sym)
                ) >>= function
                  | Nothing ->
                      error ("Erun couldn't resolve label: `" ^ show sym ^
                             "' for procedure `" ^ show current_proc ^ "'")
                  | Just (syms, cont_expr) ->
                      let cont_expr' = List.foldl (fun acc (sym, pe) ->
                        unsafe_subst_sym_expr sym pe acc
                      ) cont_expr (List.zip syms pes) in
                      E.return <| th_st with
                        arena= cont_expr';
(*                        stack= push_empty_continuation (Just current_proc) sk;*) (* TODO check *)
                     |>
                end
              end
          | Epar es ->
              error "WIP: PAR"
          | Ewait tid ->
              error "WIP: WAIT"
          | _ ->
              match one_step eval_pexpr th_st.env expr with
                | Nothing ->
                    error ("STUCK ==> " ^ Pp.stringFromCore_expr expr)
                | Just (TAU debug_str env' expr') ->
                    Step_tau2 debug_str Core_run.TSK_Misc <| th_st with arena= apply_ctx ctx expr'; env= env' |>
                | Just (EVAL debug_str eval_m) ->
                    Step_eval2 debug_str begin
                      eval_m >>= fun expr' ->
                      E.return (wrap_expr expr')
                    end
                | Just (MEMOP memop cvals) ->
                    Step_memop_request2 th_st.current_loc memop cvals current_tid (fun cval ->
                      wrap_expr (Caux.mk_pure_e (Caux.mk_value_pe cval))
                    )
                | Just UNSEQUENCED_RACE ->
                    (* TODO: loc *)
                    Step_eval2 "unsequenced race" begin
                      E.undef Loc.unknown [Undefined.UB035_unsequenced_race]
                    end
                | Just (ILLTYPED str) ->
                    Step_error2 str
              end
        end
  end) (get_ctx th_st.arena)
