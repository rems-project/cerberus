open import Pervasives

import Core Boot Decode Formatted Set_extra Map
import Core_aux Builtins Core_linking
module Caux = Core_aux

open import Utils Show Errors Trace_event
import Cmm_op Cmm_csem

import Core_eval Core_run Core_reduction


import Translation_aux
import Enum State_exception_undefined Exception Undefined Nondeterminism Dlist


import AilSyntax IntegerType Ctype

import Translation_aux

import Fs

module Mem = struct
  include import Mem Mem_aux Mem_common
end

import Pp
(* import Driver_effect *)

module Cmm = Cmm_csem

(* The indirection is required because of a bug in Lem *)
module U = Undefined


module SEU = State_exception_undefined
module ND  = Nondeterminism


import Global



(* DEBUG *)
val stringFromCore_core_state: forall 'a. Core_run.core_state -> string
declare ocaml target_rep function stringFromCore_core_state = `String_core_run.string_of_core_state`


type driver_error =
  | DErr_core_run of core_run_cause
  | DErr_memory of Mem_common.mem_error
  | DErr_concurrency of string
  | DErr_other of string

type driver_state = <|
  core_file:         Core.file Core_run.core_run_annotation;
  core_extern:       map Symbol.sym Symbol.sym; (* declarations -> definitions *)
  core_state:        Core_run.core_state;       (* state of the core program *)
  core_run_state:    Core_run.core_run_state;   (* state of the core evaluator *)
  layout_state:      Mem.mem_state;         (* state of memory layout model *)
  concurrency_state: Cmm_op.symState;       (* state of the concurrency memmodel *)
  fs_state:          Fs.fs_state;           (* state of the file system *)
  trace:             list trace_event;
  
  symbolic_assoc: map Symbol.sym Core.object_value;
  
  blocked: bool; (* concurrency model ended by blocking *)
  (* DEBUG *)
  (*trace: list string;*)
  dr_step_counter: nat;
|>

let driver_state_eq dr_st1 dr_st2 =
     dr_st1.core_state = dr_st2.core_state
  && dr_st1.layout_state = dr_st2.layout_state
(*  && dr_st1.concurrency_state = dr_st2.concurrency_state *) (* TODO *)

instance (Eq driver_state)
  let (=) = driver_state_eq
  let (<>) = fun x y -> not (driver_state_eq x y)
end

(* NOTE: Used by the UI to distinguish runtime step kinds *)
type step_kind =
  | SK_action_request of string
  | SK_memop_request
  | SK_tau of string
  | SK_eval of string
  | SK_done
  | SK_misc of list string

instance (Show step_kind)
  let show kind =
    match kind with
    | SK_action_request str ->
      "action request: " ^ str
    | SK_memop_request ->
      "memop request"
    | SK_tau str ->
      "tau: " ^ str
    | SK_eval str ->
      "eval: " ^ str
    | SK_done ->
      "done"
    | SK_misc ss ->
      "misc: " ^ String.concat "," ss
    end
end

type driverM 'a = ND.ndM 'a step_kind driver_error Mem.mem_iv_constraint driver_state



(* open ND.Operators *)
let inline (>>=)      = ND.bind
let inline (>>) m1 m2 = ND.bind m1 (fun _ -> m2)


val liftMem: forall 'a. Mem.memM 'a -> driverM 'a
let liftMem m =
  ND.liftND (fun dr_st -> dr_st.layout_state)
    (fun dr_st mem_st -> <| dr_st with layout_state= mem_st |>)
    (fun err_str -> SK_misc ["memory"; err_str])
    (fun mem_err -> DErr_memory mem_err)
    m

val get_thread_states: driverM (list (Mem.thread_id * (maybe Mem.thread_id * Core_run.thread_state)))
let get_thread_states =
  ND.get >>= fun dr_st ->
  ND.return dr_st.core_state.Core_run.thread_states


val     print_eval_conv_aux: driver_state -> Core_run.thread_state -> Core.pexpr -> Mem.memM (either Errors.error (Undefined.t Core.value))
let rec print_eval_conv_aux dr_st th_st pe =
  match Core_eval.eval_pexpr_aux2 (Loc.other "Driver.print_eval_conv_aux") Nothing dr_st.core_extern th_st.Core_run.env (Just dr_st.layout_state) dr_st.core_file pe with
  | Exception.Result (Undefined.Defined (Right cval)) ->
      ND.return (Right (Undefined.Defined cval))
  | Exception.Result (Undefined.Defined (Left (Core.Pexpr _ () (Core.PEconstrained xs)))) ->
      ND.msum "printf_eval_conv" begin
        List.map (fun (cs, pe) ->
            ( "printf_eval_conv_pe_constrained"
            , ND.addConstraints "printf_eval_conv" cs >> print_eval_conv_aux dr_st th_st pe
            )) xs
        end
  | Exception.Result (Undefined.Defined _) ->
      error "print_eval_conv: should be a value or PEconstrained"
  | Exception.Result (Undefined.Undef loc undef) ->
      ND.return (Right (Undefined.Undef loc undef))
  | Exception.Result (Undefined.Error loc err) ->
      ND.return (Right (Undefined.Error loc err))
  | Exception.Exception err ->
      ND.return (Left (Loc.other "Driver.print_eval_conv_aux", Errors.CORE_RUN err))
end

val printf_eval_conv: driver_state -> Core_run.thread_state -> Ctype.ctype -> Mem.mem_value -> Mem.memM (either Errors.error (Undefined.t Core.value))
let printf_eval_conv dr_st th_st cty mval =
  let () = Debug.print_debug 4 [] (fun () -> "printf_eval_conv") in
  let (_, cval) = Core_aux.valueFromMemValue mval in
  print_eval_conv_aux dr_st th_st $
    Translation_aux.mk_stdcall dr_st.core_file.Core.stdlib "conv_loaded_int"
    [ Caux.mk_ctype_pe cty; Core.Pexpr [] () (Core.PEval cval)]


val liftCore_run: forall 'a. Core_run.core_runM 'a -> driverM 'a
let liftCore_run m =
  ND.get >>= fun dr_st ->
  match SEU.run m dr_st.core_run_state with
    | Exception.Result (res, run_st') ->
        ND.update (fun dr_st -> <| dr_st with core_run_state= run_st' |>) >>
        match res with
          | U.Defined z ->
              ND.return z
          | U.Undef loc ubs ->
              ND.kill (ND.Undef loc ubs)
          | U.Error loc str ->
              ND.kill (ND.Error loc str)
        end
    | Exception.Exception err ->
        ND.kill (ND.Other (DErr_core_run err))
  end

val drive_fs_step: Mem.thread_id -> Core_run.thread_state -> driver_state -> Core_run.fs_oper -> driverM unit
let drive_fs_step tid th_st dr_st fs_oper =
  let th_st_from_int n =
    let (Core.Expr arena_annots _) = th_st.Core_run.arena in
    <| th_st with Core_run.arena= Core.Expr arena_annots (Core.Epure (Caux.mk_specified_pe (Caux.mk_integer_pe n))) |>
  in
  let th_st_from_ptr p =
    let (Core.Expr arena_annots _) = th_st.Core_run.arena in
    <| th_st with Core_run.arena= Core.Expr arena_annots (Core.Epure (Caux.mk_specified_pe (Caux.mk_value_pe (Core.Vobject (Core.OVpointer p))))) |>
  in
  let th_st_from_void () =
    let (Core.Expr arena_annots _) = th_st.Core_run.arena in
    <| th_st with Core_run.arena= Core.Expr arena_annots (Core.Epure (Caux.mk_value_pe Core.Vunit)) |>
  in
  let update fs_st th_st =
    ND.update $ fun dr_st ->
      let core_st' = Core_run.update_thread_state tid th_st dr_st.core_state in
      <| dr_st with
        fs_state= fs_st;
        core_state= core_st';
        dr_step_counter= dr_st.dr_step_counter + 1;
      |>
  in
  let store_error e =
    let errname = Fs.fs_string_of_error e in
    let err = Builtins.translate_errno ("__cerbvar_" ^ errname) in
    let err_mval = Mem.integer_value_mval (IntegerType.Signed IntegerType.Int_) (Mem.integer_ival err) in
    liftMem $ Mem.store (Loc.other "update errno") Ctype.signed_int false th_st.Core_run.errno err_mval
  in
  let return (fs_st, res) =
    match res with
      | Left e ->
        store_error e >>
        update fs_st (th_st_from_int (0 - 1))
      | Right n ->
        update fs_st $ th_st_from_int (integerFromNat n)
    end
  in
  let store_buffer ptr (fs_st, res) =
    match res with
      | Left e ->
        store_error e >>
        update fs_st (th_st_from_int (0 - 1))
      | Right buf ->
        let n = integerFromNat $ List.length buf in
        (* TODO: store chars is wrong here!! it adds a \0 in the end of the array *)
        liftMem (Formatted.store_chars_in_array false ptr buf) >>
        update fs_st (th_st_from_int n)
    end
  in
  let store_buffer_trunc ptr max (fs_st, res) =
    match res with
      | Left e ->
        store_error e >>
        update fs_st (th_st_from_int (0 - 1))
      | Right buf ->
        let buf_trunc = List.take (natFromInteger max) buf in
        let n = integerFromNat $ List.length buf_trunc in
        liftMem (Formatted.store_chars_in_array false ptr buf_trunc) >>
        update fs_st (th_st_from_int n)
    end
  in
  let update_stdout out_chars =
    ND.update (fun dr_st ->
      let core_st' = Core_run.update_thread_state tid (th_st_from_int (integerFromNat (List.length out_chars))) dr_st.core_state in
      <| dr_st with
        core_state= <| core_st' with
          Core_run.io= <| dr_st.core_state.Core_run.io with Core_run.stdout=
                Dlist.append (Dlist.singleton (String.toString out_chars)) dr_st.core_state.Core_run.io.Core_run.stdout
              |>
        |>;
        dr_step_counter= dr_st.dr_step_counter + 1;
      |>
    )
  in
  let update_stderr out_chars =
    ND.update (fun dr_st ->
      let core_st' = Core_run.update_thread_state tid (th_st_from_int (integerFromNat (List.length out_chars))) dr_st.core_state in
      <| dr_st with
        core_state= <| core_st' with
          Core_run.io= <| dr_st.core_state.Core_run.io with Core_run.stderr=
                Dlist.append (Dlist.singleton (String.toString out_chars)) dr_st.core_state.Core_run.io.Core_run.stderr
              |>
        |>;
        dr_step_counter= dr_st.dr_step_counter + 1;
      |>
    )
  in
  let struct_sym name =
    let dom = Map.domain dr_st.core_file.Core.tagDefs in
    let res = Set.filter (fun sym ->
      match sym with
      | Symbol.Symbol _ _ (Symbol.SD_Id n) -> n = name
      | _ -> error ("symbol struct " ^ name ^ " not in tagDefs")
      end) dom
    in
    match Set_extra.toList res with
    | [] -> error ("no symbols for struct " ^ name ^ " in tagDefs")
    | [sym] -> sym
    | sym::_ -> sym
    end
  in
  let store_dir (fs_st, res) =
    let sym = struct_sym "dirent" in
    let loc = Loc.other "store struct dirent" in
    let dirent_cty = Ctype.Ctype [] (Ctype.Struct sym) in
    let update_mem dir_name =
      Mem.bind (Mem.allocate_object tid (Symbol.PrefOther "dirent") (Mem.alignof_ival dirent_cty) dirent_cty Nothing Nothing) (fun dirent_ptr ->
        let d_name_ptr = Mem.member_shift_ptrval dirent_ptr sym (Symbol.Identifier loc "d_name") in
        Mem.bind (Formatted.store_chars_in_array true d_name_ptr dir_name) (fun _ ->
          (Mem.return dirent_ptr)))
    in
    match res with
    | Left e ->
      store_error e >>
      update fs_st (th_st_from_ptr (Mem.null_ptrval dirent_cty))
    | Right [] ->
      update fs_st (th_st_from_ptr (Mem.null_ptrval dirent_cty))
    | Right dir_name ->
      liftMem (update_mem dir_name) >>= fun dirent_ptr ->
      update fs_st (th_st_from_ptr dirent_ptr)
    end
  in
  let store_stat stat_ptr (fs_st, res) =
    let sym = struct_sym "stat" in
    let update_mem stat =
      let loc = Loc.other "store struct stat" in
      let store iTy memb f =
        let ptr = Mem.member_shift_ptrval stat_ptr sym (Symbol.Identifier loc memb) in
        let mval = Mem.integer_value_mval iTy (Mem.integer_ival (f stat)) in
        Mem.store loc (Ctype.Ctype [] (Ctype.Basic (Ctype.Integer iTy))) false
                  ptr mval
      in
      let sint = IntegerType.Unsigned IntegerType.Int_ in
      let uint = IntegerType.Signed IntegerType.Int_ in
      let ushort = IntegerType.Unsigned IntegerType.Short in
      let slonglong = IntegerType.Signed IntegerType.LongLong in
      let ulonglong = IntegerType.Unsigned IntegerType.LongLong in
      Mem.bind (store sint "st_dev" Fs.fs_dev) (fun _ ->
      Mem.bind (store ulonglong "st_ino" Fs.fs_ino) (fun _ ->
      Mem.bind (store ushort "st_mode" Fs.fs_mode) (fun _ ->
      Mem.bind (store ushort "st_nlink" Fs.fs_nlink) (fun _ ->
      Mem.bind (store uint "st_uid" Fs.fs_uid) (fun _ ->
      Mem.bind (store uint "st_gid" Fs.fs_gid) (fun _ ->
      Mem.bind (store sint "st_rdev" Fs.fs_rdev) (fun _ ->
               (store slonglong "st_size" Fs.fs_size) )))))))
    in
    match res with
    | Left e ->
      store_error e >>
      update fs_st (th_st_from_int (0 - 1))
    | Right stat ->
      liftMem (update_mem stat) >>
      update fs_st (th_st_from_int 0)
    end
  in
  match fs_oper with
    | Core_run.FS_MKDIR path mode ->
      return $ Fs.fs_mkdir dr_st.fs_state path mode
    | Core_run.FS_OPEN path oflag mode_opt ->
      return $ Fs.fs_open dr_st.fs_state path oflag mode_opt
    | Core_run.FS_CLOSE fd ->
      return $ Fs.fs_close dr_st.fs_state fd
    | Core_run.FS_WRITE fd buf size ->
      match natFromInteger fd with
      | 0 ->
        error "driver_fs_step: stdin not supported yet."
      | 1 ->
        update_stdout (List.take (natFromInteger size) buf)
      | 2 ->
        update_stderr (List.take (natFromInteger size) buf)
      | _ ->
        return $ Fs.fs_write dr_st.fs_state fd buf size
      end
    | Core_run.FS_READ fd ptr size ->
      store_buffer ptr $ Fs.fs_read dr_st.fs_state fd size
    | Core_run.FS_PWRITE fd buf size off ->
      return $ Fs.fs_pwrite dr_st.fs_state fd buf size off
    | Core_run.FS_PREAD fd ptr size off ->
      store_buffer ptr $ Fs.fs_pread dr_st.fs_state fd size off
    | Core_run.FS_UMASK mode ->
      return $ Fs.fs_umask dr_st.fs_state mode
    | Core_run.FS_CHMOD path mode ->
      return $ Fs.fs_chmod dr_st.fs_state path mode
    | Core_run.FS_CHDIR path ->
      return $ Fs.fs_chdir dr_st.fs_state path
    | Core_run.FS_CHOWN path uid gid ->
      return $ Fs.fs_chown dr_st.fs_state path uid gid
    | Core_run.FS_LINK oldpath newpath ->
      return $ Fs.fs_link dr_st.fs_state oldpath newpath
    | Core_run.FS_READLINK path ptr max ->
      store_buffer_trunc ptr max $ Fs.fs_readlink dr_st.fs_state path
    | Core_run.FS_STAT path ptr ->
      store_stat ptr $ Fs.fs_stat dr_st.fs_state path
    | Core_run.FS_LSTAT path ptr ->
      store_stat ptr $ Fs.fs_lstat dr_st.fs_state path
    | Core_run.FS_SYMLINK target lpath ->
      return $ Fs.fs_symlink dr_st.fs_state target lpath
    | Core_run.FS_RMDIR path ->
      return $ Fs.fs_rmdir dr_st.fs_state path
    | Core_run.FS_TRUNCATE path len ->
      return $ Fs.fs_truncate dr_st.fs_state path len
    | Core_run.FS_UNLINK path ->
      return $ Fs.fs_unlink dr_st.fs_state path
    | Core_run.FS_LSEEK fd off whence ->
      return $ Fs.fs_lseek dr_st.fs_state fd off whence
    | Core_run.FS_RENAME oldpath newpath ->
      return $ Fs.fs_rename dr_st.fs_state oldpath newpath
    | Core_run.FS_OPENDIR path ->
      return $ Fs.fs_opendir dr_st.fs_state path
    | Core_run.FS_READDIR dir ->
      store_dir $ Fs.fs_readdir dr_st.fs_state dir
    | Core_run.FS_REWINDDIR dir ->
      update (Fs.fs_rewinddir dr_st.fs_state dir) (th_st_from_void ())
    | Core_run.FS_CLOSEDIR dir ->
      return $ Fs.fs_closedir dr_st.fs_state dir
    | Core_run.FS_PRINTF fmt args ->
      liftMem (Formatted.printf th_st.Core_run.current_loc (printf_eval_conv dr_st th_st) fmt args) >>= function
        | Left err ->
          error "TODO: printf error"
        | Right (Undefined.Defined buf) ->
          update_stdout buf
        | Right (Undefined.Error loc str) ->
          ND.kill (ND.Error loc str)
        | Right (Undefined.Undef loc ubs) ->
          ND.kill (ND.Undef loc ubs)
      end
    | Core_run.FS_VPRINTF fd fmt ap ->
      liftMem (Formatted.vprintf th_st.Core_run.current_loc (printf_eval_conv dr_st th_st) fmt ap) >>= function
        | Left err ->
          error "TODO: vprintf error"
        | Right (Undefined.Defined buf) ->
          let size = integerFromNat $ List.length buf in
          match natFromInteger fd with
          | 0 ->
            error "vprintf trying to output in the stdin"
          | 1 ->
            update_stdout buf
          | 2 ->
            update_stderr buf
          | _ ->
            return $ Fs.fs_write dr_st.fs_state fd buf size
          end
        | Right (Undefined.Error loc str) ->
          ND.kill (ND.Error loc str)
        | Right (Undefined.Undef loc ubs) ->
          ND.kill (ND.Undef loc ubs)
      end
    | Core_run.FS_VSNPRINTF ptr size fmt ap ->
      liftMem (Formatted.vsnprintf th_st.Core_run.current_loc (printf_eval_conv dr_st th_st) ptr size fmt ap) >>= function
        | Left err ->
          error "TODO: vprintf error"
        | Right (Undefined.Defined n) ->
          update dr_st.fs_state $ th_st_from_int n
        | Right (Undefined.Error loc str) ->
          ND.kill (ND.Error loc str)
        | Right (Undefined.Undef loc ubs) ->
          ND.kill (ND.Undef loc ubs)
      end
  end




(*
val     drive_core_thread2: Mem.thread_id -> driverM (maybe Core_reduction.core_step2)
let rec drive_core_thread2 tid =
  ND.get >>= fun dr_st ->
  let th_info = match List.lookup tid dr_st.core_state.Core_run.thread_states with
    | Just z ->
        z (* (tid, z) *)
    | _ ->
        error "drive_core_thread, wrong tid"
  end in
  ND.mk_step (SK_misc ["drive_core_thread2"]) $ List.map (function
    | Core_reduction.Step_thread_done2 parent_tid cval ->
        ( SK_misc ["thread_done("^ show tid ^")"]
        , (* DEBUG *) ND.print_debug 6 [Debug.DB_driver_step] (fun () ->
            "thread " ^ show tid ^ " is done"
          ) >>= fun () ->
          let actions_of_current_thread: set Cmm.action =
            Set.filter (fun act ->
              Cmm.tid_of act = tid
            ) $ dr_st.concurrency_state.Cmm_op.symPre.Cmm.actions in
          let last_actions_of_current_thread: set Cmm.action =
            Set.filter (fun act ->
              not (Set.any (fun (act', _) ->
                act = act'
              ) dr_st.concurrency_state.Cmm_op.symPre.Cmm.sb)
            ) actions_of_current_thread in
          ND.update (fun dr_st -> <| dr_st with
            core_state= Core_run.kill_thread tid parent_tid (Set.map Cmm.aid_of last_actions_of_current_thread) cval dr_st.core_state;
            dr_step_counter= dr_st.dr_step_counter + 1;
          |>) >>= fun () ->
          drive_core_thread2 parent_tid )
    | (Core_reduction.Step_blocked2 as step) ->
        (SK_misc ["blocked("^show tid^")"], ND.return (Just step))
    | Core_reduction.Step_done2 cval ->
        ( SK_done, ND.return Nothing )
(*
        ( SK_done
        , get_thread_states >>= fun th_sts ->
          let th_st = match lookup tid th_sts with
            | Just (_, th_st) -> th_st
            | Nothing -> error "WIP: Step_done2"
          end in
          ND.update (fun dr_st ->
            let core_st' = Core_run.update_thread_state tid
              <| Core_run_aux.arena= Core.Expr [] (Core.Epure (Core_aux.mk_value_pe cval));
                 Core_run_aux.stack= Core_run.Stack_empty;
                 Core_run_aux.errno= Mem.null_ptrval Ctype.signed_int;
                 Core_run_aux.env= th_st.Core_run_aux.env;
                (* Dummy locations *)
                 Core_run_aux.exec_loc= Core_run_aux.ELoc_globals;
                 Core_run_aux.current_loc= Loc.unknown;
              |> dr_st.core_state
            in
            <| dr_st with
              core_state= core_st';
              dr_step_counter= dr_st.dr_step_counter + 1;
            |>) >>= fun () ->
          ND.return Nothing)
*)
    
    | Core_reduction.Step_with_runstate2 rsk step_m ->
        match rsk with
          | Core_reduction.RSK_eval debug_str ->
              ( SK_eval debug_str
              , let () = Debug.print_debug 3 [] (fun () -> "Step_eval(" ^ debug_str ^ ")") in
                liftCore_run step_m >>= fun th_st' ->
                ND.update (fun dr_st -> <| dr_st with
                  core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
                  dr_step_counter= dr_st.dr_step_counter + 1
                |>) >>= fun () ->
                drive_core_thread2 tid )
          | Core_reduction.RSK_tau debug_str tsk ->
              ( SK_tau debug_str
              , let () = Debug.print_debug 3 [] (fun () -> "Step_tau(" ^ debug_str ^ ")") in
                liftCore_run step_m >>= fun th_st' ->
                match tsk with
                  | Core_run.TSK_Misc ->
                      ND.return ()
                  | Core_run.TSK_Return sym mval_opt ->
                      ND.update $ fun dr_st ->
                        <| dr_st with trace= ME_function_return sym mval_opt :: dr_st.trace |>
                  | _ ->
                      error "TODO: drive_core_thread2, non TSK_Misc"
                end >>= fun () ->
                begin
                  (* DEBUG *) ND.print_debug 4 [Debug.DB_driver_step] (fun () -> "tau(tid_" ^ show tid ^ "): " ^ debug_str ^ " with arena= " ^
                  (* DEBUG *)                   Pp.stringFromCore_expr th_st'.Core_run.arena)
                end >>= fun () ->
                ND.update (fun dr_st -> <| dr_st with
                  core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
                  dr_step_counter= dr_st.dr_step_counter + 1
                |>) >>= fun () ->
                drive_core_thread2 tid )
        end
    
    | Core_reduction.Step_tau2 debug_str tsk th_st' ->
        ( SK_tau debug_str
        , let () = Debug.print_debug 3 [] (fun () -> "Step_tau(" ^ debug_str ^ ")") in
          match tsk with
            | Core_run.TSK_Misc ->
                ND.return ()
            | Core_run.TSK_Return sym mval_opt ->
                ND.update $ fun dr_st ->
                <| dr_st with
                  trace= ME_function_return sym mval_opt :: dr_st.trace
                |>
            | _ ->
                error "TODO: drive_core_thread2, non TSK_Misc"
          end >>= fun () ->
          
          begin
            (* DEBUG *) ND.print_debug 4 [Debug.DB_driver_step] (fun () -> "tau(tid_" ^ show tid ^ "): " ^ debug_str ^ " with arena= " ^
            (* DEBUG *)                   Pp.stringFromCore_expr th_st'.Core_run.arena)
          end >>= fun () ->
          
          ND.update (fun dr_st -> <| dr_st with
            core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
            dr_step_counter= dr_st.dr_step_counter + 1
          |>) >>= fun () ->
          drive_core_thread2 tid )
    
    | Core_reduction.Step_spawn_threads2 mk_parent_th_st spawn_th_sts ->
        ( SK_misc ["spawn_threads("^show tid^")"]
          , let ((spawn_tids, core_st'), run_st') = State.runStateM (
              State.foldlM (fun (th_tids_, core_st_) th_st ->
                State.bind (Core_run.spawn_thread (Just tid) th_st core_st_)
                  (fun (tid, core_st_') -> State.return (tid :: th_tids_, core_st_'))
              ) ([], dr_st.core_state) spawn_th_sts
            ) dr_st.core_run_state in
            ND.update (fun dr_st -> <| dr_st with
              core_run_state= run_st';
              core_state= Core_run.update_thread_state tid
                            (mk_parent_th_st spawn_tids)
                            core_st';
            |>) >>= fun () ->
            ND.mapM_ drive_core_thread2 spawn_tids >>= fun () ->
            drive_core_thread2 tid )

    | Core_reduction.Step_fs2 tid th_st m_fs_step ->
        (* TODO: can m_fs_step change the thread state?, If so this is wrong *)
        ( SK_misc ["fs_step"]
        , liftCore_run m_fs_step                >>= fun fs_step ->
          drive_fs_step tid th_st dr_st fs_step >>= fun () ->
          drive_core_thread2 tid )

    | (Core_reduction.Step_nd2 th_sts) ->
        ( SK_misc ["nd"]
        , ND.pick (SK_misc ["nd"]) th_sts >>= fun th_st' ->
          ND.update (fun dr_st -> <| dr_st with
            core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
            dr_step_counter= dr_st.dr_step_counter + 1
          |>) >>= fun () ->
          drive_core_thread2 tid )

    | Core_reduction.Step_error2 debug_str ->
        error ("WIP: Step_error --> " ^ debug_str)
    | (Core_reduction.Step_action_request2 str _ _ _ _ as step) ->
        ( SK_action_request str
        , ND.return (Just step) )
    | (Core_reduction.Step_memop_request2 _ _ _ _ _ _ as step) -> 
        ( SK_memop_request
        , ND.return (Just step) )
  end) (Core_reduction.step_ctx dr_st.layout_state dr_st.core_file dr_st.core_extern tid th_info)
*)

















(* 
(* perform drive_core_thread for all the core threads *)
val drive_core_threads: unit -> driverM (list (Mem.thread_id * maybe Core_reduction.core_step2))
let drive_core_threads () =
  ND.get >>= fun dr_st ->
  ND.mapM (fun (tid, _) ->
    ND.print_debug 9 [Debug.DB_driver] (fun () ->
      "BEFORE drive_core_thread, in drive_core_threads"
    ) >>= fun () ->
    drive_core_thread2 tid >>= fun step ->
    ND.return (tid, step)
  ) dr_st.core_state.Core_run.thread_states *)












val update_core_state: Core_run.core_state -> driver_state -> driver_state
let update_core_state core_st dr_st =
  <| dr_st with core_state= core_st |>


(* POST REDUCTION SEMANTICS *)
val action_request_sequential2:
  Loc.t -> Mem.thread_id -> Cmm.aid -> Core_reduction.action_request2 Core_run.thread_state -> driverM unit
let action_request_sequential2 loc tid aid = function
  | Core_reduction.AllocRequest2 pref align_ival size_ival mk_th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST ALLOC") in (* DEBUG *)
      liftMem (Mem.allocate_region tid pref align_ival size_ival) >>= fun ptrval ->
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid (mk_th_st' aid ptrval) dr_st.core_state;
          trace= ME_allocate_region tid pref align_ival size_ival ptrval :: dr_st.trace
        |>
      )
  
  | Core_reduction.CreateRequest2 pref align_ival lvalue_ty req_addr_opt init_opt mk_th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST CREATE") in (* DEBUG *)
      liftMem (Mem.allocate_object tid pref align_ival lvalue_ty req_addr_opt init_opt) >>= fun ptrval ->
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid (mk_th_st' aid ptrval) dr_st.core_state;
          trace= ME_allocate_object tid pref align_ival lvalue_ty init_opt ptrval :: dr_st.trace
        |>
      )
  
  | Core_reduction.LoadRequest2 mo lvalue_ty ptr_val mk_th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST LOAD") in (* DEBUG *)
      liftMem (Mem.load loc lvalue_ty ptr_val) >>= fun (fp, mval) ->
      liftMem (Mem.prefix_of_pointer ptr_val)  >>= fun pref       ->
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid (mk_th_st' aid fp mval) dr_st.core_state;
          trace= ME_load loc pref lvalue_ty ptr_val mval :: dr_st.trace
        |>
      )
  
  | Core_reduction.StoreRequest2 mo lvalue_ty is_locking ptr_val mem_val mk_th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST STORE") in (* DEBUG *)
      (* TODO: need to make memory layout detect unsequenced races (use to make
         the concurency to the check even in the sequential mode) *)
      liftMem (Mem.store loc lvalue_ty is_locking ptr_val mem_val) >>= fun fp ->
      liftMem (Mem.prefix_of_pointer ptr_val) >>= fun pref ->
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid (mk_th_st' aid fp) dr_st.core_state;
          trace= ME_store loc pref lvalue_ty is_locking ptr_val mem_val :: dr_st.trace
        |>
      )
  
  | Core_reduction.SeqRMWRequest2 lvalue_ty ptr_val mk_mval' mk_th_st' ->
      liftMem (Mem.load loc lvalue_ty ptr_val)              >>= fun (_, mval) ->
      liftCore_run (mk_mval' mval)                          >>= fun mval'     ->
      liftMem (Mem.store loc lvalue_ty false ptr_val mval') >>= fun fp        ->
      liftMem (Mem.prefix_of_pointer ptr_val)               >>= fun pref      ->
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid (mk_th_st' aid fp mval mval') dr_st.core_state;
          trace= ME_seq_rmw loc pref lvalue_ty ptr_val mval mval' :: dr_st.trace
        |>
      )
  
(*
  | Core_run.RMWRequest loc sb_edges dd_edges asw_edges aid tid mo1 mo2 lvalue_ty ptr_val mval_expected mval_actual th_st' ->
      error "WIP: Driver.seq ==> RMWRequest"
  
  | Core_run.FenceRequest loc sb_edges dd_edges asw_edges aid tid mo th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST FENCE") in (* DEBUG *)
      ND.update (fun dr_st ->
        update_core_state (Core_run.update_thread_state tid th_st' dr_st.core_state) dr_st
      )
*)
  
  | Core_reduction.KillRequest2 is_dynamic ptr_val mk_th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST KILL") in (* DEBUG *)
      liftMem (Mem.kill loc is_dynamic ptr_val) >>
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid (mk_th_st' aid) dr_st.core_state;
          trace= ME_kill loc is_dynamic ptr_val :: dr_st.trace
        |>
      )
end


val perform_action_request2:
  bool -> Loc.t -> Mem.thread_id -> Core_reduction.action_request2 Core_run.thread_state -> driverM unit
let perform_action_request2 with_concurrency loc tid request =
  let _execution_mode_is_random = match Global.current_execution_mode () with
    | Nothing   -> false
    | Just mode -> mode = Global.Random
  end in
  
  begin
    if with_concurrency then
      error "TODO: perform_action_request2 ==> concurrency"
    else
      liftCore_run (SEU.runS Core_run.fresh_action_id') >>= fun aid ->
      action_request_sequential2 loc tid aid request
  end

val perform_memop_request2: Loc.t -> Mem_common.memop -> list Core.value -> Mem.thread_id -> (Core.value -> Core_run.thread_state) -> driverM unit
let perform_memop_request2 loc memop cvals tid mk_th_st =
  match (memop, cvals) with
    | (Mem_common.Ptrdiff, [Core.Vctype ty; Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
        liftMem (Mem.diff_ptrval loc ty ptr_val1 ptr_val2) >>= fun ival ->
        ND.return (mk_th_st (Core.Vobject (Core.OVinteger ival)))
    
    | (Mem_common.IntFromPtr, [Core.Vctype ref_ty; Core.Vctype (Ctype.Ctype _ (Ctype.Basic (Ctype.Integer ity))); Core.Vobject (Core.OVpointer ptr_val)]) ->
        liftMem (Mem.intfromptr loc ref_ty ity ptr_val) >>= fun ival ->
        ND.return (mk_th_st (Core.Vobject (Core.OVinteger ival)))
    
    | (Mem_common.PtrFromInt, [Core.Vctype (Ctype.Ctype _ (Ctype.Basic (Ctype.Integer ity))); Core.Vctype ref_ty; Core.Vobject (Core.OVinteger ival)]) ->
        liftMem (Mem.ptrfromint loc ity ref_ty ival) >>= fun ptrval ->
        ND.return (mk_th_st (Core.Vobject (Core.OVpointer ptrval)))
    
    | (Mem_common.PtrValidForDeref, [Core.Vctype ref_ty; Core.Vobject (Core.OVpointer ptr_val)]) ->
        liftMem (Mem.validForDeref_ptrval ref_ty ptr_val) >>= fun is_valid ->
        ND.return (mk_th_st (if is_valid then Core.Vtrue else Core.Vfalse))
    
    | (Mem_common.PtrEq, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
        ND.print_debug 2 [Debug.DB_driver] (fun () -> "PtrEq") >> (* DEBUG *)
        liftMem (Mem.eq_ptrval loc ptr_val1 ptr_val2) >>= fun is_eq ->
        ND.return (mk_th_st (if is_eq then Core.Vtrue else Core.Vfalse))
    
    | (Mem_common.PtrNe, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
        liftMem (Mem.ne_ptrval loc ptr_val1 ptr_val2) >>= fun is_ne ->
        ND.return (mk_th_st (if is_ne then Core.Vtrue else Core.Vfalse))
    
    | (Mem_common.PtrLt, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
        liftMem (Mem.lt_ptrval loc ptr_val1 ptr_val2) >>= fun is_lt ->
        ND.return (mk_th_st (if is_lt then Core.Vtrue else Core.Vfalse))
    
    | (Mem_common.PtrGt, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
        liftMem (Mem.gt_ptrval loc ptr_val1 ptr_val2) >>= fun is_gt ->
        ND.return (mk_th_st (if is_gt then Core.Vtrue else Core.Vfalse))
    
    | (Mem_common.PtrLe, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
        liftMem (Mem.le_ptrval loc ptr_val1 ptr_val2) >>= fun is_le ->
        ND.return (mk_th_st (if is_le then Core.Vtrue else Core.Vfalse))
    
    | (Mem_common.PtrGe, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
        liftMem (Mem.ge_ptrval loc ptr_val1 ptr_val2) >>= fun is_ge ->
        ND.return (mk_th_st (if is_ge then Core.Vtrue else Core.Vfalse))
    
    | (Mem_common.Memcpy, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2);
                          Core.Vobject (Core.OVinteger size_ival)]) ->
        liftMem (Mem.memcpy loc ptr_val1 ptr_val2 size_ival) >>= fun res ->
        ND.return (mk_th_st (Core.Vobject (Core.OVpointer res)))
    
    | (Mem_common.Memcmp, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2);
                          Core.Vobject (Core.OVinteger size_ival)]) ->
        liftMem (Mem.memcmp ptr_val1 ptr_val2 size_ival) >>= fun res ->
        ND.return (mk_th_st (Core.Vobject (Core.OVinteger res)))
    
    | (Mem_common.PtrWellAligned, [Core.Vctype ref_ty; Core.Vobject (Core.OVpointer ptrval)]) ->
        liftMem (Mem.isWellAligned_ptrval ref_ty ptrval) >>= fun b ->
        ND.return (mk_th_st (if b then Core.Vtrue else Core.Vfalse))
    
    | (Mem_common.Realloc, [Core.Vobject (Core.OVinteger align_ival); Core.Vobject (Core.OVpointer old_ptr);
                          Core.Vobject (Core.OVinteger size_ival)]) ->
        liftMem (Mem.realloc loc tid align_ival old_ptr size_ival) >>= fun res ->
        ND.return (mk_th_st (Core.Vobject (Core.OVpointer res)))

    | (Mem_common.PtrArrayShift, [Core.Vobject (Core.OVpointer ptrval); Core.Vctype ty; Core.Vobject (Core.OVinteger n_ival)]) ->
        liftMem (Mem.eff_array_shift_ptrval loc ptrval ty n_ival) >>= fun res ->
        ND.update (fun dr_st ->
          <| dr_st with
            trace= ME_eff_array_shift_ptrval ptrval ty n_ival res :: dr_st.trace
          |>
        ) >>
        ND.return (mk_th_st (Core.Vobject (Core.OVpointer res)))

    | (Mem_common.PtrMemberShift tag_sym membr_ident, [Core.Vobject (Core.OVpointer ptrval)]) ->
        liftMem (Mem.eff_member_shift_ptrval loc ptrval tag_sym membr_ident) >>= fun res ->
        ND.update (fun dr_st ->
          <| dr_st with
            trace= ME_eff_member_shift_ptrval tag_sym membr_ident ptrval res :: dr_st.trace
          |>
        ) >>
        ND.return (mk_th_st (Core.Vobject (Core.OVpointer res)))

    | (Mem_common.Va_start, [Core.Vlist _ ty_cvals]) ->
        let ty_ptrs =
          List.map (function
            | Core.Vtuple [Core.Vctype ty; Core.Vobject (Core.OVpointer ptr)] -> (ty, ptr)
            | _ -> error "va_start"
          end) ty_cvals in
        liftMem (Mem.va_start ty_ptrs) >>= fun res ->
        ND.return (mk_th_st (Core.Vobject (Core.OVinteger res)))

    | (Mem_common.Va_copy, [Core.Vobject (Core.OVinteger va)]) ->
        liftMem (Mem.va_copy va) >>= fun res ->
        ND.return (mk_th_st (Core.Vobject (Core.OVinteger res)))

    | (Mem_common.Va_arg, [Core.Vobject (Core.OVinteger va); Core.Vctype ty]) ->
        liftMem (Mem.va_arg va ty) >>= fun res ->
        ND.return (mk_th_st (Core.Vobject (Core.OVpointer res)))

    | (Mem_common.Va_end, [Core.Vobject (Core.OVinteger va)]) ->
        liftMem (Mem.va_end va) >>
        ND.return (mk_th_st Core.Vunit)

    | (Mem_common.Copy_alloc_id, [Core.Vobject (Core.OVinteger ival); Core.Vobject (Core.OVpointer ptrval)]) ->
        liftMem (Mem.copy_alloc_id ival ptrval) >>= fun ptrval' ->
        ND.return (mk_th_st (Core.Vobject (Core.OVpointer ptrval')))

    | (Mem_common.CHERI_intrinsic str (ret_ty, tys), cvals) ->
        let mvals =
          Utils.map2 (fun ty cval ->
            fromJust "CHERI_intrinsic call" (Caux.memValueFromValue ty cval)
          ) tys cvals in
        liftMem (Mem.call_intrinsic loc str mvals) >>= fun res_opt ->
        match res_opt with
          | Just res ->
              ND.return (mk_th_st (Core.Vloaded (snd (Caux.loadedValueFromMemValue res))))
          | Nothing ->
            ND.return (mk_th_st Core.Vunit)
        end

    | _ ->
        error ("INVALID memop request: " ^ show memop ^ " ==> " ^ Pp.stringFromCore_value (Core.Vtuple cvals) )
  end >>= fun th_st' ->
  ND.update (fun dr_st ->
    update_core_state (Core_run.update_thread_state tid th_st' dr_st.core_state) dr_st
  )
















let can_advance = function
  | Core_reduction.Step_ccall2 _ _ ->
      false
  | Core_reduction.Step_with_runstate2 _ _ ->
      true
  | Core_reduction.Step_tau2 _ _ _ ->
      true
  | Core_reduction.Step_action_request2 _ _ _ is_unseq_with_ccall _ ->
      (* TODO: only correct if there is only ONE thread *)
      not is_unseq_with_ccall (* false *)
  | Core_reduction.Step_blocked2 ->
      false
  | Core_reduction.Step_error2 _ ->
      error "can_advance: Step_error2"
  | Core_reduction.Step_thread_done2 _ _ ->
      true
  | Core_reduction.Step_done2 _ ->
      false
  | Core_reduction.Step_memop_request2 _ _ _ _ is_unseq_with_ccall _ ->
      (* TODO: only correct if there is only ONE thread *)
      not is_unseq_with_ccall (* false *)
  | Core_reduction.Step_spawn_threads2 _ _ ->
      true
  | Core_reduction.Step_fs2 _ _ _ ->
      false
  | Core_reduction.Step_nd2 _ ->
      true
end

type advance_info =
  | NOWAKEUP
  | WAKEUP of bool * list Mem.thread_id 

let advance_step tid step =
  match step with
    | Core_reduction.Step_ccall2 _ _ ->
        ND.return NOWAKEUP
    | Core_reduction.Step_with_runstate2 rsk step_m ->
        match rsk with
          | Core_reduction.RSK_tau _ (Core_run.TSK_Return sym mval_opt) ->
              ND.update (fun dr_st ->
                <| dr_st with trace= ME_function_return sym mval_opt :: dr_st.trace |>
              )
          | _ ->
              ND.return ()
        end >>= fun () ->
        liftCore_run step_m >>= fun th_st' ->
        ND.update (fun dr_st -> <| dr_st with
          core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
          dr_step_counter= dr_st.dr_step_counter + 1
        |>) >>= fun () ->
        ND.return NOWAKEUP

    | Core_reduction.Step_tau2 debug_str tsk th_st' ->
        match tsk with
          | Core_run.TSK_Return sym mval_opt ->
              ND.update (fun dr_st ->
                <| dr_st with trace= ME_function_return sym mval_opt :: dr_st.trace |>
              )
          | _ ->
              ND.return ()
        end >>= fun () ->          
        ND.update (fun dr_st -> <| dr_st with
          core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
          dr_step_counter= dr_st.dr_step_counter + 1
        |>) >>= fun () ->
        ND.return NOWAKEUP

    | Core_reduction.Step_action_request2 _ loc tid is_unseq_with_ccall m_request ->
        begin if is_unseq_with_ccall then
          ND.return ()
        else
          liftCore_run m_request >>= fun request ->
          perform_action_request2 false (*TODO!!! with_concurrency*) loc tid request
        end >>= fun () ->
        ND.return NOWAKEUP

    | Core_reduction.Step_blocked2 ->
        ND.return NOWAKEUP

    | Core_reduction.Step_error2 debug_str ->
        error ("Driver.advance_step => Step_error2: " ^ debug_str)

    | Core_reduction.Step_thread_done2 parent_tid cval ->
        ND.read (fun dr_st ->
          let actions_of_current_thread: set Cmm.action =
            Set.filter (fun act ->
              Cmm.tid_of act = tid
            ) (dr_st.concurrency_state.Cmm_op.symPre.Cmm.actions) in
          Set.filter (fun act ->
            not (Set.any (fun (act', _) ->
              act = act'
            ) dr_st.concurrency_state.Cmm_op.symPre.Cmm.sb)
          ) actions_of_current_thread
        ) >>= fun (last_actions_of_current_thread: set Cmm.action) ->
        ND.update (fun dr_st -> <| dr_st with
          core_state= Core_run.kill_thread tid parent_tid (Set.map Cmm.aid_of last_actions_of_current_thread) cval dr_st.core_state;
          dr_step_counter= dr_st.dr_step_counter + 1;
        |>) >>= fun () ->
        ND.return (WAKEUP true [parent_tid])

    | Core_reduction.Step_done2 cval ->
        ND.return NOWAKEUP

    | Core_reduction.Step_memop_request2 loc memop cvals tid is_unseq_with_ccall mk_th_st ->
        begin if is_unseq_with_ccall then
          ND.return ()
        else
          perform_memop_request2 loc memop cvals tid mk_th_st
        end >>= fun () ->
        ND.return NOWAKEUP

    | Core_reduction.Step_spawn_threads2 mk_parent_th_st spawn_th_sts ->
        ND.read (fun dr_st ->
          State.runStateM (
            State.foldlM (fun (th_tids_, core_st_) th_st ->
              State.bind (Core_run.spawn_thread (Just tid) th_st core_st_)
                (fun (tid, core_st_') -> State.return (tid :: th_tids_, core_st_'))
            ) ([], dr_st.core_state) spawn_th_sts
          ) dr_st.core_run_state
        ) >>= fun ((spawn_tids, core_st'), run_st') ->
        ND.update (fun dr_st -> <| dr_st with
          core_run_state= run_st';
          core_state= Core_run.update_thread_state tid
                        (mk_parent_th_st spawn_tids)
                        core_st';
        |>) >>= fun () ->
        ND.return (WAKEUP false spawn_tids)

    | Core_reduction.Step_fs2 _ _ _ ->
        error "TODO: Step_fs2"
    
    | Core_reduction.Step_nd2 th_sts ->
        ND.pick (SK_misc ["nd"]) th_sts >>= fun th_st' ->
        ND.update (fun dr_st -> <| dr_st with
          core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
          dr_step_counter= dr_st.dr_step_counter + 1
        |>) >>= fun () ->
        ND.return NOWAKEUP
  end


let rec find_can_advance steps =
  match steps with
    | [] ->
        Nothing
    | step :: steps' ->
        if can_advance step then
          Just step
        else
          find_can_advance steps'
  end



let rec drive_nonmemory_steps_aux2 (acc: map Mem.thread_id (list Core_reduction.core_step2)) = function
  | [] ->
      ND.return acc
  | tid :: xs' ->
      ND.read (fun dr_st ->
        let th_info =
          match List.lookup tid dr_st.core_state.Core_run.thread_states with
            | Just z -> z
            | Nothing ->
                error ("Driver.drive_nonmemory_steps_aux2 => invalid tid: " ^ show tid)
          end in
        Core_reduction.step_ctx dr_st.layout_state dr_st.core_file dr_st.core_extern tid th_info
      ) >>= fun steps ->
      match find_can_advance steps with
        | Nothing ->
            drive_nonmemory_steps_aux2 (Map.insert tid steps acc) xs'
        | Just step ->
            advance_step tid step >>= fun wakeups ->
            let xs'' =
              match wakeups with
                | NOWAKEUP ->
                    tid :: xs'
                | WAKEUP false tids ->
                    tid :: Utils.list_inserts tids xs'
                | WAKEUP true tids ->
                    Utils.list_inserts tids xs'
              end in
            drive_nonmemory_steps_aux2 acc xs''
      end
end

(*
type next =
  | CONTINUE
  | SAVE_STEPS of Core_reduction.core_step2 * list Core_reduction.core_step2
  | STOP
  | PROGRAM_DONE of Core.value
  | WAKEUP of list Mem_common.thread_id

type continue =
  | DO_CONTINUE of list Core_reduction.core_step2
  | NEXT



let rec drive_nonmemory_steps_aux (acc: map Mem.thread_id (list Core_reduction.core_step2)) continue = function
  | [] ->
      ND.return acc
  | tid :: xs' ->
      match continue with
        | DO_CONTINUE continue_steps ->
            let () = Debug.print_debug 0 [] (fun () ->
              "DO_CONTINUE |continue_steps| = " ^ show (List.length continue_steps) ^ "==> " ^ show continue_steps
            ) in
            ND.return continue_steps
        | NEXT ->
          let () = Debug.print_debug 0 [] (fun () ->
            "NEXT"
          ) in
          ND.read (fun dr_st ->
            let th_info =
              match List.lookup tid dr_st.core_state.Core_run.thread_states with
                | Just z -> z
                | Nothing ->
                    error "Driver.drive_nonmemory_steps_aux => invalid tid"
              end in
            Core_reduction.step_ctx dr_st.layout_state dr_st.core_file dr_st.core_extern tid th_info
          )
      end >>= function
        | [] ->
            drive_nonmemory_steps_aux acc NEXT xs'
        | step :: next_steps ->
            let () =
              if List.length (step :: next_steps) > 1 then
                Debug.print_debug 0 [] (fun () ->
                  "ENTER |steps| = " ^ show (List.length (step :: next_steps)) ^ " ==> " ^ show (step :: next_steps)
                )
              else
                () in
            match step with
              | Core_reduction.Step_with_runstate2 rsk step_m ->
                  match rsk with
                    | Core_reduction.RSK_tau _ (Core_run.TSK_Return sym mval_opt) ->
                        ND.update (fun dr_st ->
                          <| dr_st with trace= ME_function_return sym mval_opt :: dr_st.trace |>
                        )
                    | _ ->
                        ND.return ()
                  end >>= fun () ->
                  liftCore_run step_m >>= fun th_st' ->
                  ND.update (fun dr_st -> <| dr_st with
                    core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
                    dr_step_counter= dr_st.dr_step_counter + 1
                  |>) >>= fun () ->
                  ND.return CONTINUE 
              
              | Core_reduction.Step_tau2 debug_str tsk th_st' ->
                  match tsk with
                    | Core_run.TSK_Return sym mval_opt ->
                        ND.update (fun dr_st ->
                          <| dr_st with trace= ME_function_return sym mval_opt :: dr_st.trace |>
                        )
                    | _ ->
                        ND.return ()
                  end >>= fun () ->          
                  ND.update (fun dr_st -> <| dr_st with
                    core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
                    dr_step_counter= dr_st.dr_step_counter + 1
                  |>) >>= fun () ->
                  ND.return CONTINUE

              | Core_reduction.Step_action_request2 _ _ _ _ ->
                  ND.return (SAVE_STEPS step next_steps)

              | Core_reduction.Step_aseq _ _ _ _ ->
                  error "TODO: Driver.drive_nonmemory_steps_aux => Step_aseq"
              
              | Core_reduction.Step_blocked2 ->
                  ND.return STOP

              | Core_reduction.Step_error2 debug_str ->
                  error ("Driver.drive_nonmemory_steps_aux => Step_error2: " ^ debug_str)

              | Core_reduction.Step_thread_done2 parent_tid cval ->
                  ND.read (fun dr_st ->
                    let actions_of_current_thread: set Cmm.action =
                      Set.filter (fun act ->
                        Cmm.tid_of act = tid
                      ) (dr_st.concurrency_state.Cmm_op.symPre.Cmm.actions) in
                    Set.filter (fun act ->
                      not (Set.any (fun (act', _) ->
                        act = act'
                      ) dr_st.concurrency_state.Cmm_op.symPre.Cmm.sb)
                    ) actions_of_current_thread
                  ) >>= fun (last_actions_of_current_thread: set Cmm.action) ->
                  ND.update (fun dr_st -> <| dr_st with
                    core_state= Core_run.kill_thread tid parent_tid (Set.map Cmm.aid_of last_actions_of_current_thread) cval dr_st.core_state;
                    dr_step_counter= dr_st.dr_step_counter + 1;
                  |>) >>= fun () ->
                  (* try to wake up the parent thread *)
                  ND.return (WAKEUP [parent_tid])

              | Core_reduction.Step_done2 cval ->
                  ND.return (PROGRAM_DONE cval)

              | Core_reduction.Step_memop_request2 _ _ _ _ ->
                  ND.return (SAVE_STEPS step next_steps)

              | Core_reduction.Step_spawn_threads2 mk_parent_th_st spawn_th_sts ->
                  ND.read (fun dr_st ->
                    State.runStateM (
                      State.foldlM (fun (th_tids_, core_st_) th_st ->
                        State.bind (Core_run.spawn_thread (Just tid) th_st core_st_)
                          (fun (tid, core_st_') -> State.return (tid :: th_tids_, core_st_'))
                      ) ([], dr_st.core_state) spawn_th_sts
                    ) dr_st.core_run_state
                  ) >>= fun ((spawn_tids, core_st'), run_st') ->
                  ND.update (fun dr_st -> <| dr_st with
                    core_run_state= run_st';
                    core_state= Core_run.update_thread_state tid
                                  (mk_parent_th_st spawn_tids)
                                  core_st';
                  |>) >>= fun () ->
                  ND.return (WAKEUP spawn_tids)

              | Core_reduction.Step_fs2 th_st m_fs_step ->
                  (* TODO: can m_fs_step change the thread state?, If so this is wrong *)
                  liftCore_run m_fs_step                >>= fun fs_step ->
                  ND.get >>= fun dr_st ->
                  drive_fs_step tid th_st dr_st fs_step >>= fun () ->
                  ND.return CONTINUE

              | Core_reduction.Step_nd2 _ ->
                  error "TODO: Step_nd2"
            end >>= function
              | PROGRAM_DONE cval ->
                  ND.return (Map.insert tid [Core_reduction.Step_done2 cval] Map.empty)
              | CONTINUE ->
                  let continue' =
                    match continue with
                      | NEXT -> NEXT
                      | DO_CONTINUE _ -> DO_CONTINUE next_steps
                    end in
                  drive_nonmemory_steps_aux acc continue' (tid :: xs')
              | SAVE_STEPS step next_steps ->
                  let () = Debug.print_debug 0 [] (fun () ->
                    "SAVE_STEPS |next_steps| = " ^ show (List.length next_steps) ^ "\n" ^ show next_steps
                  ) in
                  let acc' =
                    match Map.lookup tid acc with
                      | Nothing ->
                          Map.insert tid [step] acc
                      | Just steps ->
                          Map.insert tid (step :: steps) acc
                    end in
                  (* List.map (fun step -> (tid, Just step)) steps ++ acc in *)
                  match next_steps with
                    | [] ->
                        drive_nonmemory_steps_aux acc' NEXT xs'
                    | _ ->
                        drive_nonmemory_steps_aux acc' (DO_CONTINUE next_steps) (tid :: xs')
                  end
              | STOP ->
                  drive_nonmemory_steps_aux acc NEXT xs'
              | WAKEUP tids ->
                  drive_nonmemory_steps_aux acc NEXT (tids ++ xs')
            end
      end
end
*)


val new_drive_core_threads: unit -> driverM (list (Mem.thread_id * maybe Core_reduction.core_step2))
let new_drive_core_threads () =
  ND.get >>= fun dr_st ->
  let tids = List.map fst dr_st.core_state.Core_run.thread_states in
  drive_nonmemory_steps_aux2 Map.empty (*NEXT*) tids >>= fun m ->
  ND.mapM (fun (tid, steps) ->
    let size = List.length steps in
    let () = 
      if size > 1 then
        Debug.print_debug 5 [] (fun () ->
          "picking step for thread(" ^ show tid ^ ") size: " ^ show size ^ " ==> " ^ show steps
        )
      else
        () in
    ND.pick (SK_misc ["new_drive_core_threads"]) steps >>= fun step ->
    let () =
    if size > 1 then
      Debug.print_debug 5 [] (fun () ->
        "===> PICKED: " ^ show step
      )
    else
      () in
    ND.return (tid, Just step)
  ) (Map_extra.toList m)











let prepare_exit core_st cval =
  match List.find (function (_, (Nothing, _)) -> true | _ -> false end) core_st.Core_run.thread_states with
    | Nothing ->
        error "Driver.prepare_exit ==> failed to find the initial thread"
    | Just (tid0, (_, th_st)) ->
        let th_st' =
          <| th_st with Core_run.arena= Core_aux.mk_value_e cval; Core_run.stack= Core_run.Stack_empty |> in
        <| core_st with Core_run.thread_states= [(tid0, (Nothing, th_st'))] |>
  end

(* performing all action and memop requests until there are no more *)
val process_core_step2: bool -> (bool -> driverM unit) -> Core_reduction.core_step2 -> driverM unit
let process_core_step2 with_concurrency driver2 = function
  | Core_reduction.Step_action_request2 _ loc tid _ m_request ->
      liftCore_run m_request >>= fun request ->
      perform_action_request2 with_concurrency loc tid request >>= fun () ->
      driver2 with_concurrency

  | Core_reduction.Step_memop_request2 loc memop cvals tid _ mk_th_st ->
      perform_memop_request2 loc memop cvals tid mk_th_st >>= fun () ->
      driver2 with_concurrency
  
  | Core_reduction.Step_done2 cval ->
    ND.print_debug 3 [Debug.DB_driver] (fun () ->
      "driver.process_core_step ==> Step_done2 with value: " ^ Pp.stringFromCore_value cval
    ) >> (* DEBUG *)
    (* ND.return () *)
    ND.update (fun dr_st ->
      (* killing all threads and aborting the main thread and placing [cval] as its result *)
      <| dr_st with core_state= prepare_exit dr_st.core_state cval |>
    )
  

  | Core_reduction.Step_ccall2 tid step_m ->
      liftCore_run step_m >>= fun th_st' ->
      ND.update (fun dr_st -> <| dr_st with
        core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
        dr_step_counter= dr_st.dr_step_counter + 1
      |>) >>= fun () ->
        driver2 with_concurrency
  
  | Core_reduction.Step_fs2 tid th_st m_fs_step ->
      liftCore_run m_fs_step >>= function
        | Core_reduction.FS_done cval ->
            ND.update (fun dr_st ->
              (* killing all threads and aborting the main thread and placing [cval] as its result *)
              <| dr_st with core_state= prepare_exit dr_st.core_state cval |>
            )
        | Core_reduction.FS_oper fs_step ->
            ND.get                                >>= fun dr_st ->
            drive_fs_step tid th_st dr_st fs_step >>= fun ()    ->
            driver2 with_concurrency
      end

  | wrong_step ->
      error ("Driver.process_core_step2: WRONG STEP ==> " ^ show wrong_step)
end


val     driver2: bool -> driverM unit
let rec driver2 with_concurrency =
  let () = Debug.print_debug 2 [] (fun () -> "ENTERING Driver.driver2") in
  new_drive_core_threads   () >>= fun tid_steps ->
  ND.get >>= fun post_core_dr_st ->
  
  (* TODO: hackish *)
  let _non_blocked_th_sts = List.filter (fun (tid, th_info) ->
    List.any (fun step -> step <> Core_reduction.Step_blocked2) $
      Core_reduction.step_ctx post_core_dr_st.layout_state post_core_dr_st.core_file post_core_dr_st.core_extern tid th_info
  ) post_core_dr_st.core_state.Core_run.thread_states in
  
  begin if Global.current_execution_mode () = Just Global.Random then
    (* HACK The problem is that some threads are blocked (they wait
       for other threads to finish. If we randomly pick that thread to
       execute, there will not be any steps to execute, and the whole
       execution comes to a halt. To properly solve this, we need to
       implement back tracking. Since we haven't, we temporarily
       switch to exhaustive mode and also compute the steps of the
       other threads. *)
(*
    ND.bindExhaustive (ND.pick (SK_misc ["driver 2"]) non_blocked_th_sts)
                      (fun (tid, th_info) ->
                       ND.pick (SK_misc ["driver 3"]) $
                        Core_reduction.step_ctx post_core_dr_st.layout_state post_core_dr_st.core_file post_core_dr_st.core_extern tid th_info)
*)
    ND.bindExhaustive
      (ND.pick (SK_misc ["driver 2"]) tid_steps)
      (fun (tid, step_opt) ->
         let () = Debug.print_debug 3 [] (fun () ->
           show tid ^ " ==> " ^ Maybe.maybe "Nothing" show step_opt
         ) in
         match step_opt with
           | Just step ->
               process_core_step2 with_concurrency driver2 step
           | Nothing ->
               (* TODO: hack hack, should just exit *)
               ND.return ()
         end)
   else begin
    let non_blocked =
      List.filter (fun (tid, step_opt) ->
        step_opt <> Just Core_reduction.Step_blocked2
      ) tid_steps in
    begin
      if List.length non_blocked = 0 then
        let () = Debug.print_debug 5 [] (fun () ->
          "|tid_steps| = " ^ show (List.length tid_steps) ^ "\n" ^
          show tid_steps
        ) in
        ND.return ()
      else
        ND.return ()
    end >>= fun () ->
    ND.pick (SK_misc ["driver non_blocked"]) non_blocked >>= function
      | (_, Nothing) ->
          (* TODO: hack hack, should just exit *)
          ND.return ()
      | (_, Just step) ->
      process_core_step2 with_concurrency driver2 step
    end
    (*
    ND.pick (SK_misc ["driver 4"]) non_blocked_th_sts >>= fun (tid, th_info) ->
    ND.pick (SK_misc ["driver 5"]) (Core_reduction.step_ctx post_core_dr_st.layout_state post_core_dr_st.core_file post_core_dr_st.core_extern tid th_info)
      >>= (process_core_step2 with_concurrency driver2)
    *)
    end
  end









val     hack: map Symbol.sym Symbol.sym -> list (map Symbol.sym Core.value) -> Mem.mem_state -> Core.file Core_run.core_run_annotation -> map Symbol.sym Core.object_value -> Core.pexpr -> Core.value
let rec hack core_extern env mem_st core_file concur_sym_map pexpr =
  let () = Debug.print_debug 2 [] (fun () -> "ENTERING Driver.hack") in
  match Core_eval.step_eval_pexpr 0 (Loc.other "Driver.hack") Nothing core_extern env (Just mem_st) core_file false pexpr with
    | Exception.Result (Undefined.Defined pexpr') ->
        match Core_aux.valueFromPexpr pexpr' with
          | Just cval ->
              cval
          | Nothing ->
              hack core_extern env mem_st core_file concur_sym_map pexpr'
        end
    | _ ->
        error ("Driver.hack, UNDEF/ERROR:" ^ Pp.stringFromCore_pexpr pexpr)
end



type driver_result = <|
  dres_blocked: bool;
  dres_concurrency_state: Cmm_op.symState;
  dres_driver_steps: nat;
  dres_core_value: Core.value;
  dres_stdout: string;
  dres_stderr: string;
|>


val finalize: string -> driver_state -> driver_result (* (string * (bool * Cmm_op.symState * Core.value) * (nat * nat)) *)
let finalize debug_str dr_st =
  match dr_st.core_state.Core_run.thread_states with
    | [(tid, (_, th_st))] ->
        let cval = hack dr_st.core_extern th_st.Core_run.env dr_st.layout_state dr_st.core_file dr_st.symbolic_assoc
            match Core_aux.to_pure th_st.Core_run.arena with
(*
              | Just (Core.PEval (Core.Vinteger ival)) ->
                  let Just symb = Mem_aux.symbolicFromIntegerValue ival in
                  Core_aux.unsymbolify symb
*)
              | Just pe ->
                  pe
              | Nothing ->
                  error ("Driver.finalize: the arena wasn't pure ==> " ^ Pp.stringFromCore_expr th_st.Core_run.arena)
            end in
        <|
          dres_blocked= dr_st.blocked;
          dres_concurrency_state= dr_st.concurrency_state;
          dres_driver_steps= dr_st.dr_step_counter;
          dres_core_value= cval;
          dres_stdout= List.foldr String.stringAppend "" (Dlist.toList dr_st.core_state.Core_run.io.Core_run.stdout);
          dres_stderr= List.foldr String.stringAppend "" (Dlist.toList dr_st.core_state.Core_run.io.Core_run.stderr);
        |>
    | xs ->
        let () = Debug.print_debug 3 [Debug.DB_driver] (fun () -> "ERROR (end of the Driver)\n" ^ stringFromCore_core_state dr_st.core_state) in (* DEBUG *)
        error ("BOOM finalize [" ^ debug_str ^ "]")
  end







(* TODO: it is problematic for proofy backend that this function may diverge *)
(* TODO: HACK *)
let initial_driver_state file fs_state =
  <|
    core_file=         file;
    core_extern=       Core_linking.create_extern_symmap file;
    core_state=        Core_run.initial_core_state;
    core_run_state=    Core_run.initial_core_run_state (Caux.collect_labeled_continuations_NEW file);
    layout_state=      Mem.initial_mem_state;
    concurrency_state= Cmm_op.symInitialState Cmm_op.symInitialPre;
    fs_state=          fs_state;
    trace=             [];
    symbolic_assoc=    Map.empty;
    blocked=           false;
    dr_step_counter=   0;
  |>


val spawn_thread: maybe Mem.thread_id -> Core_run.thread_state -> driverM Mem.thread_id
let driver_spawn_thread parent_tid_opt th_st =
  ND.get >>= fun dr_st ->
  let ((tid, core_st'), run_st') = State.runStateM (
    Core_run.spawn_thread parent_tid_opt th_st dr_st.core_state
  ) dr_st.core_run_state in
  ND.update (fun dr_st -> <| dr_st with
    core_state= core_st';
    core_run_state= run_st';
  |>) >>
  ND.return tid
let inline spawn_thread = driver_spawn_thread


val update_thread_state: Mem.thread_id -> Core_run.thread_state -> driverM unit
let driver_update_thread_state tid th_st =
  ND.update (fun dr_st ->
    <| dr_st with core_state= Core_run.update_thread_state tid th_st dr_st.core_state |>
  )
let inline update_thread_state = driver_update_thread_state


val driver_globals: bool -> Core.file Core_run.core_run_annotation -> driverM Mem.thread_id
let driver_globals with_concurrency file =
  (* spawning a thread for the initialisation of globals, and later the execution of main *)
  spawn_thread Nothing <|
    (* NOTE: the pure(unit) is just a placeholder, the thread is given its actual state later *)
    Core_run.arena=  Core.Expr [] (Core.Epure (Core.Pexpr [] () (Core.PEval Core.Vunit)));
    Core_run.stack=  Core_run.Stack_empty (*Core_run.push_empty_continuation Nothing Core_run.empty_stack*);
    Core_run.errno=  Mem.null_ptrval Ctype.signed_int;
    Core_run.env= [Map.empty];
    Core_run.current_loc= Loc.unknown;
    Core_run.exec_loc= Core_run.ELoc_globals;
    Core_run.current_proc_opt= Nothing;
  |> >>= fun tid0 ->
  
  ND.read (fun dr_st ->
    dr_st.core_file.Core.globs
  ) >>= fun globs ->
  let glob_defs = List.reverse $ List.foldl (fun acc (sym, glb) ->
    match glb with
    | Core.GlobalDef (bTy, _) e -> (sym, bTy, e) :: acc
    | Core.GlobalDecl _ -> acc
    end) [] globs
  in
  ND.mapM_ (fun (glob_sym, glob_bTy, expr) ->
    let () = Debug.print_debug 6 [Debug.DB_driver] (fun () ->      (* DEBUG *)
      "Starting the evaluation of global `" ^ show glob_sym ^ "'"  (* DEBUG *)
    ) in                                                           (* DEBUG *)
    (* setting up the initialisation of the current global in thread 0 *)
    get_thread_states >>= function
      | [(_, (_, th_st))] ->
        update_thread_state tid0 <|
          (* the previously evaluated globals are substituted in the body of the
             global we are about to evaluate *)
          Core_run.arena= expr;
          Core_run.stack= Core_run.Stack_empty (*Core_run.push_empty_continuation Nothing Core_run.empty_stack*);
          Core_run.env= th_st.Core_run.env;
          Core_run.errno=  Mem.null_ptrval Ctype.signed_int;
          Core_run.current_loc= Loc.other ("global(" ^ show glob_sym ^ ")"); (* TODO: preserve locations in Core.globs *)
          Core_run.exec_loc= Core_run.ELoc_globals;
          Core_run.current_proc_opt= Nothing;
        |>
      | _ ->
          error "ERROR (in Driver, global init didn't evaluate to value)"
    end >>= fun () ->
    
    (* evaluation of the initialisation *)
    driver2 with_concurrency >>= fun () ->
    
    get_thread_states >>= function
      | [(_, (_, th_st))] ->
          (* TODO: technically the arena should always be a value at this point *)
          match Core_aux.to_pure th_st.Core_run.arena with
            | Just pe ->
                match Core_aux.valueFromPexpr pe with
                  | Nothing ->
                      error "WIP: driver_globals"
                  | Just cval ->
                      update_thread_state tid0
                        <| th_st with
                            Core_run.env = Core_aux.update_env (Core.Pattern [] (Core.CaseBase (Just (glob_sym), glob_bTy))) cval th_st.Core_run.env
                        |>
                        (*

                      ND.update (fun dr_st ->
                        <| dr_st with
                          core_run_state=
                            <| dr_st.core_run_state with Core_run.env= Core_aux.update_env (Core.Pattern [] (Core.CaseBase (Just (glob_sym), glob_bTy))) cval dr_st.core_run_state.Core_run.env |>
                        |>
                     ) *)
                end
            | Nothing ->
                error "TODO(msg): Driver.driver_globals, the end of the evaluation of a glob didn't produce a value"
          end
      | _ ->
          error "ERROR (in Driver, global init didn't evaluate to value)"
    end
  ) glob_defs >>
  ND.return tid0



val pp_exeState: Cmm_op.symState -> string
declare ocaml target_rep function pp_exeState = `Pp_cmm.pp_execState`




val drive: bool -> Core.file Core_run.core_run_annotation -> list string -> driverM driver_result
let drive (with_concurrency: bool) file (arg_strs: list string) =
  (* Setting the read-only tag definitions (used by the memory model) *)
  (* first we execute the body of global definitions and remove their symbols
     from the rest of the program *)
  driver_globals with_concurrency file >>= fun tid0 (*, post_globals_dr_st) *) ->
  ND.get >>= fun post_globals_dr_st ->
  
  (* we need a startup function to have been declared *)
  match post_globals_dr_st.core_file.Core.main with
    | Just sym ->
        ND.return sym
    | Nothing ->
        ND.kill (ND.Other (DErr_other "no startup function was declared"))
  end >>= fun main_sym ->
  
  (* setting the arena of thread 0 to the body of the main function *)
  match Map.lookup main_sym post_globals_dr_st.core_file.Core.funs with
    | Nothing ->
        ND.kill (ND.Other (DErr_other "couldn't find the startup function"))
    
    | Just decl ->
        match decl with
          | Core.Fun  _ params pe ->
              ND.return (Loc.other "main args", params, Core.Expr [] (Core.Epure pe))
          | Core.ProcDecl _ _ _ ->
              ND.kill (ND.Other (DErr_other "the startup function has no definition"))
          | Core.BuiltinDecl _ _ _ ->
              ND.kill (ND.Other (DErr_other "the startup function has no definition"))
          | Core.Proc loc _ _ params e ->
              ND.return (loc, params, e)
        end >>= fun (loc, params, expr) ->
        
        match params with
          | [(argc_sym, _); (argv_sym, _)] ->
              (* memory_values to be stored in memory objects pointed to by
                 the element of main.argv  *)
              let args_mem_val_tys =
                List.map (fun arg_str ->
                  let mem_vals =
                    List.map (fun c ->
                      (* TODO: fixing impl choice here (ASCII) *)
                      Mem.integer_mval IntegerType.Char $ Decode.decode_character_constant (String.toString [c])
                    ) (String.toCharList arg_str) in
                  (* NOTE: adding a null termination to the char array *)
                  (
                    Mem.array_mval $ mem_vals ++ [Mem.integer_mval IntegerType.Char 0],
                    Ctype.Ctype [] (Ctype.Array Ctype.char (Just $ (integerFromNat $ List.length mem_vals) + 1))
                  )
                ) arg_strs in
              
              (* memory value to be stored in the memory object pointed to by main.argc *)
              let number_of_args = integerFromNat (List.length args_mem_val_tys) in
              let argc_mem_val = Mem.integer_mval (IntegerType.Signed IntegerType.Int_) number_of_args in
              
              (* begin if false (*Global.has_switch Global.SW_inner_arg_temps*) then
                (* in this switch (for CN) Core procedures elaborating C functions
                   receive values (and to the temp allocation themselves) *)
                   ND.return (Core.Vobject (Core.OVinteger (Mem.integer_ival number_of_args)))
              else *)
                (* allocating and initialising an object for main.argc *)
                liftMem (
                  Mem.bind (Mem.allocate_object tid0 (Symbol.PrefSource loc [main_sym; argc_sym])
                              (Mem.alignof_ival Ctype.signed_int) Ctype.signed_int Nothing Nothing) (fun ptr_val ->
                    Mem.bind (Mem.store (Loc.other "argc init") Ctype.signed_int false ptr_val argc_mem_val) (fun _ ->
                      Mem.return (Core.Vobject (Core.OVpointer ptr_val))
                    )
                  )
                )
              (*end*) >>= fun argc_cval ->
              
              (* allocating and initialising the objects pointed to by the elements of argv *)
              ND.foldlM (fun ptr_vals (arg_mem_val, arg_ty) ->
                liftMem (
                  Mem.bind (Mem.allocate_object tid0 (Symbol.PrefOther "argv refs") (Mem.alignof_ival arg_ty) arg_ty Nothing Nothing) (fun ptr_val ->
                    Mem.bind (Mem.store (Loc.other "argv refs init") arg_ty false ptr_val arg_mem_val) (fun _ ->
                      Mem.return (ptr_val :: ptr_vals)
                    )
                  )
                )
              ) [] args_mem_val_tys >>= fun ptr_vals_rev ->
              
              (* allocating and initialising an object for main.argv *)
              (* NOTE: the element argv[argc] is required to be a null pointer
                 by the STD, hence argv has one more element than the number
                 of supplied arguments *)
              let argv_array_elem_ty = Ctype.Ctype [] (Ctype.Pointer Ctype.no_qualifiers Ctype.char) in
              let argv_array_ty = Ctype.Ctype [] (Ctype.Array argv_array_elem_ty (Just (1 + (integerFromNat $ List.length ptr_vals_rev)))) in
              let argv_array_mem_val = Mem.array_mval $
                List.map (Mem.pointer_mval Ctype.char) (List.reverse ptr_vals_rev ++ [Mem.null_ptrval Ctype.char]) in
              liftMem (
                Mem.bind (Mem.allocate_object tid0 (Symbol.PrefSource loc [main_sym; argv_sym(*TODO: change the sym?*)])
                            (Mem.alignof_ival argv_array_ty) argv_array_ty Nothing Nothing) (fun array_ptr_val ->
                Mem.bind (Mem.store (Loc.other "argv array init") argv_array_ty false array_ptr_val argv_array_mem_val) (fun _ ->
                
                (* NOTE: because of argument promotions, the char *argv[] is turned into a char **argv
                   so two objects are allocated: an array and a pointer to that array (which is what argv designate) *)
                let argv_ty = Ctype.Ctype [] (Ctype.Pointer Ctype.no_qualifiers (Ctype.Ctype [] (Ctype.Pointer Ctype.no_qualifiers Ctype.char))) in
                Mem.bind (Mem.allocate_object tid0 (Symbol.PrefSource loc [main_sym; argv_sym])
                            (Mem.alignof_ival argv_ty) argv_ty Nothing Nothing) (fun argv_ptr_val ->
                Mem.bind (Mem.store (Loc.other "argv init") argv_ty false argv_ptr_val
                            (Mem.pointer_mval (Ctype.Ctype [] (Ctype.Pointer Ctype.no_qualifiers Ctype.char)) array_ptr_val)) ( fun _ ->

                Mem.return (Core.Vobject (Core.OVpointer argv_ptr_val))
                ))))
              ) >>= fun argv_cval ->
              (* Adding the values of argc and argv to the Core symbol environment *)
              get_thread_states >>= function
                | [(_, (_, th_st))] ->
                  update_thread_state tid0
                    <| th_st with
                        Core_run.env =
                          match th_st.Core_run.env with
                            | [] ->
                                [Map.fromList [ (argc_sym ,argc_cval)
                                              ; (argv_sym, argv_cval) ]]
                            | (xs :: xs') ->
                                (Map.insert argc_sym argc_cval
                                  (Map.insert argv_sym argv_cval xs)) :: xs'
                          end
                   |>
                | _ ->
                    error "ERROR (in Driver 1)"
              end >>= fun () ->
              ND.return expr
          | _ ->
              ND.return expr
        end >>= fun expr ->
        
        (* allocating and initialising errno *)
        liftMem (
          Mem.bind (Mem.allocate_object tid0 (Symbol.PrefOther "errno") (Mem.alignof_ival Ctype.signed_int) Ctype.signed_int Nothing Nothing) (fun ptr_val ->
            let zero = Mem.integer_value_mval (IntegerType.Signed IntegerType.Int_) (Mem.integer_ival 0) in
            Mem.bind (Mem.store (Loc.other "errno init") Ctype.signed_int false ptr_val zero) (fun _ ->
              Mem.return ptr_val
            )
          )
        ) >>= fun errno_ptr_val ->
        
        get_thread_states >>= function
          | [(_, (_, th_st))] ->
              update_thread_state tid0 <|
                Core_run.arena= expr;
                Core_run.stack= Core_run.Stack_empty (*Core_run.push_empty_continuation (Just main_sym) Core_run.empty_stack*);
                Core_run.errno= errno_ptr_val;
                Core_run.current_loc= Loc.other "Driver.drive";
                Core_run.exec_loc= Core_run.ELoc_normal [(main_sym, Loc.other "Driver.drive")];
                Core_run.env = th_st.Core_run.env;
                Core_run.current_proc_opt= Just main_sym;
              |>
          | _ ->
              error "ERROR (in Driver 2)"
        end >>
        driver2 with_concurrency >>
        
        if with_concurrency then
          error "CONCURRENCY IS BROKEN"
        else
          ND.get >>= fun dr_st' ->
          ND.return (finalize "drive (without concur)" dr_st')
end
