(* generated by Ott 0.28 from: core.ott *)
open import Pervasives

open import Ctype Annot Loc
import Symbol Implementation Undefined Cmm_csem
import Mem Mem_common
import Linux


type core_object_type =  (* types for C objects *)
 | OTy_integer
 | OTy_floating
 | OTy_pointer
 | OTy_array of core_object_type
 | OTy_struct of Symbol.sym
 | OTy_union of Symbol.sym

let rec eq_core_object_type oTy1 oTy2 =
  let ord = function
    | OTy_integer ->
        (0: nat)
    | OTy_floating ->
        1
    | OTy_pointer ->
        2
    | OTy_array _ ->
        3
    | OTy_struct _ ->
        4
    | OTy_union _ ->
        5
  end in
  match (oTy1, oTy2) with
    | (OTy_array oTy1, OTy_array oTy2) ->
        eq_core_object_type oTy1 oTy2
    | (OTy_struct sym1, OTy_struct sym2) ->
        sym1 = sym2
    | (OTy_union sym1, OTy_union sym2) ->
        sym1 = sym2
    | _ ->
        ord oTy1 = ord oTy2
  end
instance (Eq core_object_type)
  let (=) = eq_core_object_type
  let (<>) = fun x y -> not (eq_core_object_type x y)
end


type core_base_type =  (* Core base types *)
 | BTy_unit (* unit *)
 | BTy_boolean (* boolean *)
 | BTy_ctype (* Core type of C type exprs *)
 | BTy_list of core_base_type (* list *)
 | BTy_tuple of list core_base_type (* tuple *)
 | BTy_object of core_object_type (* C object value *)
 | BTy_loaded of core_object_type (* core_object_type or unspecified *)
 | BTy_storable (* top type for integer/float/pointer/structs (maybe union?). This is only used in the type system *)

let rec eq_core_base_type bTy1 bTy2 =
  let ord = function
    | BTy_unit ->
        (0: nat)
    | BTy_boolean ->
        1
    | BTy_ctype ->
        2
    | BTy_list _ ->
        3
    | BTy_tuple _ ->
        4
    | BTy_object _ ->
        5
    | BTy_loaded _ ->
        6
    | BTy_storable ->
        7
  end in
  match (bTy1, bTy2) with
    | (BTy_list bTy1', BTy_list bTy2') ->
        eq_core_base_type bTy1' bTy2'
    | (BTy_tuple bTys1, BTy_tuple bTys2) ->
        listEqualBy eq_core_base_type bTys1 bTys2
    | (BTy_object oTy1, BTy_object oTy2) ->
        oTy1 = oTy2
    | (BTy_loaded oTy1, BTy_loaded oTy2) ->
        oTy1 = oTy2
    | _ ->
        ord bTy1 = ord bTy2
  end
instance (Eq core_base_type)
  let (=) = eq_core_base_type
  let (<>) = fun x y -> not (eq_core_base_type x y)
end


type binop =  (* binary operators *)
 | OpAdd
 | OpSub
 | OpMul
 | OpDiv
 | OpRem_t
 | OpRem_f
 | OpExp
 | OpEq
 | OpGt
 | OpLt
 | OpGe
 | OpLe
 | OpAnd
 | OpOr


type core_type =  (* Core types *)
 | TyBase of core_base_type (* pure base type *)
 | TyEffect of core_base_type (* effectful base type *)

instance (Eq binop)
  let (=)  = unsafe_structural_equality
  let (<>) = unsafe_structural_inequality
end

instance (Show binop)
  let show op = 
    match op with
      | OpAdd   -> "OpAdd"
      | OpSub   -> "OpSub"
      | OpMul   -> "OpMul"
      | OpDiv   -> "OpDiv"
      | OpRem_t -> "OpRem_t"
      | OpRem_f -> "OpRem_f"
      | OpExp   -> "OpExp"
      | OpEq    -> "OpEq"
      | OpGt    -> "OpGt"
      | OpLt    -> "OpLt"
      | OpGe    -> "OpGe"
      | OpLe    -> "OpLe"
      | OpAnd   -> "OpAnd"
      | OpOr    -> "OpOr"
    end
  end


type polarity =  (* memory action polarities *)
 | Pos (* sequenced by \ottkw{let\ weak} and \ottkw{let\ strong} *)
 | Neg (* only sequenced by \ottkw{let\ strong} *)


type generic_name 'sym = 
 | Sym of 'sym (* Core identifier *)
 | Impl of Implementation.implementation_constant (* implementation-defined constant *)

instance forall 'sym. MapKeyType 'sym => (MapKeyType (generic_name 'sym))
  let mapKeyCompare nm1 nm2 =
    match (nm1, nm2) with
      | (Sym sym1, Sym sym2) ->
          mapKeyCompare sym1 sym2
      | (Impl iCst1, Impl iCst2) ->
          mapKeyCompare iCst1 iCst2
      | (Sym _, Impl _) ->
          LT
      | (Impl _, Sym _) ->
          GT
    end
end


type generic_object_value 'sym =  (* C object values *)
 | OVinteger of Mem.integer_value (* integer value *)
 | OVfloating of Mem.floating_value (* floating-point value *)
 | OVpointer of Mem.pointer_value (* pointer value *)
 | OVarray of list (generic_loaded_value 'sym) (* C array value *)
 | OVstruct of Symbol.sym * list (Symbol.identifier * ctype * Mem.mem_value) (* C struct value *)
 | OVunion of Symbol.sym * Symbol.identifier * Mem.mem_value (* C union value *)

and generic_loaded_value 'sym =  (* potentially unspecified C object values *)
 | LVspecified of (generic_object_value 'sym) (* non-unspecified loaded value *)
 | LVunspecified of ctype (* unspecified loaded value *)


type generic_value 'sym =  (* Core values *)
 | Vobject of (generic_object_value 'sym) (* C object value *)
 | Vloaded of (generic_loaded_value 'sym) (* loaded C object value *)
 | Vunit
 | Vtrue
 | Vfalse
 | Vctype of ctype (* C type as value *)
 | Vlist of core_base_type * list (generic_value 'sym)
 | Vtuple of list (generic_value 'sym) (* tuple *)


type generic_ctor =  (* data constructors *)
 | Cnil of core_base_type (* empty list *) 
 (* annotated with the type of the list items *)
 | Ccons (* list cons *)
 | Ctuple (* tuple *)
 | Carray (* C array *)
 | Civmax (* max integer value *)
 | Civmin (* min integer value *)
 | Civsizeof (* sizeof value *)
 | Civalignof (* alignof value *)
 | CivCOMPL (* bitwise complement *)
 | CivAND (* bitwise AND *)
 | CivOR (* bitwise OR *)
 | CivXOR (* bitwise XOR *)
 | Cspecified (* non-unspecified loaded value *)
 | Cunspecified (* unspecified loaded value *)
 | Cfvfromint (* cast integer to floating value *)
 | Civfromfloat (* cast floating to integer value *)


type generic_pattern_ 'sym = 
 | CaseBase of (maybe 'sym * core_base_type)
 | CaseCtor of generic_ctor * list (generic_pattern 'sym)

and generic_pattern 'sym = 
 | Pattern of list annot * (generic_pattern_ 'sym)


type generic_pexpr_ 'bty 'sym =  (* Core pure expressions *)
 | PEsym of 'sym
 | PEimpl of Implementation.implementation_constant (* implementation-defined constant *)
 | PEval of (generic_value 'sym)
 | PEconstrained of list (Mem.mem_iv_constraint * (generic_pexpr 'bty 'sym)) (* constrained value *)
 | PEundef of Loc.t * Undefined.undefined_behaviour (* undefined behaviour *)
 | PEerror of string * (generic_pexpr 'bty 'sym) (* impl-defined static error *)
 | PEctor of generic_ctor * list (generic_pexpr 'bty 'sym) (* data constructor application *)
 | PEcase of (generic_pexpr 'bty 'sym) * list ((generic_pattern 'sym) * (generic_pexpr 'bty 'sym)) (* pattern matching *)
 | PEarray_shift of (generic_pexpr 'bty 'sym) * ctype * (generic_pexpr 'bty 'sym) (* pointer array shift *)
 | PEmember_shift of (generic_pexpr 'bty 'sym) * 'sym * Symbol.identifier (* pointer struct/union member shift *)
 | PEmemop of Mem_common.pure_memop * list (generic_pexpr 'bty 'sym)
 | PEnot of (generic_pexpr 'bty 'sym) (* boolean not *)
 | PEop of binop * (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym)
 | PEstruct of 'sym * list (Symbol.identifier * (generic_pexpr 'bty 'sym)) (* C struct expression *)
 | PEunion of 'sym * Symbol.identifier * (generic_pexpr 'bty 'sym) (* C union expression *)
 | PEcfunction of (generic_pexpr 'bty 'sym) (* C function pointer expression *)
 | PEmemberof of 'sym * Symbol.identifier * (generic_pexpr 'bty 'sym) (* C struct/union member access *)
 | PEcall of (generic_name 'sym) * list (generic_pexpr 'bty 'sym) (* pure function call *)
 | PElet of (generic_pattern 'sym) * (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) (* pure let *)
 | PEif of (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) (* pure if *)
 | PEis_scalar of (generic_pexpr 'bty 'sym)
 | PEis_integer of (generic_pexpr 'bty 'sym)
 | PEis_signed of (generic_pexpr 'bty 'sym)
 | PEis_unsigned of (generic_pexpr 'bty 'sym)
 | PEbmc_assume of (generic_pexpr 'bty 'sym)
 | PEare_compatible of (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym)

and generic_pexpr 'bty 'sym = 
 | Pexpr of list annot * 'bty * (generic_pexpr_ 'bty 'sym)


type kill_kind = 
  | Dynamic
  | Static of Ctype.ctype

let is_dynamic = function
  | Dynamic -> true
  | Static _ -> false
  
end

type generic_action_ 'bty 'sym =  (* memory actions *)
 | Create of (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * Symbol.prefix
 | CreateReadOnly of (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * Symbol.prefix
 | Alloc of (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * Symbol.prefix
 | Kill of kill_kind  * (generic_pexpr 'bty 'sym) (* the boolean indicates whether the action is dynamic (i.e. free()), the size *)
 | Store of bool * (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * Cmm_csem.memory_order (* the boolean indicates whether the store is locking *)
 | Load of (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * Cmm_csem.memory_order
 | RMW of (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * Cmm_csem.memory_order * Cmm_csem.memory_order
 | Fence of Cmm_csem.memory_order
 | CompareExchangeStrong of (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * Cmm_csem.memory_order * Cmm_csem.memory_order
 | CompareExchangeWeak of (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * Cmm_csem.memory_order * Cmm_csem.memory_order
 | LinuxFence of Linux.linux_memory_order
 | LinuxLoad of (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * Linux.linux_memory_order
 | LinuxStore of (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * Linux.linux_memory_order
 | LinuxRMW of (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * Linux.linux_memory_order


type generic_action 'a 'bty 'sym = 
 | Action of Loc.t * 'a * (generic_action_ 'bty 'sym)


type generic_paction 'a 'bty 'sym =  (* memory actions with polarity *)
 | Paction of polarity * (generic_action 'a 'bty 'sym)

type generic_expr_ 'a 'bty 'sym =  (* (effectful) expression *)
 | Epure of (generic_pexpr 'bty 'sym)
 | Ememop of Mem_common.generic_memop 'sym * list (generic_pexpr 'bty 'sym) (* pointer op involving memory *)
 | Eaction of (generic_paction 'a 'bty 'sym) (* memory action *)
 | Ecase of (generic_pexpr 'bty 'sym) * list ((generic_pattern 'sym) * (generic_expr 'a 'bty 'sym)) (* pattern matching *)
 | Elet of (generic_pattern 'sym) * (generic_pexpr 'bty 'sym) * (generic_expr 'a 'bty 'sym)
 | Eif of (generic_pexpr 'bty 'sym) * (generic_expr 'a 'bty 'sym) * (generic_expr 'a 'bty 'sym)
 | Eskip
 | Eccall of 'a * (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * list (generic_pexpr 'bty 'sym) (* C function call *)
 | Eproc of 'a * (generic_name 'sym) * list (generic_pexpr 'bty 'sym) (* Core procedure call *)
 | Eunseq of list (generic_expr 'a 'bty 'sym) (* unsequenced expressions *)
 | Ewseq of (generic_pattern 'sym) * (generic_expr 'a 'bty 'sym) * (generic_expr 'a 'bty 'sym) (* weak sequencing *)
 | Esseq of (generic_pattern 'sym) * (generic_expr 'a 'bty 'sym) * (generic_expr 'a 'bty 'sym) (* strong sequencing *)
 | Easeq of ('sym * core_base_type) * (generic_action 'a 'bty 'sym) * (generic_paction 'a 'bty 'sym) (* atomic sequencing *)
 | Eindet of nat * (generic_expr 'a 'bty 'sym) (* indeterminately sequenced expr *)
 | Ebound of nat * (generic_expr 'a 'bty 'sym) (* $\ldots$and boundary *)
 | End of list (generic_expr 'a 'bty 'sym) (* nondeterministic sequencing *)
 | Esave of ('sym * core_base_type) * list ('sym * ((core_base_type * maybe (Ctype.ctype * bool)) * generic_pexpr 'bty 'sym)) * (generic_expr 'a 'bty 'sym) (* save label *)
 | Erun of 'a * 'sym * list (generic_pexpr 'bty 'sym) (* run from label *)
 | Epar of list (generic_expr 'a 'bty 'sym) (* cppmem-like thread creation *)
 | Ewait of Mem_common.thread_id (* wait for thread termination *)
 (* for CN *)
 | Epack of Annot.to_pack_unpack * list (generic_pexpr 'bty 'sym)
 | Eunpack of Annot.to_pack_unpack * list (generic_pexpr 'bty 'sym)
 | Ehave of Symbol.identifier * list (generic_pexpr 'bty 'sym)
 | Eshow of Symbol.identifier * list (generic_pexpr 'bty 'sym)

and generic_expr 'a 'bty 'sym = 
 | Expr of list annot * (generic_expr_ 'a 'bty 'sym)

type generic_impl_decl 'bty =
  | Def of core_base_type * generic_pexpr 'bty Symbol.sym
  | IFun of core_base_type * list (Symbol.sym * core_base_type) * generic_pexpr 'bty Symbol.sym
type generic_impl 'bty = map Implementation.implementation_constant (generic_impl_decl 'bty)

type generic_fun_map_decl 'bty 'a =
  | Fun of core_base_type * list (Symbol.sym * core_base_type) * generic_pexpr 'bty Symbol.sym
  | Proc of Loc.t * core_base_type * list (Symbol.sym * core_base_type) * generic_expr 'a 'bty Symbol.sym
  | ProcDecl of Loc.t * core_base_type * list core_base_type
  | BuiltinDecl of Loc.t * core_base_type * list core_base_type

type generic_fun_map 'bty 'a = map Symbol.sym (generic_fun_map_decl 'bty 'a)

instance forall 'sym. (Located (generic_pattern 'sym))
  let locOf pat =
    let (Pattern annots _) = pat in
    get_loc_ annots
end

instance forall 'bty 'sym. (Located (generic_pexpr 'bty 'sym))
  let locOf pe =
    let (Pexpr annots _ _) = pe in
    get_loc_ annots
end

instance forall 'a 'bty 'sym. (Located (generic_expr 'a 'bty 'sym))
  let locOf e =
    let (Expr annots _) = e in
    get_loc_ annots
end

type linking_kind =
  | LK_none
  | LK_tentative of Symbol.sym
  | LK_normal of Symbol.sym

instance (Show linking_kind)
 let show x = 
   match x with
   | LK_none -> "LK_none"
   | LK_tentative sym -> "LK_tentative" ^ show sym
   | LK_normal sym -> "LK_normal" ^ show sym
   end
end


type extern_map =
  map Symbol.identifier (list Symbol.sym * linking_kind)

type generic_globs 'a 'bty=
  | GlobalDef of (core_base_type * Ctype.ctype) * generic_expr 'a 'bty Symbol.sym
  | GlobalDecl of (core_base_type * Ctype.ctype)

type generic_globs_map 'a 'bty =
  map Symbol.sym (generic_globs 'a 'bty)

type core_tag_definitions =
  map Symbol.sym Ctype.tag_definition

(* a Core file is just a set of named functions *)
type generic_file 'bty 'a = <|
  main    : maybe Symbol.sym;
  tagDefs : core_tag_definitions;
  stdlib  : generic_fun_map 'bty 'a;
  impl    : generic_impl 'bty;
  globs   : list (Symbol.sym * generic_globs 'a 'bty);
  funs    : generic_fun_map 'bty 'a;
  extern  : extern_map;
  funinfo : map Symbol.sym (Loc.t * Annot.attributes * ctype * list (maybe Symbol.sym * ctype) * bool * bool);
  loop_attributes : Annot.loop_attributes;
|>


type name            = generic_name Symbol.sym
type object_value    = generic_object_value Symbol.sym
type loaded_value    = generic_loaded_value Symbol.sym
type value           = generic_value Symbol.sym
type ctor            = generic_ctor
type pattern         = generic_pattern Symbol.sym
type pexpr           = generic_pexpr unit Symbol.sym
type expr 'a         = generic_expr 'a unit Symbol.sym
type action 'a       = generic_action 'a unit Symbol.sym
type paction 'a      = generic_paction 'a unit Symbol.sym
type impl_decl       = generic_impl_decl unit
type impl            = generic_impl unit
type fun_map_decl 'a = generic_fun_map_decl unit 'a
type fun_map 'a      = generic_fun_map unit 'a
type file 'a         = generic_file unit 'a

type typed_ctor            = generic_ctor
type typed_pattern         = generic_pattern Symbol.sym
type typed_pexpr           = generic_pexpr core_base_type Symbol.sym
type typed_expr 'a         = generic_expr 'a core_base_type Symbol.sym
type typed_action 'a       = generic_action 'a core_base_type Symbol.sym
type typed_paction 'a      = generic_paction 'a core_base_type Symbol.sym
type typed_impl_decl       = generic_impl_decl core_base_type
type typed_impl            = generic_impl core_base_type
type typed_fun_map_decl 'a = generic_fun_map_decl core_base_type 'a
type typed_fun_map 'a      = generic_fun_map core_base_type 'a
type typed_file 'a         = generic_file core_base_type 'a



declare {coq} rename type impl = impl_ (* workaround for Lem issue #74 *)






 
 
 
 
 
 (* runtime stuff *)
type continuation_element 'a =
  | Kunseq of list annot * list (expr 'a) * list (expr 'a)
  | Kwseq  of list annot * pattern * expr 'a
  | Ksseq  of list annot * pattern * expr 'a
 (*  | Ktry   list (string * expr 'a) *)

type continuation 'a = list (continuation_element 'a)
(* type labeled_continuation 'a = list (Symbol.sym * ctype) * expr 'a *)
type labeled_continuations 'a = map Symbol.sym (list Symbol.sym * expr 'a)


type stack 'a =
  | Stack_empty
    (* the symbol is that of the procedure being executed *)
  | Stack_cons of maybe Symbol.sym * (*labeled_continuations 'a * *) continuation 'a * stack 'a
 
 
 
 
 
 
 (* basic class instanciations *)
 instance (SetType polarity)
   let setElemCompare = defaultCompare
 end



