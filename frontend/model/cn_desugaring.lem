(* Cabs to Ail desugaring auxiliary functions (included in Cabs_to_ail_effect) *)
open import Pervasives
import Symbol Loc Ctype State_exception Errors Map_extra String_extra

open import Cn


type cn_desugaring_state = <|
  (* cn_oargs: map Symbol.sym (map Symbol.identifier (Symbol.sym * Cn.base_type Ctype.ctype)); *)
  cn_idents: map (cn_namespace * Symbol.identifier) Symbol.sym;
  cn_current_scope: map (cn_namespace * Symbol.identifier) Symbol.sym;
  cn_predicates: list (Symbol.identifier * (Symbol.sym * cn_predicate Symbol.sym Ctype.ctype));
  cn_datatypes: list (Symbol.identifier * (cn_datatype Symbol.sym Ctype.ctype));
  cn_functions: list (Symbol.identifier * (Symbol.sym * cn_function Symbol.sym Ctype.ctype));
  (* cn_c_identifier_env: AilSyntax.identifier_env; *)
|>

let initial_cn_desugaring_state = <|
  cn_idents= Map.empty;
  cn_current_scope= Map.empty;
  cn_predicates= [];
  cn_datatypes= [];
  cn_functions= [];
  (* cn_c_identifier_env= Map.empty; *)
|>

(* let state_with_idents cn_idents = *)
(*   <| initial_cn_desugaring_state with cn_idents= cn_idents |> *)
(* let set_c_identifier_env env st = <| st with cn_c_identifier_env= env |> *)

(* type cn_desugM 'a = State_exception.stExceptM 'a cn_desugaring_state Errors.error *)

(* module Eff = State_exception *)
(* val return: forall 'a. 'a -> cn_desugM 'a *)
(* let inline return = State_exception.return *)
(* let inline (>>=) = Eff.bind *)
(* val fail: forall 'a. Loc.t -> Errors.desugar_cause -> cn_desugM 'a *)
(* let inline fail loc dcause = State_exception.fail (loc, Errors.DESUGAR dcause) *)
(* let inline foldlM = State_exception.foldlM *)



