open import Pervasives Utils Cabs AilSyntax Std Constraint Assert_extra

open import Cabs_to_ail_aux
import Cabs_to_ail_effect

import IntegerImpl Range

import Debug Pp Cabs Multiset Decode
import AilSyntaxAux AilTypesAux Builtins

import Errors

import Mini_pipeline
import Desugaring_init

import Cn


module E = Cabs_to_ail_effect

let inline (>>=)    = E.bind
let inline (>>) m f = m >>= fun _ -> f (* NOTE: the inline is important *)
let inline (<$>)    = E.fmap
let inline (<*>)    = E.app



(* STD ยง6.9.2#2, sentence 1 *)
(* TODO replace the bool by this type? *)
(*
THIS IS UNUSED
type tentative_definition_bool =
  | IsTentativeDefinition
  | NotTentativeDefinition
*)

type declaration_context =
  | Object_decl_context
  | Function_decl_context

instance (Eq declaration_context)
  let (=)  = unsafe_structural_equality
  let (<>) = unsafe_structural_inequality
end










(* initialisation *)

type init_element =
  | Elem_array of integer
  | Elem_member of Symbol.identifier
(*   | Elem_union of Symbol.identifier *)

type init_path = list init_element


let init_elementEqual elem1 elem2 =
  match (elem1, elem2) with
    | (Elem_array n1, Elem_array n2) ->
        n1 = n2
    | (Elem_member ident1, Elem_member ident2) ->
        ident1 = ident2
    | _ ->
        false
  end

instance (Eq init_element)
  let (=) elem1 elem2 =
    init_elementEqual elem1 elem2
  let (<>) elem1 elem2 =
    not (init_elementEqual elem1 elem2)
end


let stringFromInit_element = function
  | Elem_array n ->
      "[" ^ show n ^ "]"
  | Elem_member ident ->
      "." ^ show ident
end

let stringFromInit_path xs =
  String.concat "" (List.map stringFromInit_element xs)




(* STD ยง6.7.9#3 *)
let check_initialised_type_constraint loc ty =
  E.is_complete_object ty >>= fun is_complete_object ->
  if not (   AilTypesAux.is_array_unknown_size ty
          || (is_complete_object && not (AilTypesAux.is_vla ty)) ) then
    let kind =
      if AilTypesAux.is_vla ty then
        InitialisedVLA
      else
        InitialisedIncomplete ty in
    E.constraint_violation loc (IllegalInitialisation kind)
  else
    E.return ()




(* ====================================================================================================================== *)

(*
val     elemPathFromCtype_aux3: map identifier tag_definition -> (init_path * Ctype.ctype) -> Ctype.ctype -> list (init_path * (init_path * Ctype.ctype))
*)
let rec wip tagDefs acc path_prefix (outer_path, outer_ty) (Ctype.Ctype _ cty) =
  match cty with
    | Ctype.Void ->
        error "elemPathFromCtype_aux3, Void"
    | Ctype.Function _ _ _ ->
        error "elemPathFromCtype_aux3, Function"
    | Ctype.FunctionNoParams _ ->
        error "elemPathFromCtype_aux3, FunctionNoParams"
    | Ctype.Basic _ ->
        (path_prefix, outer_path, outer_ty) :: acc
    | Ctype.Pointer _ _ ->
        (path_prefix, outer_path, outer_ty) :: acc
    | Ctype.Array _ Nothing ->
        error "elemPathFromCtype_aux3, Array Nothing"
    | Ctype.Array elem_ty (Just n) ->
        List.foldl (fun acc i ->
          wip tagDefs acc (Elem_array i :: path_prefix) (Elem_array i :: path_prefix, elem_ty) elem_ty
        ) (wip tagDefs acc (Elem_array 0 :: path_prefix) (outer_path, outer_ty) elem_ty)
          (Utils.mkListFromTo 1 (n-1))
    | Ctype.Atomic atom_ty ->
        wip tagDefs acc path_prefix (outer_path, outer_ty) atom_ty
    | Ctype.Struct tag_sym ->
        match Map.lookup tag_sym tagDefs with
          | Just (Struct_definition _ _ isAnonymous ((first_memb_ident, (_, _, _, first_memb_ty)) :: xs) _) ->
              let () = if isAnonymous then
                Debug.print_debug 2 [] (fun () ->
                  "elemPathFromCtype_aux3: this may be WRONG ==> anonymous Struct"
                )
              else () in
              List.foldl (fun acc (memb_ident, (_, _, _, memb_ty)) ->
                wip tagDefs acc
                  (Elem_member memb_ident :: path_prefix)
                  (Elem_member memb_ident :: path_prefix, memb_ty)
                  memb_ty
              ) (wip tagDefs acc
                   (Elem_member first_memb_ident :: path_prefix)
                   (outer_path, outer_ty) 
                   first_memb_ty)
                xs
          | _ ->
              error "elemPathFromCtype_aux3, Struct"
        end
    | Ctype.Union tag_sym ->
        (* TODO: check *)
        match Map.lookup tag_sym tagDefs with
          | Just (Union_definition _ _ isAnonymous ((first_memb_ident, (_, _, _, first_memb_ty)) :: _)) ->
              let () = if isAnonymous then
                Debug.print_debug 2 [] (fun () ->
                  "elemPathFromCtype_aux3: this may be WRONG ==> anonymous Union"
                )
              else () in
              (wip tagDefs acc
                 (Elem_member first_memb_ident :: path_prefix)
                 (outer_path, outer_ty) 
                 first_memb_ty)
          | _ ->
              error "elemPathFromCtype_aux3, Union"
        end
  end

val elemPathFromCtype3: bool -> map ail_identifier tag_definition -> Ctype.ctype -> list (init_path * init_path * Ctype.ctype)
let elemPathFromCtype3 is_unknown_size tagDefs (Ctype.Ctype _ entity_ty as entity_cty) =
  match entity_ty with
    | Ctype.Array _ Nothing ->
        error "TODO: elemPathFromCtype3, array with unknown size"
    | _ ->
        let (outer_path, outer_ty) = match entity_ty with
          | Ctype.Array elem_ty _ ->
              ([Elem_array 0], if is_unknown_size then entity_cty else elem_ty)
          | Ctype.Struct tag_sym ->
              match Map.lookup tag_sym tagDefs with
                | Just (Struct_definition _ _ isAnonymous ((first_memb_ident, (_, _, _, first_memb_ty)) :: _) _) ->
                    let () = if isAnonymous then
                      Debug.print_debug 2 [] (fun () ->
                        "elemPathFromCtype3_aux: this may be WRONG ==> anonymous Struct"
                      )
                    else () in
                    ([Elem_member first_memb_ident], if is_unknown_size then entity_cty else first_memb_ty)
                | _ ->
                    error "elemPathFromCtype3, Struct"
              end
          | Ctype.Union tag_sym ->
              (* TODO: check *)
              match Map.lookup tag_sym tagDefs with
                | Just (Union_definition _ _ isAnonymous ((first_memb_ident, (_, _, _, first_memb_ty)) :: _)) ->
                    let () = if isAnonymous then
                      Debug.print_debug 2 [] (fun () ->
                        "elemPathFromCtype3: this may be WRONG ==> anonymous Union"
                      )
                    else () in
                    ([Elem_member first_memb_ident], if is_unknown_size then entity_cty else first_memb_ty)
                | _ ->
                    error "elemPathFromCtype3, Union"
              end
          | _ ->
              ([], entity_cty)
        end in
        let xs =
          wip tagDefs
            []              (* acc *)
            []              (* current path prefix *)
            (outer_path, outer_ty) (* current outer path and it's type *)
            entity_cty in
        List.map (fun (path, outer_path, ty) ->
          (List.reverse path, List.reverse outer_path, ty)
        ) (List.reverse xs)
  end

type path_elem =
  init_path * init_path * Ctype.ctype




let rec skipTo_aux acc path = function
  | [] ->
      Nothing
  | ((path', _, _) as x) :: xs ->
      let () = Debug.print_debug 2 [] (fun () ->
        "path: " ^ stringFromInit_path path ^ " <--> " ^
        "path': " ^ stringFromInit_path path' ^ " === " ^
        (if List.isPrefixOf path path' then "true" else "false")
      ) in
      if List.isPrefixOf path path' then
        Just (x :: xs, List.reverse acc)
      else
        skipTo_aux (x :: acc) path xs
end
let skipTo path elems =
  skipTo_aux [] path elems


(*

skipTo cursor_path elems

take1 elem

splitAt

update inner elements

*)

(* 
type withElemsM 'a = State.stateM 'a (list path_elem)

val _UNUSED_skipToPath: init_path -> withElemsM (list path_elem)
let _UNUSED_skipToPath path =
  State.bind State.get (fun elems ->
  match skipTo path elems with
    | Nothing ->
        error "WIP: skipToPath"
    | Just (elems', skipped) ->
        State.bind (State.put elems') begin fun () ->
        State.return skipped
        end
  end)


val _UNUSED_getElem: withElemsM (maybe path_elem)
let _UNUSED_getElem =
  State.bind State.get function
    |  [] ->
        State.return Nothing
    | x::xs ->
        State.bind (State.put xs) (fun () -> State.return (Just x))
  end


val _UNUSED_getElems: integer -> withElemsM (list path_elem)
let _UNUSED_getElems n =
  State.bind State.get begin fun elems ->
    let (xs,ys) = List.splitAt (natFromInteger n) elems in
    State.bind (State.put ys) (fun () -> State.return xs)
  end
 *)





(*
type elemPathMaker = <|
  skipTo: init_path -> maybe ((list path_elem * list path_elem) * elemPathMaker);
  getElem: unit -> (path_elem * elemPathMaker);
  getElems: integer -> (list path_elem * elemPathMaker);
|>

val mk_elemsPathFromCtype: map ail_identifier tag_definition -> Ctype.ctype -> elemPathMaker
let mk_elemsPathFromCtype tagDefs ty =
  let elems = elemPathFromCtype3 tagDefs ty in
  <|
    skipTo=
      fun path -> match skipTo path elems with
        | Nothing -> Nothing
        | Just 
      end
 |>
*)




let rec cardinalityOfCtype tagDefs (Ctype.Ctype _ ty) =
  match ty with
    | Ctype.Array _ Nothing ->
        error "cardinalityOfCtype: Array Nothing"
    | Ctype.Array elem_ty (Just n) ->
        n * cardinalityOfCtype tagDefs elem_ty
    | Ctype.Struct tag_sym ->
        match Map.lookup tag_sym tagDefs with

          | Just (Struct_definition _ _ isAnonymous xs _) ->
              let () = if isAnonymous then
                Debug.print_debug 2 [] (fun () ->
                  "cardinalityOfCtype: this may be WRONG ==> anonymous Struct"
                )
              else () in
              List.foldl (fun acc (_, (_, _, _, memb_ty)) ->
                cardinalityOfCtype tagDefs memb_ty + acc
              ) 0 xs
          |  _ ->
              error "cardinalityOfCtype: Struct"
        end
    | Ctype.Atomic atom_ty ->
        cardinalityOfCtype tagDefs atom_ty
    | _ ->
        1
  end















val     _UNUSED_ctypeAtPath: map ail_identifier tag_definition -> Ctype.ctype -> init_path -> Ctype.ctype
let rec _UNUSED_ctypeAtPath tagDefs (Ctype.Ctype _ ty as cty) path =
  match (ty, path) with
    | (_, []) ->
        cty
    | (Ctype.Array elem_ty (Just n1), Elem_array n2 :: path') ->
        if n1 <= n2 then
          error "ctypeAtPath: array type smaller than path needed"
        else
          _UNUSED_ctypeAtPath tagDefs elem_ty path'
    | (Ctype.Struct tag_sym, Elem_member memb_ident :: path') ->
        match Map.lookup tag_sym tagDefs with
          | Just (Struct_definition _ _ _ xs _) ->
              match List.lookup memb_ident xs with
                | Nothing ->
                    error "ctypeAtPath: Struct, invalid member"
                | Just (_, _, _, memb_ty) ->
                    _UNUSED_ctypeAtPath tagDefs memb_ty path'
              end
          | _ ->
              error "ctypeAtPath: Struct"
        end
    (* TODO: union *)
    | _ ->
        error ("ctypeAtPath: wildcard ==> " ^
               Pp.stringFromAil_ctype Ctype.no_qualifiers cty ^
               " --- path: " ^ stringFromInit_path path)
  end


let rec innerCtype tagDefs (Ctype.Ctype _ ty as cty) =
  match ty with
    | Ctype.Void ->
        error "innerCtype: Void"
    | Ctype.Basic _ ->
        cty
    | Ctype.Array elem_ty _ ->
        innerCtype tagDefs elem_ty
    | Ctype.Function _ _ _ ->
        error "innerCtype: Function"
    | Ctype.FunctionNoParams _ ->
        error "innerCtype: FunctionNoParams"
    | Ctype.Pointer _ _ ->
        cty
    | Ctype.Atomic atom_ty ->
        (* TODO: check *)
        innerCtype tagDefs atom_ty
    | Ctype.Struct tag_sym ->
        match Map.lookup tag_sym tagDefs with
          | Just (Struct_definition _ _ _ ((_, (_, _, _, memb_ty)) :: _) _) ->
              innerCtype tagDefs memb_ty
          | _ ->
              error "innerCtype: Struct"
        end
    | Ctype.Union tag_sym ->
        (* TODO: this may be wrong when called in a Desig context ... *)
        match Map.lookup tag_sym tagDefs with
          | Just (Union_definition _ _ _ ((_, (_, _, _, memb_ty)) :: _)) ->
              innerCtype tagDefs memb_ty
          | _ ->
              error "innerCtype: Union"
        end
  end




val     _UNUSED_outerValidPath: map ail_identifier tag_definition -> Ctype.ctype -> list (init_element) -> init_path
let rec outerValidPath_aux tagDefs (Ctype.Ctype _ ty) path acc =
  match (ty, path) with
    | (_, []) ->
        List.reverse acc
    | (Ctype.Array elem_ty _, Elem_array n :: path') ->
        if n = 0 then
          


          match path' with
            | [] ->
                List.reverse (Elem_array n :: acc)
            | _ ->
                outerValidPath_aux tagDefs elem_ty path' (Elem_array n :: acc)
          end
        else (* n > 0 *)
          List.reverse acc
    | (Ctype.Struct tag_sym, Elem_member memb_ident :: path') ->
        match Map.lookup tag_sym tagDefs with
          | Just (Struct_definition _ _ _ ((first_memb_ident, (_, _, _, memb_ty)) :: _) _) ->
              if first_memb_ident = memb_ident then
                match path' with
                  | [] ->
                      List.reverse (Elem_member memb_ident :: acc)
                  | _ ->
                      outerValidPath_aux tagDefs memb_ty path' (Elem_member memb_ident :: acc)
                end
              else
                List.reverse acc
          | _ ->
              error "outerValidPath: Struct"
        end
    (* TODO: union *)
    | _ ->
        error "outerValidPath: wildcard"
  end

let _UNUSED_outerValidPath tagDefs ty path =
  outerValidPath_aux tagDefs ty path []


(*
type init_element =
  | Elem_array of integer
  | Elem_member of Symbol.identifier

type init_path = list init_element * Ctype.ctype
*)

(*
E.desugM (list (init_path * expression unit) * list (init_path * init_path * Ctype.ctype)) =
*)

val constructValue: map ail_identifier tag_definition -> list (init_path * expression unit) -> Ctype.ctype -> expression unit
let rec constructValue_aux tagDefs path elems (Ctype.Ctype _ ty as cty) =
  match ty with
    | Ctype.Array _ Nothing ->
        let () = Debug.print_debug 2 [] (fun () ->
          "==> " ^ stringFromList (stringFromPair stringFromInit_path Pp.stringFromAil_expression) elems
        ) in
        error "constructValue_aux: Array Nothing"
    | Ctype.Array elem_ty (Just n) ->
        let es =
          List.map (fun i ->
            Just (constructValue_aux tagDefs (path ++ [Elem_array i]) elems elem_ty)
          ) (Utils.mkListN n) in
        AnnotatedExpression () [] (Loc.locOf cty) begin
          AilEarray false(*TODO*) elem_ty es
        end
    | Ctype.Struct tag_sym ->
        match Map.lookup tag_sym tagDefs with
          | Just (Struct_definition _ _ isAnonymous xs _) ->
              let () = if isAnonymous then
                Debug.print_debug 2 [] (fun () ->
                  "constructValue_aux: this may be WRONG ==> anonymous Struct"
                )
              else () in
              let membrs = List.map (fun (memb_ident, (_, _, _, memb_ty)) ->
                (memb_ident, Just (constructValue_aux tagDefs (path ++ [Elem_member memb_ident]) elems memb_ty))
              ) xs in
              AnnotatedExpression () [] (Loc.other "Cabs_to_ail.constructValue") begin
                AilEstruct tag_sym membrs
              end
          | _ ->
              error "constructValue_aux, Struct"
        end
    | Ctype.Union tag_sym ->
        match Map.lookup tag_sym tagDefs with
          | Just (Union_definition _ _ isAnonymous ((first_memb_ident, (_, _, _, first_memb_ty)) :: _)) ->
              let () = if isAnonymous then
                Debug.print_debug 2 [] (fun () ->
                  "constructValue_aux: this may be WRONG ==> anonymous Union"
                )
              else () in
              (* TODO: this is only correct if the first member was the one initialised *)
              AnnotatedExpression () [] (Loc.other "Cabs_to_ail.constructValue") begin
                AilEunion tag_sym first_memb_ident
                  (Just (constructValue_aux tagDefs (path ++ [Elem_member first_memb_ident]) elems first_memb_ty))
              end
          | _ ->
              error "constructValue_aux, Union"
        end
    | Ctype.Atomic ty' ->
        (* TODO: check this *)
        constructValue_aux tagDefs path elems ty'
    | _ ->
        match List.lookup path elems with
          | Nothing ->
              mk_zeroInit tagDefs cty
          | Just e ->
              e
        end
  end

let constructValue tagDefs elems ty =
  constructValue_aux tagDefs [] elems ty





























(* BEGIN predicates on Ail syntax *)
(* see ยง6.6#6 *)
(* TODO: make the function pure, when complete *)
val     is_integer_constant_expression: expression unit -> E.desugM bool
let rec is_integer_constant_expression (AnnotatedExpression () _ loc expr_ as expr) =
  STD_ "ยง6.6#6" match expr_ with
    | AilEunary uop e ->
        match uop with
          | Plus ->
              is_integer_constant_expression e
          | Minus ->
              is_integer_constant_expression e
          | Bnot ->
              is_integer_constant_expression e
          | Address ->
              E.return false
          | Indirection ->
              E.return false
          | PostfixIncr ->
              E.return false
          | PostfixDecr ->
              E.return false
        end
    | AilEcast _ _ _ ->
        E.fail loc (Errors.Desugar_NotYetSupported "cast operator in `integer constant expressions'")
    | AilEassert _ ->
        E.return false
    | AilEoffsetof _ _ ->
        E.fail loc (Errors.Desugar_NotYetSupported "offsetof() in `integer constant expressions'")
    | AilEstr _ ->
        E.return false
(*
    | AilEgeneric of expression 'a * list (generic_association 'a)
    | AilEarray of bool * ctype * list (maybe (expression 'a))
    | AilEstruct of ail_identifier * list (Symbol.identifier * maybe (expression 'a)) (* tag, pairs of member id, expression *)
    | AilEunion of ail_identifier * Symbol.identifier * maybe (expression 'a)
    | AilEcompound of ctype * expression 'a
    | AilEmemberof of expression 'a * Symbol.identifier
    | AilEmemberofptr of expression 'a * Symbol.identifier
    | AilEbuiltin of string (* TODO: see if that can be moved to [constant] *)
    | AilEstr of stringLiteral
    | AilEconst of constant
    | AilEident of ail_identifier
*)
    | AilEannot _ e ->
        is_integer_constant_expression e

    | AilEva_start _ _ ->
        E.return false
    | AilEva_copy _ _ ->
        E.return false
    | AilEva_arg _ _ ->
        E.return false
    | AilEva_end _ ->
        E.return false
    | AilEprint_type e ->
        is_integer_constant_expression e
    | AilEbmc_assume _ ->
        E.return false
    | AilErvalue _ ->
        (* NOTE: this only exists after the Ail typing *)
        error "cabs_to_ail.is_integer_constant_expression (AilErvalue _)"
    | AilEarray_decay _ ->
        (* NOTE: this only exists after the Ail typing *)
        error "cabs_to_ail.is_integer_constant_expression (AilEarray_decay _)"
    | AilEfunction_decay _ ->
        (* NOTE: this only exists after the Ail typing *)
        error "cabs_to_ail.is_integer_constant_expression (AilEfunction_decay _)"
    | AilEatomic _ ->
        (* NOTE: this only exists after the Ail typing *)
        error "cabs_to_ail.is_integer_constant_expression (AilEatomic _)"

    | AilEconst (ConstantInteger _) ->
        (* NOTE: this includes enumeration constants *)
        E.return true
    | AilEconst (ConstantFloating _) ->
        E.return false
    | AilEconst (ConstantCharacter _) ->
        E.return true
    | AilEconst (ConstantPredefined PConstantFalse) ->
        E.return true
    | AilEconst (ConstantPredefined PConstantTrue) ->
        E.return true
    | AilEsizeof _ ty ->
        if AilTypesAux.is_vla ty then
          (* STD ยง6.5.3.4#2, sentence 4 *)
          E.return false
        else
          E.return true
    | AilEsizeof_expr _ ->
        (* TODO: this is wrong if the expression is a VLA *)
        (* but I can't easily ask the Ail typing for now ... *)
(*
        if AilTypesAux.is_vla ty then
          (* STD ยง6.5.3.4#2, sentence 4 *)
          E.return false
        else
*)
          E.return true
    | AilEalignof _ _ ->
        E.return true


(*

floating constants that are the immediate operands of casts.

Cast operators in an integer constant expression shall only convert arithmetic types to integer types, except as part of an operand to the sizeof or _Alignof operator.
*)


(*
Constant expressions shall not


increment

decrement

function-call

or comma operators

except when they are contained within a subexpression that is not evaluated.115)
*)

    | AilEassign _ _ ->
        (* STD ยง6.6#3 *)
        E.return false
    | AilEcompoundAssign _ _ _ ->
        (* STD ยง6.6#3 *)
        E.return false

    | AilEcall _ _ ->
        (* STD ยง6.6#3 *)
        E.return false
    | AilEbinary _ Comma _ ->
        (* STD ยง6.6#3 *)
        E.return false
    | AilEbinary e1 _ e2 ->
        is_integer_constant_expression e1 >>= fun b1 ->
        if b1 then
          is_integer_constant_expression e2
        else
          E.return false
    
    | AilEcond e1 Nothing e3 ->
        is_integer_constant_expression e1 >>= fun b1 ->
        if b1 then
          (* TODO: this is too strict, it is allowed for the dead branch to not be a constant *)
          is_integer_constant_expression e3
        else
          E.return false

    | AilEcond e1 (Just e2) e3 ->
        is_integer_constant_expression e1 >>= fun b1 ->
        if b1 then
          is_integer_constant_expression e2 >>= fun b2 ->
          is_integer_constant_expression e3 >>= fun b3 ->
          (* TODO: this is too strict, it is allowed for the dead branch to not be a constant *)
          E.return (b2 && b3)
        else
          E.return false
    
    
    | AilEmemberof _ _ ->
        E.return false
    | AilEmemberofptr _ _ ->
        E.return false
    
    
    | AilEident _ ->
        E.return false
    

    
    | _ ->
        error ("TODO: Cabs_to_ail.is_integer_constant_expression, wildcard ==> " ^
               Pp.stringFromAil_expression expr)
end




























(* STD ยง6.6#8 *)
(* TODO: this is super partial and hackish *)
(* TODO: I assume from the "shall only have operands" that arithmetic operations are allowed *)
val     is_arithmetic_constant_expression: bool -> expression unit -> E.desugM bool
let rec is_arithmetic_constant_expression is_lvalue ((AnnotatedExpression () _ loc expr)) =
  match expr with
    | AilEconst (ConstantInteger _) ->
        E.return true
    | AilEconst (ConstantFloating _) ->
        E.return true
    | AilEconst (ConstantCharacter _) ->
        E.return true
    | AilEconst (ConstantPredefined PConstantFalse) ->
        E.return true
    | AilEconst (ConstantPredefined PConstantTrue) ->
        E.return true
(*
    | AilEconst (ConstantArray _) ->
        (* NOTE: is Ail specific *)
        E.return true
*)

    | AilEident _ ->
        E.return is_lvalue

    (* TODO: not sure about this! but I want to include enumerations *)
    | AilEannot _ e ->
        is_arithmetic_constant_expression true e

    | AilEunary Address e ->
        is_arithmetic_constant_expression true e
    | AilEunary _ e ->
        is_arithmetic_constant_expression is_lvalue e

    | AilEbinary e1 _ e2 ->
        is_arithmetic_constant_expression is_lvalue e1 >>= fun b1 ->
        is_arithmetic_constant_expression is_lvalue e2 >>= fun b2 ->
        E.return (b1 && b2)

    | AilEsizeof _ ty ->
        (* TODO: sizeof expressions whose results are integer constants *)
        E.return (not (AilTypesAux.is_vla ty))
    | AilEalignof _ _ ->
        E.return true
    | AilEcast _ ty e ->
        if not (AilTypesAux.is_arithmetic ty) then
          E.return false
        else
          E.print_debugM 2 (fun () -> "WARNING[Cabs_to_ail.is_arithmetic_constant_expression] AilEcast: annoying ==> need to typecheck e...") >>
(*          E.return true *)
          (* TODO: is_lvalue might be wrong depending on the type of e? *)
          is_arithmetic_constant_expression is_lvalue e
        
    | _ ->
        E.return false

  end


val     is_lvalue_to_static_object: expression unit -> E.desugM bool
let rec is_lvalue_to_static_object (AnnotatedExpression () _ loc expr) =
  match expr with
    | AilEident sym ->
        E.is_static_object_identifier sym
(* The array-subscript [] and member-access . and -> operators, the address & and indirection * unary operators, and pointer casts may be used in the creation of an address constant, but the value of an object shall not be accessed by use of these operators. *)
    | AilEbinary e1 (Arithmetic Add) e2 ->
        (* NOTE: this case corresponds to array-subcript *)
        is_lvalue_to_static_object e1        >>= fun b11 ->
        is_arithmetic_constant_expression false (* TODO check *) e1 >>= fun b12 ->
        is_lvalue_to_static_object e2        >>= fun b21 ->
        is_arithmetic_constant_expression false (* TODO check *) e2 >>= fun b22 ->
        E.return (b11 && b22 || b12 && b21)
    | AilEmemberof e _ ->
        (* TODO: not sure *)
        is_lvalue_to_static_object e
    | AilEmemberofptr e _ ->
        (* TODO: not sure *)
        is_lvalue_to_static_object e
    | AilEcast _ ty e ->
        (* TODO: check *)
        if not (AilTypesAux.is_pointer ty) then
          E.return false
        else
          is_lvalue_to_static_object e

(* TODO
    | AilEmemberof e ident ->
*)
    | _ ->
        E.return false
  end



(* STD ยง6.6#9 *)
val is_address_constant: expression unit -> E.desugM bool
let is_address_constant a_expr =
  (* TODO: not sure is_null_pointer_constant is the right predicate *)
  (* An address constant (...) *)
  if AilSyntaxAux.is_null_pointer_constant a_expr then
    (* (...) is a null pointer, *)
    E.return true
  
  else match a_expr with
    | AnnotatedExpression () _ _ (AilEident sym) ->
        E.is_function_designator sym >>= function
          | true ->
              E.return true
          | false ->
              E.fetch_object_declaration sym >>= fun (_, _, dur, _, _, _, ty) ->
              match dur with
                | Static ->
                    E.return (AilTypesAux.is_array ty)
                | _ ->
                    E.return false
              end
        end
    | AnnotatedExpression () _ _ (AilEunary Address expr) ->
        is_lvalue_to_static_object expr
    | AnnotatedExpression () _ _ (AilEcast _ _ expr) ->
        is_lvalue_to_static_object expr >>= function
          | true ->
              E.return true
          | false ->
              is_integer_constant_expression expr
        end
    | _ ->
        E.return false
  end




(* As defined in STD ยง6.6#7, in the context of initializers, "constant expressions" 
   can have more things in them *)
(* TODO: "or evaluate to" *)
val is_initializer_constant_expression_or_string_literal: expression unit -> E.desugM bool
let is_initializer_constant_expression_or_string_literal (AnnotatedExpression () _ loc expr as a_expr) =
  is_arithmetic_constant_expression false (* TODO check *) a_expr >>= fun b1 ->
  is_address_constant a_expr               >>= fun b2 ->
  (* STD ยง6.6#7, bullets 1 - 3 *)
  if b1 || AilSyntaxAux.is_null_pointer_constant a_expr || b2 then
    E.return true
  
  (* STD ยง6.6#7, bullets 4 *)
  else match expr with
    | AilEbinary e1 (Arithmetic Add) e2 ->
        is_address_constant e1            >>= fun b11 ->
        is_integer_constant_expression e2 >>= fun b12 ->
        is_address_constant e2            >>= fun b21 ->
        is_integer_constant_expression e1 >>= fun b22 ->
        E.return (b11 && b12 || b21 && b22)
    | AilEbinary e1 (Arithmetic Sub) e2 ->
        is_address_constant e1            >>= fun b11 ->
        is_integer_constant_expression e2 >>= fun b12 ->
        is_address_constant e2            >>= fun b21 ->
        is_integer_constant_expression e1 >>= fun b22 ->
        E.return (b11 && b12 || b21 && b22)
    | AilEstr _ ->
        E.return true
    | _ ->
        E.return false
  end
(* END predicates on Ail syntax *)




















type fundef =
  | IsFunDef
  | NotFunDef


type qs_ctype_builder =
  Ctype.qualifiers -> Ctype.ctype -> (Ctype.qualifiers * Ctype.ctype)


val desugar_struct_declaration:
  struct_declaration -> E.desugM (list (Symbol.identifier * (Annot.attributes * maybe Ctype.alignment * Ctype.qualifiers * Ctype.ctype)))

val desugar_struct_declarator:
  bool(* has_alignment *) -> struct_declarator -> E.desugM ((Annot.attributes * Symbol.identifier) * qs_ctype_builder)

val desugar_init_declarator_BROKEN:
  Ctype.qualifiers -> Ctype.ctype -> list storage_class_specifier -> init_declarator ->
  E.desugM (Symbol.identifier * bool * (Ctype.qualifiers * Ctype.ctype) *
            (unit -> E.desugM (maybe (Ctype.ctype * expression unit))))

val desugar_init_declarator:
  Annot.attributes ->
  bool(* isAtomic *) -> bool(* has_alignment *) ->
  Ctype.qualifiers -> Ctype.ctype ->
  list storage_class_specifier -> init_declarator ->
  E.desugM (maybe (Loc.t * Annot.attributes * linkage * ail_identifier * bool * (Ctype.qualifiers * Ctype.ctype) *
            (unit -> E.desugM (maybe (Ctype.ctype * expression unit)))))

val desugar_generic_association:
  cabs_generic_association -> E.desugM (generic_association unit)

val check_storage_class_specifiers:
  Loc.t -> declaration_context -> list storage_class_specifier -> E.desugM unit

val desugar_enumerator:
  enumerator -> E.desugM (Symbol.identifier * maybe (Loc.t * integer))

val desugar_alignment_specifier:
  Loc.t -> alignment_specifier -> E.desugM (maybe Ctype.alignment)

val desugar_parameter_type_list:
  fundef -> parameter_type_list -> E.desugM (maybe (list (maybe Symbol.identifier * (Ctype.qualifiers * Ctype.ctype * bool))) * bool)

val desugar_type_name:
  type_name -> E.desugM (Ctype.qualifiers * Ctype.ctype)

val desugar_initializer_:
  initializer_ -> E.desugM (expression unit)

val desugar_designator:
  designator -> E.desugM unit

val desugar_and_register_static_assert_declaration:
  static_assert_declaration -> E.desugM unit

val desugar_for_clause:
  for_clause -> E.desugM unit

(* TODO: WIP *)
val wip_desugar_initializer_:
  Loc.t -> storageDuration -> Ctype.ctype -> initializer_ -> E.desugM (Ctype.ctype * expression unit)

val _UNUSED_static_thread_implicit_initializer:
  map ail_identifier tag_definition -> Ctype.ctype -> constant



































val translate_integer_suffix: cabs_integer_suffix -> integerSuffix
let translate_integer_suffix = function
  | CabsSuffix_U   -> U
  | CabsSuffix_UL  -> UL
  | CabsSuffix_ULL -> ULL
  | CabsSuffix_L   -> L
  | CabsSuffix_LL  -> LL
end

val translate_integer_constant: cabs_integer_constant -> integerConstant
let translate_integer_constant (str, suff_opt) =
  let (basis, n) = Decode.decode_integer_constant str in
  match suff_opt with
    | Just suff -> IConstant n basis (Just (translate_integer_suffix suff))
    | Nothing   -> IConstant n basis Nothing
  end

val translate_floating_suffix: cabs_floating_suffix -> floatingSuffix
let translate_floating_suffix = function
  | CabsFloatingSuffix_F -> Fsuf_F
  | CabsFloatingSuffix_L -> Fsuf_L
end

val translate_floating_constant: cabs_floating_constant -> floatingConstant
let translate_floating_constant (str, suff_opt) =
  (str, maybe Nothing (Just -| translate_floating_suffix) suff_opt)


val translate_character_prefix: cabs_character_prefix -> characterPrefix
let translate_character_prefix = function
  | CabsPrefix_L -> Pref_L
  | CabsPrefix_u -> Pref_u
  | CabsPrefix_U -> Pref_U
end


val translate_character_constant: cabs_character_constant -> characterConstant
let translate_character_constant (pref_opt, str) =
  (maybe Nothing (Just -| translate_character_prefix) pref_opt, str)










val evaluate_integer_constant_expression: Loc.t -> maybe Ctype.ctype -> expression unit -> E.desugM integer
let evaluate_integer_constant_expression loc ty_opt expr =
  E.get_core_eval_stuff >>= fun core_env ->
  E.get_sigma_sofar >>= fun sigm ->
  E.liftException
      (Mini_pipeline.evalIntegerConstantExpression loc core_env sigm ty_opt expr)




















val translate_unary_operator: cabs_unary_operator -> unaryOperator
let translate_unary_operator = function
  | CabsAddress     -> Address
  | CabsIndirection -> Indirection
  | CabsPlus        -> Plus
  | CabsMinus       -> Minus
  | CabsBnot        -> Bnot
  (* This case cannot occurs since Not is translated away. *)
  | CabsNot         -> error "[Cabs_to_ail.translate_unary_operator] Not"
end


val translate_arithmetic_operator: cabs_binary_operator -> arithmeticOperator
let translate_arithmetic_operator = function
  | CabsAdd  -> Add
  | CabsSub  -> Sub
  | CabsMul  -> Mul
  | CabsDiv  -> Div
  | CabsMod  -> Mod
  | CabsBand -> Band
  | CabsBxor -> Bxor
  | CabsBor  -> Bor
  | CabsShl  -> Shl
  | CabsShr  -> Shr
  | _ -> error "[Cabs0_to_ail.translate_arithmetic_operator] should only be called on \
                operators allowed for compound assignments [ยง6.5.16#1]."
end


val translate_binary_operator: cabs_binary_operator -> binaryOperator
let translate_binary_operator = function
  | CabsAnd   -> And
  | CabsOr    -> Or
  | CabsEq    -> Eq
  | CabsNe    -> Ne
  | CabsLt    -> Lt
  | CabsGt    -> Gt
  | CabsLe    -> Le
  | CabsGe    -> Ge
  | op      -> Arithmetic (translate_arithmetic_operator op)
end


val translate_assignment_operator: cabs_assignment_operator -> maybe arithmeticOperator
let translate_assignment_operator = function
  | Assign      -> Nothing
  | Assign_Mul  -> Just Mul
  | Assign_Div  -> Just Div
  | Assign_Mod  -> Just Mod
  | Assign_Add  -> Just Add
  | Assign_Sub  -> Just Sub
  | Assign_Shl  -> Just Shl
  | Assign_Shr  -> Just Shr
  | Assign_Band -> Just Band
  | Assign_Bxor -> Just Bxor
  | Assign_Bor  -> Just Bor
end






val desugar_cabs_constant: Loc.t -> cabs_constant -> E.desugM constant
let desugar_cabs_constant loc = function
  | CabsInteger_const iCst ->
      E.return (ConstantInteger (translate_integer_constant iCst))
  | CabsFloating_const fCst ->
      E.return (ConstantFloating (translate_floating_constant fCst))
  | CabsCharacter_const cCst ->
      E.return (ConstantCharacter (translate_character_constant cCst))
end


val translate_cabs_encoding_prefix: cabs_encoding_prefix -> encodingPrefix
let translate_cabs_encoding_prefix = function
  | CabsEncPrefix_u8 ->
      Enc_u8
  | CabsEncPrefix_u ->
      Enc_u
  | CabsEncPrefix_U ->
      Enc_U
  | CabsEncPrefix_L ->
      Enc_L
end


val translate_cabs_string_literal: cabs_string_literal -> stringLiteral
let translate_cabs_string_literal (pref_opt, str) =
   (maybe Nothing (Just -| translate_cabs_encoding_prefix) pref_opt, str)

val string_of_string_literal: cabs_string_literal -> string
let string_of_string_literal (_, ss) =
  String.concat "" (List.map (fun (_, s) -> String.concat "" s) ss)


val project_base_type_specifier: cabs_type_specifier -> maybe (cabs_base_type_specifier * Loc.t)
let project_base_type_specifier (TSpec loc tspec) =
  match tspec with
    | TSpec_void ->
        Just (BTSpec_void, loc)
    | TSpec_char ->
        Just (BTSpec_char, loc)
    | TSpec_short ->
        Just (BTSpec_short, loc)
    | TSpec_int ->
        Just (BTSpec_int, loc)
    | TSpec_long ->
        Just (BTSpec_long, loc)
    | TSpec_float ->
        Just (BTSpec_float, loc)
    | TSpec_double ->
        Just (BTSpec_double, loc)
    | TSpec_signed ->
        Just (BTSpec_signed, loc)
    | TSpec_unsigned ->
        Just (BTSpec_unsigned, loc)
    | TSpec_Bool ->
        Just (BTSpec_Bool, loc)
    | TSpec_Complex ->
        Just (BTSpec_Complex, loc)
    | _ ->
        Nothing
   end


val     project_base_type_specifiers: list cabs_type_specifier -> maybe (list cabs_base_type_specifier * list Loc.t)
let rec project_base_type_specifiers_aux (acc_bts, acc_locs) = function
  | [] ->
      Just (List.reverse acc_bts, acc_locs)
  | spec :: specs' ->
      match project_base_type_specifier spec with
        | Just (z, loc) ->
            project_base_type_specifiers_aux (z::acc_bts, loc::acc_locs) specs'
        | Nothing ->
            Nothing
      end
  end
let project_base_type_specifiers =
  project_base_type_specifiers_aux ([], [])






(* TODO: this is temporary *)
val     _UNUSED_is_fully_non_designated: list (maybe (list designator) * initializer_) -> bool
let rec _UNUSED_is_fully_non_designated xs =
  List.all function
    | (Nothing, Init_expr _) ->
        true
    | (Nothing, Init_list _ xs') ->
        _UNUSED_is_fully_non_designated xs'
    | _ ->
        false
  end xs

(*
List.all (function
                            | (Nothing, Init_expr _)  -> true
                            | (Nothing, Init_list xs) -> List.all 
                            | _                       -> false
                          end)
*)





val desugar_basic_type_specifiers: list Loc.t -> Multiset.t cabs_base_type_specifier -> E.desugM (maybe (Loc.t * Ctype.basicType))
let desugar_basic_type_specifiers locs specs =
  let loc = Loc.bbox_location locs in
STD_ "ยง6.7.2#2, sentence 2 (non `void' case)" $
  if specs = Multiset.from_list [BTSpec_float; BTSpec_Complex] then
    (* STD ยง6.7.2#2, item 17 *)
    E.fail loc (Errors.Desugar_NeverSupported "_Complex types")
  else if specs = Multiset.from_list [BTSpec_double; BTSpec_Complex] then
    (* STD ยง6.7.2#2, item 18 *)
    E.fail loc (Errors.Desugar_NeverSupported "_Complex types")
  else if specs = Multiset.from_list [BTSpec_long; BTSpec_double; BTSpec_Complex] then
    (* STD ยง6.7.2#2, item 19 *)
    E.fail loc (Errors.Desugar_NeverSupported "_Complex types")
  
  else
    E.return $
      if specs = Multiset.from_list [BTSpec_char] then
        (* STD ยง6.7.2#2, item 2 *)
        Just (loc, Ctype.Integer Ctype.Char)
      else if specs = Multiset.from_list [BTSpec_signed; BTSpec_char] then
        (* STD ยง6.7.2#2, item 3 *)
        Just (loc, Ctype.Integer (Ctype.Signed Ctype.Ichar))
      else if specs = Multiset.from_list [BTSpec_unsigned; BTSpec_char] then
        (* STD ยง6.7.2#2, item 4 *)
        Just (loc, Ctype.Integer (Ctype.Unsigned Ctype.Ichar))
      else if List.any (fun z -> specs = z) [
                Multiset.from_list [BTSpec_short];
                Multiset.from_list [BTSpec_signed; BTSpec_short];
                Multiset.from_list [BTSpec_short; BTSpec_int];
                Multiset.from_list [BTSpec_signed; BTSpec_short; BTSpec_int] ] then
        (* STD ยง6.7.2#2, item 5 *)
        Just (loc, Ctype.Integer (Ctype.Signed Ctype.Short))
      else if List.any (fun z -> specs = z) [
                Multiset.from_list [BTSpec_unsigned; BTSpec_short];
                Multiset.from_list [BTSpec_unsigned; BTSpec_short; BTSpec_int] ] then
        (* STD ยง6.7.2#2, item 6 *)
        Just (loc, Ctype.Integer (Ctype.Unsigned Ctype.Short))
      else if List.any (fun z -> specs = z) [
                Multiset.from_list [BTSpec_int];
                Multiset.from_list [BTSpec_signed];
                Multiset.from_list [BTSpec_signed; BTSpec_int] ] then
        (* STD ยง6.7.2#2, item 7 *)
        Just (loc, Ctype.Integer (Ctype.Signed Ctype.Int_))
      else if List.any (fun z -> specs = z) [
                Multiset.from_list [BTSpec_unsigned];
                Multiset.from_list [BTSpec_unsigned; BTSpec_int] ] then
        (* STD ยง6.7.2#2, item 8 *)
        Just (loc, Ctype.Integer (Ctype.Unsigned Ctype.Int_))
      else if List.any (fun z -> specs = z) [
                Multiset.from_list [BTSpec_long];
                Multiset.from_list [BTSpec_signed; BTSpec_long];
                Multiset.from_list [BTSpec_long; BTSpec_int];
                Multiset.from_list [BTSpec_signed; BTSpec_long; BTSpec_int] ]then
        (* STD ยง6.7.2#2, item 9 *)
        Just (loc, Ctype.Integer (Ctype.Signed Ctype.Long))
      else if List.any (fun z -> specs = z) [
                Multiset.from_list [BTSpec_unsigned; BTSpec_long];
                Multiset.from_list [BTSpec_unsigned; BTSpec_long; BTSpec_int] ] then
        (* STD ยง6.7.2#2, item 10 *)
        Just (loc, Ctype.Integer (Ctype.Unsigned Ctype.Long))
      else if List.any (fun z -> specs = z) [
                Multiset.from_list [BTSpec_long; BTSpec_long];
                Multiset.from_list [BTSpec_signed; BTSpec_long; BTSpec_long];
                Multiset.from_list [BTSpec_long; BTSpec_long; BTSpec_int];
                Multiset.from_list [BTSpec_signed; BTSpec_long; BTSpec_long; BTSpec_int] ] then
        (* STD ยง6.7.2#2, item 11 *)
        Just (loc, Ctype.Integer (Ctype.Signed Ctype.LongLong))
      else if List.any (fun z -> specs = z) [
                Multiset.from_list [BTSpec_unsigned; BTSpec_long; BTSpec_long];
                Multiset.from_list [BTSpec_unsigned; BTSpec_long; BTSpec_long; BTSpec_int] ] then
        (* STD ยง6.7.2#2, item 12 *)
        Just (loc, Ctype.Integer (Ctype.Unsigned Ctype.LongLong))
      else if specs = Multiset.from_list [BTSpec_float] then
        (* STD ยง6.7.2#2, item 13 *)
        Just (loc, Ctype.Floating (Ctype.RealFloating Ctype.Float))
      else if specs = Multiset.from_list [BTSpec_double] then
        (* STD ยง6.7.2#2, item 14 *)
        Just (loc, Ctype.Floating (Ctype.RealFloating Ctype.Double))
      else if specs = Multiset.from_list [BTSpec_long; BTSpec_double] then
        (* STD ยง6.7.2#2, item 15 *)
        Just (loc, Ctype.Floating (Ctype.RealFloating Ctype.LongDouble))
      else if specs = Multiset.from_list [BTSpec_Bool] then
        (* STD ยง6.7.2#2, item 16 *)
        Just (loc, Ctype.Integer (Ctype.Bool))
      else
        Nothing


val translate_type_qualifiers: list cabs_type_qualifier -> bool * Ctype.qualifiers
let translate_type_qualifiers qs =
STD_ "ยง6.7.3#5" $ (* TODO: except for "or via one or more typedefs" *)
  ( List.elem Q_Atomic qs
  , Ctype.make_qualifiers
      (List.elem Q_const qs) (List.elem Q_restrict qs)
      (List.elem Q_volatile qs)  )














type under_array =
  | IsUnderArray
  | NotUnderArray



val desugar_array_declarator:
  under_array -> array_declarator -> E.desugM (Ctype.qualifiers -> Ctype.ctype -> (Ctype.qualifiers * Ctype.ctype))
val desugar_pointer_declarator:
  pointer_declarator -> E.desugM (Ctype.qualifiers -> Ctype.ctype -> (Ctype.qualifiers * Ctype.ctype))
val desugar_abstract_declarator:
  under_array -> abstract_declarator -> E.desugM (Ctype.qualifiers -> Ctype.ctype -> (Ctype.qualifiers * Ctype.ctype))
val desugar_direct_abstract_declarator:
  under_array -> direct_abstract_declarator -> E.desugM (Ctype.qualifiers -> Ctype.ctype -> (Ctype.qualifiers * Ctype.ctype))










(*
val arrayFromStringLiteral: maybe int -> stringLiteral -> expression unit
let arrayFromStringLiteral size_opt (pref_opt, strs) =
  let ns = List.map Decode.decode_character_constant strs in
  error "TODO"
  *)







let rec reduces_to_ddecl_identifier ddecltor =
  match ddecltor with
    | DDecl_identifier _ _ ->
        true
    | DDecl_declarator (Declarator Nothing ddecltor') ->
        reduces_to_ddecl_identifier ddecltor'
    | DDecl_declarator (Declarator (Just _) _) ->
        false
    | DDecl_array _ _ ->
        false
    | DDecl_function _ _ ->
        false
end









(* STD ยง6.7.2.1#3, except for the flexible array part *)
let check_members membrDefs =
  E.mapM_ (fun (ident, (_, _, qs, ty)) ->
    if AilTypesAux.is_function ty then
      E.constraint_violation (Loc.locOf ident) (StructMemberFunctionType ident)
    else
      E.is_incomplete ty >>= function
        | true ->
            E.constraint_violation (Loc.locOf ident) (StructMemberIncompleteType qs ty)
        | false ->
            E.return ()
      end
  ) membrDefs

type struct_or_union =
  | STRUCT
  | UNION


type stmt_context = <|
  (* switch_stack: list switch_info; *)
  cont_ident_opt: maybe Symbol.identifier; (* Just ..., if inside a loop *)
|>


val     desugar_type_specifiers: list cabs_type_specifier -> E.desugM (Ctype.qualifiers * Ctype.ctype)
let rec desugar_type_specifiers specs =
  match project_base_type_specifiers specs with
    | Just (z, locs) ->
        desugar_basic_type_specifiers locs (Multiset.from_list z)
    | Nothing ->
        E.return Nothing
  end >>= function
    | Just (loc, bty) ->
        E.return (Ctype.no_qualifiers, Ctype.Ctype [Annot.Aloc loc] (Ctype.Basic bty))
    | Nothing ->
        let desugar_new_struct_or_union loc attrs struct_or_union tag_ident_opt sdecls =
          let (kind_ctor, (*def_ctor, *)type_ctor) =
            match struct_or_union with
              | STRUCT ->
                  (E.Kind_struct, fun sym -> Ctype.Ctype [Annot.Aloc loc] (Ctype.Struct sym))
              | UNION ->
                  (E.Kind_union, fun sym -> Ctype.Ctype [Annot.Aloc loc] (Ctype.Union sym))
            end in
          (* STD ยง6.7.2.1#8, sentence 1 *)
          (* NOTE: the std say that because we have a 'Just sdecls', a new
             type is being declared within the translation unit *)
          E.register_tag loc kind_ctor tag_ident_opt >>= fun tag_sym ->
          (* TODO: check that is indeed the UB I'm thinking of... *)
          List.concat <$> E.mapM desugar_struct_declaration sdecls >>= fun all_membDefs ->
          
          (* Checks whether a member identifier is duplicated *)
          E.foldlM (fun acc (ident, _) ->
            if List.elem ident acc then
              E.fail (Loc.locOf ident) (Errors.Desugar_TODO ("duplicate member: " ^ show ident))
            else
              E.return (ident :: acc)
          ) [] all_membDefs >>= fun _ ->
          
          begin
            if List.length all_membDefs = 0 && struct_or_union = UNION then
              (* STD ยง6.7.2.1#8, sentence 3 *)
              E.undef loc Undefined.UB061_no_named_members
            else if List.length all_membDefs = 1 || struct_or_union = UNION then
              check_members all_membDefs >>= fun _ ->
              E.return Nothing
            else match Utils.last all_membDefs with
              | Nothing ->
                  (* xs was an empty list *)
                  (* STD ยง6.7.2.1#8, sentence 3 *)
                  E.undef loc Undefined.UB061_no_named_members
              | Just ((last_ident, (lastMemb_attrs, _, lastMemb_qs, lastMemb_ty)), membDefs) ->
                  (* STD ยง6.7.2.1#3 *)
                  check_members membDefs >>
                  if AilTypesAux.is_function lastMemb_ty then
                      E.constraint_violation (Loc.locOf last_ident) (StructMemberFunctionType last_ident)
                  else
                    E.is_incomplete lastMemb_ty >>= function
                      | true ->
                          if struct_or_union = STRUCT then
                            match lastMemb_ty with
                              | Ctype.Ctype _ (Ctype.Array elem_ty Nothing) ->
                                  (* if we have an array with unknown size *)
                                  if List.length all_membDefs = 1 then
                                    E.constraint_violation (Loc.locOf last_ident) (IllegalFlexibleArrayMember last_ident)
                                  else
                                    E.return (Just (membDefs, Ctype.FlexibleArrayMember lastMemb_attrs last_ident lastMemb_qs elem_ty))
                              | _ ->
                                  E.constraint_violation (Loc.locOf last_ident) (StructMemberIncompleteType lastMemb_qs lastMemb_ty)
                            end
                          else
                            E.constraint_violation (Loc.locOf last_ident) (StructMemberIncompleteType lastMemb_qs lastMemb_ty)
                      | false ->
                          E.return Nothing
                    end
            end
          end >>= fun flexible_opt ->
          let loc = match tag_ident_opt with
            | Nothing ->
                loc
            | Just tag_ident ->
                Loc.with_cursor_from loc (Loc.locOf tag_ident)
          end in
          E.register_tag_definition loc tag_sym
            match (struct_or_union, flexible_opt) with
              | (UNION, _) ->
                  Union_definition loc attrs (isNothing tag_ident_opt) all_membDefs
              | (STRUCT, Nothing) ->
                  Struct_definition loc attrs (isNothing tag_ident_opt) all_membDefs Nothing
              | (STRUCT, Just (membDefs', flexible)) ->
                  Struct_definition loc attrs (isNothing tag_ident_opt) membDefs' (Just flexible)
            end >>= fun () ->
          E.return (Ctype.no_qualifiers, type_ctor tag_sym) in
        match specs with
            (* NOTE: The parser does not generate a declaration without a type specifier *)
          | [] ->
              STD_ "ยง6.7.2#2, sentence 1"
                E.constraint_violation Loc.unknown NoTypeSpecifierInDeclaration
          
          | [TSpec loc TSpec_void] ->
              STD_ "ยง6.7.2#2, sentence 2 (`void' case)"
                E.return (Ctype.no_qualifiers, Ctype.Ctype [Annot.Aloc loc] Ctype.Void)
          
            (* NOTE: The parser does not generate such enum *)
          | [TSpec _ (TSpec_enum Nothing Nothing)] ->
              error "TSpec_enum Nothing, Nothing"
          
            (* NOTE: The parser does not generate such struct *)
          | [TSpec _ (TSpec_struct _ Nothing Nothing)] ->
              error "TSpec_struct Nothing, Nothing"
          
            (* NOTE: The parser does not generate such union *)
          | [TSpec _ (TSpec_union _ Nothing Nothing)] ->
              error "TSpec_union Nothing, Nothing"
          
          | [TSpec loc (TSpec_enum (Just tag_ident) Nothing)] ->
              (* NOTE: 'desugar_type_specifiers' must NOT be called on a
                 specifier occurring in the form described by ยง6.7.2.3#7 (FOOTNOTE 131) *)
              E.resolve_extraordinary_identifier tag_ident E.Namespace_tag >>= function
                | Just (_, (tag_sym, _)) ->
                    STD_ "ยง6.7.2.3#9"
                    E.return ( Ctype.no_qualifiers
                             , Ctype.Ctype [Annot.Aloc loc] (Ctype.Basic (Ctype.Integer (Ctype.Enum tag_sym))) )
                | Nothing ->
                    E.constraint_violation loc EnumTagIncomplete
              end
          
          | [TSpec loc (TSpec_struct attrs (Just tag_ident) Nothing)] ->
              if attrs <> Annot.no_attributes then
                E.fail loc (Errors.Desugar_TODO "Attribute constraint violation ==> N2335 6.7.2.1#6 and 6.7.2.3#4")
              else
                (* NOTE: 'desugar_type_specifiers' must NOT be called on a
                   specifier occurring in the form described by ยง6.7.2.3#7 *)
                E.resolve_extraordinary_identifier tag_ident E.Namespace_tag >>= function
                  | Just (_, (tag_sym, E.Kind_tag E.Kind_struct)) ->
                      STD_ "ยง6.7.2.3#9"
                        E.return (Ctype.no_qualifiers, Ctype.Ctype [] (Ctype.Struct tag_sym))
                  | Just (_, (tag_sym, _)) ->
                      E.constraint_violation loc (TagRedeclaration tag_sym)
                  | Nothing ->
                      (* STD ยง6.7.2.3#8 *)
                      (* TODO: check, but this seems right *)
                      E.register_tag loc E.Kind_struct (Just tag_ident) >>= fun tag_sym ->
                      E.return (Ctype.no_qualifiers, Ctype.Ctype [Annot.Aloc loc] (Ctype.Struct tag_sym))
                end
          
          | [TSpec loc (TSpec_union attrs (Just tag_ident) Nothing)] ->
              (* NOTE: 'desugar_type_specifiers' must NOT be called on a
                 specifier occurring in the form described by ยง6.7.2.3#7 *)
              E.resolve_extraordinary_identifier tag_ident E.Namespace_tag >>= function
                | Just (_, (tag_sym, E.Kind_tag E.Kind_union)) ->
                    STD_ "ยง6.7.2.3#9"
                      E.return (Ctype.no_qualifiers, Ctype.Ctype [] (Ctype.Union tag_sym))
                | Just (_, (tag_sym, _)) ->
                    E.constraint_violation loc (TagRedeclaration tag_sym)
                | Nothing ->
                    (* STD ยง6.7.2.3#8 *)
                    (* TODO: check, but this seems right *)
                    E.register_tag loc E.Kind_union (Just tag_ident) >>= fun tag_sym ->
                    E.return (Ctype.no_qualifiers, Ctype.Ctype [Annot.Aloc loc] (Ctype.Union tag_sym))
              end
          
          | [TSpec loc (TSpec_struct attrs tag_ident_opt (Just sdecls))] ->
              desugar_new_struct_or_union loc attrs STRUCT tag_ident_opt sdecls
          
          | [TSpec loc (TSpec_union attrs tag_ident_opt (Just sdecls))] ->
              desugar_new_struct_or_union loc attrs UNION tag_ident_opt sdecls
          
          | [TSpec loc (TSpec_Atomic tyname)] ->
              desugar_type_name tyname >>= fun (qs, ty) ->
              (* STD ยง6.7.2.4#3 *)
              (* TODO: shouldn't this be done by the Ail typing? *)
              if    AilTypesAux.is_array ty
                 || AilTypesAux.is_function ty
                 || AilTypesAux.is_atomic ty
                 || not (AilTypesAux.is_unqualified qs) then
                E.constraint_violation loc AtomicTypeConstraint
              else
                E.is_incomplete ty >>= function
                  | true ->
                      E.constraint_violation loc AtomicTypeConstraint
                  | false ->
                        (* TODO: qualifiers *)
                        E.return (qs, Ctype.Ctype [Annot.Aloc loc] (Ctype.Atomic ty))
                end
          
          | [TSpec loc (TSpec_enum tag_ident_opt (Just enums))] ->
              E.register_tag loc E.Kind_enum tag_ident_opt >>= fun tag_sym ->
              register_enumerators loc tag_sym enums >>= fun ns_rev ->
              (* NOTE: this function doesn't care about the order of the integers *)
              E.register_tag_definition loc tag_sym (Enum_definition ns_rev) >>
              E.return (Ctype.no_qualifiers, Ctype.Ctype [Annot.Aloc loc] (Ctype.Basic (Ctype.Integer (Ctype.Enum tag_sym))))
          
          (* *)
          | [TSpec _ (TSpec_name ((Symbol.Identifier cid_loc str) as ident))] ->
              E.print_debugM 2 (fun () -> "Cabs_to_ail, TSpec_name ==> " ^ str) >>
              match Builtins.translate_builtin_typenames str with
                | Just ty ->
                    E.return (Ctype.no_qualifiers, ty)
                | Nothing ->
                    (* TODO: check the namespace *)
                    E.resolve_ordinary_identifier cid_loc ident >>= function
                      | Just (_, E.OReg_typedef sym) ->
                          E.resolve_typedef sym >>= fun (attrs, qs, Ctype.Ctype _ ty) ->
                          E.return (qs, Ctype.Ctype [Annot.Aloc cid_loc; Annot.Atypedef sym] ty)
                      | Just _ ->
                          E.fail cid_loc (Errors.Desugar_NotYetSupported "TODO: Tspec_name, not King_typedef")
                      | Nothing ->
                          E.fail cid_loc (Errors.Desugar_NotYetSupported "TODO: Tspec_name, not resolved")
                    end
              end

          | [TSpec loc (TSpec_typeof_expr e)] ->
              desugar_expression e >>= fun d_e  ->
              E.get_sigma_sofar    >>= fun sigm ->
              E.get_gamma_sofar    >>= fun gamm ->
              match ErrorMonad.runErrorMonad (GenTyping.annotate_expression (GenTyping.annotate_block Nothing) sigm gamm GenTyping.CTXsizeof d_e) with
              | Left (loc, err) ->
                  E.fail_ailtyping loc err
              | Right a_expr ->
                  (* TODO: this is fixing an integer implementation... *)
                  let (qs, ty) = Translation_aux.qualified_ctype_of a_expr in
                  E.return (qs, ty)
              end

          | [TSpec loc (TSpec_typeof_type tyname)] ->
              desugar_type_name tyname
          
          | _ ->
              let loc = Loc.bbox_location (List.map Loc.locOf specs) in
              E.constraint_violation loc IllegalTypeSpecifierInDeclaration
        end
end


(* val register_enumerators: Symbol.sym -> list enumerator -> E.desugM unit *)
and register_enumerators tag_loc tag_sym enums =
  (* STD ยง6.7.2.2#3 *)
  E.foldlM (fun (current_n, acc) enum ->
    desugar_enumerator enum >>= fun (ident, loc_n_opt) ->
    let (loc, n) = match loc_n_opt with
      | Nothing ->
          (Loc.other "TODO: register_enumerators", current_n)
      | Just loc_n ->
          loc_n
    end in
    begin if Global.isAgnostic () then
      let minimal_int_range = IntegerImpl.min_integer_range (Ctype.Signed Ctype.Int_) in
      if Range.mem n minimal_int_range then
        E.return ()
      else
        E.fail loc (Errors.Desugar_agnosticFailure "enumerator constant out of bound of the minimal range for 'signed int'")
    else
      (* TODO: need to check if 'n' is in range of 'signed int' using the current integer implementation *)
      (* if Mini_pipeline.in_range_of_signed_int n then
        E.return ()
      else
        E.constraint_violation loc WrongTypeEnumConstant *)
      E.return ()
    end >>= fun () ->
    let d_e =
      AilEannot Ctype.signed_int (
        AnnotatedExpression () ["ยง6.7.2.2#3"] loc (
          AilEconst (ConstantInteger (IConstant n Decimal Nothing))
        )
      ) in
    (* STD ยง6.2.1#7, sentence 2 *)
    (* the scope  of an enumeration constant start just after it's appearance in
       the enumerator list *)
    E.register_enum_constant ident d_e >>
    E.return (n + 1, n :: acc)
  ) (0, []) enums >>= fun (_, ns_rev) ->
  E.return ns_rev







(*
int                                     int
int *                                   pointer to int
int *[3]                                array of three pointers to int
int ( * )[3]                            pointer to an array of three ints
int ( * )[*]                            pointer to a variable length array of an unspecified number of ints,
int *()                                 function with no parameter specification returning a pointer to int
int ( * )(void)                         pointer to function with no parameters returning an int
int ( * const [])(unsigned int, ...)    array of an unspecified number of constant pointers to functions, each with
                                        one parameter that has type unsigned int and an unspecified number of other
                                        parameters, returning an int.



*)












and desugar_array_declarator under_array (ADecl loc tquals is_static a_decltor_size_opt) =
  let (isAtomic, tquals_qs) = translate_type_qualifiers tquals in
  (* NOTE: if we are in prototype scope, then we are dealing with
     a function parameter *)
  E.get_scope >>= function
     | E.Scope_prototype _ ->
         if under_array = IsUnderArray && (tquals <> [] || is_static) then
STD_ "ยง6.7.6.2#1, sentence 5, not outermost" $
           E.constraint_violation loc ArrayDeclarationQsAndStaticOnlyOutmost
         else
           (* TODO: check, but after rereading the STD I think adjustment should only
              happen when the whole type of a parameter is "array of". But NOT for the
              inner array types. (Hence the commented code) *)
(*
           (* STD ยง6.7.6.3#7, sentence 1 *)
           E.return (fun qs ty ->
             match ty with
               | Ctype.Array elem_ty _ ->
                   (* NOTE: these are the qualifiers of the pointer *)
                   ( Ctype.combine_qualifiers qs tquals_qs
                   , (if isAtomic then Ctype.Atomic else id) (Ctype.Pointer Ctype.no_qualifiers elem_ty) )
               | ty ->
                   (qs, ty)
             end)
*)
           E.return (fun qs ty ->
             ( Ctype.combine_qualifiers qs tquals_qs
             , (if isAtomic then Ctype.mk_ctype_atomic else id) ty )
           )

     | _ ->
         if tquals <> [] || is_static then
STD_ "ยง6.7.6.2#1, sentence 5, not function parameter" $
           E.constraint_violation loc ArrayDeclarationQsAndStaticOutsideFunctionProto
         else
           (* not dealing with a parameter, so no adjustement needed *)
           E.return (fun qs ty -> (qs, ty))
  end >>= fun perform_adjust ->
  
  (* TODO: is_static not yet supported *)
  if is_static then
    E.fail loc (Errors.Desugar_NotYetSupported "array parameter with the static keyword")
  
  else match a_decltor_size_opt with
    | Just (ADeclSize_expression e) ->
        (* here the array declarator: has no qualifiers, is not static, and has
           a size expression *)
        (* STD ยง6.7.6.2#4, sentence 3 *)
        desugar_expression e >>= fun d_e ->
        is_integer_constant_expression d_e >>= function
          | false ->
              E.fail loc (Errors.Desugar_NotYetSupported "variable length array type 2")
          | true ->
             (* STD ยง6.7.6.2#1, sentence 2 *)
             (* NOTE: the preceding STD clause is performed by a typecheck done by
                [Mini_pipeline.evalIntegerConstantExpression] *)
             evaluate_integer_constant_expression loc Nothing d_e >>= fun n ->
              if n <= 0 then
                E.constraint_violation loc ArrayDeclarationNegativeSize
              else
                E.return (fun qs ty -> perform_adjust qs (Ctype.Ctype [Annot.Aloc loc] (Ctype.Array ty (Just n))))
        end
    
    | Just ADeclSize_asterisk ->
        E.get_scope >>= function
          | E.Scope_prototype _ ->
              (* STD ยง6.7.6.2#4, sentence 2 *)
              E.fail loc (Errors.Desugar_NotYetSupported "variable length array type")
          | _ ->
              E.fail loc (Errors.Desugar_MiscViolation Errors.ArrayDeclarationStarIllegalScope)
        end
    
    | Nothing ->
        (* here the array declarator: has no size expression *)
        E.return (fun qs ty -> perform_adjust qs (Ctype.Ctype [Annot.Aloc loc] (Ctype.Array ty Nothing)))
  end


(* TYPE: pointer_declarator -> E.desugM (Ctype.qualifiers -> Ctype.ctype -> (Ctype.qualifiers * Ctype.ctype)) *)
and desugar_pointer_declarator (PDecl ptr_loc tquals ptr_decltor_opt)  =
  (* if ptr_decltor_opt = Nothing, these qualifiers are of the current pointer
     type we are building; otherwise, they are of the referenced type of the
     inner [ptr_decltor] *)
  let (isAtomic, tquals_qs) = translate_type_qualifiers tquals in
  let mk_pointer_ctype ref_qs (Ctype.Ctype annots _ as ref_ty) =
    let loc = Loc.bbox_location [Annot.get_loc_ annots; ptr_loc] in
    (if isAtomic then Ctype.mk_ctype_atomic else id) (Ctype.Ctype [Annot.Aloc loc] (Ctype.Pointer ref_qs ref_ty)) in
  (* STD  ยง6.7.6.1#1 *)
  match ptr_decltor_opt with
    (* in this case [tquals_qs] are the qualifiers of the referenced type of
       the inner [ptr_decltor] *)
    | Just ptr_decltor ->
        (* the INNER [ptr_decltor] gets desugared to an OUTER pointer type,
           and [tquals_qs] are the qualifiers of the referenced type that OUTER
           pointer type *)
        desugar_pointer_declarator ptr_decltor >>= fun mk_outer_pointer_ctype ->
        E.return (
          fun base_qs base_ty ->
            mk_outer_pointer_ctype tquals_qs (mk_pointer_ctype base_qs base_ty)
        )
    | Nothing ->
        (* in this case [tquals_qs] are the qualifiers of the pointer type we
           are currently building *)
        E.return (
          fun base_qs base_ty -> (tquals_qs, mk_pointer_ctype base_qs base_ty)
        )
  end


and desugar_abstract_declarator under_array = function
  | AbsDecl_pointer ptr_decltor ->
      desugar_pointer_declarator ptr_decltor
  | AbsDecl_direct ptr_decltor_opt dabs_decltor ->
      maybe (E.return (fun qs ty -> (qs, ty))) desugar_pointer_declarator
        ptr_decltor_opt >>= fun mk_pointer_qs_ctype ->
      desugar_direct_abstract_declarator under_array dabs_decltor >>= fun mk_qs_ctype ->
      E.return (
        fun base_qs base_ty ->
          let (ptr_qs, ptr_ty) = mk_pointer_qs_ctype base_qs base_ty in
          mk_qs_ctype ptr_qs ptr_ty
      )
end


and desugar_direct_abstract_declarator under_array = function
  | DAbs_abs_declarator abs_decltor ->
      desugar_abstract_declarator under_array abs_decltor
  | DAbs_array dabs_decltor_opt a_decltor ->
      (* NOTE: the recursive call is "under an array" declaration *)
      maybe (E.return (fun qs ty -> (qs, ty)))
        (desugar_direct_abstract_declarator IsUnderArray) dabs_decltor_opt >>= fun mk_outer_qs_ctype ->
      desugar_array_declarator under_array a_decltor                       >>= fun mk_array_qs_ctype ->
      E.return (
        fun base_qs base_ty ->
          let (array_qs, array_ty) = mk_array_qs_ctype base_qs base_ty in
          mk_outer_qs_ctype array_qs array_ty
      )
  | DAbs_function dabs_decltor_opt param_tys ->
      (* TODO: documentation (the code the same as for desugar_direct_declarator, DDecl_function *)
      maybe (E.return (fun qs ty -> (qs, ty)))
        (desugar_direct_abstract_declarator under_array) dabs_decltor_opt >>= fun mk_qs_ctype ->
      E.fresh_prototype_scope >>= fun proto_scope ->
      E.under_scope proto_scope
        (desugar_parameter_type_list NotFunDef param_tys) >>= fun (params_opt, isVariadic) ->
      match params_opt with
        (* TODO: isn't this dead code ? *)
        | Just [(Nothing, (qs, Ctype.Ctype annots Ctype.Void, _))] ->
            if not (AilTypesAux.is_unqualified qs) then
              let () = Debug.warn [Debug.DB_desugaring] (fun () ->
                "(UNSURE) forbidding the 'void' parameter to have qualifiers") in
              (* NOTE: I can't find if the STD actually requires this, but
                 allowing qualifiers would be meaningless and compilers (at
                 least clang and gcc) do the same *)
              E.undef (Annot.get_loc_ annots) Undefined.UB078_modified_void_parameter
            else
              (* STD ยง6.7.6.3#10 *)
              E.return (Just [])
        | Just params ->
            E.return (
              Just begin
                List.map (fun (_, (qs, ty, isRegister)) ->
                  (qs, ty, isRegister)
                ) params
              end
            )
        | Nothing ->
            E.return Nothing
      end >>= fun params_opt ->
      let mk_fun_ctype ret_qs_ty =
        match params_opt with
          | Nothing ->
              Ctype.FunctionNoParams ret_qs_ty
          | Just params ->
              Ctype.Function ret_qs_ty params isVariadic
        end in
      (* TODO: this is morally wrong: it should check that we are not building
        a function type returning a function or an array. Technically, the
        Ail typing does catch that error afterwards, but it's still tasteless *)
      E.return (
      fun base_qs base_ty ->
        mk_qs_ctype Ctype.no_qualifiers
          (Ctype.Ctype [] (mk_fun_ctype (base_qs, base_ty)))
      )
end

(* TYPE: E.desugM (Symbol.identifier * (Ctype.qualifiers -> Ctype.ctype -> (Ctype.qualifiers * Ctype.ctype))) *)
and desugar_direct_declarator fundef under_array = function
  | DDecl_identifier attrs ident ->
      E.return ((attrs, ident), fun base_qs base_ty -> (base_qs, base_ty))
  
  | DDecl_declarator decltor ->
      desugar_declarator fundef decltor
  
  | DDecl_array ddecltor a_decltor ->
      (* NOTE: the recursive call is "under an array" declaration *)
      desugar_direct_declarator fundef IsUnderArray ddecltor >>= fun (attrs_ident, mk_outer_qs_ctype) ->
      desugar_array_declarator under_array a_decltor         >>= fun mk_array_qs_ctype          ->
      E.return ( attrs_ident
               , fun base_qs base_ty ->
                   let (array_qs, array_ty) = mk_array_qs_ctype base_qs base_ty in
                   mk_outer_qs_ctype array_qs array_ty )
  
  | DDecl_function ddecltor param_tys ->
      let fundef' =
        match fundef with
          | IsFunDef ->
              if reduces_to_ddecl_identifier ddecltor then
                IsFunDef
              else
                NotFunDef
          | _ ->
              NotFunDef
        end in
      (* TODO: check the NotFunDef *)
      desugar_direct_declarator fundef under_array ddecltor >>= fun (attrs_ident, mk_qs_ctype) ->
      match fundef' with
        | IsFunDef ->
            desugar_parameter_type_list fundef' param_tys
        | NotFunDef ->
            E.fresh_prototype_scope >>= fun proto_scope ->
            E.under_scope proto_scope
              (desugar_parameter_type_list fundef' param_tys)
      end >>= fun (_params_opt, isVariadic) ->
      let params_opt =
        (* NOTE2: but our current parser doesn't support identifier-list (this is an old syntax) *)
        match _params_opt with
          | Just _params ->
              Just begin 
                List.map (fun (_, (qs, ty, isRegister)) ->
                  (qs, ty, isRegister)
                ) _params
              end
          | Nothing ->
              Nothing
        end in
      (* TODO: this is morally wrong: it should check that we are not building
         a function type returning a function or an array. Technically, the
         Ail typing does catch that error afterwards, but it's still tasteless *)
      let mk_fun_ctype ret_qs_ty =
        match params_opt with
          | Nothing ->
              Ctype.FunctionNoParams ret_qs_ty
          | Just params ->
              Ctype.Function ret_qs_ty params isVariadic
        end in
      E.return ( attrs_ident
               , fun base_qs base_ty ->
                   mk_qs_ctype Ctype.no_qualifiers
                     (Ctype.Ctype [Annot.Aloc (Loc.locOf ddecltor)] (mk_fun_ctype (base_qs, base_ty))) )
end



and desugar_parameter_type_list fundef (Params param_decls isVariadic) =
  match param_decls with
    | [] ->
        E.return Nothing
    | x::xs ->
        desugar_parameter_declaration (* is_first *)true fundef x >>= fun p  ->
        E.mapM (desugar_parameter_declaration false fundef) xs    >>= fun ps ->
        E.return (Just (p::ps))
  end >>= fun params_opt ->
  
  match params_opt with
    | Just [(Nothing, (qs, Ctype.Ctype annots Ctype.Void, isRegister))] ->
        (* NOTE: the (illegal) case where there is a identifier is dealt with
           inside 'desugar_parameter_declaration' *)
        if not (AilTypesAux.is_unqualified qs) || isRegister then
          (* NOTE: this is undefined according to annex J.2, though
             I don't undestand why when reading the text (at ยง6.7.6.3) *)
          E.undef (Annot.get_loc_ annots) Undefined.UB078_modified_void_parameter
        else
          (* STD ยง6.7.6.3#10 *)
          E.return (Just [], isVariadic)
    | _ ->
        E.return (params_opt, isVariadic)
  end


and desugar_parameter_declaration is_first fundef param_decl =
  match param_decl with
    | PDeclaration_decl specifs decltor ->
        let decltor_loc = Loc.locOf decltor in
        if List.any (fun sc -> sc <> SC_register) specifs.storage_classes then
          E.constraint_violation decltor_loc IllegalStorageClassFunctionDeclarator
        else if specifs.alignment_specifiers <> [] then
          E.constraint_violation decltor_loc (IllegalAlignas IllegalAlignas_parameter)
        else
          (* NOTE: specs_qs <> no_qualifiers when the specifiers had a type-name or _Atomic *)
          desugar_type_specifiers specifs.type_specifiers >>= fun (specs_qs, base_ty)       ->
          desugar_declarator NotFunDef decltor            >>= fun ((_, ident), mk_qs_ctype) ->
          let (isAtomic, tquals_qs) = translate_type_qualifiers specifs.type_qualifiers in
          (* STD ยง6.9.1#7, sentence 4 *)
          let (_qs, _ty) =
            mk_qs_ctype (Ctype.combine_qualifiers specs_qs tquals_qs) base_ty in
          
          if AilTypesAux.is_void _ty then
            match fundef with
              | IsFunDef ->
                  E.constraint_violation decltor_loc IllegalIdentifierTypeVoidInFunctionDefinition
              | NotFunDef ->
                  (* STD ยง6.7#7 *)
                  (* NOTE: this paragraph applies here because identifiers declared to
                     be a function parameter have no linkage *)
                  E.undef decltor_loc Undefined.UB059_incomplete_no_linkage_identifier
            end
          else
            let (qs, ty) = AilTypesAux.adjust _qs _ty in
            E.is_incomplete ty >>= function
              | true ->
                  match fundef with
                    | IsFunDef ->
                        (* STD ยง6.9.1#7, sentence 4 *)
                        (* NOTE(TODO): at the same time, ยง6.7.6.3#4 seems to
                           make this a constraint violation, but then there is
                           also ยง6.7#7 that should apply here (making it UB
                           afterall) ... *)
                        E.undef decltor_loc Undefined.UB086_incomplete_adjusted_parameter
                    | NotFunDef ->
                        (* NOTE: ยง6.7.6.3#12, explicitly says non-fundef can have
                           incomplete (adjusted) parameter types, but I assume they
                           only mean this so unammed ones?? *)
                        (* STD ยง6.7#7 *)
                        (* NOTE: this paragraph applies here because identifiers declared to
                           be a function parameter have no linkage *)
                        E.undef decltor_loc Undefined.UB059_incomplete_no_linkage_identifier
                  end
              | false ->
                  let isRegister = List.elem SC_register specifs.storage_classes in
                  let scs = specifs.storage_classes in
                  E.register_ordinary_identifier ident (E.OK_object true) scs >>= fun (link, sym) ->
                  (* TODO: check this registration *)
                  let dur = determinate_storage_duration link scs in
                  E.register_internal_object_declaration sym (Loc.locOf ident, dur, isRegister, Nothing, qs, ty) >>
                  E.return (Just ident, ( qs
                                      , if isAtomic then Ctype.mk_ctype_atomic ty else ty
                                      , isRegister ))
            end
    | PDeclaration_abs_decl specifs abs_decltor_opt ->
        (* TODO: Should position of storage classes be tracked? *)
        let loc = Loc.bbox_location (List.map Loc.locOf specifs.type_specifiers) in
        if List.any (fun sc -> sc <> SC_register) specifs.storage_classes then
          E.constraint_violation loc IllegalStorageClassFunctionDeclarator
        else if specifs.alignment_specifiers <> [] then
          E.constraint_violation loc (IllegalAlignas IllegalAlignas_parameter)
        else
          (* NOTE: specs_qs <> no_qualifiers when the specifiers had a type-name or _Atomic *)
          desugar_type_specifiers specifs.type_specifiers >>= fun (specs_qs, base_ty)  ->
          maybe (E.return (fun qs ty -> (qs, ty)))
            (desugar_abstract_declarator NotUnderArray) abs_decltor_opt >>= fun mk_qs_ctype ->
          let (isAtomic, tquals_qs) = translate_type_qualifiers specifs.type_qualifiers in
          (* STD ยง6.9.1#7, sentence 4 *)
          let (_qs, _ty) =
            mk_qs_ctype (Ctype.combine_qualifiers specs_qs tquals_qs) base_ty in
          let (qs, ty) = AilTypesAux.adjust _qs _ty in
          let ret = (Nothing, ( qs
                              , if isAtomic then Ctype.mk_ctype_atomic ty else ty
                              , List.elem SC_register specifs.storage_classes )) in
          match fundef with
            | IsFunDef ->
                if not (is_first && AilTypesAux.is_void ty) then
                  E.constraint_violation (Loc.locOf ty) UniqueVoidParameterInFunctionDefinition
                else
                  E.return ret
            | NotFunDef ->
                if not is_first && AilTypesAux.is_void ty then
                  (* TODO: check this *)
                  E.fail (Loc.locOf ty) (Errors.Desugar_MiscViolation Errors.UniqueVoidParameterInFunctionDeclaration)
                else
                  (* NOTE: base on ยง6.7.6.3#12, this allows incomplete types *)
                  E.return ret
          end
  end




(* TYPE: E.desugM (Symbol.identifier * (AilTypes.qualifiers -> AilTypes.ctype -> (AilTypes.qualifiers * AilTypes.ctype))) *)
and desugar_declarator fundef (Declarator ptr_decltor_opt ddecltor) =
  maybe (E.return (fun qs ty -> (qs, ty))) desugar_pointer_declarator
    ptr_decltor_opt >>= fun mk_pointer_qs_ctype ->
  desugar_direct_declarator fundef NotUnderArray ddecltor >>= fun (attrs_ident, mk_qs_ctype) ->
  (* TODO: check, but seems correct *)
  E.return ( attrs_ident
           , fun base_qs base_ty ->
               let (ptr_qs, ptr_ty) = mk_pointer_qs_ctype base_qs base_ty in
               mk_qs_ctype ptr_qs ptr_ty )



























(* val     desugar_expression: cabs_expression -> E.desugM (expression unit) *)
and desugar_expression (CabsExpression loc expr) =
  AnnotatedExpression () [] loc <$>
  match expr with
    | CabsEident ident ->
        let (Symbol.Identifier _ str) = ident in (* DEBUG *)
        E.print_debugM 2 (fun () -> "DESUGARING, CabsEident: " ^ str) >>= fun () -> (* DEBUG *)
STD_ "ยง6.5.1#2" $
        E.resolve_ordinary_identifier loc ident >>= function
          | Just (_, E.OReg_enum_constant sym) ->
              E.resolve_enum_constant sym
          | Just (_, E.OReg_typedef _) ->
              E.fail (Loc.locOf ident) (Errors.Desugar_MiscViolation (Errors.UndeclaredIdentifier (show ident)))
          | Just (scope, E.OReg_other sym kind _) ->
              (* I love the fact that it is a footnote that says that undeclared
                 identifiers are syntax errors ... *)
              E.scope_is_visible scope >>= fun is_visible ->
              if not is_visible || not (E.is_object_kind kind || kind = E.OK_function) then
                E.fail (Loc.locOf ident) (Errors.Desugar_MiscViolation (Errors.UndeclaredIdentifier (show ident)))
              else
                E.add_used_identifier sym >>
                (* TODO(check): this is to let the Ail typechecker know about
                   identifiers used before their type have been completed *)
                (* TODO: only had that annotation if sym_ty is incomplete? *)
                match kind with
                  | E.OK_object _ ->
                      E.print_debugM 2 (fun () -> "before fetch_object_declaration ==> " ^ show (Loc.stringFromLocation (Loc.locOf ident))) >>= fun () ->
                      E.fetch_object_declaration sym >>= fun (_(*isTentative*), _, _, _, _, _(*sym_qs*), _(*sym_ty*)) ->
                      E.return begin
(*                  AilEannot sym_ty (AnnotatedExpression () [] loc (AilEident sym)) *)
                        AilEident sym
                      end
                  | _ ->
                      E.return (AilEident sym)
                end
          | Nothing ->
              match Builtins.translate_builtin_varnames ident with
                | Just d_e ->
                    E.return d_e
                | Nothing ->
                    E.fail (Loc.locOf ident) (Errors.Desugar_MiscViolation (Errors.UndeclaredIdentifier (show ident)))
              end
        end
    
    | CabsEconst cst ->
        AilEconst <$> desugar_cabs_constant loc cst
    | CabsEstring lit ->
        E.return (AilEstr $ translate_cabs_string_literal lit)
    | CabsEgeneric e gas ->
        AilEgeneric <$> desugar_expression e
                    <*> E.mapM desugar_generic_association gas
    
    | CabsEsubscript e1 e2 ->
STD_ "ยง6.5.2.1#2, sentence 2" $
        AilEunary Indirection <$> (
          AnnotatedExpression () [] loc <$>
          (AilEbinary <$> desugar_expression e1
                      <*> E.return (Arithmetic Add)
                      <*> desugar_expression e2)
        )
    | CabsEcall e es ->
        (* TODO: STD check + annot *)
        AilEcall <$> desugar_expression e <*> E.mapM desugar_expression es
    | CabsEmemberof e ident ->
        (* NOTE: we don't desugar the field name here because we need to know the type of [e] ... *)
        AilEmemberof <$> desugar_expression e <*> (E.return ident)
    | CabsEmemberofptr e ident ->
        (* NOTE: we don't desugar the field name here because we need to know the type of [e] ... *)
        AilEmemberofptr <$> desugar_expression e <*> (E.return ident)
    | CabsEpostincr e ->
        AilEunary PostfixIncr <$> desugar_expression e
    | CabsEpostdecr e ->
        AilEunary PostfixDecr <$> desugar_expression e
    | CabsEcompound tyname inits ->
        desugar_type_name tyname >>= fun (qs, ty)    ->
        E.is_inside_function     >>= fun inside_func ->
        (* NOTE: there is no need to do the check for STD ยง6.7.9#3 here, because of the ail typing *)
        wip_desugar_initializer_ loc (if inside_func then Automatic else Static) ty (Init_list loc inits) >>= fun (ty', d_e) ->
        E.return (AilEcompound qs ty' d_e)
    | CabsEpreincr e ->
STD_ "ยง6.5.3.1#2, sentence 3" $
(*
        desugar_expression e >>= fun d_e ->
        E.return $ AilEcompoundAssign d_e Add oneAil
*)
        (* TODO: temporary hack, while the elab doesn't support compound assigns *)
        desugar_expression e >>= fun d_e ->
        E.return $ AilEassign d_e (AnnotatedExpression () [] loc (AilEbinary d_e (Arithmetic Add) oneAil))
    | CabsEpredecr e ->
STD_ "ยง6.5.3.1#3" $
(*
        desugar_expression e >>= fun d_e ->
        E.return $ AilEcompoundAssign d_e Sub oneAil
*)
        (* TODO: temporary hack, while the elab doesn't support compound assigns *)
        desugar_expression e >>= fun d_e ->
        E.return $ AilEassign d_e (AnnotatedExpression () [] loc (AilEbinary d_e (Arithmetic Sub) oneAil))

      (* (ยง6.5.3.3#5) *)
    | CabsEunary CabsNot e ->
        desugar_expression e >>= fun d_e ->
        E.return $ AilEbinary zeroAil Eq d_e
    
    | CabsEunary uop e ->
        desugar_expression e >>= fun d_e ->
        E.return $ AilEunary (translate_unary_operator uop) d_e
    | CabsEsizeof_expr e ->
        if Global.isAgnostic () then
          E.fail loc (Errors.Desugar_NotYetSupported "sizeof(expr) in the implementation agnostic mode")
          (* NOTE: use to be
             AilEsizeof_expr <$> desugar_expression e
           *)
        else
          desugar_expression e >>= fun d_e  ->
          E.get_sigma_sofar    >>= fun sigm ->
          E.get_gamma_sofar    >>= fun gamm ->
          match ErrorMonad.runErrorMonad (GenTyping.annotate_expression (GenTyping.annotate_block Nothing) sigm gamm GenTyping.CTXsizeof d_e) with
            | Left (loc, err) ->
                E.fail_ailtyping loc err
            | Right a_expr ->
                (* TODO: this is fixing an integer implementation... *)
                let (qs, ty) = Translation_aux.qualified_ctype_of a_expr in
                E.return (AilEsizeof qs ty)
          end
    
    | CabsEsizeof_type tyname ->
        (* TODO: STD check + annot *)
        desugar_type_name tyname >>= fun (qs, ty) ->
        E.return $ AilEsizeof qs ty
    | CabsEalignof tyname ->
        (* TODO: STD check + annot *)
        desugar_type_name tyname >>= fun (qs, ty) ->
        E.return $ AilEalignof qs ty
    | CabsEcast tyname e ->
        (* TODO: check *)
        desugar_type_name tyname >>= fun (qs, ty) ->
        desugar_expression e     >>= fun d_e      ->
        E.return (AilEcast qs ty d_e)
    
    | CabsEbinary bop e1 e2 ->
        AilEbinary <$> desugar_expression e1
                   <*> E.return (translate_binary_operator bop)
                   <*> desugar_expression e2
    | CabsEcond e1 e2 e3 ->
        AilEcond <$> desugar_expression e1
                 <*> (Just <$> desugar_expression e2)
                 <*> desugar_expression e3
    | CabsEassign aop e1 e2 ->
        match translate_assignment_operator aop with
          | Nothing  ->
              AilEassign <$> desugar_expression e1
                         <*> desugar_expression e2
          | Just aop ->
              desugar_expression e1 >>= fun d_e1 ->
              desugar_expression e2 >>= fun d_e2 ->
              E.return (AilEcompoundAssign d_e1 aop d_e2)
(*
              desugar_expression e1 >>= fun d_e1 ->
              desugar_expression e2 >>= fun d_e2 ->
              E.return $ AilEassign d_e1 (AnnotatedExpression () [] loc (AilEbinary d_e1 (Arithmetic aop) d_e2))
*)
        end 
    | CabsEcomma e1 e2 ->
        AilEbinary <$> desugar_expression e1
                   <*> E.return Comma
                   <*> desugar_expression e2
    | CabsEassert e ->
        AilEassert <$> desugar_expression e
    | CabsEoffsetof tyname ident ->
        (* TODO: do something with the qualifiers? *)
        desugar_type_name tyname >>= fun (qs, ty) ->
        E.return (AilEoffsetof ty ident)
    | CabsEva_start e ident ->
        desugar_expression e >>= fun d_e ->
        desugar_expression
          (CabsExpression (Loc.locOf ident) (CabsEident ident)) >>= function
          | AnnotatedExpression _ _ _ (AilEident sym) ->
              E.return (AilEva_start d_e sym)
          | _ ->
              (* TODO: is this a fatal error? *)
              error "the second operand of va_start() was not paramN"
        end
    | CabsEva_copy e1 e2 ->
        desugar_expression e1 >>= fun d_e1 ->
        desugar_expression e2 >>= fun d_e2 ->
        E.return (AilEva_copy d_e1 d_e2)
    | CabsEva_arg e tyname ->
        (* TODO: do something with the qualifiers? *)
        desugar_expression e     >>= fun d_e      ->
        desugar_type_name tyname >>= fun (qs, ty) ->
        E.return (AilEva_arg d_e ty)
    | CabsEva_end e ->
        desugar_expression e     >>= fun d_e      ->
        E.return (AilEva_end d_e)
    | CabsEprint_type e ->
        AilEprint_type <$> desugar_expression e
    | CabsEbmc_assume e ->
        AilEbmc_assume <$> desugar_expression e
    | CabsEgcc_statement ss ->
        let ctx = <| cont_ident_opt= Nothing |> in
        desugar_block_statement (desugar_statement_aux ctx) ss >>= fun (bs, d_ss) ->
        E.return (AilEgcc_statement bs d_ss) 
    | CabsEcondGNU e1 e3 ->
        (* TODO: add extension warning *)
        AilEcond
          <$> desugar_expression e1
          <*> E.return Nothing
          <*> desugar_expression e3
    | CabsEbuiltinGNU (GNUbuiltin_types_compatible_p tyname1 tyname2) ->
        (* TODO: add extension warning *)
        (* the GCC documentation says:
            This built-in function returns 1 if the unqualified versions of the types type1
            and type2 (which are types, not expressions) are compatible, 0 otherwise.
            The result of this built-in function can be used in integer constant expressions. *)
        desugar_type_name tyname1 >>= fun (_, ty1) ->
        desugar_type_name tyname2 >>= fun (_, ty2) ->
        if AilTypesAux.are_compatible (Ctype.no_qualifiers, ty1) (Ctype.no_qualifiers, ty2) then
          E.return (AilEconst (ConstantInteger (IConstant 1 Decimal Nothing)))
        else
          E.return (AilEconst (ConstantInteger (IConstant 0 Octal Nothing)))
    | CabsEbuiltinGNU (GNUbuiltin_choose_expr const_e e1 e2) ->
        (* TODO: add extension warning *)
        desugar_expression const_e         >>= fun d_e ->
        is_integer_constant_expression d_e >>= function
          | false ->
              E.constraint_violation (Loc.locOf const_e) GNUBuiltinChooseExprNotIntegerConstant
          | true ->
              evaluate_integer_constant_expression loc Nothing d_e >>= fun n ->
              if n <> 0 then
                desugar_expression e1
              else
                desugar_expression e2
        end >>= fun (AnnotatedExpression _ _ _ expr_) ->
        E.return expr_
  end

and desugar_generic_association gas =
  match gas with
    | GA_type tyname e ->
        desugar_type_name tyname >>= fun (_, ty) ->
        (* TODO: (ยง6.5.1.1#2, sentence 2), ty must be complete and not variably modified *)
        desugar_expression e     >>= fun d_e     ->
        E.return (AilGAtype ty d_e)
    | GA_default e ->
        AilGAdefault <$> desugar_expression e
  end






(* TODO: rename this function *)
and check_storage_class_specifiers loc decl_ctxt scs =
  E.get_scope >>= fun scope ->
  if    List.length scs > 1
     && not (   List.all (fun z -> z = SC_Thread_local || z = SC_static) scs
             || List.all (fun z -> z = SC_Thread_local || z = SC_extern) scs) then
STD_ "ยง6.7.1#2" $
    E.constraint_violation loc IllegalMultipleStorageClasses
  
  else if not (decl_ctxt = Object_decl_context && E.is_block_scope scope &&
               List.elem SC_Thread_local scs -->
                 (List.elem SC_static scs || List.elem SC_extern scs)
              ) then
STD_ "ยง6.7.1#3, sentence 1" $
    E.constraint_violation loc IllegalMultipleStorageClassesThreadLocal
  
  else if decl_ctxt = Function_decl_context && List.elem SC_Thread_local scs then
STD_ "ยง6.7.1#4" $
    E.constraint_violation loc ThreadLocalFunctionDeclaration
  
  else if not (decl_ctxt = Function_decl_context && E.is_block_scope scope -->
               scs = [] || scs = [SC_extern]) then
STD_ "ยง6.7.1#7" $
    E.undef loc Undefined.UB060_block_scope_function_with_storage_class
  else
STD_ "ยง6.7.1#8" $
    (* TODO *)
    E.return ()

(*
<|
  C.storage_classes:      list storage_class_specifier;
  C.type_specifiers:      list type_specifier;
  C.type_qualifiers:      list type_qualifier;
  C.function_specifiers:  list function_specifier;
  C.alignment_specifiers: list alignment_specifier;
|>
*)

(* TODO: get rid of this function *)
(* E.desugM (Symbol.identifier * Ctype.qualifiers * Ctype.ctype * desugM (unit -> maybe expression unit)) *)
and desugar_init_declarator_BROKEN base_qs base_ty (scs: list storage_class_specifier) idecltor =
  E.print_debugM 2 (fun () ->
    "TODO ==> USING `desugar_init_declarator_BROKEN'"
  ) >>= fun () ->
  (* NOTE: this function does NOT check the wf of the storage classes *)
  E.get_scope >>= fun scope ->
  match idecltor with
    | InitDecl _ decltor Nothing ->
        desugar_declarator NotFunDef decltor >>= fun ((_, ident), mk_qs_ctype) ->
        let (qs, ty) = mk_qs_ctype base_qs base_ty in
        let mk_desug_init =
          fun () -> E.return Nothing in
        (* STD ยง6.9.2#2, sentence 1 *)
        let is_tentative = match scope with
          | E.Scope_file ->
              AilTypesAux.is_object ty && (List.elem SC_static scs || scs = [])
          | _ ->
              false
        end in
        E.return (ident, is_tentative, (qs, ty), mk_desug_init)
    
    | InitDecl loc decltor (Just init) ->
        desugar_declarator NotFunDef decltor >>= fun ((_, ident), mk_qs_ctype) ->
        let (qs, ty) = mk_qs_ctype base_qs base_ty in
        
        (* TODO: check that we really never have parameter objects here *)
        let kind = if AilTypesAux.is_function ty then E.OK_function else E.OK_object false in
        (* TODO: I don't like the fact that we are using this function directly here *)
        E.determinate_linkage ident E.Namespace_ordinary kind scs >>= fun link ->
        
        (* STD ยง6.7.9#3 *)
        check_initialised_type_constraint loc ty >>= fun () ->
        
        (* STD ยง6.7.9#5 *)
        if E.is_block_scope scope && (link = Linkage_external || link = Linkage_internal) then
          E.constraint_violation (Loc.locOf decltor) IllegalLinkageAndInitialization
        else
          (* postponing the desugaring of the initialiser since the identifier
             (which gets register after the current function) need to be in scope *)
          let mk_desug_init () =
            (* NOTE: not using <$> because of a bug in Lem *)
            wip_desugar_initializer_ loc (determinate_storage_duration link scs) ty init >>= fun z ->
            E.return (Just z) in
          E.return (ident, false, (qs, ty), mk_desug_init)
  end



and desugar_init_declarator attrs isAtomic has_alignment base_qs base_ty (scs: list storage_class_specifier) idecltor =
  (* NOTE: this function does NOT check the wf of the storage classes *)
  E.get_scope >>= fun scope ->
  match idecltor with
    | InitDecl loc decltor Nothing ->
        desugar_declarator NotFunDef decltor >>= fun ((ident_attrs, ident), mk_qs_ctype) ->
        let (qs, _ty) = mk_qs_ctype base_qs base_ty in
        let ty = if isAtomic then wrap_atomic _ty else _ty in
        let mk_desug_init =
          fun () -> E.return Nothing in
        (* STD ยง6.9.2#2, sentence 1 *)
        let is_tentative = match scope with
          | E.Scope_file ->
              AilTypesAux.is_object ty && (List.elem SC_static scs || scs = [])
          | _ ->
              false
        end in
        if scs = [SC_typedef] then
          if has_alignment then
            E.constraint_violation loc (IllegalAlignas IllegalAlignas_typedef)
          else
            E.register_typedef ident (attrs, qs, ty) >>= fun () ->
            E.return Nothing
        else
          let (ctx, ok) =
            if AilTypesAux.is_function ty then
              (Function_decl_context, E.OK_function)
            else
              (Object_decl_context, E.OK_object false) in
          check_storage_class_specifiers loc ctx scs >>= fun () ->
          E.register_ordinary_identifier ident ok scs >>= fun (link, sym) ->
          E.return (Just (Loc.locOf ident, ident_attrs, link, sym, is_tentative, (qs, ty), mk_desug_init))
    
    | InitDecl loc decltor (Just init) ->
        if scs = [SC_typedef] then
          E.fail loc (Errors.Desugar_MiscViolation Errors.TypedefInitializer)
        else
          desugar_declarator NotFunDef decltor >>= fun ((ident_attrs, ident), mk_qs_ctype) ->
          let (qs, _ty) = mk_qs_ctype base_qs base_ty in
          let ty = if isAtomic then wrap_atomic _ty else _ty in
          (* TODO: check that we really never have parameter objects here *)
          let kind = if AilTypesAux.is_function ty then E.OK_function else E.OK_object false in
          (* TODO: I don't like the fact that we are using this function directly here *)
          E.determinate_linkage ident E.Namespace_ordinary kind scs >>= fun link ->
          (* STD ยง6.7.9#3 *)
          check_initialised_type_constraint loc ty >>= fun () ->
          (* STD ยง6.7.9#5 *)
          if E.is_block_scope scope && (link = Linkage_external || link = Linkage_internal) then
              E.constraint_violation (Loc.locOf decltor) IllegalLinkageAndInitialization
           else
            (* postponing the desugaring of the initialiser since the identifier
              (which gets register after the current function) need to be in scope *)
            let mk_desug_init () =
              (* NOTE: not using <$> because of a bug in Lem *)
              wip_desugar_initializer_ loc (determinate_storage_duration link scs) ty init >>= fun z ->
              E.return (Just z) in
            
            let (ctx, ok) =
              if AilTypesAux.is_function ty then
                (Function_decl_context, E.OK_function)
              else
                (Object_decl_context, E.OK_object false) in
            check_storage_class_specifiers loc ctx scs >>= fun () ->
            E.register_ordinary_identifier ident ok scs >>= fun (link, sym) ->
            E.return (Just (Loc.locOf ident, ident_attrs, link, sym, false, (qs, ty), mk_desug_init))
  end


and desugar_struct_declaration struct_decl =
  match struct_decl with
    | Struct_declaration outer_attrs specs tquals align_specs sdecltors ->
        desugar_type_specifiers specs >>= fun (specs_qs, base_ty) ->
        let (isAtomic, tquals_qs) = translate_type_qualifiers tquals in
        if List.null sdecltors then
          E.get_anonymous_struct_or_union base_ty >>= function
            | Just membrs ->
                (* STD ยง6.7.2.1#13 *)
                (* this is an unammed anonymous structure or union *)
                E.return membrs
            | Nothing ->
                (* STD ยง6.7.2.1#2 *)
                E.constraint_violation (Loc.locOf base_ty) StructDeclarationLacksDeclaratorList
          end
        else
          E.mapM (fun sdecltor ->
            desugar_struct_declarator (align_specs <> []) sdecltor >>= fun ((attrs, ident), mk_qs_ctype) ->
            (* NOTE: the checks for ยง6.7.2.1#3 are done by desugar_type_specifiers because
               we need to special case the last member. *)
            let (qs, ty) =
              mk_qs_ctype (Ctype.combine_qualifiers tquals_qs specs_qs) base_ty in
            desugar_alignment_specifiers (Loc.locOf ident) ty align_specs >>= fun align_opt ->
            E.return (ident, (Annot.combine_attributes outer_attrs attrs, align_opt, qs, if isAtomic then wrap_atomic ty else ty))
          ) sdecltors
    
    | Struct_assert sa_decl ->
        desugar_and_register_static_assert_declaration sa_decl >>
        E.return []
  end

and desugar_struct_declarator has_alignment struct_decltor =
  match struct_decltor with
    | SDecl_simple decltor ->
        desugar_declarator NotFunDef decltor
    | SDecl_bitfield decltor_opt (CabsExpression loc _) ->
        if has_alignment then
          E.constraint_violation loc (IllegalAlignas IllegalAlignas_bitfield)
        else if Global.isIgnoreBitfields () then
          match decltor_opt with
            | Nothing ->
                E.fail loc (Errors.Desugar_NotYetSupported "bit-fields")
            | Just decltor ->
                E.warnM (fun () -> "ignoring a bit-field declarator at " ^ Loc.stringFromLocation loc) >>= fun () ->
                desugar_declarator NotFunDef decltor
          end
        else
          E.fail loc (Errors.Desugar_NotYetSupported "bit-fields")
  end

and desugar_enumerator (ident, e_opt) =
  match e_opt with
    | Nothing ->
      E.return (ident, Nothing)
    | Just e ->
        let loc = Loc.locOf e in
        desugar_expression e >>= fun d_e ->
        (* STD ยง6.7.2.2#2 *)
        is_integer_constant_expression d_e >>= function
          | false ->
              E.constraint_violation loc WrongTypeEnumConstant
          | true ->
              (* TODO: the type provided to the evaluator should be the integer type
                 compatible with the enum? *)
              evaluate_integer_constant_expression loc (Just Ctype.signed_int) d_e >>= fun n ->
              E.return (ident, Just (loc, n))
        end
  end


and desugar_alignment_specifier loc align_spec =
  match align_spec with
    | AS_type tyname ->
      desugar_type_name tyname >>= fun (_, ty) ->
      E.return (Just (Ctype.AlignType ty))
    | AS_expr e ->
        let loc = Loc.locOf e in
        desugar_expression e >>= fun d_e ->
        (* STD ยง6.7.2.2#2 *)
        is_integer_constant_expression d_e >>= function
          | false ->
              E.constraint_violation loc AlignasNotIntegerConstant
          | true ->
              (* TODO: the type provided to the evaluator should be the integer type
                 compatible with the enum? *)
              evaluate_integer_constant_expression loc Nothing d_e >>= fun n ->
              if n = 0 then
                (* STD (ยง6.7.5#6, second sentence) *)
                E.return Nothing
              else if n < 0 || not (is_power_of_two n) then
                E.constraint_violation loc AlignasInvalidIntegerConstant
              else
                E.return (Just (Ctype.AlignInteger n))
        end
  end


and desugar_alignment_specifiers loc decl_ty xs =
  E.get_alignof >>= fun alignof_ty ->
  E.foldlM (fun acc_opt aspec ->
    desugar_alignment_specifier loc aspec >>= function
      | Nothing ->
          E.return acc_opt
      | Just al ->
          let common prev_n new_n =
            if prev_n >= new_n then
              E.return acc_opt
            else
              E.return (Just al) in
          match (acc_opt, al) with
            | (Nothing, _) ->
                E.return (Just al)
            | (Just (Ctype.AlignType prev_ty), Ctype.AlignType new_ty) ->
                match AilTypesAux.agnostic_alignment_requirement_ord prev_ty new_ty with
                  | Nothing ->
                      if Global.isAgnostic () then
                        E.fail loc (Errors.Desugar_agnosticFailure "alignment specifiers are too complicated")
                      else match (alignof_ty prev_ty, alignof_ty new_ty) with
                        | (Just prev_n, Just new_n) ->
                            common (integerFromNat prev_n) (integerFromNat new_n)
                        | _ ->
                          E.fail loc (Errors.Desugar_TODO "error msg: need a better implementation (2)")
                      end
                  | Just EQ ->
                      E.return acc_opt
                  | Just GT ->
                      E.return acc_opt
                  | Just LT ->
                      E.return (Just al)
                end
            | (Just (Ctype.AlignInteger prev_n), Ctype.AlignInteger new_n) ->
                common prev_n new_n
            | (Just (Ctype.AlignType prev_ty), Ctype.AlignInteger new_n) ->
                match alignof_ty prev_ty with
                  | Just prev_n ->
                      common (integerFromNat prev_n) new_n
                  | Nothing ->
                      E.fail loc (Errors.Desugar_TODO "error msg: need a better implementation (3a)")
                end
            | (Just (Ctype.AlignInteger prev_n), Ctype.AlignType new_ty) ->
                match alignof_ty new_ty with
                  | Just new_n ->
                      common prev_n (integerFromNat new_n)
                  | Nothing ->
                      E.fail loc (Errors.Desugar_TODO "error msg: need a better implementation (3b)")
                end
          end
    end
  ) Nothing xs >>= function
    | Nothing ->
        E.return Nothing
    | Just ((Ctype.AlignInteger al_n) as al) ->
        if AilTypesAux.is_character decl_ty then
          (* by construction we know that n >= 1 (and _Alignas(char) = 1)*)
          E.return (Just al)
        else if Global.isAgnostic () then
          E.fail loc (Errors.Desugar_agnosticFailure "alignment specifiers are too complicated")
        else match alignof_ty decl_ty with
          | Just decl_n ->
              if (integerFromNat decl_n) > al_n then
                E.constraint_violation loc (AlignasLessThanRequired decl_ty)
              else
                E.return (Just al)
          | _ ->
            E.fail loc (Errors.Desugar_TODO "error msg: need a better implementation (5)")
        end
    | Just ((Ctype.AlignType al_ty) as al) ->
        match AilTypesAux.agnostic_alignment_requirement_ord decl_ty al_ty with
          | Nothing ->
              if Global.isAgnostic () then
                E.fail loc (Errors.Desugar_agnosticFailure "alignment specifiers are too complicated")
              else match (alignof_ty decl_ty, alignof_ty al_ty) with
                | (Just decl_n, Just al_n) ->
                    if (integerFromNat decl_n) > (integerFromNat al_n) then
                      E.constraint_violation loc (AlignasLessThanRequired decl_ty)
                    else
                      E.return (Just al)
                | _ ->
                  E.fail loc (Errors.Desugar_TODO "error msg: need a better implementation (7)")
              end
          | Just EQ ->
              (* no change to the alignment from declaration type *)
              E.return Nothing
          | Just GT ->
            E.constraint_violation loc (AlignasLessThanRequired decl_ty)
          | Just LT ->
              E.return (Just al)
        end
  end





























(*  desugar_type_name: type_name -> E.desugM (Ctype.qualifiers * Ctype.ctype) *)
and desugar_type_name (Type_name specs tquals align_specs abs_decltor_opt) =
  (* TODO: align_specs is ignored here *)
  desugar_type_specifiers specs >>= fun (specs_qs, base_ty) ->
  maybe (E.return (fun qs ty -> (qs, ty)))
    (desugar_abstract_declarator NotUnderArray) abs_decltor_opt >>= fun mk_qs_ctype ->
  let (isAtomic, tquals_qs) = translate_type_qualifiers tquals in
  
  let (qs, ty) =
    mk_qs_ctype (Ctype.combine_qualifiers specs_qs tquals_qs) base_ty in
  E.return (qs, (if isAtomic then wrap_atomic ty else ty))














(*

DESUGARING (DUH)

2-  No initializer shall attempt to provide a value for an object not contained within the entity being initialized.


STATIC-TYPING

3-  The type of the entity to be initialized shall be an array of unknown size or a complete object type that is not a variable length array type.


OTHER

4-  All the expressions in an initializer for an object that has static or thread storage duration shall be constant expressions or string literals.



5-  If the declaration of an identifier has block scope, and the identifier has external or internal linkage, the declaration shall have no initializer for the identifier.


*)




(* STD ยง6.7.9#10, second sentence *)
and _UNUSED_static_thread_implicit_initializer tagDefs (Ctype.Ctype _ ty as cty) =
  let () = Debug.print_debug 8 [Debug.DB_desugaring]
      (fun () -> "ENTERING Cabs_to_ail.static_thread_implicit_initializer: " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers cty) in
  match ty with
    | Ctype.Pointer _ _ ->
        ConstantNull
    | Ctype.Basic _ ->
        if AilTypesAux.is_arithmetic cty then
          ConstantInteger (IConstant 0 Octal Nothing)
        else
          error ("type error 1: " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers cty)
    | Ctype.Array elem_ty n_opt ->
        match n_opt with
          | Just n ->
              ConstantArray elem_ty (Utils.replicate_list (_UNUSED_static_thread_implicit_initializer tagDefs elem_ty) (natFromInteger n))
          | Nothing ->
              error "type error, (TODO find quote): subarray with no size"
        end
    
    | Ctype.Struct tag_sym ->
        match Map.lookup tag_sym tagDefs with
          | Just (Struct_definition _ _ _ xs Nothing) ->
              ConstantStruct tag_sym $
                List.map (fun (ident, (_, _, _, ty)) ->
                  (* we ignore the qualifiers, initialisers don't care about them *)
                  (ident, _UNUSED_static_thread_implicit_initializer tagDefs ty)
                ) xs
          | Just (Struct_definition _ _ _ _ (Just _)) ->
              error "TODO: Cabs_to_ail.static_thread_implicit_initializer => flexible array member"
          | _ ->
              error "Cabs_to_ail.static_thread_implicit, Struct, not Struct_definition"
        end
    
    | Ctype.Union tag_sym ->
        match Map.lookup tag_sym tagDefs with
          | Just (Union_definition _ _ _ xs) ->
              let (ident, (_, _, _, ty)) = match xs with
                | [] ->
                    (* NOTE: I don't the parser can produce an empty Union_definition *)
                    error "Cabs_to_ail.static_thread_implicit, Union, empty definition"
                | z :: _ ->
                    z
              end in
              (* we ignore the qualifiers, initialisers don't care about them *)
              ConstantUnion tag_sym ident (_UNUSED_static_thread_implicit_initializer tagDefs ty)
          | _ ->
              error "Cabs_to_ail.static_thread_implicit, Union, not Union_definition"
        end

    | _ ->
        error ("type error 2: " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers cty)
(*  | Function ty qs_tys is_variadic ->
        
    | Atomic ty ->
        
    | Struct of identifier * list (Cabs.Symbol.identifier * ctype) (* TODO: no bitfields for now *)
    | Union of identifier * list (Cabs.Symbol.identifier * ctype) (* TODO: no bitfields for now *) *)
  end




















(* KKK: new initializer_ *)

(*val pathFromDesigs: list designator -> E.desugM init_path *)
and pathFromDesigs_aux acc = function
  | [] ->
      E.return (List.reverse acc)
  | Desig_array e :: xs ->
      desugar_expression e               >>= fun d_e ->
      is_integer_constant_expression d_e >>= function
        | false ->
            E.constraint_violation (Loc.locOf e) IllegalTypeArrayDesignator
        | true ->
            evaluate_integer_constant_expression (Loc.locOf e) Nothing d_e >>= fun n ->
            if n < 0 then
              E.constraint_violation (Loc.locOf e) IllegalSizeArrayDesignator
            else
              pathFromDesigs_aux (Elem_array n :: acc) xs
      end
  | Desig_member memb_ident :: xs ->
      pathFromDesigs_aux (Elem_member memb_ident :: acc) xs
end
and pathFromDesigs desigs =
  pathFromDesigs_aux [] desigs


(*
val foo_aux:
  list init_path -> initializer_ ->
  E.desugM (list (init_path * maybe (expression unit)) * list init_path)
*)

and foo_aux
(*  (entity_ty: Ctype.ctype) *)
  (acc: list (init_path * expression unit))
  (elems: list (init_path * init_path * Ctype.ctype))
  (unknown_array: maybe (integer * list (init_path * init_path * Ctype.ctype)))
  (xs: list (maybe (list designator) * initializer_))
  : E.desugM (list (init_path * expression unit) * list (init_path * init_path * Ctype.ctype) * maybe integer) =
  
  match xs with
    | [] ->
        E.get_tag_definitions >>= fun tagDefs ->
        let pad = List.map (fun (path, _, outer_ty) ->
          (path, mk_zeroInit tagDefs (innerCtype tagDefs outer_ty))
        ) elems in
        let n_opt = match unknown_array with
          | Nothing     -> Nothing
          | Just (n, _) -> Just n
        end in
        E.return (List.reverse acc ++ pad, [], n_opt)
    | (Just desigs, init_) :: xs' ->
        pathFromDesigs desigs >>= fun cursor_path ->
        match skipTo cursor_path elems with
          | Nothing ->
              error ("foo_aux, TODO: Just desigs ==> backward (or union desig) ==> cursor_path: " ^ stringFromInit_path cursor_path)
          | Just (elems', skipped_elems) ->
              (* TODO: hackish *)
              E.get_tag_definitions >>= fun tagDefs ->
              let acc' = List.foldl (fun acc (path, _, outer_ty) ->
                (path, mk_zeroInit tagDefs (innerCtype tagDefs outer_ty)) :: acc
              ) acc skipped_elems in
              foo_aux (*entity_ty*) acc' elems' unknown_array ((Nothing, init_) :: xs')
        end
    | (Nothing, init_) :: xs' ->
        match elems with
          | [] ->
              match unknown_array with
                | Nothing ->
                    (* TODO: check this, are we missing anything? *)
                    foo_aux (*entity_ty*) acc elems unknown_array xs'
                | Just (i, elems_) ->
                    let elems =
                      List.map (fun (path, opath, ty) ->
                        (Elem_array (i+1) :: path, Elem_array (i+1) :: opath, ty)
                      ) elems_ in
                    foo_aux acc elems (Just (i+1, elems_)) xs
              end
          | (cursor_path, _(*outer_path*), outer_ty) :: elems' ->
              let do_scalar d_e =
                E.get_tag_definitions >>= fun tagDefs ->
                let cursor_ty = innerCtype tagDefs outer_ty in
                E.print_debugM 2 (fun () ->
                  "Init_expr, cursor_ty: " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers cursor_ty ^
                  ", outer_ty: " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers outer_ty ^
                  " ===> " ^ Pp.stringFromAil_expression d_e
                ) >>= fun () ->
                (* TODO: should use Ail typing instead of this *)
                let d_e' =
                  if AilTypesAux.is_pointer cursor_ty && AilSyntaxAux.is_null_pointer_constant d_e then
                    A.AnnotatedExpression () [] Loc.unknown (AilEconst A.ConstantNull)
                  else
                    d_e in
                foo_aux (*entity_ty*) ((cursor_path, d_e') :: acc) elems' unknown_array xs'
              in
              let do_scalar_with_desugar e =
                desugar_expression e >>= fun d_e ->
                do_scalar d_e in
              
              let do_string_literal loc lit =
                if not (AilTypesAux.is_array_of_character outer_ty) then
                  (* TODO: this is wrong *)
                  E.fail loc (Errors.Desugar_MiscViolation Errors.ArrayCharStringLiteral)
                else
                  let size = match Ctype.unatomic_ outer_ty with
                    | Ctype.Array _ (Just n) ->
                        natFromInteger n
                    | _ ->
                        error "foo_aux: string literal"
                  end in
                  match lit with
                    | (Nothing, strs) ->
                        let strs = List.concat (List.map snd strs) in (* FIXME *)
                        let str_xs = List.map (fun str ->
                          (Nothing, Init_expr (CabsExpression loc (CabsEconst (CabsCharacter_const (Nothing, str)))))
                        ) strs ++ begin
                          List.replicate (max 1 (size - List.length strs))
                            (Nothing, Init_expr (CabsExpression loc (CabsEconst (CabsCharacter_const (Nothing, "\\0")))))
                        end in
                        foo_aux acc elems unknown_array (str_xs ++ xs')
                    | _ ->
                        error "TODO(foo_aux): CabsEstring with encoding prefix"
                  end in
              match init_ with
                | Init_expr (CabsExpression loc (CabsEstring lit) as e) ->
                    if AilTypesAux.is_scalar outer_ty then
                      do_scalar_with_desugar e
                    else
                      do_string_literal loc lit
                | Init_list _ [(Nothing, Init_expr (CabsExpression loc (CabsEstring lit) as e))] ->
                    if AilTypesAux.is_scalar outer_ty then
                      do_scalar_with_desugar e
                    else
                      do_string_literal loc lit
(*
                | Init_expr (CabsExpression loc (CabsEcompound tyname inits)) ->
                    desugar_type_name tyname >>= fun (qs, ty) ->
                    (* TODO the check for STD ยง6.7.9#3 *)
                    if outer_ty <> ty then
                      error "TODO(foo_aux): CabsEcompound, outer_ty <> ty"
                    else
                      error "TODO(foo_aux): CabsEcompound"
*)

                | Init_expr e ->
                    desugar_expression e >>= fun d_e ->
                    E.get_sigma_sofar >>= fun sigm ->
                    E.get_gamma_sofar >>= fun gamm ->
                    match Mini_pipeline.typecheckAil sigm gamm d_e with
                      | Left (loc, _) ->
                          error ("WIP: foo_aux, Init_expr Ail type error ==> " ^ Loc.stringFromLocation loc)
                      | Right ty ->
                          if AilTypesAux.is_struct ty then
                            if ty = outer_ty then
                              let tag_sym = match Ctype.unatomic_ ty with
                                | Ctype.Struct tag_sym ->
                                    tag_sym
                                | _ ->
                                    error "INTERNAL ERROR(foo_aux): Init_expr, is_struct -> not Struct"
                              end in
                              E.get_tag_definitions >>= fun tagDefs ->
                              match Map.lookup tag_sym tagDefs with
                                | Just (Struct_definition _ _ isAnonymous membrs _) ->
                                    begin if isAnonymous then
                                      E.print_debugM 2 (fun () ->
                                        "foo_aux (Init_expr, is_struct): this may be WRONG ==> anonymous Struct"
                                      )
                                    else
                                      E.return ()
                                    end >>= fun () ->
                                    let (elems1, elems2) = List.splitAt (List.length membrs) elems in
                                    E.print_debugM 2 (fun () ->
                                      stringFromList (fun (a,b,_) ->
                                        stringFromInit_path a ^ ", " ^ stringFromInit_path b
                                      ) elems1
                                    ) >>= fun () ->
                                    let acc' = List.foldl (fun acc ((path, _, _), (memb_ident, _)) ->
                                      (path, AnnotatedExpression () []
                                               (Loc.other "init with struct expr") (AilEmemberof d_e memb_ident)) :: acc
                                    ) acc (List.zip elems1 membrs) in
                                    foo_aux acc' elems2 unknown_array xs'
                                | _ ->
                                    error "INTERNAL ERROR(foo_aux): Init_expr, is_struct"
                                end
                            else
                              error "TODO: foo_aux, Init_expr ==> struct (not compatible)"
                          else if AilTypesAux.is_union ty then
                            error "TODO: foo_aux, Init_expr ==> union"
                          else
                            do_scalar d_e
                    end
(*                    do_scalar e *)
                | Init_list _ ys ->
                    E.print_debugM 2 (fun () -> "HELLO 4") >>= fun () ->
                    E.get_tag_definitions >>= fun tagDefs ->
                    let outerCard = cardinalityOfCtype tagDefs outer_ty in
                    let (inner_elems_, elems') = List.splitAt (natFromInteger outerCard) elems in
                    
                    let inner_elems = match inner_elems_ with
                      | [] ->
                          error "foo_aux, Init_list, inner_elems = []"
                      | (path, opath, ty) :: zs ->
                          let ty' = match ty with
                            | Ctype.Ctype _ (Ctype.Array elem_ty _) ->
                                elem_ty
                            | Ctype.Ctype _ (Ctype.Struct tag_sym) ->
                                let (_, isAnonymous, xs, _) = desug_get_structDefs tagDefs tag_sym in
                                let (_, (_, _, _, first_memb_ty)) = List_extra.head xs in
                                let () = if isAnonymous then
                                  Debug.print_debug 2 [] (fun () ->
                                    "foo_aux: this may be WRONG ==> anonymous Struct"
                                  )
                                else () in
                                first_memb_ty
                            | _ ->
                                ty
                          end in
                          (path, opath, ty') :: zs
                    end in
                    
                    (* let inner_elems = List.map (fun (path, opath, ty) ->
                      (match path with [] -> [] | _::xs -> xs end, match opath with [] -> [] | _::xs -> xs end, ty) (* KKK *)
                    ) inner_elems in *)
                    E.print_debugM 2 (fun () ->
                      "ONE"
                    ) >>= fun () ->
                    foo_aux (*outer_ty*) [] inner_elems (*unknown_array*)Nothing ys >>= fun (inner, _, _) ->
                    E.print_debugM 2 (fun () ->
                      "TWO"
                    ) >>= fun () ->
                    foo_aux (*entity_ty*) (List.reverse inner ++ acc) elems' unknown_array xs'
              end
        end
  end

(*
and bar i elems acc xs =
  let elems' =
    List.map (fun path ->
      Elem_array i :: path
    ) elems in
  foo_aux [] elems' xs >>= fun (xs', acc2) ->
  let acc' = acc ++ acc2 in
  match xs' with
    | [] ->
        E.return acc'
    | _ ->
        bar (i+1) elems acc' xs'
  end
*)

(* val foo: Ctype.ctype -> initializer_ -> E.desugM (list (init_path * maybe (expression unit))) *)
and foo entity_ty init_ : E.desugM (Ctype.ctype * list (init_path * expression unit)) =
  E.get_tag_definitions >>= fun tagDefs ->
  match (entity_ty, init_) with
    | (Ctype.Ctype annots (Ctype.Array elem_ty Nothing), Init_list _ xs) ->
        E.print_debugM 2 (fun () ->
          "HELLO 5"
        ) >>= fun () ->
        let elems = elemPathFromCtype3 true tagDefs elem_ty in
        let elems' =
          List.map (fun (path, opath, ty) ->
            (Elem_array 0 :: path, Elem_array 0 :: opath, ty)
          ) elems in
        foo_aux [] elems' (Just (0, elems)) xs >>= fun (ret, _, n_opt) ->
        match n_opt with
          | Nothing ->
              error "foo: Array Nothing"
          | Just n ->
              E.return (Ctype.Ctype annots (Ctype.Array elem_ty (Just (n+1))), ret)
        end
    | (Ctype.Ctype _ (Ctype.Array _ _), Init_list _ xs) ->
        let elems = elemPathFromCtype3 false tagDefs entity_ty in
        E.print_debugM 2 (fun () ->
          "HELLO 2\n" ^
          stringFromList (fun (x,y,z) ->
            stringFromInit_path x ^ " -- " ^ stringFromInit_path y
                                  ^ " -- " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers z ^ "\n"
          ) elems
        ) >>= fun () ->
        foo_aux (*entity_ty*) [] elems Nothing xs >>= fun (ret, _, _) ->
        E.return (entity_ty, ret)
    | (Ctype.Ctype _ (Ctype.Struct _), Init_list _ xs) ->
        let elems = elemPathFromCtype3 false tagDefs entity_ty in
        E.print_debugM 2 (fun () ->
          "HELLO 1\n" ^
          stringFromList (fun (x,y,z) ->
            stringFromInit_path x ^ " -- " ^ stringFromInit_path y
                                  ^ " -- " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers z ^ "\n"
          ) elems
        ) >>= fun () ->
        foo_aux (*entity_ty*) [] elems Nothing xs >>= fun (ret, _, _) ->
        E.return (entity_ty, ret)
    | _ ->
        let elems = elemPathFromCtype3 false tagDefs entity_ty in
        foo_aux (*entity_ty*) [] elems Nothing [(Nothing, init_)] >>= fun (ret, _, _) ->
        E.return (entity_ty, ret)
  end























(*  wip_desugar_initializer_: storageDuration -> ctype -> initializer_ -> E.desugM ? *)

(* NOTE: the check for STD ยง6.7.9#3 is done by [desugar_init_declarator] *)
and wip_desugar_initializer_ loc dur current_ty init =
  (* YUCK + TODO: move somewhere *)
  let is_string_literal_init = function
    | Init_expr (CabsExpression _ (CabsEstring _)) ->
        true
    | Init_list _ [(Nothing, Init_expr (CabsExpression _ (CabsEstring _)))] ->
        true
    | _ ->
        false
  end in

  if AilTypesAux.is_scalar current_ty then
    match init with
      | Init_expr e ->
          E.return e
      | Init_list _ [(Nothing, Init_expr e)] ->
          (* NOTE: scalar can be initialised with optional enclosing braces *)
          E.return e
      | _ ->
          (* STD ยง6.7.9#11, sentence 1 *)
          (* NOTE: the STD says "shall" and this is not a 'Constraints' section,
             so this is undefined behaviour... *)
          E.undef loc Undefined.UB081_scalar_initializer_not_single_expression
    end >>= fun e ->
    desugar_expression e >>= fun d_e ->
    (* STD ยง6.7.9#4 *)
    if dur = Static || dur = Thread then
      is_initializer_constant_expression_or_string_literal d_e >>= function
        | false ->
            E.constraint_violation (Loc.locOf d_e) IllegalStorageClassStaticOrThreadInitializer
        | true ->
            if AilTypesAux.is_integer current_ty then
(* TODO: bring back the evaluation if possible. But the following code is wrong
   because the setting the suffix to Nothing regardless of the value of n is wrong. *)
              E.return (current_ty, d_e)
(*
              evaluate_integer_constant_expression loc (Just current_ty) d_e >>= fun n ->
              E.return begin
                (current_ty, AnnotatedExpression () [] loc (AilEconst (ConstantInteger (IConstant n Decimal Nothing))))
              end
*)
            else
              (* TODO: floating and pointer *)
              E.return (current_ty, d_e)
      end
    else
      E.return (current_ty, d_e)
  
  else if AilTypesAux.is_array_of_character current_ty && is_string_literal_init init then
    translate_cabs_string_literal <$> match init with
      | Init_expr (CabsExpression _ (CabsEstring lit)) ->
          E.return lit
      | Init_list _ [(Nothing, Init_expr (CabsExpression _ (CabsEstring lit)))] ->
          E.return lit
      | _ ->
          (* TODO: KAYVAN CHECK: this is dead code, `_is_string_literal_init` will filter this out! *)
          E.undef loc Undefined.UB083
    end >>= fun (_(*pref_opt*), char_strs) ->

    let char_strs = List.concat (List.map snd char_strs) in
    
    let (elem_ty, mk_ty, current_size_opt) = match current_ty with
      (* | Ctype.Ctype annots (Ctype.Atomic (Ctype.Ctype annots' (Ctype.Array elem_ty sz))) ->
          (elem_ty, fun z -> Ctype.Ctype annots (Ctype.Atomic (Ctype.Ctype annots' (Ctype.Array elem_ty z))), sz) *)
      | Ctype.Ctype annots (Ctype.Array elem_ty sz) ->
          (elem_ty, fun z -> Ctype.Ctype annots (Ctype.Array elem_ty z), sz)
      | _ -> error "TODO(msg): assert false, array_of_character init, no size opt"
    end in
    
    let do_wrap xs =
      List.map (fun z ->
        Just (
          AnnotatedExpression () [] loc (
            AilEconst (ConstantCharacter (Nothing, z))
          )
        )
      ) xs in
    let (new_ty, chars_array) =
      let chars_n = List.length char_strs in
      match current_size_opt with
        | Just _current_n ->
            let current_n = natFromInteger _current_n in
            (current_ty, match compare current_n (chars_n + 1) with
              | EQ ->
                  do_wrap char_strs ++ [Just zeroAil]
              | LT ->
                  do_wrap (List.take current_n char_strs)
              | GT ->
                  do_wrap char_strs ++
                  List.replicate (current_n - chars_n) (Just zeroAil)
            end)
        | Nothing ->
            (mk_ty (Just (integerFromNat chars_n + 1)), do_wrap char_strs ++ [Just zeroAil])
      end in
    let conved_chars_array =
      List.map (function
        | Nothing ->
            Nothing
        | Just z ->
            Just (
              AnnotatedExpression () [] loc (AilEcast Ctype.no_qualifiers elem_ty z)
            )
      end) chars_array in
    (* TODO: check *)
    E.return
      ( new_ty
      , AnnotatedExpression () [] loc (AilEarray true elem_ty conved_chars_array))
  
  else if (*TODO: An array with element type compatible with a qualified or unqualified version of wchar_t, char16_t, or char32_t *) false then
    error "TODO: wip_desugar_initializer_, An array with element type compatible with a qualified or unqualified version of wchar_t, char16_t, or char32_t"

  else
    E.print_debugM 2 (fun () ->
      "TODO[wip_desugar_initializer_]: in the remaining cases (object that has aggregate or union type), init must Init_list, otherwise this UNDEFINED BEHAVIOUR..." 
    ) >>= fun () ->
    match (Ctype.unatomic_ current_ty, init) with
      | (Ctype.Struct _, Init_expr e) ->
          (* TODO: hack *)
          desugar_expression e >>= fun d_e ->
          E.return (current_ty, d_e)
      | _ ->
          E.get_tag_definitions >>= fun tagDefs ->
          let funcs = <|
            Desugaring_init.desugar_expression= desugar_expression;
            Desugaring_init.is_integer_constant_expression= is_integer_constant_expression;
            Desugaring_init.is_initializer_constant_expression_or_string_literal= is_initializer_constant_expression_or_string_literal;
            Desugaring_init.evaluate_integer_constant_expression= evaluate_integer_constant_expression;
          |> in
          Desugaring_init.desugar_init tagDefs funcs (dur = Static || dur = Thread) current_ty init >>= fun (current_ty', init_st, _) ->
          E.return (current_ty', Desugaring_init.constructValue tagDefs init_st current_ty')

          (* E.get_tag_definitions >>= fun tagDefs ->
          foo current_ty init >>= fun (current_ty', xs) ->
          
          E.print_debugM 2 (fun () ->
            "current_ty': " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers current_ty' ^
            ", FOO ==> " ^ stringFromList (fun (path, expr) ->
              stringFromInit_path path ^
              " := " ^ Pp.stringFromAil_expression expr
            ) xs
          ) >>= fun () ->
          E.return (current_ty', constructValue tagDefs xs current_ty') *)
    end


and desugar_and_register_static_assert_declaration sa_decl =
  match sa_decl with
   | Static_assert (CabsExpression loc _ as e) lit ->
       desugar_expression e >>= fun d_e ->
       is_integer_constant_expression d_e >>= function
         | false ->
             E.undef loc Undefined.UB204_illtyped_Static_assert
         | true ->
             evaluate_integer_constant_expression loc Nothing d_e >>= fun n ->
             if n = 0 then
               E.constraint_violation loc (StaticAssertFailed (string_of_string_literal lit))
             else
               E.return ()
         end
  end


(* TODO: this is broken *)
(* val desugar_declaration_base: Annot.attributes -> specifiers -> list init_declarator -> E.desugM (list (ail_identifier * expression unit)) *)
and desugar_declaration_base attrs specifs idecltors =
  E.print_debugM 2 (fun () ->
    "BROKEN: desugar_declaration_base"
  ) >>= fun () ->
          desugar_type_specifiers specifs.type_specifiers >>= fun (specs_qs, base_ty) ->
          (* for each [init_declarator] *)
          E.foldlM (fun acc (InitDecl loc _ _ as init) ->
            (* NOTE: the wf of the storage classes is checked later (see the
               pattern match on [ty]) *)
            let (isAtomic, tquals_qs) = translate_type_qualifiers specifs.type_qualifiers in
            let base_qs = Ctype.combine_qualifiers specs_qs tquals_qs in
            desugar_init_declarator_BROKEN base_qs base_ty specifs.storage_classes init >>= fun (ident, is_tentative, (qs, _ty), mk_desug_init) ->
            let ident_loc = Loc.locOf ident in
            let (Ctype.Ctype _ ty as cty) = if isAtomic then Ctype.mk_ctype_atomic _ty else _ty in
            
            if is_tentative then
              (* NOTE: this shouldn't be possible since tentative definition are file scoped *)
              error "Cabs_to_ail.desugar_declaration_base found a positive is_tentative"
            
            else if specifs.storage_classes = [SC_typedef] then
              (* Case of a typedef *)
              E.register_typedef ident (attrs, qs, cty) >>
              E.return acc
              
            else
              let do_function return_qs_ty params_opt is_variadic =
                check_storage_class_specifiers loc Function_decl_context specifs.storage_classes >>= fun () ->
                if specifs.alignment_specifiers <> [] then
                  E.constraint_violation ident_loc (IllegalAlignas IllegalAlignas_function)
                else
                  E.register_ordinary_identifier ident
                    E.OK_function specifs.storage_classes >>= fun (_, sym) ->
                  E.register_function_declaration ident_loc attrs sym true (
                    return_qs_ty,
                    params_opt,
                    is_variadic,
                    List.elem FS_inline   specifs.function_specifiers,
                    List.elem FS_Noreturn specifs.function_specifiers
                  ) >>
                  E.return acc in
              match ty with
                | Ctype.Function return_qs_ty params is_variadic ->
                    do_function return_qs_ty (Just params) is_variadic
                | Ctype.FunctionNoParams return_qs_ty ->
                    do_function return_qs_ty Nothing false
                | _ ->
                    if List.elem SC_register specifs.storage_classes && specifs.alignment_specifiers <> [] then
                      E.constraint_violation ident_loc (IllegalAlignas IllegalAlignas_register)
                    else
                    desugar_alignment_specifiers ident_loc cty specifs.alignment_specifiers >>= fun align_opt ->
                    check_storage_class_specifiers loc Object_decl_context specifs.storage_classes >>= fun () ->
                    E.register_ordinary_identifier ident
                      (E.OK_object false) specifs.storage_classes >>= fun (link, sym) ->
                    
                    let dur = determinate_storage_duration link specifs.storage_classes in
                    match link with
                      | Linkage_external ->
                          E.register_external_object_declaration sym
                            (false(*TODO:check*), ident_loc, attrs, dur, List.elem SC_register specifs.storage_classes, align_opt, qs, cty)
                      | _ ->
                          E.register_internal_object_declaration sym
                            (ident_loc, dur, List.elem SC_register specifs.storage_classes, align_opt, qs, cty)
                    end >>
                    mk_desug_init () >>= function
                      | Just (ty', d_e) ->
                          E.print_debugM 2 (fun () ->
                            "Hello, ty' = " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers ty'
                          ) >>= fun () ->
                          begin if cty <> ty' then
                            E.print_debugM 2 (fun () ->
                              "ty' is new"
                            ) >>= fun () ->
                            (* TODO: tentative *)
                            E.update_internal_object_type sym ty'
  (*
                            E.register_internal_object_declaration ident_loc sym
                              (dur, List.elem SC_register specifs.storage_classes, qs, ty')
  *)
                          else
                            E.return ()
                          end >>
                          match dur with
                            | Static ->
                                E.register_global_object_definition2 ident_loc sym link (E.Definition d_e) >>
                                E.return (ty', acc)
                            | Thread ->
                                error "TODO: desugar_declaration_base, Thread duration"
                            | _ ->
                                E.return (ty', (sym, Just d_e) :: acc)
                          end
                      | Nothing ->
                          match dur with
                            | Static ->
                                if not (List.elem SC_extern specifs.storage_classes) then
                                  E.get_tag_definitions >>= fun tagDefs ->
                                  E.register_global_object_definition sym (E.Definition (mk_zeroInit tagDefs cty)) >>= fun () ->
                                  E.return (cty, acc)
                                else
                                  E.return (cty, acc)
                            | Automatic ->
                                E.return (cty, (sym, Nothing) :: acc)
                            | Thread ->
                                (* TODO check *)
                                E.return (cty, acc)
                          end
                    end >>= fun (ty', ret) ->
                    E.is_incomplete ty' >>= fun is_incomplete ->
                    if link = Linkage_none && is_incomplete then
                      E.undef (Loc.locOf ident) Undefined.UB059_incomplete_no_linkage_identifier
                    else
                      E.return ret
              end
          ) [] idecltors >>= (List.reverse |- E.return)


and desugar_block_statement self ss =
(* TODO: STD check + annot *)
E.fresh_block_scope >>= fun scope ->
  E.collect_with_scope scope (
    E.mapM self ss
  ) >>= fun (bs_, d_ss) ->
  
  let bs = List.filter (fun (_, ((_, dur, _), _, _, _)) ->
    match dur with
      | Static ->
          false
      | Thread ->
          false
      | _ ->
          true
    end) bs_ in
  
  (* this is removing unnecessary blocks and skips introduced by the desugared.
      TODO: check carefully that we don't remove source blocks *)
  let d_ss' =
    List.foldr (fun z acc ->
      match z with
        | (CabsStatement _ _ CabsSnull, AnnotatedStatement _ _ AilSskip) ->
            (* this is the case of a block already present in the Cabs code. *)
            snd z :: acc
        | (CabsStatement _ _ _, AnnotatedStatement _ attrs AilSskip) ->
            if attrs = Annot.no_attributes then
              acc
            else
              snd z :: acc
        | (CabsStatement _ _ (CabsSblock _), AnnotatedStatement _ _ (AilSblock _ _)) ->
            (* this is the case of a block already present in the Cabs code. *)
            snd z :: acc
        | (_, AnnotatedStatement _ attrs (AilSblock [] xs)) ->
            if attrs = Annot.no_attributes then
              (* here a block with no local variables was introduced by the desugaring *)
              xs ++ acc
            else
              (* we keep it if there are attributes *)
              snd z :: acc
        | _ ->
            snd z :: acc
      end
    ) [] (List.zip ss d_ss) in
  
  E.return (bs, d_ss')


and desugar_statement_aux ctx (CabsStatement loc attrs stmt_) =
  let attrs_outer = attrs in
  let self = desugar_statement_aux ctx in
  AnnotatedStatement loc attrs <$>
    match stmt_ with
      | CabsSlabel ident s ->
          AilSlabel <$> E.resolve_label ident
                    <*> self s
                    <*> E.return Nothing
      
      | CabsScase e s ->
          if Global.isAgnostic () then
            E.fail loc (Errors.Desugar_agnosticFailure "case statements are not supported in the agnostic mode")
          else
            desugar_expression e >>= evaluate_integer_constant_expression (Loc.locOf e) Nothing >>= fun n ->
            E.register_case (Loc.locOf e) (E.CaseSelectConst n) >>= fun () ->
            AilScase n <$> self s
      
      | CabsSdefault s ->
          E.register_default loc >>= fun () ->
          AilSdefault <$> self s
      
      | CabsSblock ss ->
          desugar_block_statement self ss >>= fun (bs, d_ss') ->
          E.return (AilSblock bs d_ss')
      
      | CabsSdecl (Declaration_base attrs specifs idecltors) ->
          function
            | [] ->
                AilSskip
            | xs ->
                AilSdeclaration xs
          end <$> desugar_declaration_base attrs specifs idecltors
      
      | CabsSdecl (Declaration_static_assert sa_decl) ->
          desugar_and_register_static_assert_declaration sa_decl >>
          (* TODO: hackish *)
          E.return AilSskip
      
      | CabsSnull ->
          E.return AilSskip
      
      | CabsSexpr e ->
          AilSexpr <$> desugar_expression e
      
      | CabsSif e s1 s2_opt ->
          (* STD ยง6.8.4#3 both the if-statement and its sub statements are distinct blocks *)
          (* NOTE: there is no risk of missing object delcarations in these scopes because:
                     1. the controlling expression can't declare any object (but can declare enum
                        constants, hence the scope)
                     2. if the sub-statements are declaring objects, it can be because of
                        a naked CabsSdecl because the parser won't accept it *)
          E.fresh_block_scope >>= fun if_scope ->
          E.fresh_block_scope >>= fun s1_scope ->
          E.under_scope if_scope begin
            AilSif <$> desugar_expression e
                   <*> E.under_scope s1_scope (self s1)
                   <*> maybe (E.return $ AnnotatedStatement loc Annot.no_attributes AilSskip)
                             (fun z -> E.fresh_block_scope >>= fun s2_scope ->
                                       E.under_scope s2_scope (self z))
                             s2_opt
          end
      
      | CabsSswitch e s ->
          (* STD ยง6.8.4#3 both the switch-statement and its sub statement are distinct blocks *)
          (* NOTE: see the note in CabsSif *)
          E.fresh_block_scope >>= fun switch_scope ->
          E.fresh_block_scope >>= fun s_scope      ->
          E.under_scope switch_scope begin
            AilSswitch <$> desugar_expression e
                       <*> E.under_scope s_scope (E.as_switch_body (self s))
          end
      
      | CabsSwhile e s ->
          (* TODO: when supporting VLAs ==> ยง6.8.4.2#2 *)
          E.freshify (Symbol.Identifier loc "__cerb_continue") >>= fun cont_ident ->
          E.register_label cont_ident >>
          E.resolve_label cont_ident >>= fun cont_sym ->
          let ctx' =
            <| cont_ident_opt= Just cont_ident |> in
          (* STD ยง6.8.5#5 both the while-statement and its body are distinct blocks *)
          (* NOTE: the note in CabsSif also applies here *)
          E.fresh_block_scope >>= fun while_scope ->
          E.fresh_block_scope >>= fun s_scope     ->
          E.under_scope while_scope begin
            desugar_expression e >>= fun d_e ->
            E.under_scope s_scope
              (desugar_statement_aux ctx' s) >>= fun d_s ->
            E.return (d_e, d_s)
          end >>= fun (d_e, d_s) ->
          let loop_id = Symbol.fresh_int () in
          E.record_loop_attribute loop_id attrs >>= fun () ->
          if has_continue s then
            (* while (E) S  ==>  while (E) { S; cont: ;} *)
            E.return begin
                AilSwhile d_e begin
                  AnnotatedStatement loc Annot.no_attributes begin
                    AilSblock [] [ d_s
                                 ; AnnotatedStatement loc Annot.no_attributes
                                     (AilSlabel cont_sym (AnnotatedStatement loc Annot.no_attributes AilSskip) (Just (Annot.LAloop_continue loop_id))) ]
                  end
                end loop_id 
            end
          else
            E.return (AilSwhile d_e d_s loop_id)
      
      | CabsSdo e s ->
          E.freshify (Symbol.Identifier loc "__cerb_continue") >>= fun cont_ident ->
          E.register_label cont_ident >>
          E.resolve_label cont_ident >>= fun cont_sym ->
          let ctx' =
            <| cont_ident_opt= Just cont_ident |> in
          (* STD ยง6.8.5#5 both the do-statement and its body are distinct blocks *)
          (* NOTE: the note in CabsSif also applies here *)
          E.fresh_block_scope >>= fun while_scope ->
          E.fresh_block_scope >>= fun s_scope     ->
          E.under_scope while_scope begin
            E.under_scope s_scope
              (desugar_statement_aux ctx' s) >>= fun d_s ->
            desugar_expression e >>= fun d_e ->
            E.return (d_e, d_s)
          end >>= fun (d_e, d_s) ->
          let loop_id = Symbol.fresh_int () in
          E.record_loop_attribute loop_id attrs >>= fun () ->
          if has_continue s then
            (* do S (E)  ==>  do { S; cont: ;} (E) *)
            E.return begin
                AilSdo begin
                  AnnotatedStatement loc Annot.no_attributes begin
                    AilSblock [] [ d_s
                                 ; AnnotatedStatement loc Annot.no_attributes
                                     (AilSlabel cont_sym (AnnotatedStatement loc Annot.no_attributes AilSskip) (Just (Annot.LAloop_continue loop_id)))]
                  end
                end d_e loop_id
            end
          else
            E.return (AilSdo d_s d_e loop_id)
      
      | CabsSfor (Just (FC_decl decl_loc ((Declaration_base attrs specifs idecltors)))) e2_opt e3_opt s ->
          E.freshify (Symbol.Identifier loc "__cerb_continue") >>= fun cont_ident ->
          E.register_label cont_ident >>
          E.resolve_label cont_ident >>= fun cont_sym ->
          let ctx' =
            <| cont_ident_opt= Just cont_ident |> in
          E.fresh_block_scope >>= fun for_scope ->
          E.under_scope for_scope (
            desugar_type_specifiers specifs.type_specifiers >>= fun (specs_qs, base_ty) ->
            let (isAtomic, tquals_qs) = translate_type_qualifiers specifs.type_qualifiers in
            let base_qs = Ctype.combine_qualifiers specs_qs tquals_qs in
            E.mapM (fun (InitDecl loc _ _ as init) ->
              check_storage_class_specifiers loc Object_decl_context specifs.storage_classes >>= fun () ->
              desugar_init_declarator attrs isAtomic (specifs.alignment_specifiers <> []) base_qs base_ty specifs.storage_classes init
            ) idecltors  >>= fun xs ->
            let loop_id = Symbol.fresh_int () in
            E.record_loop_attribute loop_id attrs_outer >> 
            (* for each [init_declarator] *)
            E.foldrM (fun opt (acc1, acc2) ->
              match opt with
                | Nothing ->
                    (* Case of a typedef *)
                    E.constraint_violation loc IllegalStorageClassIterationStatement
                
                | Just (ident_loc, _, link, sym, is_tentative, (qs, ty), mk_desug_init) ->
                    if is_tentative then
                      (* NOTE: this shouldn't be possible since tentative definition are file scoped *)
                      error "Cabs_to_ail.desugar_statement, CabsSfor found a positive is_tentative"
                    
                    else if not (specifs.storage_classes = []        ||
                                 specifs.storage_classes = [SC_auto] ||
                                 specifs.storage_classes = [SC_register]) then
                      (* NOTE: amusingly, as it is written, the STD doesn't allow the absence of storage-class ... *)
                      E.constraint_violation ident_loc IllegalStorageClassIterationStatement
                    
                    else match ty with
                      | Ctype.Ctype _ (Ctype.Function _ _ _) ->
                          E.constraint_violation loc IllegalStorageClassIterationStatement
                      | _ ->
                          mk_desug_init () >>= function
                            | Just (ty', d_e) ->
                                let dur = determinate_storage_duration link specifs.storage_classes in
                                E.print_debugM 2 (fun () ->
                                  "Hello, ty' = " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers ty'
                                ) >>= fun () ->
                                begin if ty <> ty' then
                                  E.print_debugM 2 (fun () ->
                                    "ty' is new"
                                  ) >>= fun () ->
                                  (* TODO: tentative *)
                                  E.register_internal_object_declaration sym
                                    (ident_loc, dur, List.elem SC_register specifs.storage_classes, Nothing, qs, ty')
                                else
                                  E.register_internal_object_declaration sym
                                    (ident_loc, dur, List.elem SC_register specifs.storage_classes, Nothing, qs, ty)
                                end >>= fun () ->
                                E.return ( (sym, Just d_e) :: acc1
                                         , (sym, ((ident_loc, dur, List.elem SC_register specifs.storage_classes), Nothing, qs, ty)) :: acc2 )
                            | Nothing ->
                                let dur = determinate_storage_duration link specifs.storage_classes in
                                E.register_internal_object_declaration sym
                                  (ident_loc, dur, List.elem SC_register specifs.storage_classes, Nothing, qs, ty) >>= fun () ->
                                E.return ( acc1
                                         , (sym, ((ident_loc, dur, List.elem SC_register specifs.storage_classes), Nothing, qs, ty)) :: acc2 )
                          end
                    end
              end) ([], []) (List.reverse xs) >>= fun (sym_d_es, bindings) ->
              (* see (ยง6.8.5.3#2, second sentence) for the Nothing case *)
              maybe (E.return oneAil) desugar_expression e2_opt >>= fun d_e2 ->
              (* STD ยง6.8.5#5 the body has its own scope *)
              (* NOTE: the desugaring of s needs to be done last, because there might be some enum constants
                       declarations in any of the expressions *)
              E.fresh_block_scope >>= fun s_scope ->
              let loop_annot = Just (Annot.LAloop_continue loop_id) in
              match e3_opt with
                | Just e3 ->
                    desugar_expression e3 >>= fun d_e3 ->
                    E.under_scope s_scope (desugar_statement_aux ctx' s) >>= fun d_s  ->
                    let d_s_e3 = AnnotatedStatement Loc.unknown Annot.no_attributes $ AilSexpr d_e3 in
                    E.return match d_s with
                      | AnnotatedStatement loc' attrs (AilSblock bindings d_ss) ->
                          AnnotatedStatement loc' attrs (
                            AilSblock bindings (d_ss ++ [AnnotatedStatement loc Annot.no_attributes (AilSlabel cont_sym d_s_e3 loop_annot)])
                          )
                      | _ ->
                          AnnotatedStatement loc Annot.no_attributes (
                            AilSblock [] [d_s; AnnotatedStatement loc Annot.no_attributes (AilSlabel cont_sym d_s_e3 loop_annot)]
                          )
                    end
                | Nothing ->
                    E.under_scope s_scope (desugar_statement_aux ctx' s) >>= fun d_s ->
                    E.return begin
                      AnnotatedStatement loc Annot.no_attributes (
                        AilSblock [] [ d_s
                                     ; AnnotatedStatement loc Annot.no_attributes (AilSlabel cont_sym (AnnotatedStatement loc Annot.no_attributes AilSskip) loop_annot) ]
                      )
                    end
              end >>= fun d_s_body ->
            (* TODO: this seems to put the attributes not on the while loop but the declaration part *)
              E.return begin
                AilSblock bindings [
                  AnnotatedStatement decl_loc Annot.no_attributes (AilSdeclaration sym_d_es);
                  AnnotatedStatement loc Annot.no_attributes (AilSwhile d_e2 d_s_body loop_id)
                ]
              end
          )
      
      | CabsSfor fc_opt e2_opt e3_opt s ->
          (* fc_opt is either Nothing, a static assertion, or a FC_expr *)
          E.freshify (Symbol.Identifier loc "__cerb_continue") >>= fun cont_ident ->
          E.register_label cont_ident >>
          E.resolve_label cont_ident >>= fun cont_sym ->
          let loop_id = Symbol.fresh_int () in
          E.record_loop_attribute loop_id attrs >>
          let ctx' =
            <| cont_ident_opt= Just cont_ident |> in
          
          (* NOTE: it is important that the expressions and the body are
             desugared in the order of the syntax *)
          E.fresh_block_scope >>= fun for_scope ->
          E.under_scope for_scope begin
            match fc_opt with
              | Just (FC_expr e1) ->
                  (* for (E1; E2; E3) S ==> { E1; while(E2) { S'; cont: E3   } }  *)
                  (* for (E1; E2; ) S   ==> { E1; while(E2) { S'; cont: skip } }  *)
                  desugar_expression e1 >>= fun d_e1 ->
                  let d_s_e1 =
                    AnnotatedStatement (Loc.locOf e1) Annot.no_attributes (AilSexpr d_e1) in
                  let mk_d_s_body d_s_e3 = function
                    | AnnotatedStatement loc attrs (AilSblock bs d_ss) ->
                        AnnotatedStatement loc attrs (AilSblock bs (d_ss ++ [d_s_e3]))
                    | d_s ->
                        AnnotatedStatement loc Annot.no_attributes (AilSblock [] [d_s; d_s_e3])
                  end in
                  E.return begin
                    fun d_e2 d_s_e3 d_s ->
                      AilSblock [] [ d_s_e1
                                   ; AnnotatedStatement loc Annot.no_attributes (AilSwhile d_e2 (mk_d_s_body d_s_e3 d_s) loop_id) ]
                  end
              | Just (FC_decl _ (Declaration_base _ _ _)) ->
                  error "desugar_statement_aux: Just (FC_decl (Declaration_base _ _ _)), _)"
              | Just (FC_decl _ (Declaration_static_assert sa_decl)) ->
                  (* for (_Static_assert(...); E2; E3) S ==> while(E2) { S'; cont: E3 } *)
                  (* for (_Static_assert(...); E2; ) S ==> while(E2) { S'; cont: skip } *)
                  desugar_and_register_static_assert_declaration sa_decl >>
                  let mk_d_s_body d_s_e3 = function
                    | AnnotatedStatement loc attrs (AilSblock bs d_ss) ->
                        AnnotatedStatement loc attrs (AilSblock bs (d_ss ++ [d_s_e3]))
                    | d_s ->
                        AnnotatedStatement Loc.unknown Annot.no_attributes begin
                          AilSblock [] [d_s; d_s_e3]
                        end
                  end in
                  E.return (fun d_e2 d_s_e3 d_s -> AilSwhile d_e2 (mk_d_s_body d_s_e3 d_s) loop_id)
              | Nothing ->
                  (* for (; E2; E3) S ==> while(E2) { S'; cont: E3 } *)
                  (* for (; E2; ) S ==> while(E2) { S'; cont: skip } *)
                  let mk_d_s_body d_s_e3 = function
                    | AnnotatedStatement loc attrs (AilSblock bs d_ss) ->
                        AnnotatedStatement loc attrs (AilSblock bs (d_ss ++ [d_s_e3]))
                    | d_s ->
                        AnnotatedStatement Loc.unknown Annot.no_attributes begin
                          AilSblock [] [d_s; d_s_e3]
                        end
                  end in
                  E.return (fun d_e2 d_s_e3 d_s -> AilSwhile d_e2 (mk_d_s_body d_s_e3 d_s) loop_id)
            end >>= fun mk_for ->
            (* see (ยง6.8.5.3#2, second sentence) for the Nothing case *)
            (* for (...; ; ...) ...   ==> { ...; while(1) ... } *)
            maybe (E.return oneAil) desugar_expression e2_opt >>= fun d_e2 ->
            let loop_annot = Just (Annot.LAloop_continue loop_id) in
            match e3_opt with
              | Nothing ->
                  E.return begin
                    AnnotatedStatement loc Annot.no_attributes (
                      AilSlabel cont_sym (AnnotatedStatement loc Annot.no_attributes AilSskip) loop_annot
                    )
                  end
              | Just e3 ->
                  desugar_expression e3 >>= fun d_e3 ->
                  E.return begin
                    AnnotatedStatement loc Annot.no_attributes (
                      AilSlabel cont_sym (AnnotatedStatement (Loc.locOf e3) Annot.no_attributes (AilSexpr d_e3)) loop_annot
                    )
                  end
            end >>= fun d_s_e3 ->
            E.fresh_block_scope >>= fun s_scope ->
            E.under_scope s_scope (desugar_statement_aux ctx' s) >>= fun d_s ->
            E.return (mk_for d_e2 d_s_e3 d_s)
        end
      
      | CabsSgoto ident ->
          AilSgoto <$> E.resolve_label ident
      
      | CabsScontinue ->
          match ctx.cont_ident_opt with
            | Nothing ->
                E.constraint_violation loc ContinueOutsideLoop
            | Just cont_ident ->
                self (CabsStatement loc Annot.no_attributes (CabsSgoto cont_ident)) >>= fun (AnnotatedStatement _ _ stmt_) ->
                E.return stmt_
          end
      
      | CabsSbreak ->
          E.is_in_switch >>= function
            | true ->
                E.return AilSbreak
            | false ->
                match ctx.cont_ident_opt with
                  | Just _ ->
                      E.return AilSbreak
                  | Nothing ->
                      E.constraint_violation loc BreakOutsideSwitchOrLoop
                end
          end
      
      | CabsSreturn Nothing ->
          E.get_current_return_type >>= function
            | Ctype.Ctype _ Ctype.Void ->
                E.return AilSreturnVoid
            | _ ->
                E.constraint_violation loc VoidReturnNonVoidFunction
          end
      
      | CabsSreturn (Just e) ->
          E.get_current_return_type >>= function
            | Ctype.Ctype _ Ctype.Void ->
                E.constraint_violation loc NonVoidReturnVoidFunction
            | _ ->
                AilSreturn <$> desugar_expression e
          end
      
      | CabsSpar ss ->
          AilSpar <$> E.mapM self ss
      
      | CabsSasm is_volatile is_inline xs (* list (list string) *) ->
          (* TODO: erasing inline assembly for now *)
          E.return AilSskip
      
      | CabsScaseGNU e1 e2 s ->
          let desugar_case_constant e =
            desugar_expression e >>=
            evaluate_integer_constant_expression (Loc.locOf e) Nothing in
          if Global.isAgnostic () then
            E.fail loc (Errors.Desugar_agnosticFailure "case statements are not supported in the agnostic mode")
          else
            E.is_in_switch >>= function
              | true ->
                  (* TODOO *)
                  desugar_case_constant e1 >>= fun n1 ->
                  desugar_case_constant e2 >>= fun n2 ->
                  E.register_case (Loc.bbox_location [Loc.locOf e1; Loc.locOf e2]) (E.CaseSelectRange n1 n2) >>= fun () ->
                  if n1 <= n2 then
                    AilScase_rangeGNU n1 n2 <$> self s
                  else
                    E.warnM (fun () -> "empty case range [" ^ Loc.stringFromLocation loc ^ "] discarded by the desugaring") >>= fun () ->
                    E.return AilSskip
              | false ->
                  E.constraint_violation loc LabelStatementOutsideSwitch
            end
      | CabsSmarker s ->
          E.record_marker () >>= fun id ->
          AilSmarker id <$> self s
    end

val desugar_statement: cabs_statement -> E.desugM (statement unit)
let desugar_statement stmt =
  desugar_statement_aux <| cont_ident_opt= Nothing |> stmt


val     register_labels: cabs_statement -> E.desugM unit
let rec register_labels (CabsStatement _ _ stmt_) =
  match stmt_ with
    | CabsSlabel ident s ->
        E.register_label ident >>
        register_labels s
    | CabsScase _ s ->
        register_labels s
    | CabsSdefault s ->
        register_labels s
    | CabsSblock ss ->
        E.mapM_ register_labels ss
    | CabsSdecl _ ->
        E.return ()
    | CabsSnull ->
        E.return ()
    | CabsSexpr _ ->
        E.return ()
    | CabsSif _ s1 s2_opt ->
        register_labels s1 >>
        maybe (E.return ()) register_labels s2_opt
    | CabsSswitch _ s ->
        register_labels s
    | CabsSwhile _ s ->
        register_labels s
    | CabsSdo _ s ->
        register_labels s
    | CabsSfor _ _ _ s ->
        register_labels s
    | CabsSgoto _ ->
        E.return ()
    | CabsScontinue ->
        E.return ()
    | CabsSbreak ->
        E.return ()
    | CabsSreturn _ ->
        E.return ()
    | CabsSpar _ ->
        (* TODO: temporary *)
        E.return ()
    | CabsSasm _ _ _ ->
        (* TODO: check whether labels can declared here *)
        E.return ()
    | CabsScaseGNU _ _ s ->
        register_labels s
(* BEGIN CN *)
    | CabsSmarker s ->
        register_labels s
(* END CN *)
  end



(* BEGIN CN *)
open Cn

let unique_record_members f members =
    E.foldlM (fun acc (member, thing) ->
      match List.lookup member acc with
        | Just _ ->
          E.fail (Loc.locOf member) (Errors.Desugar_CN (CNErr_duplicate_field member))
        | Nothing ->
          f thing >>= fun thing ->
          E.return ((member, thing) :: acc)
      end) [] members

let sort_record_members f members =
    let cmp (mem1, _) (mem2, _) = Show.show mem1 < Show.show mem2 in
    Sorting.sortBy cmp <$> unique_record_members f members

let rec desugar_cn_base_type loc bTy =
  match bTy with
    | CN_unit ->
        E.return CN_unit
    | CN_bool ->
      E.return CN_bool
    | CN_integer ->
      E.return CN_integer
    | CN_bits sign n ->
      E.return (CN_bits sign n)
    | CN_real ->
      E.return CN_real
    | CN_loc ->
      E.return CN_loc
    | CN_alloc_id ->
      E.return CN_alloc_id
    | CN_struct tag_ident ->
        E.resolve_extraordinary_identifier tag_ident E.Namespace_tag >>= function
          | Just (_, (tag_sym, E.Kind_tag E.Kind_struct)) ->
              E.return (CN_struct tag_sym)
          | Just _ ->
              E.fail loc (Errors.Desugar_CN CNErr_invalid_tag)
          | Nothing ->
              E.fail loc (Errors.Desugar_CN CNErr_invalid_tag)
        end
    | CN_record members ->
      CN_record <$> sort_record_members (desugar_cn_base_type loc) members
    | CN_datatype ident ->
       E.resolve_cn_ident CN_datatype_nm ident >>= fun sym_resolved ->
       let sym = Cn.ensure_not_c_variable sym_resolved in
       E.return (CN_datatype sym)
    | CN_map bTy1 bTy2 ->
        CN_map <$> desugar_cn_base_type loc bTy1
              <*> desugar_cn_base_type loc bTy2
    | CN_list bTy ->
        CN_list <$> desugar_cn_base_type loc bTy
    | CN_tuple bTys ->
        CN_tuple <$> E.mapM (desugar_cn_base_type loc) bTys
    | CN_set bTy ->
        CN_set <$> desugar_cn_base_type loc bTy
    | CN_user_type_name ident ->
        E.resolve_cn_user_type_name ident
    | CN_c_typedef_name _ ->
        Assert_extra.failwith "CN_c_typedef_name before elaboration"
end

let rec register_and_desugar_cn_pattern (CNPat loc pat_) =
  match pat_ with
    | CNPat_sym ident ->
        E.register_cn_ident CN_vars ident >>= fun sym ->
        E.return (CNPat loc (CNPat_sym sym))
    | CNPat_wild ->
        E.return (CNPat loc (CNPat_wild))
    | CNPat_constructor cons args ->
        E.resolve_cn_ident CN_constructor cons >>= fun cons_resolved ->
        let cons_resolved = Cn.ensure_not_c_variable cons_resolved in
        E.mapM (fun (member, pat') ->
            register_and_desugar_cn_pattern pat' >>= fun pat' ->
            E.return (member, pat')
          ) args >>= fun args ->
        E.return (CNPat loc (CNPat_constructor cons_resolved args))
end

let pair x y = (x, y)

let desugar_maybe desugar_f o =
  match o with
  | Just x -> desugar_f x >>= fun x -> E.return (Just x)
  | Nothing -> E.return Nothing
  end

let rec desugar_cn_expr (CNExpr loc expr_) =
  match expr_ with
    | CNExpr_const cst ->
        E.return (CNExpr_const cst)
    | CNExpr_var ident ->
        E.resolve_cn_ident CN_vars ident >>= fun (sym, kind) ->
        match kind with
        | Var_kind_cn -> E.return (CNExpr_var sym)
        | Var_kind_c kind -> E.return (CNExpr_value_of_c_atom sym kind)
        end
    | CNExpr_list es ->
        CNExpr_list <$> E.mapM desugar_cn_expr es
    | CNExpr_memberof e ident_membr ->
        CNExpr_memberof <$> desugar_cn_expr e
                        <*> (E.return ident_membr)
    | CNExpr_arrow e ident_membr ->
        CNExpr_arrow <$> desugar_cn_expr e
                     <*> (E.return ident_membr)
    | CNExpr_record members ->
      CNExpr_record <$> sort_record_members desugar_cn_expr members
    | CNExpr_struct tag members ->
      (* copying from CNExpr_membershift case *)
      E.resolve_extraordinary_identifier tag E.Namespace_tag >>= function
          | Just (_, (tag_sym, _)) ->
             CNExpr_struct <$> (E.return tag_sym)
                           <*> sort_record_members desugar_cn_expr members
          | Nothing ->
              E.fail loc (Errors.Desugar_CN CNErr_invalid_tag)
      end
    | CNExpr_memberupdates e updates ->
        CNExpr_memberupdates <$> desugar_cn_expr e
                             <*> unique_record_members desugar_cn_expr updates
    | CNExpr_arrayindexupdates e updates ->
        CNExpr_arrayindexupdates <$> desugar_cn_expr e
                            <*> E.mapM (fun (i, v) -> 
                                    desugar_cn_expr i >>= fun i ->
                                    desugar_cn_expr v >>= fun v ->
                                    E.return (i, v)
                                  ) updates
    | CNExpr_binop bop e1 e2 ->
        CNExpr_binop bop <$> desugar_cn_expr e1
                         <*> desugar_cn_expr e2
    | CNExpr_sizeof ct ->
      desugar_type_name ct >>= fun (_, ct) ->
      E.return (CNExpr_sizeof ct)
    | CNExpr_offsetof struct_tag memb ->
      E.resolve_extraordinary_identifier struct_tag E.Namespace_tag >>= function
          | Just (_, (tag_sym, _)) ->
              E.return (CNExpr_offsetof tag_sym memb)
          | Nothing ->
              E.fail loc (Errors.Desugar_CN CNErr_invalid_tag)
      end
    | CNExpr_membershift e Nothing memb ->
      desugar_cn_expr e >>= fun e ->
      E.return (CNExpr_membershift e Nothing memb)
    | CNExpr_membershift e (Just struct_tag) memb ->
      E.resolve_extraordinary_identifier struct_tag E.Namespace_tag >>= function
          | Just (_, (tag_sym, _)) ->
              desugar_cn_expr e >>= fun e ->
              E.return (CNExpr_membershift e (Just tag_sym) memb)
          | Nothing ->
              E.fail loc (Errors.Desugar_CN CNErr_invalid_tag)
      end
    | CNExpr_addr nm ->
       E.resolve_ordinary_identifier loc nm >>= function
          | Just (_, E.OReg_other nm_sym _ _) ->
              E.return (CNExpr_addr nm_sym)
          | Just (_, E.OReg_enum_constant _) ->
              E.fail loc (Errors.Desugar_CN (CNErr_unknown_c_identifier nm))
          | Just (_, E.OReg_typedef _) ->
              E.fail loc (Errors.Desugar_CN (CNErr_unknown_c_identifier nm))
          | Nothing ->
              E.fail loc (Errors.Desugar_CN (CNErr_unknown_c_identifier nm))
      end
    | CNExpr_cast ty e ->
        CNExpr_cast <$> desugar_cn_base_type loc ty
                    <*> desugar_cn_expr e
    | CNExpr_array_shift e1 ct e2 ->
      desugar_cn_expr e1 >>= fun e1 ->
      desugar_maybe desugar_type_name ct >>= fun ct_tup ->
      let ct = Maybe.map (fun (_, ct) -> ct) ct_tup in
      desugar_cn_expr e2 >>= fun e2 ->
      E.return (CNExpr_array_shift e1 ct e2)
    | CNExpr_call nm es ->
        E.resolve_cn_ident CN_function nm >>= fun sym_resolved ->
        let sym = Cn.ensure_not_c_variable sym_resolved in
        CNExpr_call sym <$> E.mapM desugar_cn_expr es
    | CNExpr_cons nm es ->
       E.resolve_cn_ident CN_constructor nm >>= fun sym_resolved ->
       let sym = Cn.ensure_not_c_variable sym_resolved in
       E.mapM (fun (nm2, exp) -> pair nm2 <$> desugar_cn_expr exp) es >>= fun es ->
       E.return (CNExpr_cons sym es)
    | CNExpr_each ident bTy r e ->
        E.push_cn_scope >>= fun () ->
        E.register_cn_ident CN_vars ident >>= fun sym ->
        desugar_cn_base_type (Loc.locOf ident) bTy >>= fun bTy ->
        desugar_cn_expr e >>= fun e ->
        E.pop_cn_scope >>= fun () ->
        E.return (CNExpr_each sym bTy r e)
    | CNExpr_match x ms ->
        E.mapM (fun (lhs, rhs) ->
          E.push_cn_scope >>= fun () ->
          register_and_desugar_cn_pattern lhs >>= fun lhs ->
          desugar_cn_expr rhs >>= fun rhs ->
          E.pop_cn_scope >>= fun () ->
          E.return (lhs, rhs)
        ) ms >>= fun ms ->
        CNExpr_match <$> desugar_cn_expr x <*> E.return ms
    | CNExpr_let ident e body ->
          (*copy-pasting from CNExpr_match and adjusting*)
          desugar_cn_expr e >>= fun e ->
          E.push_cn_scope >>= fun () ->
          E.register_cn_ident CN_vars ident >>= fun sym ->
          desugar_cn_expr body >>= fun body ->
          E.pop_cn_scope >>= fun () ->
          E.return (CNExpr_let sym e body)
    | CNExpr_ite e1 e2 e3 ->
        CNExpr_ite <$> desugar_cn_expr e1
                    <*> desugar_cn_expr e2
                    <*> desugar_cn_expr e3
    | CNExpr_good ty e ->
        CNExpr_good <$> (snd <$> desugar_type_name ty)
                    <*> desugar_cn_expr e
    | CNExpr_deref e ->
        CNExpr_deref <$> desugar_cn_expr e
    | CNExpr_value_of_c_atom _ _ ->
        Assert_extra.failwith "CNExpr_var_of_c_atom"
    | CNExpr_unchanged e ->
       CNExpr_unchanged <$> desugar_cn_expr e
    | CNExpr_at_env e envname ->
       CNExpr_at_env <$> desugar_cn_expr e <*> (E.return envname)
    | CNExpr_not e ->
       CNExpr_not <$> desugar_cn_expr e
    | CNExpr_bnot e ->
       CNExpr_bnot <$> desugar_cn_expr e
    | CNExpr_negate e ->
       CNExpr_negate <$> desugar_cn_expr e
    | CNExpr_default bt ->
       CNExpr_default <$> desugar_cn_base_type loc bt
  end >>= fun ret ->
  E.return (CNExpr loc ret)

let desugar_cn_pred = function
  | CN_owned (Just tyname) ->
      desugar_type_name tyname >>= fun (_, ty) ->
      E.return (CN_owned (Just ty))
  | CN_owned Nothing ->
      E.return (CN_owned Nothing)
  | CN_block (Just tyname) ->
      desugar_type_name tyname >>= fun (_, ty) ->
      E.return (CN_block (Just ty))
  | CN_block Nothing ->
      E.return (CN_block Nothing)
  | CN_named ident ->
      E.resolve_cn_ident CN_predicate ident >>= fun sym_resolved ->
      let sym = Cn.ensure_not_c_variable sym_resolved in
      E.return (CN_named sym)
end

let desugar_cn_resource = function
  | CN_pred loc pred es ->
      CN_pred loc <$> desugar_cn_pred pred
                  <*> E.mapM desugar_cn_expr es
  | CN_each ident bTy e loc pred es ->
      desugar_cn_pred pred >>= fun pred ->
      desugar_cn_base_type (Loc.locOf ident) bTy >>= fun bTy ->
      E.push_cn_scope >>= fun () ->
      E.register_cn_ident CN_vars ident >>= fun sym ->
      desugar_cn_expr e >>= fun e ->
      E.mapM desugar_cn_expr es >>= fun es ->
      E.pop_cn_scope >>= fun () ->
      E.return (CN_each sym bTy e loc pred es)
end




let desugar_o_cn_func_body = function
    | Nothing -> 
       E.return Nothing
    | Just body ->
       desugar_cn_expr body >>= fun body' ->
       E.return (Just body')
  end
  
let desugar_cn_assertion a =
  match a with
    | CN_assert_exp e -> CN_assert_exp <$> desugar_cn_expr e
    | CN_assert_qexp ident bTy e1 e2 ->
      desugar_cn_base_type (Loc.locOf ident) bTy >>= fun bTy ->
      E.push_cn_scope >>= fun () ->
      E.register_cn_ident CN_vars ident >>= fun sym ->
      desugar_cn_expr e1 >>= fun e1 ->
      desugar_cn_expr e2 >>= fun e2 ->
      E.pop_cn_scope >>= fun () ->
      E.return (CN_assert_qexp sym bTy e1 e2)
  end



let rec desugar_cn_clause_aux clause =
  match clause with
    | CN_letResource loc ident res c ->
        desugar_cn_resource res              >>= fun res' ->
        E.register_cn_ident CN_vars ident >>= fun sym  ->
        desugar_cn_clause_aux c                  >>= fun c'   ->
        E.return (CN_letResource loc sym res' c')
    | CN_letExpr loc ident e c ->
        desugar_cn_expr e                    >>= fun e'  ->
        E.register_cn_ident CN_vars ident >>= fun sym ->
        desugar_cn_clause_aux c                  >>= fun c'  ->
        E.return (CN_letExpr loc sym e' c')
    | CN_assert loc a c ->
        CN_assert loc <$> desugar_cn_assertion a
                      <*> desugar_cn_clause_aux c
    | CN_return loc ret -> 
      desugar_cn_expr ret >>= fun ret' ->
      E.return (CN_return loc ret')
  end

let desugar_cn_clause clause = 
  E.push_cn_scope >>= fun () ->
  desugar_cn_clause_aux clause >>= fun clause ->
  E.pop_cn_scope >>= fun () ->
  E.return clause


let rec desugar_cn_clauses clauses =
  match clauses with
  | CN_clause loc clause ->
      CN_clause loc <$> desugar_cn_clause clause
  | CN_if loc e c cs ->
      CN_if loc <$> desugar_cn_expr e
                <*> desugar_cn_clause c
                <*> desugar_cn_clauses cs
  end

let desugar_maybe_cn_clauses = function
  | Just clauses -> Just <$> (desugar_cn_clauses clauses)
  | Nothing -> E.return Nothing
end

let desugar_cn_arg ns (ident, bTy) =
  desugar_cn_base_type (Loc.locOf ident) bTy >>= fun bTy' ->
  E.register_cn_ident ns ident               >>= fun sym ->
  E.return (sym, bTy')

let desugar_cn_oarg (bTy, ident) =
  desugar_cn_base_type (Loc.locOf ident) bTy >>= fun bTy' ->
  E.return (bTy', ident)


let desugar_cn_output (loc, bt) = 
  desugar_cn_base_type loc bt >>= fun bt' ->
  E.return (loc, bt')


let desugar_and_register_cn_predicate pred =
  E.register_cn_predicate pred.cn_pred_magic_loc pred.cn_pred_name pred.cn_pred_loc begin
    desugar_cn_output pred.cn_pred_output >>= fun output   ->
    E.mapM (desugar_cn_arg CN_vars) pred.cn_pred_iargs >>= fun iargs   ->
    desugar_maybe_cn_clauses pred.cn_pred_clauses               >>= fun clauses ->
    E.return (pred.cn_pred_attrs, output, iargs, clauses)
  end

let desugar_cn_dt_arg (bTy, ident) =
  desugar_cn_base_type (Loc.locOf ident) bTy >>= fun bTy' ->
  E.return (bTy', ident) 

let desugar_and_register_cn_datatype dt =
  E.register_cn_datatype dt.cn_dt_magic_loc dt.cn_dt_name dt.cn_dt_loc begin
    E.mapM (fun (id, args) ->
      E.register_cn_ident CN_constructor id >>= fun sym ->
      let args = List.map (fun (ident, bTy) -> (ident, (Loc.locOf ident, bTy))) args in
      unique_record_members (fun (loc, bTy) -> desugar_cn_base_type loc bTy) args >>= fun args ->
      E.return (sym, args)
    ) dt.cn_dt_cases
  end

let desugar_and_register_cn_type_synonym ts =
  desugar_cn_base_type ts.cn_tysyn_loc ts.cn_tysyn_rhs >>= fun bt ->
  E.register_cn_type_synonym ts.cn_tysyn_name bt

let desugar_and_register_cn_function func =
  E.register_cn_function func.cn_func_magic_loc func.cn_func_name func.cn_func_loc begin
    desugar_cn_base_type func.cn_func_loc func.cn_func_return_bty >>= fun return_bty' ->
    E.mapM (desugar_cn_arg CN_vars) func.cn_func_args >>= fun args ->
    desugar_o_cn_func_body func.cn_func_body               >>= fun body ->
    E.return (func.cn_func_attrs, return_bty', args, body)
  end


(* adapting desugar_cn_clause *)
let desugar_cn_condition condition =
  match condition with
  | CN_cletResource loc ident res ->
     desugar_cn_resource res >>= fun res' ->
     E.register_cn_ident CN_vars ident >>= fun sym ->
     E.return (CN_cletResource loc sym res')
  | CN_cletExpr loc ident e ->
     desugar_cn_expr e >>= fun e' ->
     E.register_cn_ident CN_vars ident >>= fun sym ->
     E.return (CN_cletExpr loc sym e')
  | CN_cconstr loc assrt ->
     desugar_cn_assertion assrt >>= fun assrt' ->
     E.return (CN_cconstr loc assrt')
  end

(* in cn 'conditions' the scoping follows the list structure *)
let desugar_cn_conditions conditions =
  E.mapM desugar_cn_condition conditions


(* copying and adjusting desugar_and_register_cn_function *)
let desugar_and_register_cn_lemma lmma =
  E.register_cn_lemma lmma.cn_lemma_magic_loc lmma.cn_lemma_name begin
    E.mapM (desugar_cn_arg CN_vars) lmma.cn_lemma_args >>= fun args ->
    desugar_cn_conditions lmma.cn_lemma_requires >>= fun requires ->
    desugar_cn_conditions lmma.cn_lemma_ensures >>= fun ensures ->
    E.return (args, requires, ensures)
  end

(* copying and adjusting desugar_and_register_cn_lemma *)
let desugar_and_register_cn_fun_spec spec =
  E.record_marker ()     >>= fun marker_id ->
  let loc = Loc.locOf spec.cn_spec_name in
  E.resolve_ordinary_identifier loc spec.cn_spec_name >>= function
    | Just (_, E.OReg_other nm_sym _ _) ->
        E.return nm_sym
    | Just (_, E.OReg_enum_constant _) ->
        E.fail loc (Errors.Desugar_CN (CNErr_unknown_c_identifier spec.cn_spec_name))
    | Just (_, E.OReg_typedef _) ->
        E.fail loc (Errors.Desugar_CN (CNErr_unknown_c_identifier spec.cn_spec_name))
    | Nothing ->
        E.fail loc (Errors.Desugar_CN (CNErr_unknown_c_identifier spec.cn_spec_name))
  end
  >>= fun fun_sym ->
  E.register_cn_fun_spec spec.cn_spec_magic_loc loc fun_sym marker_id begin
    E.mapM (desugar_cn_arg CN_vars) spec.cn_spec_args >>= fun args ->
    desugar_cn_conditions spec.cn_spec_requires >>= fun requires ->
    E.register_cn_ident CN_vars (Symbol.Identifier Loc.unknown "return") >>= fun rsym ->
    desugar_cn_conditions spec.cn_spec_ensures >>= fun ensures ->
    E.return (args, requires, ensures, rsym)
  end



let desugar_cn_statement (CN_statement loc stmt_) =
  match stmt_ with
  | CN_pack_unpack pack_unpack pred iargs ->
     (* copying from desugar_cn_resource *)
     desugar_cn_pred pred >>= fun pred ->
     E.mapM desugar_cn_expr iargs >>= fun iargs ->
     E.return (CN_pack_unpack pack_unpack pred iargs)
  | CN_have assrt ->
     desugar_cn_assertion assrt >>= fun assrt ->
     E.return (CN_have assrt)
  | CN_instantiate o_filter expr ->
     match o_filter with
     | I_Everything -> 
        E.return I_Everything
     | I_Good tyname ->
        desugar_type_name tyname >>= fun (_, ty) ->
        E.return (I_Good ty)
     | I_Function f -> 
        E.resolve_cn_ident CN_function f >>= fun f_resolved ->
        let f = Cn.ensure_not_c_variable f_resolved in
        E.return (I_Function f)
     end >>= fun o_filter ->
     desugar_cn_expr expr >>= fun expr ->
     E.return (CN_instantiate o_filter expr)
  | CN_split_case cond ->
     desugar_cn_assertion cond >>= fun cond ->
     E.return (CN_split_case cond)
  | CN_extract attrs to_extract expr ->
    match to_extract with
    | E_Everything -> E.return E_Everything
    | E_Pred pred -> 
        desugar_cn_pred pred >>= fun pred ->
        E.return (E_Pred pred)
    end >>= fun to_extract ->
    desugar_cn_expr expr >>= fun expr ->
    E.return (CN_extract attrs to_extract expr)
  | CN_unfold f args ->
     E.resolve_cn_ident CN_function f >>= fun f_resolved ->
     let f = Cn.ensure_not_c_variable f_resolved in
     E.mapM desugar_cn_expr args >>= fun args ->
     E.return (CN_unfold f args)
  | CN_assert_stmt e ->
     desugar_cn_assertion e >>= fun e ->
     E.return (CN_assert_stmt e)
  | CN_apply l args ->
     E.resolve_cn_ident CN_lemma l >>= fun l_resolved ->
     let l = Cn.ensure_not_c_variable l_resolved in
     E.mapM desugar_cn_expr args >>= fun args ->
     E.return (CN_apply l args)
  | CN_inline nms ->
     CN_inline <$> E.mapM (fun nm ->
       E.resolve_ordinary_identifier loc nm >>= function
         | Just (_, E.OReg_other nm_sym _ _) ->
           E.return nm_sym
         | Just (_, E.OReg_enum_constant _) ->
           E.fail loc (Errors.Desugar_CN (CNErr_unknown_c_identifier nm))
         | Just (_, E.OReg_typedef _) ->
           E.fail loc (Errors.Desugar_CN (CNErr_unknown_c_identifier nm))
         | Nothing ->
           E.fail loc (Errors.Desugar_CN (CNErr_unknown_c_identifier nm))
         end) nms
  | CN_print e ->
     desugar_cn_expr e >>= fun e ->
     E.return (CN_print e)
  end >>= fun stmt_ ->
  E.return (CN_statement loc stmt_)


(* END CN *)


(* TODO: check + annotate with STD *)
val desugar_and_register_function_definition: function_definition -> E.desugM unit
let desugar_and_register_function_definition (FunDef fundef_loc fundef_attrs specifs (Declarator ptr_decltor_opt ddecltor as decltor) stmt) =
  if List.any (fun sc -> SC_extern <> sc && SC_static <> sc) specifs.storage_classes then
    E.constraint_violation fundef_loc IllegalStorageClassFunctionDefinition
  else if specifs.alignment_specifiers <> [] then
    E.constraint_violation fundef_loc (IllegalAlignas IllegalAlignas_function)
  else
    (* NOTE: ยง6.9.1#5 is enforced inside the following call to
       'desugar_declarator' (see 'desugar_direct_declarator') *)

    E.fresh_block_scope >>= fun funblock_scope ->
    E.with_scope2 funblock_scope begin
      desugar_declarator IsFunDef decltor
    end >>= fun (idents_map, ((_, fun_ident), mk_qs_ctype)) ->
    
    (* NOTE: as per ยง6.9.1#2, we perform a dummy instantiation of the type
       **specified by the declarator portion of the function definition**, which
       here means `ddecltor' without `specifs' *)
    match mk_qs_ctype Ctype.no_qualifiers (Ctype.Ctype [] Ctype.Void) with
      | (_, Ctype.Ctype _ (Ctype.Function _ _ _)) ->
          E.return ()
      | (_, Ctype.Ctype _ (Ctype.FunctionNoParams _)) ->
          E.return ()
      | _ ->
          (* STD ยง6.9.1#2 *)
          E.constraint_violation (Loc.locOf ddecltor) WrongTypeFunctionIdentifier
    end >>
    
    E.register_ordinary_identifier fun_ident E.OK_function specifs.storage_classes >>= fun (_(*loc_fun_sym*), fun_sym) ->
    
    E.under_scope E.Scope_function begin
      register_labels stmt >>
      
      E.under_scope funblock_scope begin
        (* TODO: this is a horrible hack, DO BETTER *)
        E.hack_inject_idents_map idents_map >>


(*        desugar_declarator (IsFunDef specifs) decltor >>= fun (fun_ident, mk_qs_ctype) -> *)
        desugar_type_specifiers specifs.type_specifiers >>= fun (specs_qs, specs_ty)  ->
        let (isAtomic, tquals_qs) = translate_type_qualifiers specifs.type_qualifiers in
        let base_ty = if isAtomic then Ctype.mk_ctype_atomic specs_ty else specs_ty in
        let base_qs = Ctype.combine_qualifiers specs_qs tquals_qs in
        
        let (qs, ty) = mk_qs_ctype base_qs base_ty in
        let process (return_qs, return_ty) params_opt isVariadic =
          (* NOTE: the constraint in ยง6.9.1#3 is enforced later in the Ail
            typechecker *)
          let () = Debug.print_debug 4 [] (fun () ->
            show fun_ident ^ " ===> " ^ Pp.stringFromAil_ctype qs ty
          ) in
          E.function_is_defined fun_sym >>= function
            | true  -> E.constraint_violation (Loc.locOf fun_ident) (ExternalRedefinition fun_sym)
            | false -> E.return ()
          end >>
          E.register_function_declaration (Loc.locOf fun_ident) fundef_attrs fun_sym false (
            (return_qs, return_ty),
            params_opt,
            isVariadic,
            List.elem FS_inline   specifs.function_specifiers,
            List.elem FS_Noreturn specifs.function_specifiers
          ) >>
          E.inside_function return_ty begin
            E.record_marker ()     >>= fun marker_id ->
            desugar_statement stmt >>= fun d_stmt    ->
            E.return (Loc.locOf fun_ident, marker_id, fun_sym, d_stmt)
          end in
        match ty with
          | Ctype.Ctype _ (Ctype.Function return_qs_ty params isVariadic) ->
              process return_qs_ty (Just params) isVariadic
          | Ctype.Ctype _ (Ctype.FunctionNoParams return_qs_ty) ->
              process return_qs_ty Nothing false
          | _ ->
              (* This should not be possible due to the earlier check *)
              error "Cabs_to_ail.desugar_and_register_function_definition"
        end
      end >>= fun (loc, marker_id, fun_sym, d_stmt) ->
      E.bindings_of_idents_map idents_map >>= fun bindings ->
      E.register_function_definition fun_sym
      (* NOTE: the Cabs parser can't easily find the location of the
         function identifier, so add it here *)
      (Loc.with_cursor_from fundef_loc loc, marker_id, fundef_attrs, List.map fst bindings, d_stmt)
    end


val desugar_and_register_external_declaration: external_declaration -> E.desugM unit
let desugar_and_register_external_declaration edecl =
  let edecl_loc = Loc.locOf edecl in
  let storage_classes =
    maybe [] (fun z -> z.storage_classes) (specifiers_of_external_declaration edecl) in
  
  (* STD ยง6.9#2 *)
  if List.any (fun z -> z = SC_auto || z = SC_register) storage_classes then
    E.constraint_violation edecl_loc IllegalStorageClassFileScoped
  
  else match edecl with
    | EDecl_func fdef ->
        desugar_and_register_function_definition fdef
    
    (* struct-or-union identifier ; *)
    | EDecl_decl (Declaration_base _ <|
        storage_classes= [];
        type_specifiers= [TSpec _ (TSpec_struct attrs (Just ident) Nothing)];
        type_qualifiers= [];
        function_specifiers= [];
        alignment_specifiers= [];
      |> []) ->
        let () =
          if attrs <> Annot.no_attributes then
            Debug.print_debug 0 [] (fun () ->
              "TODO(attributes ignored) -- TSpec_struct 3 => " ^ show ident)
          else () in
        STD_ "ยง6.7.2.3#7"
        E.void (E.register_tag edecl_loc E.Kind_struct (Just ident))
    
    (* struct-or-union identifier ; *)
    | EDecl_decl (Declaration_base _ <|
        storage_classes= [];
        type_specifiers= [TSpec _ (TSpec_union attrs (Just ident) Nothing)];
        type_qualifiers= [];
        function_specifiers= [];
        alignment_specifiers= [];
      |> []) ->
        STD_ "ยง6.7.2.3#7"
        E.void (E.register_tag edecl_loc E.Kind_union (Just ident))
    
    (* enum identifier ; *)
    | EDecl_decl (Declaration_base _ <|
        storage_classes= [];
        type_specifiers= [TSpec _ (TSpec_enum (Just ident) Nothing)];
        type_qualifiers= [];
        function_specifiers= [];
        alignment_specifiers= [];
      |> []) ->
        E.fail (Loc.locOf ident) (Errors.Desugar_MiscViolation Errors.EnumSimpleDeclarationConstruction)
    
    (* TODO: check *)
    | EDecl_decl (Declaration_base attrs specifs idecltors) ->
        desugar_type_specifiers specifs.type_specifiers >>= fun (specs_qs, base_ty) ->
        let (isAtomic, tquals_qs) = translate_type_qualifiers specifs.type_qualifiers in
        let base_qs = Ctype.combine_qualifiers specs_qs tquals_qs in
        (* TODO: why the two maps? *)
        (* NOTE: this is (at least) needed to get the scope of typedefs right
           (see suite/parsing/declarator_visibility.c) *)
        (* NOTE: `desugar_init_declarator' does register the identifier it finds *)
        E.mapM (fun init ->
          desugar_init_declarator attrs isAtomic (specifs.alignment_specifiers <> []) base_qs base_ty specifs.storage_classes init
        ) idecltors >>= fun xs ->
        
        (* for each [init_declarator] *)
        E.mapM_ (function
          | Nothing ->
              (* Case of a typedef *)
              E.return ()
          | Just (ident_loc, ident_attrs, link, sym, isTentative, (qs, ty), mk_desug_init) ->
              let do_function fun_qs return_qs_ty params_opt is_variadic =
                let () =
                  if Annot.no_attributes <> ident_attrs then
                    Debug.print_debug 0 [] (fun () ->
                      "WARNING: desugaring of a function initdecl is erasing some attributes!"
                    )
                  else
                    () in
                if qs <> Ctype.no_qualifiers then
                  E.undef ident_loc Undefined.UB066_qualified_function_specification
                else if specifs.alignment_specifiers <> [] then
                  E.constraint_violation ident_loc (IllegalAlignas IllegalAlignas_function)
                else
                E.register_function_declaration ident_loc attrs sym true (
                  return_qs_ty,
                  params_opt,
                  is_variadic,
                  List.elem FS_inline   specifs.function_specifiers,
                  List.elem FS_Noreturn specifs.function_specifiers
                ) in
              (* NOTE: `desugar_init_declarator' takes care of isAtomic *)
              match ty with
                | Ctype.Ctype _ (Ctype.Function return_qs_ty params is_variadic) ->
                    do_function qs return_qs_ty (Just params) is_variadic
                | Ctype.Ctype _ (Ctype.FunctionNoParams return_qs_ty) ->
                    do_function qs return_qs_ty Nothing false
                | ty ->
                    if List.elem SC_register specifs.storage_classes && specifs.alignment_specifiers <> [] then
                      E.constraint_violation ident_loc (IllegalAlignas IllegalAlignas_register)
                    else
                    desugar_alignment_specifiers ident_loc ty specifs.alignment_specifiers >>= fun align_opt ->
                    let dur = determinate_storage_duration link specifs.storage_classes in
                    E.register_external_object_declaration sym
                      (isTentative, ident_loc, Annot.combine_attributes attrs ident_attrs, dur, List.elem SC_register specifs.storage_classes, align_opt, qs, ty) >>
                    
                    mk_desug_init () >>= function
                      | Just (ty', d_e) ->
                          E.print_debugM 2 (fun () ->
                            "Hello, ty' = " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers ty'
                          ) >>=fun () ->
                          begin if ty <> ty' then
                            E.print_debugM 2 (fun () ->
                              "ty' is new"
                            ) >>= fun () ->
                            (* TODO: tentative *)
                            E.update_external_object_type sym ty'
                          else
                            E.return ()
                          end >>
                          (* NOTE: it is the type after the initialisation which must be complete *)
                          E.is_incomplete ty' >>= fun is_incomplete ->
                          if link = Linkage_none && is_incomplete then
                            E.undef ident_loc Undefined.UB059_incomplete_no_linkage_identifier
                          else
(* KKK:
                            E.global_object_is_defined sym >>= function
                              | true ->
                                  match link with
                                    | Linkage_internal ->
                                        (* STD ยง6.9#3, sentence 1 *)
                                        E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "ยง6.9#3, sentence 1")
                                    | Linkage_external ->
                                        (* STD ยง6.9#5, sentence 2 *)
                                        E.fail ident_loc (Errors.Desugar_UndefinedBehaviour Undefined.UB084)
                                    | Linkage_none ->
                                        error "[Cabs_to_ail.desugar_and_register_external_declaration] - internal ERROR"
                                  end
                              | false ->
                                  E.register_global_object_definition2 sym (E.ExternalDefinition d_e)
                              end
*)
                                  E.register_global_object_definition2 ident_loc sym link (E.ExternalDefinition d_e)
                      | Nothing ->
                          E.is_incomplete ty >>= fun is_incomplete ->
                          if link = Linkage_internal && is_incomplete then
                            (* TODO: this is wrong (see tentative definition in the STD) *)
                            E.undef ident_loc Undefined.UB089_tentative_definition_internal_linkage
                          else if link = Linkage_none && is_incomplete then
                            E.undef ident_loc Undefined.UB059_incomplete_no_linkage_identifier
                          else
                            if dur = Static || dur = Thread then
                              (* TODO: not correct for thread? *)
                              if List.elem SC_extern specifs.storage_classes then
                                E.return ()
                              else
                                E.register_global_object_definition2 ident_loc sym link (E.Tentative ident_loc ty (*mk_zeroInit tagDefs ty*))
                            else
                              E.return ()
                    end
              end
        end) xs
  
    | EDecl_decl (Declaration_static_assert sa_decl) ->
        desugar_and_register_static_assert_declaration sa_decl
    | EDecl_magic str ->
      E.add_toplevel_magic str
    | EDecl_predCN pred ->
      desugar_and_register_cn_predicate pred
    | EDecl_funcCN pred ->
      desugar_and_register_cn_function pred
    | EDecl_lemmaCN lmma ->
      desugar_and_register_cn_lemma lmma
    | EDecl_fun_specCN spec ->
      desugar_and_register_cn_fun_spec spec
    | EDecl_datatypeCN dt ->
      desugar_and_register_cn_datatype dt
    | EDecl_type_synCN ts ->
      desugar_and_register_cn_type_synonym ts
  end

val register_cn_predicate_names: list external_declaration -> E.desugM unit
let register_cn_predicate_names xs =
  E.mapM_ (function
    | EDecl_predCN pred ->
        E.register_cn_ident Cn.CN_predicate pred.cn_pred_name >>= fun _ ->
        E.return ()
    | _ ->
        E.return ()
  end) xs

val register_cn_function_names: list external_declaration -> E.desugM unit
let register_cn_function_names xs =
  E.mapM_ (function
    | EDecl_funcCN pred ->
        E.register_cn_ident Cn.CN_function pred.cn_func_name >>= fun _ ->
        E.return ()
    | _ ->
        E.return ()
  end) xs

val register_cn_datatype_names: list external_declaration -> E.desugM unit
let register_cn_datatype_names xs =
  E.mapM_ (function
    | EDecl_datatypeCN dt ->
        E.print_debugM 2 (fun () ->
          "adding a datatype name"
        ) >>= fun () ->
        E.register_cn_ident Cn.CN_datatype_nm dt.cn_dt_name >>= fun _ ->
        E.return ()
    | _ ->
        E.return ()
  end) xs

val register_additional_cn_var: Symbol.identifier -> E.desugM Symbol.sym
let register_additional_cn_var id = E.register_cn_ident CN_vars id


import Core
val desugar: (map string Symbol.sym) * Core.fun_map unit * Core.impl -> Cn_desugaring.init_scope -> string -> translation_unit ->
  Exception.exceptM (E.fin_markers_env * ail_program unit) Errors.error
let desugar core_eval_stuff cn_eval_stuff startup_str (TUnit edecls) =
(*
  E.eval sym_counter core_eval_stuff cn_eval_stuff (
    E.under_scope E.Scope_file (
      let (base_qs1, base_ty1, ptr_decltor1) =
        ( Ctype.make_qualifiers true false false
        , Ctype.Basic (Ctype.Integer (Ctype.Signed Ctype.Int_))
        , PDecl [] (Just (PDecl [] Nothing)) ) in (* int const **ptrToPtrToConstInt *)
      
      let (base_qs2, base_ty2, ptr_decltor2) =
        ( Ctype.no_qualifiers
        , Ctype.Basic (Ctype.Integer (Ctype.Signed Ctype.Int_))
        , PDecl [Q_const] (Just (PDecl [] Nothing)) ) in (* int * const *ptrToConstPtrToInt *)
      
      let (base_qs3, base_ty3, ptr_decltor3) =
        ( Ctype.no_qualifiers
        , Ctype.Basic (Ctype.Integer (Ctype.Signed Ctype.Int_))
        , PDecl [] (Just (PDecl [Q_const] Nothing)) ) in (* int ** const constPtrToPtrToInt *)
      
      desugar_pointer_declarator ptr_decltor1 >>= fun mk_type1 ->
      let (qs1, ty1) = mk_type1 base_qs1 base_ty1 in
      let () = Debug.print_debug 2 [] (fun () -> "int const **ptrToPtrToConstInt") in
      let () = Debug.print_debug 2 [] (fun () -> (Pp.stringFromAil_ctype qs1 ty1)) in
      
      desugar_pointer_declarator ptr_decltor2 >>= fun mk_type2 ->
      let (qs2, ty2) = mk_type2 base_qs2 base_ty2 in
      let () = Debug.print_debug 2 [] (fun () -> "int * const *ptrToConstPtrToInt") in
      let () = Debug.print_debug 2 [] (fun () -> (Pp.stringFromAil_ctype qs2 ty2)) in
      
      desugar_pointer_declarator ptr_decltor3 >>= fun mk_type3 ->
      let (qs3, ty3) = mk_type3 base_qs3 base_ty3 in
      let () = Debug.print_debug 2 [] (fun () -> "int ** const constPtrToPtrToInt") in
      let () = Debug.print_debug 2 [] (fun () -> (Pp.stringFromAil_ctype qs3 ty3)) in
      
      (* ----- *)
      
      let decltor1 =
        Declarator (Just ptr_decltor1) (DDecl_identifier (Identifier Loc.unknown "ptrToPtrToConstInt")) in
      let specifs1 = <|
        storage_classes= [];
        type_specifiers= [TSpec_int];
        type_qualifiers= [Q_const];
        function_specifiers= [];
        alignment_specifiers= [];
      |> in
      let edecl1 =
        EDecl_decl (Declaration_base specifs1
          [InitDecl Loc.unknown decltor1 Nothing]) in
      
      desugar_declarator decltor1 >>= fun (_, mk_qs_type1) ->
      desugar_type_specifiers specifs1.type_specifiers >>= fun (specs_qs, base_ty) ->
      let (qs, ty) =
        let (_, tquals_qs) = translate_type_qualifiers specifs1.type_qualifiers in
        mk_qs_type1 (Ctype.combine_qualifiers specs_qs tquals_qs) base_ty in
      
      let () = Debug.print_debug 2 [] (fun () -> "DECLTOR1:") in
      let () = Debug.print_debug 2 [] (fun () -> (Pp.stringFromAil_ctype qs ty)) in
      
      (* ----- *)
      
      let (_, tquals_qs) = translate_type_qualifiers specifs1.type_qualifiers in
      desugar_init_declarator (Ctype.combine_qualifiers specs_qs tquals_qs) base_ty specifs1.storage_classes
        (InitDecl Loc.unknown decltor1 Nothing) >>= fun (ident, (qs, ty), mk_desug_init) ->
      
      let () = Debug.print_debug 2 [] (fun () -> "INIT DECLARATOR:") in
      let () = Debug.print_debug 2 [] (fun () -> (Pp.stringFromAil_ctype qs ty)) in
      
      
      
      
      E.mapM_ desugar_and_register_external_declaration edecls >>
      E.extract_program startup_str
    )
  ) 
*)
  E.eval core_eval_stuff cn_eval_stuff (
    E.under_scope E.Scope_file (
      register_cn_predicate_names edecls                       >>= fun () ->
      register_cn_function_names edecls                        >>= fun () ->
      register_cn_datatype_names edecls                        >>= fun () ->
      E.mapM_ desugar_and_register_external_declaration edecls >>= fun () ->
      E.extract_program startup_str
    )
  ) 
