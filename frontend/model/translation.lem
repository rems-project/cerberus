(* TODO: for now everything is mapped to nonatomics. The translation to atomics
         still needs to be defined *)

open import Pervasives Utils Global Loc String_extra Num

import State Translation_effect Loc List_extra
open import Translation_aux
import Cmm_csem Mem

import Decode
import Core_typing

import AilSyntax AilSyntaxAux Ctype AilTypesAux
import GenTypes
import Core Core_aux Undefined Builtins Annot Core_linking

import Linux

import Ctype

module A    = AilSyntax
module Aaux = AilSyntaxAux


module C    = Core
module Cty  = struct 
  include import Ctype
  include import Core_ctype_aux
end
module Caux = Core_aux
module U    = Undefined

module Cmm = Cmm_csem


module E = Translation_effect
module Operators = struct
  let inline (>>=)      = E.bind
  let inline (>>) m f   = E.bind m (fun _ -> f)
  let inline (<$>) f ma = E.bind ma (fun a -> E.return (f a))
  let inline (<*>) mf m = E.bind mf (fun f -> f <$> m)
end

open Operators


val illTypedAil: forall 'a. Loc.t -> string -> 'a
let illTypedAil loc debug_str =
  error ("[Translation => '" ^ debug_str ^ "'] fatal error, the Ail program was ill-typed")


(*
(* Return the core_object_type that the elaboration of an ail expression of a
   given ctype will have *)
val     core_type_of_expr_ctype: Ctype.ctype -> either C.core_base_type C.core_object_type
let rec core_type_of_expr_ctype ty =
  match ty with
    | Ctype.Void ->
        Left C.BTy_unit
    | Ctype.Basic (Ctype.Integer _) ->
        Right C.OTy_integer
    | Ctype.Basic (Ctype.Floating _) ->
        Right C.OTy_floating
    | Ctype.Array _ _ ->
        Right C.OTy_pointer
(*
    | Ctype.Function of (Ctype.qualifiers * ctype) * list (Ctype.qualifiers * ctype) * bool (*isVariadic*) ->
*)      
    | Ctype.Pointer _ _ ->
        Right C.OTy_pointer
    | Ctype.Atomic atom_ty ->
        core_type_of_expr_ctype atom_ty
    | Ctype.Struct tag_ident ->
        Right (C.OTy_struct tag_ident)
    | Ctype.Union tag_ident ->
        Right (C.OTy_union tag_ident)
    | Ctype.Builtin str ->
        error "TODO: Translation.core_object_type_of_expr_ctype"
  end
*)


(* NOTE: it only fails in function types and unspecified sized arrays *)
let force_core_object_type_of_ctype ty =
  match Caux.core_object_type_of_ctype ty with
    | Just oTy ->
        oTy
    | (*BISECT-IGNORE*) Nothing ->
        error "Translation.force_core_object_type_of_ctype: Nothing"
  end

val signedInt_gty: GenTypes.genType
let signedInt_gty =
  GenTypes.GenBasic (GenTypes.GenInteger (GenTypes.Concrete (Ctype.Signed Ctype.Int_)))




(* STD §6.5.13#3, sentence 1 *)
(* STD §6.5.14#3, sentence 1 *)
(* STD §6.5.15#4, sentence 2 *)
(* STD §6.7.10#2 *)
(* STD §6.8.4.1#2, sentence 1-2 *)
(* STD §6.8.5#4, sentence 1 *)
(* Some C constructs perform tests on scalar expression, with dynamic semantics
   varying on whether its value "compares equal to 0". The semantics of the quoted
   sentence implicitly refers to that of the C binary equality operator.
   This function turns a [e] scalar expression into a [e == 0], so that elaboration
   of the equality operator can be reused *)

type test_operator =
  | TestEq
  | TestNe

val mkTestExpression: forall 'a. test_operator -> A.expression GenTypes.genTypeCategory -> A.expression GenTypes.genTypeCategory
let mkTestExpression op (A.AnnotatedExpression gty annots _ _ as a_expr) =
  let loc = locOf a_expr in
  let gtc =
    (* STD §6.5.9#3, sentence 1 *)
    GenTypes.GenRValueType signedInt_gty in
  let bop = match op with
    | TestEq -> A.Eq
    | TestNe -> A.Ne
  end in
  let zero_const =
    if AilTypesAux.is_integer (ctype_of a_expr) then
      A.ConstantInteger (A.IConstant 0 A.Octal Nothing)
    else if AilTypesAux.is_floating (ctype_of a_expr) then
      A.ConstantFloating ("0.0", Nothing)
    else if AilTypesAux.is_pointer (ctype_of a_expr) then
      A.ConstantNull
    else
      (*BISECT-IGNORE*) error "[Translation.mkTestExpression] must be called on scalar expression" in
  A.AnnotatedExpression gtc annots loc
    (A.AilEbinary a_expr bop (A.AnnotatedExpression gty annots loc (A.AilEconst zero_const)))


val zeroAil_tau: A.expression GenTypes.genTypeCategory
let zeroAil_tau =
  A.AnnotatedExpression
    (GenTypes.GenRValueType signedInt_gty) [] Loc.unknown
    (A.AilEconst (A.ConstantInteger (A.IConstant 0 A.Octal Nothing)))

val oneAil_tau: A.expression GenTypes.genTypeCategory
let oneAil_tau =
  A.AnnotatedExpression
    (GenTypes.GenRValueType signedInt_gty) [] Loc.unknown
    (A.AilEconst (A.ConstantInteger (A.IConstant 1 A.Decimal Nothing)))


(* ========================================================================== *)

let mk_cheri_derive_and_assign_cap is_signed cap_op (obj1_sym_pe, obj2_sym_pe) core_pe =
  E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, cap_sym_pat, cap_sym_pe) ->
  E.return begin
    Caux.mk_let_pe cap_sym_pat
      (Caux.mk_memop_pe (Mem_common.DeriveCap cap_op is_signed)
        [obj1_sym_pe; obj2_sym_pe])
      (Caux.mk_memop_pe Mem_common.CapAssignValue
        [cap_sym_pe; core_pe])
  end


(*
val shiftPathFromMember: A.program GenTypes.genTypeCategory -> Symbol.sym -> Symbol.identifier -> C.shift_path
let shiftPathFromMember program tag ident =
  match List.lookup tag (snd program).A.tag_definitions with
    | Just (A.StructDef ident_tys) ->
        let sh = fromRight $ List.foldl (fun acc_ (ident', ty) ->
          match acc_ with
            | Left acc ->
                if ident = ident' then
                  if List.null acc then
                    Right [(ty, Caux.mk_integer_pe 0)]
                  else
                    Right acc
                else
                  Left ((ty, Caux.mk_integer_pe 1) :: acc)
            | Right acc ->
                Right acc
          end
        ) (Left []) ident_tys in
        sh
    | Just (A.UnionDef ident_tys) ->
        [(Caux.proj_ctype (fromJust "Translation.shiftPathFromMember" $ List.lookup ident ident_tys), Caux.mk_integer_pe 0)]
    
    | Nothing ->
        error ("Translation.shiftPathFromMember: couldn't find a definition for `" ^ show tag ^ "'")
  end
*)


val translate_integerConstant: A.integerConstant -> C.pexpr
let translate_integerConstant iCst =
  C.Pexpr [] () (C.PEval (C.Vobject (C.OVinteger (
    match iCst with
      | A.IConstant n _ _ ->
          Mem.integer_ival n
      | A.IConstantMax ity ->
          Mem.max_ival ity
      | A.IConstantMin ity ->
          Mem.min_ival ity
    end
  ))))

val translate_memory_order: A.expression GenTypes.genTypeCategory -> Cmm.memory_order
let translate_memory_order (A.AnnotatedExpression _ _ _ expr as a_expr) =
  match expr with
    | A.AilEconst (A.ConstantInteger (A.IConstant n _ _)) ->
        match Builtins.decode_memory_order (natFromInteger n) with
          | Just mo -> mo
          | Nothing ->
              error ("Translation.translate_memory_order: " ^ show n)
        end
    | (*BISECT-IGNORE*) _ ->
        error ("Translation.translate_memory_order: " ^ Pp.stringFromAil_expression a_expr)
  end

val translate_linux_memory_order: A.expression GenTypes.genTypeCategory -> Linux.linux_memory_order
let translate_linux_memory_order (A.AnnotatedExpression _ _ _ expr as a_expr) =
  match expr with
    | A.AilEconst (A.ConstantInteger (A.IConstant n _ _)) ->
        match natFromInteger n with
          | 0 -> Linux.Once
          | 1 -> Linux.LAcquire
          | 2 -> Linux.LRelease
          | 3 -> Linux.Rmb
          | 4 -> Linux.Wmb
          | 5 -> Linux.Mb
          | 6 -> Linux.RbDep
          | 7 -> Linux.RcuLock
          | 8 -> Linux.RcuUnlock
          | 9 -> Linux.SyncRcu
          | (*BISECT-IGNORE*) _ ->
              error ("Translation.translate_linux_memory_order: " ^ show n)
        end
    | (*BISECT-IGNORE*) _ ->
        error ("Translation.translate_linux_memory_order: " ^ Pp.stringFromAil_expression a_expr)
  end






val     translate_constant: A.constant -> C.pexpr
let rec translate_constant cst =
  match cst with
    | A.ConstantIndeterminate ty ->
        (* NOTE: we assume the lack of trap representation *)
        Caux.mk_value_pe (C.Vloaded (C.LVunspecified ty))
    | A.ConstantNull ->
        (* TODO: should make the Ail ctor take a ctype? *)
        Caux.mk_specified_pe (Caux.mk_nullptr_pe Cty.void)
    | A.ConstantInteger (A.IConstant n _ _) ->
        (* TODO: suffix/basis? + check *)
        Caux.mk_value_pe (C.Vloaded (C.LVspecified (C.OVinteger (Mem.integer_ival n))))
    | A.ConstantInteger (A.IConstantMax ity) ->
        Caux.mk_value_pe (C.Vloaded (C.LVspecified (C.OVinteger (Mem.max_ival ity))))
    | A.ConstantInteger (A.IConstantMin ity) ->
        Caux.mk_value_pe (C.Vloaded (C.LVspecified (C.OVinteger (Mem.min_ival ity))))
    | A.ConstantFloating (str, _) ->
        (* TODO: suffix *)
        Caux.mk_value_pe (C.Vloaded (C.LVspecified (C.OVfloating (Mem.str_fval str))))
    | A.ConstantCharacter (_, str) ->
        (* TODO: prefix? *)
        (* TODO: making an implementation fix here (ASCII) *)
        Caux.mk_value_pe (C.Vloaded (C.LVspecified (C.OVinteger (Mem.integer_ival (Decode.decode_character_constant str)))))
    | A.ConstantArray _ csts ->
        Caux.mk_specified_pe (Caux.mk_array_pe (List.map translate_constant csts))
    | A.ConstantStruct tag_sym xs ->
        Caux.mk_specified_pe begin
          Caux.mk_struct_pe tag_sym begin
            List.map (fun (memb_ident, cst) -> (memb_ident, translate_constant cst)) xs
          end
        end
    | A.ConstantUnion tag_sym memb_ident pe ->
        Caux.mk_specified_pe (Caux.mk_union_pe tag_sym memb_ident (translate_constant pe))
  end



type expr_ctx =
  | ECTX_glob of Symbol.sym * Symbol.sym
  | ECTX_other


let rec translate_function_designator ctx variadic_env stdlib tagDefs (A.AnnotatedExpression _ _ _ expr as a_expr) =
  let (Ctype.Ctype _ cty as ty) = ctype_of a_expr in
  match (cty, expr) with
    | (Ctype.Function _ params is_variadic, A.AilEunary A.Indirection e) ->
        let () = Debug.print_debug 1 [] (fun () -> "FUNTION POINTERS: UNARY INDIRECTION") in
        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (fun_sym, fun_sym_pat, fun_sym_pe) ->
        translate_expression ctx variadic_env stdlib tagDefs e >>= fun core_e ->
        E.return (Caux.mk_sseq_e fun_sym_pat core_e (Caux.mk_pure_e (Caux.mk_sym_pe fun_sym)))
    | (Ctype.Function _ params is_variadic, A.AilEident fid) ->
        let fid_pe = match fid with
          | Symbol.Symbol _ _ (Symbol.SD_Id str) ->
              match Map.lookup str stdlib.ailnames with
                | Just sym ->
                    Caux.mk_value_pe (Core.Vloaded (C.LVspecified (Core.OVpointer (Mem.fun_ptrval sym))))
                | Nothing ->
                    Caux.mk_value_pe (Core.Vloaded (C.LVspecified (Core.OVpointer (Mem.fun_ptrval fid))))
              end
          | _ ->
              Caux.mk_value_pe (Core.Vloaded (C.LVspecified (Core.OVpointer (Mem.fun_ptrval fid))))
        end in
        E.return (Caux.mk_pure_e fid_pe)
    | (*BISECT-IGNORE*) _ ->
        error ("[Translation.translate_function_designator] wildcard case ==> " ^
               Pp.stringFromAil_expression a_expr ^ " and type= " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers ty)
  end


(* STD §6.5.5 Multiplicative operators *)
and translate_mul_operator loc self usual_arithmetic_conversion stdlib result_ty e1 e2 =
  let oTy1 = force_core_object_type_of_ctype (ctype_of e1) in
  let oTy2 = force_core_object_type_of_ctype (ctype_of e2) in
  self e1                                    >>= fun core_e1                               ->
  self e2                                    >>= fun core_e2                               ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy1) >>= fun (e1_sym  , e1_sym_pat  , e1_sym_pe  ) ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy2) >>= fun (e2_sym  , e2_sym_pat  , e2_sym_pe  ) ->
  E.wrapped_fresh_symbol (C.BTy_object oTy1) >>= fun (obj1_sym, obj1_sym_pat, obj1_sym_pe) ->
  E.wrapped_fresh_symbol (C.BTy_object oTy2) >>= fun (obj2_sym, obj2_sym_pat, obj2_sym_pe) ->
  E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, cap_sym_pat, cap_sym_pe) ->
  let (promoted1_pe, promoted2_pe) =
    Caux.mk_std_pair_pe "§6.5.5#3"
      (usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe) in
  E.return begin
    C.Expr [Annot.Astd "§6.5.5"] (
      C.Ewseq (Caux.mk_tuple_pat [ e1_sym_pat; e2_sym_pat ]) (Caux.mk_unseq [core_e1; core_e2]) (
        Caux.mk_pure_e (
          Caux.mk_case_pe (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
            [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_sym_pat
                                 ; Caux.mk_specified_pat obj2_sym_pat ],
               (* Both operand are specified *)
               let core_mul = Caux.mk_std_pe "§6.5.5#4" (Caux.mk_op_pe C.OpMul promoted1_pe promoted2_pe) in
               Caux.mk_specified_pe begin
if Global.is_CHERI () && Ctype.is_ptr_t result_ty then
                  Caux.mk_let_pe cap_sym_pat
                    (Caux.mk_memop_pe (Mem_common.DeriveCap (Mem_common.DCbinary (A.Arithmetic A.Mul)) (AilTypesAux.is_signed_integer_type result_ty))
                      [obj1_sym_pe; obj2_sym_pe])
                    (Caux.mk_memop_pe Mem_common.CapAssignValue
                      [cap_sym_pe; stdlib.mkcall_wrapI result_ty core_mul])

else if AilTypesAux.is_signed_integer_type result_ty then
                 stdlib.mkcall_catch_exceptional_condition result_ty core_mul
else if AilTypesAux.is_integer result_ty then
                 stdlib.mkcall_wrapI result_ty core_mul
else
                 core_mul
               end )
            ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy1; C.BTy_loaded oTy2]),
               (* If either operand is unspecified, the result is also unspecified is the
                  result type of unsigned. Otherwise it is undef, since the multiplication
                  may overflow *)
if AilTypesAux.is_unsigned_integer_type result_ty then
               Caux.mk_unspecified_pe result_ty
else
               Caux.mk_undef_exceptional_condition loc) ]
        )
      )
    )
  end


and translate_div_mod_operator loc self usual_arithmetic_conversion stdlib result_ty aop e1 e2 =
  (* STD "§6.5.5" *)
  let oTy1    = force_core_object_type_of_ctype (ctype_of e1) in
  let oTy2    = force_core_object_type_of_ctype (ctype_of e2) in
  let oTy_res = force_core_object_type_of_ctype result_ty     in
  let zero_pe = match oTy_res with
    | C.OTy_integer ->
        Caux.mk_integer_pe 0
    | C.OTy_floating ->
        Caux.mk_floating_value_pe Mem.zero_fval
    | (*BISECT-IGNORE*) _ ->
      illTypedAil Loc.unknown "AilEbinary Div, Mod"
  end in
  self e1                                       >>= fun core_e1                                  ->
  self e2                                       >>= fun core_e2                                  ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy1)    >>= fun (e1_sym   , e1_sym_pat   , e1_sym_pe   ) ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy2)    >>= fun (e2_sym   , e2_sym_pat   , e2_sym_pe   ) ->
  E.wrapped_fresh_symbol (C.BTy_object oTy1)    >>= fun (obj1_sym , obj1_sym_pat , obj1_sym_pe ) ->
  E.wrapped_fresh_symbol (C.BTy_object oTy2)    >>= fun (obj2_sym , obj2_sym_pat , obj2_sym_pe ) ->
  E.wrapped_fresh_symbol (C.BTy_object oTy_res) >>= fun (conv1_sym, conv1_sym_pat, conv1_sym_pe) ->
  E.wrapped_fresh_symbol (C.BTy_object oTy_res) >>= fun (conv2_sym, conv2_sym_pat, conv2_sym_pe) ->
  let (promoted1_pe, promoted2_pe) = Caux.mk_std_pair_pe "§6.5.5#3"
    (usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe) in
  let (ub, core_pe) = match aop with
    | A.Div ->
        (Undefined.UB045a_division_by_zero,
         Caux.mk_op_pe C.OpDiv promoted1_pe conv2_sym_pe)
    | A.Mod ->
        (Undefined.UB045b_modulo_by_zero,
(*         Caux.mk_if_pe (Caux.mk_op_pe C.OpLt conv1_sym_pe (Caux.mk_integer_pe 0)) *)
           (Caux.mk_op_pe C.OpRem_t conv1_sym_pe conv2_sym_pe)
(*           (Caux.mk_op_pe C.OpRem_t (Caux.mk_op_pe C.OpAdd conv1_sym_pe conv2_sym_pe) conv2_sym_pe) *))
    | (*BISECT-IGNORE*) _ ->
        error "[Translation.translate_div_mod_operator], 'aop' must be multiplicative"
  end in
  (* TODO[check]: When integers are divided, the result of the / operator is the algebraic
                  quotient with any fractional part discarded.105) If the quotient a/b is
                  representable, the expression (a/b)*b + a%b shall equal a; otherwise, the
                  behavior of both a/b and a%b is undefined. *)
    E.return begin
      C.Expr [Annot.Astd "§6.5.5"] (
        C.Ewseq (Caux.mk_tuple_pat [ e1_sym_pat; e2_sym_pat ]) (Caux.mk_unseq [core_e1; core_e2]) (
          Caux.mk_pure_e (
            Caux.mk_case_pe (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
              [ ( Caux.mk_tuple_pat [ Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                                   ; Caux.mk_empty_pat (C.BTy_loaded oTy2) ]
                ,
if AilTypesAux.is_signed_integer_type result_ty then
                  Caux.mk_undef_exceptional_condition loc
else
                  Caux.mk_unspecified_pe result_ty )

              ; ( Caux.mk_tuple_pat [ Caux.mk_empty_pat (C.BTy_loaded oTy1)
                                    ; Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype) ]
                , Caux.mk_std_undef_pe loc "§6.5.5#5, sentence 2" ub )

              ; ( Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_sym_pat
                                    ; Caux.mk_specified_pat obj2_sym_pat ]
                , Caux.mk_let_pe conv1_sym_pat promoted1_pe (
                    Caux.mk_let_pe conv2_sym_pat promoted2_pe (
                      Caux.mk_if_pe_ [Annot.Anot_explode] (Caux.mk_op_pe C.OpEq conv2_sym_pe zero_pe)
                        (Caux.mk_std_undef_pe loc "§6.5.5#5, sentence 2" ub)
                        (* if a/b is representable *)
                        (Caux.mk_if_pe_ [Annot.Anot_explode] (stdlib.mkcall_is_representable (Caux.mk_op_pe C.OpDiv promoted1_pe conv2_sym_pe) result_ty)
                           begin
                             Caux.mk_specified_pe (Caux.mk_std_pe "§6.5.5#5, sentence 1" begin
                               if AilTypesAux.is_signed_integer_type result_ty then
                                 stdlib.mkcall_catch_exceptional_condition result_ty core_pe
                               else if AilTypesAux.is_integer result_ty then
                                 stdlib.mkcall_wrapI result_ty core_pe
                               else
                                 core_pe
                             end)
                           end
                           (Caux.mk_undef_pe loc Undefined.UB045c_quotient_not_representable))
                      )
                    ) ) ]
          )
        )
      )
    end

(* STD §6.5.8 Relational operators *)
and translate_relational_operator self usual_arithmetic_conversion result_ty bop e1 e2 =
  (* STD "§6.5.8" *)
  let oTy1    = force_core_object_type_of_ctype (ctype_of e1) in
  let oTy2    = force_core_object_type_of_ctype (ctype_of e2) in
  (* let oTy_res = force_core_object_type_of_ctype (result_ty)     in *)
  self e1                                    >>= fun core_e1                                  ->
  self e2                                    >>= fun core_e2                                  ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy1) >>= fun (e1_sym   , e1_sym_pat   , e1_sym_pe   ) ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy2) >>= fun (e2_sym   , e2_sym_pat   , e2_sym_pe   ) ->
  E.wrapped_fresh_symbol (C.BTy_object oTy1) >>= fun (obj1_sym , obj1_sym_pat , obj1_sym_pe ) ->
  E.wrapped_fresh_symbol (C.BTy_object oTy2) >>= fun (obj2_sym , obj2_sym_pat , obj2_sym_pe ) ->
  (* TODO: restrict this to the ptr vs ptr case *)
  E.wrapped_fresh_symbol C.BTy_boolean >>= fun (memop_sym, memop_sym_pat, memop_sym_pe) ->
  (* The object type on which the Core operator is going to work on. *)
  (* By typing it is enough to look at the type of one of the operand (see STD §6.5.8#2) *)
  let real_bop = match bop with
    | A.Lt -> C.OpLt
    | A.Gt -> C.OpGt
    | A.Le -> C.OpLe
    | A.Ge -> C.OpGe
    | (*BISECT-IGNORE*) _ -> error "[Translation.translate_relational_operator], 'bop' must be relational"
  end in
  E.return begin
    C.Expr [Annot.Astd "§6.5.8"] (
      C.Ewseq (Caux.mk_tuple_pat [ e1_sym_pat; e2_sym_pat ]) (Caux.mk_unseq [core_e1; core_e2]) (
        C.Expr [] (
          C.Ecase (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
              [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_sym_pat
                                   ; Caux.mk_specified_pat obj2_sym_pat ],
(if AilTypesAux.is_real (ctype_of e1) then
                 let (promoted1_pe, promoted2_pe) = Caux.mk_std_pair_pe "§6.5.8#3"
                     (usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe) in
                 C.Expr [Annot.Astd "§6.5.8#6"] (
                   C.Epure (
                     Caux.mk_if_pe_ [Annot.Anot_explode] (Caux.mk_op_pe real_bop promoted1_pe promoted2_pe)
                       (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
                       (Caux.mk_specified_pe (Caux.mk_integer_pe 0))
                   )
                 )
else
                 let memop = match bop with
                   | A.Lt -> Mem_common.PtrLt
                   | A.Gt -> Mem_common.PtrGt
                   | A.Le -> Mem_common.PtrLe
                   | A.Ge -> Mem_common.PtrGe
                   | (*BISECT-IGNORE*) _ -> error "[Translation.translate_relational_operator], 'bop' must be relational"
                 end in
                 C.Expr [] (
                   C.Ewseq memop_sym_pat (C.Expr [] (C.Ememop memop [obj1_sym_pe; obj2_sym_pe])) (
                     C.Expr [Annot.Astd "§6.5.8#6"] (
                       C.Epure (
                         Caux.mk_if_pe_ [Annot.Anot_explode] memop_sym_pe
                           (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
                           (Caux.mk_specified_pe (Caux.mk_integer_pe 0))
                       )
                     )
                   )
                 )
               ))
              ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy1; C.BTy_loaded oTy2]),
                 (* TODO: check with Peter *)
                 Caux.mk_pure_e (Caux.mk_unspecified_pe result_ty)) ]
        )
      )
    )
  end


(* STD §6.5.9 Equality operators *)
and translate_equality_operator loc translate usual_arithmetic_conversion result_ty bop e1 e2 =
    (* STD §6.5.9 *)
if    Aaux.is_null_pointer_constant e1 && AilTypesAux.is_pointer (ctype_of e2)
   || AilTypesAux.is_pointer (ctype_of e1) && Aaux.is_null_pointer_constant e2 then
  let e = if Aaux.is_null_pointer_constant e1 then e2 else e1 in
  let nullptr_pe = Caux.mk_std_pe "§6.5.9#5, sentence 2" (Caux.mk_nullptr_pe (ctype_of e)) in
  
  translate e                                         >>= fun core_e                             ->
  E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (e_sym  , e_sym_pat  , e_sym_pe  ) ->
  E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (obj_sym, obj_sym_pat, obj_sym_pe) ->
  let memop_sym = Symbol.fresh () in
  let memop_sym_pe = Caux.mk_sym_pe memop_sym in
  let memop = match bop with
    | A.Eq -> Mem_common.PtrEq
    | A.Ne -> Mem_common.PtrNe
    | (*BISECT-IGNORE*) _ -> error "[Translation.translate_equality_operator], 'bop' must be an equality operator"
  end in
  
  E.return (
    Caux.mk_wseq_e e_sym_pat core_e (
      Caux.mk_case_e e_sym_pe
  [ (Caux.mk_specified_pat obj_sym_pat,
           Caux.mk_wseq_e (Caux.mk_sym_pat memop_sym C.BTy_boolean) (C.Expr [] (C.Ememop memop [obj_sym_pe; nullptr_pe])) (
             C.Expr [Annot.Astd "§6.5.9#3"] (C.Epure (
               Caux.mk_if_pe_ [Annot.Anot_explode] memop_sym_pe
                 (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
                 (Caux.mk_specified_pe (Caux.mk_integer_pe 0))
             ))
    ))
    ; (Caux.mk_empty_pat (C.BTy_loaded C.OTy_pointer),
       (* TODO: check with Peter *)
       Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY ("Elab. equality operator (ptr vs NULL)")))) ]
    )
  )
  
else (* both operands have arithmetic or pointer types *)
  translate e1 >>= fun core_e1       ->
  translate e2 >>= fun core_e2       ->
  let e1_sym   = Symbol.fresh () in
  let e2_sym   = Symbol.fresh () in
  let obj1_sym = Symbol.fresh () in
  let obj2_sym = Symbol.fresh () in
  (* The object type on which the Core operator is going to work on. *)
  let oTy1 = force_core_object_type_of_ctype (ctype_of e1) in
  let oTy2 = force_core_object_type_of_ctype (ctype_of e2) in
  let e1_sym_pe   = Caux.mk_sym_pe e1_sym   in
  let e2_sym_pe   = Caux.mk_sym_pe e2_sym   in
  let obj1_sym_pe = Caux.mk_sym_pe obj1_sym in
  let obj2_sym_pe = Caux.mk_sym_pe obj2_sym in
  
  (* TODO: could case this only for the pointer case *)
  let memop_sym    = Symbol.fresh () in
  let memop_sym_pe = Caux.mk_sym_pe memop_sym in
  
  E.return begin
    Caux.mk_wseq_e (Caux.mk_tuple_pat [ Caux.mk_sym_pat e1_sym (C.BTy_loaded oTy1)
                                      ; Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy2) ]) (Caux.mk_unseq [core_e1; core_e2]) (
      
if AilTypesAux.is_arithmetic (ctype_of e1) && AilTypesAux.is_arithmetic (ctype_of e2) then
  let mk_op_pe = match bop with
    | A.Eq -> Caux.mk_op_pe C.OpEq
    | A.Ne -> fun x y -> Caux.mk_not_pe (Caux.mk_op_pe C.OpEq x y)
    | (*BISECT-IGNORE*) _ -> error "[Translation.translate_equality_operator], 'bop' must be relational"
  end in
      Caux.mk_pure_e (
        C.Pexpr [] () (
          C.PEcase (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
            [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy1))
                                 ; Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy2)) ],
               let (promoted1_pe, promoted2_pe) =
                 Caux.mk_std_pair_pe "§6.5.9#4, sentence 1"
                   (usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe) in
               Caux.mk_std_pe "§6.5.9#3" begin
                 Caux.mk_if_pe_ [Annot.Anot_explode] (Caux.mk_std_pe "§6.5.9#4, sentence 3" (mk_op_pe promoted1_pe promoted2_pe))
                   (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
                   (Caux.mk_specified_pe (Caux.mk_integer_pe 0))
               end )
            ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy1; C.BTy_loaded oTy2]),
               (* TODO: check with Peter *)
               Caux.mk_unspecified_pe result_ty) ]
                )
              )

else (* both operand have pointer type *)
  (* TODO: should have a case for 6.5.9#5 sentence 3 ? *)
      Caux.mk_case_e (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
            [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy1))
                                 ; Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy2)) ],
  let memop = match bop with
    | A.Eq -> Mem_common.PtrEq
    | A.Ne -> Mem_common.PtrNe
    | (*BISECT-IGNORE*) _ -> error "[Translation.translate_equality_operator], 'bop' must be relational"
  end in
               Caux.mk_wseq_e (Caux.mk_sym_pat memop_sym C.BTy_boolean) (C.Expr [] (C.Ememop memop [obj1_sym_pe; obj2_sym_pe])) (
                 Caux.mk_pure_e (
                   Caux.mk_std_pe "§6.5.9#3" begin
                     Caux.mk_if_pe_ [Annot.Anot_explode] memop_sym_pe
                       (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
                       (Caux.mk_specified_pe (Caux.mk_integer_pe 0))
                   end
                 )
               ) )
            ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy1; C.BTy_loaded oTy2]),
               (* TODO: check with Peter *)
               Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY "Elab. equality operator (both arith or ptr)"))) ]
            )
  end


(* STD §6.5.10  Bitwise AND operator          *)
(* STD §6.5.11  Bitwise exclusive OR operator *)
(* STD §6.5.12  Bitwise inclusive OR operator *)
and translate_bitwise_operator loc translate usual_arithmetic_conversion stdlib result_ty aop e1 e2 =
  let (std_id, stdlib_call) = match aop with
    | A.Band -> ("§6.5.10", (fun ty pe1 pe2 -> C.Pexpr [] () (C.PEctor C.CivAND [Caux.mk_ail_ctype_pe ty; pe1; pe2])))
    | A.Bxor -> ("§6.5.11", (fun ty pe1 pe2 -> C.Pexpr [] () (C.PEctor C.CivXOR [Caux.mk_ail_ctype_pe ty; pe1; pe2])))
    | A.Bor  -> ("§6.5.12", (fun ty pe1 pe2 -> C.Pexpr [] () (C.PEctor C.CivOR [Caux.mk_ail_ctype_pe ty; pe1; pe2])))
    | (*BISECT-IGNORE*) _ -> error "[Translation.translate_bitwise_operator], 'bop' must be a bitwise operator"
  end in
  let e1_sym    = Symbol.fresh () in
  let e2_sym    = Symbol.fresh () in
  let obj1_sym  = Symbol.fresh () in
  let obj2_sym  = Symbol.fresh () in
  translate e1   >>= fun core_e1   ->
  translate e2   >>= fun core_e2   ->
  let oTy = C.OTy_integer in
  let e1_sym_pe   = Caux.mk_sym_pe e1_sym   in
  let e2_sym_pe   = Caux.mk_sym_pe e2_sym   in
  let obj1_sym_pe = Caux.mk_sym_pe obj1_sym in
  let obj2_sym_pe = Caux.mk_sym_pe obj2_sym in
  let (promoted1_pe, promoted2_pe) =
    Caux.mk_std_pair_pe (std_id ^ "#3")
      (usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe) in
  let core_bop = stdlib_call result_ty promoted1_pe promoted2_pe in
  let is_signed = AilTypesAux.is_signed_integer_type result_ty in
  mk_cheri_derive_and_assign_cap is_signed
    (Mem_common.DCbinary (A.Arithmetic aop))
    (obj1_sym_pe, obj2_sym_pe)
    core_bop >>= fun core_cheri_bop ->
  E.return begin
    C.Expr [Annot.Astd std_id] (
      C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat e1_sym (C.BTy_loaded oTy)
                                 ; Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy) ]) (Caux.mk_unseq_e [core_e1; core_e2]) (
        Caux.mk_pure_e (
          C.Pexpr [] () (
            C.PEcase (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
              [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy))
                                   ; Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy)) ],
                 (* Both operand are specified *)
                Caux.mk_specified_pe (Caux.mk_std_pe (std_id ^ "#4") begin
                  if Global.is_CHERI () && Ctype.is_ptr_t result_ty then
                    core_cheri_bop
                  else
                    core_bop
                end) )
              ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy; C.BTy_loaded oTy]),
                 Caux.mk_unspecified_pe result_ty) ]
          )
        )
      )
    )
  end


and translate_postfix loc self stdlib result_ty op e =
  let (std_para, core_op, shift_const) =
    match op with
      | A.PostfixIncr ->
          ("#2", C.OpAdd, 1)
      | A.PostfixDecr ->
          ("#3", C.OpSub, 0 - 1)
      | (*BISECT-IGNORE*) _ ->
          error "[Translation.translate_postfix], 'op' must be a postfix operator"
    end in
  let std_sentence_n (n: nat) = "§6.5.2.4" ^ std_para ^ ", sentence " ^ show n in
  (* STD §6.5.2.4 *)
  let () =
    if AilTypesAux.is_atomic (ctype_of e) then
      Debug.warn [Debug.DB_elaboration] (fun () -> "TODO: elaboration is wrong for atomic types")
    else
      () in
  self e >>= fun core_e ->
  let () = Debug.print_debug 1 [Debug.DB_elaboration] (fun () -> "TODO: needs to fix this") in
  let ty  = AilTypesAux.rvalue_coercion (snd (from_lvalue_type e)) in
  let oTy = force_core_object_type_of_ctype ty    in
  let core_ty_e = Caux.mk_ail_ctype_pe ty in
  E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (lvalue_sym, lvalue_sym_pat, lvalue_sym_pe) ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy)           >>= fun (load_sym,   load_sym_pat,   load_sym_pe)   ->
  E.wrapped_fresh_symbol (C.BTy_object oTy)           >>= fun (obj_sym,    obj_sym_pat,    obj_sym_pe)    ->
  let mk_common () =
    E.return begin
      Caux.add_stds ["§6.5.2.4"; std_sentence_n 1; std_sentence_n 3] begin
        Caux.mk_wseq_e lvalue_sym_pat core_e begin
          C.Expr [Annot.Astd (std_sentence_n 4)] begin
            C.Easeq (load_sym, C.BTy_loaded oTy)
              (C.Action loc default (C.Load core_ty_e lvalue_sym_pe Cmm.NA))
              (C.Paction C.Neg (C.Action loc default (C.Store false(* not locking *)
                core_ty_e
                lvalue_sym_pe
                (Caux.mk_case_pe load_sym_pe
                  [ ( Caux.mk_specified_pat obj_sym_pat
                    , Caux.mk_specified_pe $ Caux.mk_std_pe (std_sentence_n 2)
match Ctype.unatomic_ ty with
  | Ctype.Basic (Ctype.Integer _) ->
      (* TODO: check again *)
      let core_incr = Caux.mk_op_pe core_op obj_sym_pe (Caux.mk_integer_pe 1) in
      if AilTypesAux.is_signed_integer_type result_ty then
                        stdlib.mkcall_catch_exceptional_condition result_ty core_incr
      else (* is unsigned *)
                        stdlib.mkcall_wrapI result_ty core_incr
  | Ctype.Basic (Ctype.Floating (Ctype.RealFloating _)) ->
                        (* TODO: not correct semantics for float *)
                        Caux.mk_op_pe core_op obj_sym_pe (Caux.mk_floating_value_pe Mem.one_fval)
  | Ctype.Pointer _ ref_ty ->
                        Caux.mk_array_shift obj_sym_pe ref_ty (Caux.mk_integer_pe shift_const)
  | (*BISECT-IGNORE*) _ ->
      illTypedAil loc "AilEunary PostfixIncr|PostfixDecr"
end
                    )
                  ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                    , Caux.mk_unspecified_pe ty(*TODO:check*) )
                  ] )
                  Cmm.NA)))
          end
        end
      end
    end in
if Global.is_CHERI () then
  match Ctype.unatomic_ ty with
    | Ctype.Pointer _ ref_ty ->
        (* for CHERI we use the effectful array_shift operator *)
        (* TODO: the load + store are NOT atomic ==> need a new operator in the memory interface ... *)
        E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, shift_sym_pat, shift_sym_pe) ->
        E.return begin
          Caux.add_stds ["§6.5.2.4"; std_sentence_n 1; std_sentence_n 3] begin
            Caux.mk_wseq_e lvalue_sym_pat core_e begin
            Caux.mk_wseq_e load_sym_pat (Caux.pload loc core_ty_e lvalue_sym_pe Cmm.NA) begin
              Caux.mk_case_e load_sym_pe
                [ ( Caux.mk_specified_pat obj_sym_pat
                  , Caux.mk_wseq_e shift_sym_pat
                      (Caux.mk_memop_e Mem_common.PtrArrayShift [obj_sym_pe; Caux.mk_ail_ctype_pe ref_ty; Caux.mk_integer_pe shift_const])
                      begin
                        Caux.mk_wseq_e (Caux.mk_empty_pat C.BTy_unit)
                          begin
                            C.Expr [Annot.Astd (std_sentence_n 4)]
                              (C.Eaction (C.Paction C.Neg (C.Action loc default (C.Store false(* not locking *) core_ty_e lvalue_sym_pe (Caux.mk_specified_pe shift_sym_pe) Cmm.NA))))
                          end
                          (Caux.mk_pure_e load_sym_pe)
                      end )
                ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                  , Caux.mk_pure_e (Caux.mk_unspecified_pe ty(*TODO:check*)) ) ]
            end end
          end
        end
    | _ ->
        mk_common ()
  end
else
  mk_common ()


and translate_expression ctx variadic_env stdlib (tagDefs : Core.core_tag_definitions) a_expr : E.elabM (C.expr unit) =
  let self = translate_expression ctx variadic_env stdlib tagDefs in
  let is_lvalue = match GenTypes.genTypeCategoryOf a_expr with
    | GenTypes.GenLValueType _ _ _ ->
        true
    | GenTypes.GenRValueType _ ->
        false
  end in
  (* TODO !!!! *)
  let integer_promotion (ty: Ctype.ctype) (e: C.pexpr) : C.pexpr =
    let promoted_ty = fromJust "Translation_aux.integer_promotion" (AilTypesAux.promotion integerImpl ty) in
    stdlib.mkcall_conv_int promoted_ty e in
  
  (* STD §6.3.1.8 *)
  let usual_arithmetic_conversion (ty1: Ctype.ctype) (ty2: Ctype.ctype) (e1: C.pexpr) (e2: C.pexpr) : C.pexpr * C.pexpr =
    match (AilTypesAux.corresponding_real_type ty1, AilTypesAux.corresponding_real_type ty2) with
      (* TODO: Convert (long double, double and float) to Ocaml float! This is not the standard behaviour! *)
      | (Just _, Just _) ->
          (e1, e2)
      | (Just _, _) ->
          (e1, C.Pexpr [] () (C.PEctor C.Cfvfromint [e2]))
      | (_, Just _) ->
          (C.Pexpr [] () (C.PEctor C.Cfvfromint [e1]), e2)
      | (Nothing, Nothing) ->
          (* TODO: this is so readable ... *)
          (* STD §6.3.1.8#1, bullet 4 *)
          match (AilTypesAux.promotion integerImpl ty1, AilTypesAux.promotion integerImpl ty2) with
            | (Just (Ctype.Ctype _ (Ctype.Basic (Ctype.Integer ity1')) as ty1'), Just (Ctype.Ctype _ (Ctype.Basic (Ctype.Integer ity2')) as ty2')) ->
                (* "If both operants have the same type, then no further conversion is needed." *)
                if ty1' = ty2' then
                  (stdlib.mkcall_conv_int ty1' e1, stdlib.mkcall_conv_int ty2' e2)

                (* "Otherwise, if both operands have signed integer types or both have unsigned integer types,
                    the operand with the type of lesser integer conversion rank is converted to the type
                    of the operand with greater rank." *)
                else if   (AilTypesAux.is_signed_integer_type ty1' && AilTypesAux.is_signed_integer_type ty2')
                       || (AilTypesAux.is_unsigned_integer_type ty1' && AilTypesAux.is_unsigned_integer_type ty2') then
                  if AilTypesAux.lt_integer_rank ity1' ity2' then
                    (stdlib.mkcall_conv_int ty2' e1, stdlib.mkcall_conv_int ty2' e2)
                  else
                    (stdlib.mkcall_conv_int ty1' e1, stdlib.mkcall_conv_int ty1' e2)

                (* "Otherwise, if the operand that has unsigned type has rank greater or equal to the rank of the
                    rank of the type of the other operand, then the operand with signed integer type is converted
                    to the type of the operand with unsigned integer type." *)
                else if AilTypesAux.is_unsigned_integer_type ty1' && AilTypesAux.ge_integer_rank ity1' ity2' then
                  (stdlib.mkcall_conv_int ty1' e1, stdlib.mkcall_conv_int ty1' e2)
                else if AilTypesAux.is_unsigned_integer_type ty2' && AilTypesAux.ge_integer_rank ity2' ity1' then
                  (stdlib.mkcall_conv_int ty2' e1, stdlib.mkcall_conv_int ty2' e2)

                (* "Otherwise, if the type of the operand with signed integer type can represent all of the values
                    of the type of the operand with unsigned integer type, then the operand with unsigned integer
                    type is converted to the type of the operand with signed integer type." *)
                else if AilTypesAux.is_signed_integer_type ty1' then
(*
                  (Caux.mk_if_pe (stdlib.mkcall_is_representable e2 ty1')
                     (stdlib.mkcall_conv_int ty1' e1)
                     (stdlib.mkcall_conv_int (Ctype.Basic (Ctype.Integer (AilTypesAux.make_corresponding_unsigned ity1'))) e1)
                  ,
                   Caux.mk_if_pe (stdlib.mkcall_is_representable e2 ty1')
                     (stdlib.mkcall_conv_int ty1' e2)
                     (stdlib.mkcall_conv_int (Ctype.Basic (Ctype.Integer (AilTypesAux.make_corresponding_unsigned ity1'))) e2)
                  )
*)
                  (Caux.mk_if_pe_ [Annot.Anot_explode] (stdlib.mkcall_all_values_representable_in ty2' ty1')
                     (stdlib.mkcall_conv_int ty1' e1)
                     (* "Otherwise, both operands are converted to the unsigned integer type corresponding to the type
                         of the operand with signed integer type". *)
                     (stdlib.mkcall_conv_int (Ctype.Ctype [] (Ctype.Basic (Ctype.Integer (AilTypesAux.make_corresponding_unsigned ity1')))) e1)
                  ,
                  Caux.mk_if_pe_ [Annot.Anot_explode] (stdlib.mkcall_all_values_representable_in ty2' ty1')
                     (stdlib.mkcall_conv_int ty1' e2)
                     (stdlib.mkcall_conv_int (Ctype.Ctype [] (Ctype.Basic (Ctype.Integer (AilTypesAux.make_corresponding_unsigned ity1')))) e2)
                  )

                  (* ASK: Should you not check that ty2 is signed ? Can we delete the previous code? *)
                else (* if AilTypesAux.is_signed_integer_type ty2' then *)
(*
                  (Caux.mk_if_pe (stdlib.mkcall_is_representable e2 ty2')
                     (stdlib.mkcall_conv_int ty2' e1)
                     (stdlib.mkcall_conv_int (Ctype.Basic (Ctype.Integer (AilTypesAux.make_corresponding_unsigned ity2'))) e1)
                  ,
                  Caux.mk_if_pe (stdlib.mkcall_is_representable e2 ty2')
                     (stdlib.mkcall_conv_int ty2' e2)
                     (stdlib.mkcall_conv_int (Ctype.Basic (Ctype.Integer (AilTypesAux.make_corresponding_unsigned ity2'))) e2)
                  )
*)
                  (Caux.mk_if_pe_ [Annot.Anot_explode] (stdlib.mkcall_all_values_representable_in ty1' ty2')
                     (stdlib.mkcall_conv_int ty2' e1)
                     (stdlib.mkcall_conv_int (Ctype.Ctype [] (Ctype.Basic (Ctype.Integer (AilTypesAux.make_corresponding_unsigned ity2')))) e1)
                  ,
                  Caux.mk_if_pe_ [Annot.Anot_explode] (stdlib.mkcall_all_values_representable_in ty1' ty2')
                     (stdlib.mkcall_conv_int ty2' e2)
                     (stdlib.mkcall_conv_int (Ctype.Ctype [] (Ctype.Basic (Ctype.Integer (AilTypesAux.make_corresponding_unsigned ity2')))) e2)
                  )

            | _ ->
                let () = Debug.print_debug 1 [] (fun () ->
                  "is_arithmetic ty1: " ^ (if AilTypesAux.is_arithmetic ty1 then "true" else "false")
                ) in
                let () = Debug.print_debug 1 [] (fun () ->
                  "is_arithmetic ty2: " ^ (if AilTypesAux.is_arithmetic ty2 then "true" else "false")
                ) in
                let () = Debug.print_debug 1 [] (fun () ->
                  "ty1: " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers ty1 ^
                  ", ty2: " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers ty2 ^
                  ", e1: " ^ Pp.stringFromCore_pexpr e1 ^
                  ", e2: " ^ Pp.stringFromCore_pexpr e2
                ) in
                error "Translation.usual_arithmetic_conversion: not (integer vs integer)"
          end
      end in
  
  let result_ty = ctype_of a_expr in
  
  if AilTypesAux.is_pointer result_ty && Aaux.is_null_pointer_constant a_expr then
    (* TODO: this is a bit tasteless as it makes the case AilEconst, ConstantNull unreachable *)
    E.return (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_nullptr_pe result_ty)))
  else
    let A.AnnotatedExpression annot std_annots loc expr = a_expr in
    Caux.add_loc loc <$> match expr with
      (* CHECKED IN APR2016 *)
      | A.AilEunary A.Plus e ->
          (* STD §6.5.3.3#2 *)
          let (oTy, mk_conversion) =
            if AilTypesAux.is_integer result_ty then
              (C.OTy_integer, integer_promotion (ctype_of e))
            else
              (C.OTy_floating, fun z -> z) in
          let obj_sym = Symbol.fresh () in
          let e_sym   = Symbol.fresh () in
          self e    >>= fun core_e  ->
          E.return begin
            C.Expr [Annot.Astd "§6.5.3.3#2"] (
              C.Ewseq (Caux.mk_sym_pat e_sym (C.BTy_loaded oTy)) core_e (
                C.Expr [] (
                  C.Epure (
                    C.Pexpr [] () (
                      C.PEcase (Caux.mk_sym_pe e_sym)
                        [ (Caux.mk_specified_pat (Caux.mk_sym_pat obj_sym (C.BTy_object oTy)),
                           Caux.mk_specified_pe (mk_conversion (Caux.mk_sym_pe obj_sym)))
                        ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                           (* TODO: check that result_ty = promoted (ctype_of e) *)
                           Caux.mk_unspecified_pe result_ty) ]
                    )
                  )
                )
              )
            )
          end
      
      (* CHECKED IN APR2016 *)
      | A.AilEunary A.Minus e ->
          (* STD §6.5.3.3#3 *)
          let (oTy, zero_pe, mk_conversion) =
            if AilTypesAux.is_integer result_ty then
              (C.OTy_integer, Caux.mk_integer_pe 0, integer_promotion (ctype_of e))
            else
              (C.OTy_floating, Caux.mk_floating_value_pe Mem.zero_fval, fun z -> z) in
          let obj_sym = Symbol.fresh () in
          let e_sym   = Symbol.fresh () in
          self e    >>= fun core_e  ->
          E.return begin
            C.Expr [Annot.Astd "§6.5.3.3#3"] (
              C.Ewseq (Caux.mk_sym_pat e_sym (C.BTy_loaded oTy)) core_e (
                C.Expr [] (
                  C.Epure (
                    C.Pexpr [] () (
                      C.PEcase (Caux.mk_sym_pe e_sym)
                        [ (C.Pattern [] (C.CaseCtor C.Cspecified [Caux.mk_sym_pat obj_sym (C.BTy_object oTy)]),
                           let expr =
                             Caux.mk_op_pe C.OpSub zero_pe (mk_conversion (Caux.mk_sym_pe obj_sym)) in
                           Caux.mk_specified_pe (
if AilTypesAux.is_signed_integer_type result_ty then
                             stdlib.mkcall_catch_exceptional_condition result_ty expr
else if AilTypesAux.is_integer result_ty then
                             stdlib.mkcall_wrapI result_ty expr
else
                             expr))
                        ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                           (* TODO: check that result_ty = promoted (ctype_of e) *)
                           Caux.mk_unspecified_pe result_ty) ]
                    )
                  )
                )
              )
            )
          end
      
      (* CHECKED IN APR2016 *)
      | A.AilEunary A.Bnot e ->
          (* STD §6.5.3.3#4 *)
          self e >>= fun core_e ->
          let oTy = force_core_object_type_of_ctype (ctype_of e) in
          E.wrapped_fresh_symbol (C.BTy_loaded oTy)           >>= fun (_, e_sym_pat  , e_sym_pe  ) ->
          E.wrapped_fresh_symbol (C.BTy_object oTy)           >>= fun (_, obj_sym_pat, obj_sym_pe) ->
          let promoted_e = Caux.mk_std_pe "§6.5.3.3#4, sentence 2" (integer_promotion (ctype_of e) obj_sym_pe) in
          let core_bnot =
            if AilTypesAux.is_unsigned_integer_type result_ty then
              (* STD §6.5.3.3#4, sentence 3 *)
              Caux.mk_std_pe "§6.5.3.3#4, sentence 3"
                (Caux.mk_op_pe C.OpSub (Caux.mk_ivmax_pe (Caux.mk_ail_ctype_pe result_ty)) promoted_e)
            else
              Caux.bitwise_complement_pe (Caux.mk_ail_ctype_pe result_ty) promoted_e in
          let is_signed = AilTypesAux.is_signed_integer_type result_ty in
          mk_cheri_derive_and_assign_cap is_signed
            (Mem_common.DCunary A.Bnot)
            (Caux.mk_nullcap_pe is_signed, obj_sym_pe)
            core_bnot >>= fun core_cheri_bnot ->
          E.return begin
            Caux.add_std "§6.5.3.3#4" begin
              Caux.mk_wseq_e e_sym_pat core_e begin
                Caux.mk_pure_e begin
                  Caux.mk_case_pe e_sym_pe
                    [ ( Caux.mk_specified_pat obj_sym_pat
                      , (* NOTE: result_ty == promoted type of e *)
                        Caux.mk_specified_pe begin
                          if Global.is_CHERI () && Ctype.is_ptr_t result_ty then
                            core_cheri_bnot
                            (* let is_signed = AilTypesAux.is_signed_integer_type result_ty in
                            Caux.mk_let_pe cap_sym_pat
                              (Caux.mk_memop_pe (Mem_common.DeriveCap (Mem_common.DCunary A.Bnot) is_signed)
                                [Caux.mk_nullcap_pe is_signed; obj_sym_pe])
                              (Caux.mk_memop_pe Mem_common.CapAssignValue
                                [cap_sym_pe; core_bnot]) *)
                          else 
                            core_bnot
                        end )
                    ; ( Caux.mk_empty_pat (C.BTy_loaded oTy)
                      , Caux.mk_unspecified_pe result_ty ) ]
                end
              end
            end
          end
      
      (* CHECKED IN APR2016 *)
      | A.AilEunary A.Address (A.AnnotatedExpression _ _ _ (A.AilEunary A.Indirection e)) ->
          (* STD §6.5.3.2#3, sentence 3 *)
          (* NOTE: footnote 102 makes it clear that this is valid even if 'e' evaluates to a null pointer *)
          self e >>= fun (C.Expr annot core_expr_) ->
          E.return (C.Expr (Annot.Astd "§6.5.3.2#3, sentence 3" :: annot) core_expr_)
      
      (* CHECKED IN APR2016 *)
      | A.AilEunary A.Address e ->
          (* STD §6.5.3.2#3, sentence 5 *)
          if AilTypesAux.is_object (ctype_of e) then
(*            let _ = Debug.print_debug 1 [] (fun _ -> "aileunary adress, result type: " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers result_ty) in*)
             let sym = Symbol.fresh () in
             self e >>= fun core_e ->
             E.return $
               C.Expr [Annot.Astd "§6.5.3.2#3, sentence 5"] (
                 C.Ewseq (Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer)) core_e (
                   C.Expr [] (
                     C.Epure (Caux.mk_specified_pe (Caux.mk_sym_pe sym))
                   )
                 )
               )
          else
(*            let _ = Debug.print_debug 1 [] (fun _ -> "call to function designator through aileunary adress") in *)
            translate_function_designator ctx variadic_env stdlib tagDefs e
      
      (* TODO: promotion? + atomicity *)
      (* NOTE: if I read N2329 correctly, in C2X this will not be an RMW for the atomic case (but a do while
         with compare_exchange_weak with seq_cst, seq_cst) *)
      | A.AilEunary A.PostfixIncr e ->
          translate_postfix loc self stdlib result_ty A.PostfixIncr e
      | A.AilEunary A.PostfixDecr e ->
          translate_postfix loc self stdlib result_ty A.PostfixDecr e
(*
        (* STD §6.5.2.4 *)
          let () = if AilTypesAux.is_atomic (ctype_of e) then
            Debug.warn [Debug.DB_elaboration] (fun () -> "TODO: elaboration is wrong for atomic types")
          else
            () in
          (* TODO: qualifiers temporarily not dealt with *)
          let lvalue_sym = Symbol.fresh () in
          let load_sym   = Symbol.fresh () in
          let obj_sym    = Symbol.fresh () in
          self e         >>= fun core_e     ->
          let ty  = AilTypesAux.rvalue_coercion (snd (from_lvalue_type e)) in
          let oTy = force_core_object_type_of_ctype ty    in
          let core_ty_e = Caux.mk_ail_ctype_pe ty in
          
          let lvalue_sym_pe = Caux.mk_sym_pe lvalue_sym in
          let load_sym_pe   = Caux.mk_sym_pe load_sym             in
          let obj_sym_pe    = Caux.mk_sym_pe obj_sym              in
          
          E.return $
            C.Expr [Annot.Astd "§6.5.2.4#3"] (
              C.Ewseq (Caux.mk_sym_pat lvalue_sym (C.BTy_object C.OTy_pointer)) core_e (
                C.Expr [] (
                  C.Easeq ((load_sym, C.BTy_loaded oTy))
                    (C.Action loc default (C.Load core_ty_e lvalue_sym_pe Cmm.NA))
                    (C.Paction C.Neg (C.Action loc default (C.Store false(* not locking *)
                       core_ty_e
                       lvalue_sym_pe
                       (C.Pexpr [] () begin
                          C.PEcase load_sym_pe
                            [ ( Caux.mk_specified_pat (Caux.mk_sym_pat obj_sym (C.BTy_object oTy))
                              , Caux.mk_specified_pe
match Ctype.unatomic_ ty with
  | Ctype.Basic (Ctype.Integer _) ->
                          (* TODO: check again *)
                          let core_decr = Caux.mk_op_pe C.OpSub obj_sym_pe (Caux.mk_integer_pe 1) in
      if AilTypesAux.is_signed_integer_type result_ty then
                          stdlib.mkcall_catch_exceptional_condition result_ty core_decr
      else (* is unsigned *)
                          stdlib.mkcall_wrapI result_ty core_decr
  | Ctype.Basic (Ctype.Floating (Ctype.RealFloating _)) ->
                          (* TODO: not correct semantics for float *)
                          Caux.mk_op_pe C.OpSub obj_sym_pe (Caux.mk_floating_value_pe Mem.one_fval)
  | Ctype.Pointer _ ref_ty ->
                                   (* TODO: check again *)
                                   Caux.mk_array_shift obj_sym_pe ref_ty (Caux.mk_integer_pe (0 - 1))
  | (*BISECT-IGNORE*) _ ->
      illTypedAil loc "AilEunary PostfixIncr"
end
                             )
                            ; ( C.Pattern [] (C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype])
                              , Caux.mk_unspecified_pe ty(*TODO:check*) )
                            ]
                       end)
                       Cmm.NA)))
                )
              )
            )
*)
      
      | A.AilEunary A.Indirection e ->
          (* TODO: if e is a pointer to a function *)
if AilTypesAux.is_pointer_to_function (ctype_of e) then
          (* STD 6.5.3.2#4 *)
          (* maybe need the ailrvalue stuff *)
          translate_function_designator ctx variadic_env stdlib tagDefs e
          (* error "WIP: Elaboration, A.Indirection, function designator" *)
else match AilTypesAux.referenced_type (ctype_of e) with
  | (*BISECT-IGNORE*) Nothing ->
      illTypedAil loc "AilEunary Indirection, not a pointer type"
  | Just ref_ty ->
          let e_sym    = Symbol.fresh () in
          let obj_sym  = Symbol.fresh () in
          let test_sym = Symbol.fresh () in (* symbol for the PtrValidForDeref test *)
          self e         >>= fun core_e   ->
          E.return $
            C.Expr [Annot.Astd "§6.5.3.2"] (
              C.Ewseq (Caux.mk_sym_pat e_sym (C.BTy_loaded C.OTy_pointer)) core_e (
                C.Expr [] (
                  C.Ecase (Caux.mk_sym_pe e_sym)
                    [ ( Caux.mk_specified_pat (Caux.mk_sym_pat obj_sym (C.BTy_object C.OTy_pointer))
                      , C.Expr [] (
                          C.Ewseq (Caux.mk_sym_pat test_sym C.BTy_boolean)
                            (C.Expr [] (C.Ememop Mem_common.PtrValidForDeref [Caux.mk_ail_ctype_pe ref_ty; Caux.mk_sym_pe obj_sym])) (
                              C.Expr [Annot.Anot_explode] (
                                C.Eif (Caux.mk_sym_pe test_sym)
                                  begin
                                    let obj_sym_pe = 
                                      Caux.mk_sym_pe obj_sym in
(*                             Caux.pload loc (Caux.mk_ail_ctype_pe result_ty) obj_sym_pe Cmm.NA *)
                                    C.Expr [] (C.Epure (obj_sym_pe))
                                  end
                                  (C.Expr [] (C.Epure (Caux.mk_std_undef_pe loc "§6.5.3.3#4, sentence 4" Undefined.UB043_indirection_invalid_value)))
                              )
                            )
                        ) )
                    ; ( C.Pattern [] (C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype])
                      , C.Expr [] (C.Epure (Caux.mk_std_undef_pe loc "§6.5.3.3#4, sentence 4" Undefined.UB043_indirection_invalid_value(*TODO:check*))) )
                    ]
                )
              )
            )
end

(*
The unary * operator denotes indirection.

If the operand points to a function, the result is a function designator; if it points to an object, the result is an lvalue designating the object.

If the operand has type ‘‘pointer to type’’, the result has type ‘‘type’’.

If an invalid value has been assigned to the pointer, the behavior of the unary * operator is undefined.
*)

      
      | A.AilEbinary e1 (A.Arithmetic A.Shl) e2 ->
          (* STD §6.5.7 *)
          self e1        >>= fun core_e1       ->
          self e2        >>= fun core_e2       ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun (_, e1_sym_pat       , e1_sym_pe  )      ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun (_, e2_sym_pat       , e2_sym_pe  )      ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, obj1_sym_pat     , obj1_sym_pe)      ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, obj2_sym_pat     , obj2_sym_pe)      ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, promoted1_sym_pat, promoted1_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, promoted2_sym_pat, promoted2_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, res_sym_pat      , res_sym_pe)       ->
          E.return begin
            C.Expr [Annot.Astd "§6.5.7"] (
              C.Ewseq (Caux.mk_tuple_pat [ e1_sym_pat; e2_sym_pat ]) (Caux.mk_unseq [core_e1; core_e2]) (
                Caux.mk_pure_e (
                  Caux.mk_case_pe
                    (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
                    [ (Caux.mk_tuple_pat [ Caux.mk_empty_pat (C.BTy_loaded C.OTy_integer)
                                          ; Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype) ],
                        Caux.mk_undef_exceptional_condition loc)
                    
                    ; (Caux.mk_tuple_pat [ Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                                          ; Caux.mk_empty_pat (C.BTy_loaded C.OTy_integer) ],
(if AilTypesAux.is_unsigned_integer_type (ctype_of e1) then
                        Caux.mk_unspecified_pe result_ty
else
                        Caux.mk_undef_exceptional_condition loc
)
                      )
                    ; (Caux.mk_tuple_pat [ Caux.mk_specified_pat (obj1_sym_pat); Caux.mk_specified_pat (obj2_sym_pat) ],
                        Caux.mk_let_pe promoted1_sym_pat
                          (Caux.mk_std_pe "§6.5.7#3, sentence 1" (integer_promotion (ctype_of e1) obj1_sym_pe))
                        (Caux.mk_let_pe promoted2_sym_pat
                          (Caux.mk_std_pe "§6.5.7#3, sentence 1" (integer_promotion (ctype_of e2) obj2_sym_pe))
                        (* (§6.5.7#2) if promoted2 < 0 then undef *)
                        (Caux.mk_if_pe_ [Annot.Anot_explode] (Caux.mk_op_pe C.OpLt promoted2_sym_pe (Caux.mk_integer_pe 0))
                          (Caux.mk_std_undef_pe loc "§6.5.7#3, sentence 3" Undefined.UB051a_negative_shift)
                        (* ctype_width(result_ty) <= promoted2 *)
                        (Caux.mk_if_pe_ [Annot.Anot_explode] (Caux.mk_op_pe C.OpOr (Caux.mk_op_pe C.OpLt (stdlib.mkcall_ctype_width result_ty) promoted2_sym_pe)
                                                            (Caux.mk_op_pe C.OpEq (stdlib.mkcall_ctype_width result_ty) promoted2_sym_pe))
                          (Caux.mk_std_undef_pe loc "§6.5.7#4, sentence 3" Undefined.UB51b_shift_too_large)
(if AilTypesAux.is_unsigned_integer_type (ctype_of e1) then
                        (Caux.mk_specified_pe (Caux.mk_std_pe "§6.5.7#4, sentence 2" (
                          Caux.mk_op_pe C.OpRem_t (Caux.mk_op_pe C.OpMul promoted1_sym_pe (Caux.mk_op_pe C.OpExp (Caux.mk_integer_pe 2) promoted2_sym_pe))
                                                  (Caux.mk_op_pe C.OpAdd (Caux.mk_ivmax_pe (Caux.mk_ail_ctype_pe result_ty)) (Caux.mk_integer_pe 1))
                        )))
else
                        Caux.mk_std_pe "§6.5.7#4, sentence 3"
                          (Caux.mk_if_pe_ [Annot.Anot_explode] (Caux.mk_op_pe C.OpLt promoted1_sym_pe (Caux.mk_integer_pe 0))
                            (Caux.mk_std_undef_pe loc "§6.5.7#3, sentence 3" Undefined.UB052a_negative_left_shift)
                          (Caux.mk_let_pe res_sym_pat
                            (Caux.mk_op_pe C.OpMul promoted1_sym_pe (Caux.mk_op_pe C.OpExp (Caux.mk_integer_pe 2) promoted2_sym_pe))
                          (Caux.mk_if_pe_ [Annot.Anot_explode] (stdlib.mkcall_is_representable res_sym_pe result_ty)
                            (Caux.mk_specified_pe res_sym_pe)
                          (Caux.mk_std_undef_pe loc "§6.5.7#3, sentence 3" Undefined.UB052b_non_representable_left_shift))))
)
                           )))) ]
                )
              )
            )
          end
      
      | A.AilEbinary e1 (A.Arithmetic A.Shr) e2 ->
          (* STD §6.5.7 *)
          self e1        >>= fun core_e1       ->
          self e2        >>= fun core_e2       ->
          let e1_sym        = Symbol.fresh () in
          let e2_sym        = Symbol.fresh () in
          let obj1_sym      = Symbol.fresh () in
          let obj2_sym      = Symbol.fresh () in
          let promoted1_sym = Symbol.fresh () in
          let promoted2_sym = Symbol.fresh () in
          let e1_sym_pe        = Caux.mk_sym_pe e1_sym        in
          let e2_sym_pe        = Caux.mk_sym_pe e2_sym        in
          let obj1_sym_pe      = Caux.mk_sym_pe obj1_sym      in
          let obj2_sym_pe      = Caux.mk_sym_pe obj2_sym      in
          let promoted1_sym_pe = Caux.mk_sym_pe promoted1_sym in
          let promoted2_sym_pe = Caux.mk_sym_pe promoted2_sym in
          E.return $
            C.Expr [Annot.Astd "§6.5.7"] (
              C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat e1_sym (C.BTy_loaded C.OTy_integer)
                                         ; Caux.mk_sym_pat e2_sym (C.BTy_loaded C.OTy_integer) ]) (Caux.mk_unseq [core_e1; core_e2]) (
                C.Expr [] (
                  C.Epure (
                    C.Pexpr [] () (
                      C.PEcase (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
                        [ (Caux.mk_tuple_pat [ Caux.mk_empty_pat (C.BTy_loaded C.OTy_integer)
                                             ; C.Pattern [] (C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype ]) ],
                           Caux.mk_undef_exceptional_condition loc)
                        ; (Caux.mk_tuple_pat [ C.Pattern [] (C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype])
                                             ; Caux.mk_empty_pat (C.BTy_loaded C.OTy_integer) ],
                           Caux.mk_unspecified_pe (result_ty))
                        ; (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object C.OTy_integer))
                                             ; Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object C.OTy_integer)) ],
                           Caux.mk_let_pe (Caux.mk_sym_pat promoted1_sym (C.BTy_object C.OTy_integer))
                             (integer_promotion (ctype_of e1) obj1_sym_pe)
                           (Caux.mk_let_pe (Caux.mk_sym_pat promoted2_sym (C.BTy_object C.OTy_integer))
                             (integer_promotion (ctype_of e2) obj2_sym_pe)
                           (* (§6.5.7#2) if promoted2 < 0 then undef *)
                           (Caux.mk_if_pe_ [Annot.Anot_explode] (Caux.mk_op_pe C.OpLt promoted2_sym_pe (Caux.mk_integer_pe 0))
                             (Caux.mk_std_undef_pe loc "§6.5.7#3, sentence 3" Undefined.UB051a_negative_shift)
                           
                           (* ctype_width(result_ty) <= promoted2 *)
                           (Caux.mk_if_pe_ [Annot.Anot_explode] (Caux.mk_op_pe C.OpOr (Caux.mk_op_pe C.OpLt (stdlib.mkcall_ctype_width result_ty) promoted2_sym_pe)
                                                                (Caux.mk_op_pe C.OpEq (stdlib.mkcall_ctype_width result_ty) promoted2_sym_pe))
                              (Caux.mk_std_undef_pe loc "§6.5.7#3, sentence 3" Undefined.UB51b_shift_too_large)
                              (let expr = Caux.mk_op_pe C.OpDiv obj1_sym_pe (Caux.mk_op_pe C.OpExp (Caux.mk_integer_pe 2) promoted2_sym_pe) in
                               Caux.mk_specified_pe $
if AilTypesAux.is_unsigned_integer_type (ctype_of e1) then
                               Caux.mk_std_pe "6.5.7#5, sentence 2" expr
else
                               Caux.mk_std_pe "6.5.7#5, sentence 3" $ Caux.mk_if_pe_ [Annot.Anot_explode] (Caux.mk_op_pe C.OpGe promoted1_sym_pe (Caux.mk_integer_pe 0))
                                 expr
                                 (C.Pexpr [] () (
                                    C.PEcall (C.Impl Implementation.SHR_signed_negative) [Caux.mk_ail_ctype_pe (ctype_of e1) ; promoted1_sym_pe; promoted2_sym_pe]
                                 ))))))) ]
                    )
                  )
                )
              )
            )
      
      | A.AilEident id ->
          let id_sym_pe = match ctx with
            | ECTX_other ->
                  Caux.mk_sym_pe id
            | ECTX_glob glob_sym sym' ->
                if id = glob_sym then
                  Caux.mk_sym_pe sym'
                else
                  Caux.mk_sym_pe id
          end in
          E.return (C.Expr [] (C.Epure id_sym_pe))

        (* NOTE: this is not enough *)
(*
            E.return $
              if AilTypesAux.is_array result_ty then
                (* STD §6.3.2.1# *) (* TODO check *)
                C.Epure ((*Caux.mk_specified_pe*)id_sym_pe)
              else if is_lvalue then
                C.Epure ((*Caux.mk_specified_pe*)id_sym_pe)
              else
                Caux.pload loc (Caux.mk_ail_ctype_pe result_ty) id_sym_pe Cmm.NA
*)
      
      | A.AilEcast _ cast_ty e ->
          let e_ty = ctype_of e in
          let oTy = force_core_object_type_of_ctype e_ty in
          E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun (e_sym,   e_sym_pat,   e_sym_pe  ) ->
          E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun (obj_sym, obj_sym_pat, obj_sym_pe) ->
          (* STD §6.3.2.1#2 "lvalue conversion" *)
(*          E._STD "§6.3.2.1#2" $ (* TODO: what it this std refering too? *) *)
          self e    >>= fun core_e  ->
          let let_sym = Symbol.fresh () in
          E.return $
            Caux.add_std "§6.5.4" (
if AilTypesAux.is_void cast_ty then
              Caux.mk_wseq_e e_sym_pat core_e
                Caux.mk_skip_e

else if AilTypesAux.is_pointer cast_ty && Aaux.is_null_pointer_constant e then
  match AilTypesAux.referenced_type cast_ty with
    | (*BISECT-IGNORE*) Nothing ->
              illTypedAil loc "AilEcast, pointer vs null_pointer_constant"
    | Just ref_ty ->
              Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_nullptr_pe ref_ty))
  end

else if AilTypesAux.is_arithmetic cast_ty && AilTypesAux.is_arithmetic e_ty then
  if AilTypesAux.is_integer cast_ty then
    if AilTypesAux.is_integer e_ty then
      if Global.is_CHERI () && not (Ctype.is_ptr_t (ctype_of e)) && Ctype.is_ptr_t cast_ty then
        Caux.mk_wseq_e e_sym_pat core_e begin
          Caux.mk_pure_e begin
            Caux.mk_case_pe e_sym_pe
              [ ( Caux.mk_specified_pat obj_sym_pat
                , Caux.mk_specified_pe begin
                    let is_signed = AilTypesAux.is_signed_integer_type cast_ty in
                    Caux.mk_memop_pe Mem_common.CapAssignValue [Caux.mk_nullcap_pe is_signed; stdlib.mkcall_conv_int cast_ty obj_sym_pe]
                  end )
              ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                , Caux.mk_undef_pe loc (Undefined.DUMMY "integer to [u]intptr_t cast") ) ]
          end
        end
      else if Global.is_CHERI () && Ctype.is_ptr_t (ctype_of e) && not (Ctype.is_ptr_t cast_ty) then
              Caux.mk_wseq_e e_sym_pat core_e begin
                Caux.mk_pure_e begin
                  Caux.mk_case_pe e_sym_pe
                    [ ( Caux.mk_specified_pat obj_sym_pat
                      , Caux.mk_specified_pe (stdlib.mkcall_conv_int cast_ty (Caux.mk_memop_pe Mem_common.Ptr_tIntValue [obj_sym_pe])) )
                    ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                      , Caux.mk_undef_pe loc (Undefined.DUMMY "[u]intptr_t to integer cast") ) ]
                end
              end
      else
              (* TODO: check *)
              Caux.mk_wseq_e e_sym_pat core_e (
                Caux.mk_pure_e (stdlib.mkcall_conv_loaded_int cast_ty e_sym_pe)
              )
    else (* cast_ty is floating since it is an arithmetic type *)
              Caux.mk_wseq_e e_sym_pat core_e (
                Caux.mk_pure_e (stdlib.mkcall_loaded_ivfromfloat cast_ty e_sym_pe)
              )
  else
    if AilTypesAux.is_integer e_ty then
              Caux.mk_wseq_e e_sym_pat core_e (
                Caux.mk_pure_e (stdlib.mkcall_loaded_fvfromint cast_ty e_sym_pe)
              )
    else (* cast_ty is floating since it is an arithmetic type *)
           (* TODO: should convert floating types *)
              let () = Debug.warn [Debug.DB_elaboration] (fun () ->
                "TODO: casts between floating types is currently a NOP"
              ) in
             core_e

else if AilTypesAux.is_pointer cast_ty && AilTypesAux.is_arithmetic e_ty then
            (* making a pointer from an integer *)
              let ref_ty = fromJust "Translation.translate_expression, AilEcast 1" $ AilTypesAux.referenced_type cast_ty in
              Caux.mk_wseq_e e_sym_pat core_e (
                Caux.mk_case_e e_sym_pe
                  [ ( Caux.mk_specified_pat obj_sym_pat
                    , Caux.mk_wseq_e (Caux.mk_sym_pat let_sym (C.BTy_object C.OTy_pointer))
                        (C.Expr [] (C.Ememop Mem_common.PtrFromInt [Caux.mk_ail_ctype_pe e_ty; Caux.mk_ail_ctype_pe ref_ty; obj_sym_pe]))
                        (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_sym_pe let_sym))) )
                  ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                    , (* Casting an unspecified integer to a pointer type gives an unspecified pointer *)
                      Caux.mk_pure_e (Caux.mk_unspecified_pe cast_ty) ) ]
              )

else if AilTypesAux.is_arithmetic cast_ty && AilTypesAux.is_pointer e_ty then
              (* making an integer from a pointer *)
              let ref_ty = fromJust "Translation.translate_expression, AilEcast 2" $ AilTypesAux.referenced_type e_ty in
              Caux.mk_wseq_e e_sym_pat core_e (
                  Caux.mk_case_e e_sym_pe
                    [ ( Caux.mk_specified_pat obj_sym_pat
                      , Caux.mk_wseq_e (Caux.mk_sym_pat let_sym (C.BTy_object C.OTy_integer))
                          (C.Expr [] (C.Ememop Mem_common.IntFromPtr [Caux.mk_ail_ctype_pe ref_ty; Caux.mk_ail_ctype_pe cast_ty; obj_sym_pe]))
                          (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_sym_pe let_sym))) )
                    ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                      , (* Casting an unspecified pointer to an integer type gives an unspecified integer *)
                        Caux.mk_pure_e (Caux.mk_unspecified_pe cast_ty) ) ]
              )

else (* pointer <-> pointer cast *)
              let () = Debug.warn [Debug.DB_elaboration] (fun () ->
                "NOTE: the elaboration does the identity for casts between pointer types (this is different from ISO)"
              ) in
              let ub_pe = Caux.mk_undef_pe loc Undefined.UB025_misaligned_pointer_conversion in
              match AilTypesAux.referenced_type cast_ty with
                | Just cast_ref_ty ->
  if AilTypesAux.is_void cast_ref_ty || AilTypesAux.is_function cast_ref_ty then
                    core_e
  else
                    Caux.mk_wseq_e (Caux.mk_sym_pat e_sym (C.BTy_loaded oTy)) core_e begin
                      Caux.mk_case_e e_sym_pe
                        [ ( Caux.mk_specified_pat obj_sym_pat
                          , Caux.mk_wseq_e (Caux.mk_sym_pat let_sym C.BTy_boolean)
                              (C.Expr [] (C.Ememop Mem_common.PtrWellAligned [Caux.mk_ail_ctype_pe cast_ref_ty; obj_sym_pe]))
                              (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_if_pe_ [Annot.Anot_explode] (Caux.mk_sym_pe let_sym) obj_sym_pe ub_pe))) )
                        ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                          , (* we are being daemonic (case where the resulting pointer would be misaligned) *)
                            Caux.mk_pure_e ub_pe ) ]
                    end
                | _ ->
                    error "Translation AilEcast, ptr vs ptr: just should be impossible"
              end
            )
      
      | A.AilEbinary e1 (A.Arithmetic A.Mul) e2 ->
          translate_mul_operator loc self usual_arithmetic_conversion stdlib
            result_ty e1 e2
      | A.AilEbinary e1 (A.Arithmetic (A.Div as aop)) e2 ->
          translate_div_mod_operator loc self usual_arithmetic_conversion stdlib
            result_ty aop e1 e2
      | A.AilEbinary e1 (A.Arithmetic (A.Mod as aop)) e2 ->
          translate_div_mod_operator loc self usual_arithmetic_conversion stdlib
            result_ty aop e1 e2
      
      | A.AilEbinary e1 (A.Arithmetic A.Add) e2 ->
          self e1 >>= fun core_e1 ->
          self e2 >>= fun core_e2 ->
if AilTypesAux.is_arithmetic (ctype_of e1) && AilTypesAux.is_arithmetic (ctype_of e2) then
            let oTy1 = force_core_object_type_of_ctype (ctype_of e1) in
            let oTy2 = force_core_object_type_of_ctype (ctype_of e2) in
            E.wrapped_fresh_symbol (C.BTy_loaded oTy1) >>= fun (e1_sym  , e1_sym_pat  , e1_sym_pe  ) ->
            E.wrapped_fresh_symbol (C.BTy_loaded oTy2) >>= fun (e2_sym  , e2_sym_pat  , e2_sym_pe  ) ->
            E.wrapped_fresh_symbol (C.BTy_object oTy1) >>= fun (obj1_sym, obj1_sym_pat, obj1_sym_pe) ->
            E.wrapped_fresh_symbol (C.BTy_object oTy2) >>= fun (obj2_sym, obj2_sym_pat, obj2_sym_pe) ->
            E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, cap_sym_pat, cap_sym_pe) ->
            let (promoted1_pe, promoted2_pe) =
              Caux.mk_std_pair_pe "§6.5.6#4"
                (usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe) in
            E.return begin
              C.Expr [Annot.Astd "§6.5.6"] (
                C.Ewseq (Caux.mk_tuple_pat [ e1_sym_pat; e2_sym_pat ]) (Caux.mk_unseq [core_e1; core_e2]) (
                Caux.mk_pure_e (
                  Caux.mk_case_pe (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
                    [ ( Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_sym_pat
                                          ; Caux.mk_specified_pat obj2_sym_pat ]
                      , (* Both operand are specified *)
                        let core_add = Caux.mk_std_pe "§6.5.6#5" (Caux.mk_op_pe C.OpAdd promoted1_pe promoted2_pe) in
                        Caux.mk_specified_pe (
  if Global.is_CHERI () && Ctype.is_ptr_t result_ty then
                          Caux.mk_let_pe cap_sym_pat
                            (Caux.mk_memop_pe (Mem_common.DeriveCap (Mem_common.DCbinary (A.Arithmetic A.Add)) (AilTypesAux.is_signed_integer_type result_ty))
                              [obj1_sym_pe; obj2_sym_pe])
                            (Caux.mk_memop_pe Mem_common.CapAssignValue
                              [cap_sym_pe; stdlib.mkcall_wrapI result_ty core_add])
  else if AilTypesAux.is_signed_integer_type result_ty then
                          stdlib.mkcall_catch_exceptional_condition result_ty core_add
  else if AilTypesAux.is_integer result_ty then
                          stdlib.mkcall_wrapI result_ty core_add
  else
                          core_add) )
                    
                    ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy1; C.BTy_loaded oTy2])
                      , (* If either operand is unspecified, the result is also unspecified is the
                           result type of unsigned. Otherwise it is undef, since the addition
                           may overflow *)
  if AilTypesAux.is_unsigned_integer_type result_ty then
                        Caux.mk_unspecified_pe (result_ty)
  else
                        Caux.mk_undef_exceptional_condition loc) ]
                )
                )
              )
            end
else
          (* Here one of the operand is pointer *)
          let (ptr_ty, ptr_core_e, integer_core_e) =
if AilTypesAux.is_arithmetic (ctype_of e1) then
            (ctype_of e2, core_e2, core_e1)
else
            (ctype_of e1, core_e1, core_e2) in
          
          let ref_ty = match AilTypesAux.referenced_type ptr_ty with
            | (*BISECT-IGNORE*) Nothing ->
                illTypedAil loc "A.AilEbinary (A.Arithmetic A.Add), one is pointer"
            | Just ref_ty ->
                ref_ty
          end in
          
            let ptr_sym         = Symbol.fresh () in
            let integer_sym     = Symbol.fresh () in
            let ptr_obj_sym     = Symbol.fresh () in
            let integer_obj_sym = Symbol.fresh () in
            let ptr_sym_pe         = Caux.mk_sym_pe ptr_sym         in
            let ptr_obj_sym_pe     = Caux.mk_sym_pe ptr_obj_sym     in
            let integer_sym_pe     = Caux.mk_sym_pe integer_sym     in
            let integer_obj_sym_pe = Caux.mk_sym_pe integer_obj_sym in
            E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (res_sym, res_sym_pat, res_sym_pe) ->
            E.return begin
              C.Expr [Annot.Astd "§6.5.6"] (
                C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat ptr_sym     (C.BTy_loaded C.OTy_pointer)
                                           ; Caux.mk_sym_pat integer_sym (C.BTy_loaded C.OTy_integer) ]) (Caux.mk_unseq [ptr_core_e; integer_core_e]) (
                  Caux.mk_case_e (Caux.mk_tuple_pe [ptr_sym_pe; integer_sym_pe])
                    [ ( Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat ptr_obj_sym (C.BTy_object C.OTy_pointer))
                                          ; Caux.mk_specified_pat (Caux.mk_sym_pat integer_obj_sym (C.BTy_object C.OTy_integer)) ]
                      , (* Both operand are specified *)
if Global.has_strict_pointer_arith () || Global.is_CHERI () || Global.is_PNVI () then
                        Caux.mk_wseq_e res_sym_pat
                          (C.Expr [] (C.Ememop Mem_common.PtrArrayShift [ptr_obj_sym_pe; Caux.mk_ail_ctype_pe ref_ty; integer_obj_sym_pe]))
                          (Caux.mk_pure_e (Caux.mk_specified_pe res_sym_pe))
else
                        Caux.mk_pure_e (Caux.mk_specified_pe (
                          Caux.mk_std_pe "§6.5.6#8, sentences 2-3" (Caux.mk_array_shift ptr_obj_sym_pe ref_ty integer_obj_sym_pe)
(* end if *)
                        )) )
                    ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded C.OTy_pointer; C.BTy_loaded C.OTy_integer])
                      , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY "unspecified array_shift (addr)")) ) ]
                )
              )
            end
      
      (* TODO: check + try to factorise with A.Add *)
      | A.AilEbinary e1 (A.Arithmetic A.Sub) e2 ->
          self e1 >>= fun core_e1 ->
          self e2 >>= fun core_e2 ->
if AilTypesAux.is_arithmetic (ctype_of e1) && AilTypesAux.is_arithmetic (ctype_of e2) then
          let oTy1 = force_core_object_type_of_ctype (ctype_of e1) in
          let oTy2 = force_core_object_type_of_ctype (ctype_of e2) in
          E.wrapped_fresh_symbol (C.BTy_loaded oTy1) >>= fun (e1_sym, e1_sym_pat, e1_sym_pe)       ->
          E.wrapped_fresh_symbol (C.BTy_loaded oTy2) >>= fun (e2_sym, e2_sym_pat, e2_sym_pe)       ->
          E.wrapped_fresh_symbol (C.BTy_object oTy1) >>= fun (obj1_sym, obj1_sym_pat, obj1_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_object oTy2) >>= fun (obj2_sym, obj2_sym_pat, obj2_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, cap_sym_pat, cap_sym_pe) ->
          let (promoted1_pe, promoted2_pe) =
            Caux.mk_std_pair_pe "§6.5.6#4"
              (usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe) in
          E.return $
            C.Expr [Annot.Astd "§6.5.6"] (
              C.Ewseq (Caux.mk_tuple_pat [e1_sym_pat; e2_sym_pat]) (Caux.mk_unseq [core_e1; core_e2]) (
                Caux.mk_pure_e (
                  Caux.mk_case_pe (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
                    [ ( Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_sym_pat
                                          ; Caux.mk_specified_pat obj2_sym_pat ]
                      , (* Both operand are specified *)
                        let core_sub = Caux.mk_std_pe "§6.5.6#6" $ Caux.mk_op_pe C.OpSub promoted1_pe promoted2_pe in
                        Caux.mk_specified_pe $
  if Global.is_CHERI () && Ctype.is_ptr_t result_ty then
                          Caux.mk_let_pe cap_sym_pat
                            (Caux.mk_memop_pe (Mem_common.DeriveCap (Mem_common.DCbinary (A.Arithmetic A.Sub)) (AilTypesAux.is_signed_integer_type result_ty))
                              [obj1_sym_pe; obj2_sym_pe])
                            (Caux.mk_memop_pe Mem_common.CapAssignValue
                              [cap_sym_pe; stdlib.mkcall_wrapI result_ty core_sub])
  else if AilTypesAux.is_signed_integer_type result_ty then
                          stdlib.mkcall_catch_exceptional_condition result_ty core_sub
  else if AilTypesAux.is_integer result_ty then
                          stdlib.mkcall_wrapI result_ty core_sub
  else
                          core_sub )
                    ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy1; C.BTy_loaded oTy2])
                      , (* If either operand is unspecified, the result is also unspecified is the
                           result type of unsigned. Otherwise it is undef, since the addition
                           may overflow *)
  if AilTypesAux.is_signed_integer_type result_ty then
                        Caux.mk_undef_exceptional_condition loc
  else
                        Caux.mk_unspecified_pe (result_ty) ) ]
                )
              )
            )

else if AilTypesAux.is_pointer (ctype_of e1) && AilTypesAux.is_pointer (ctype_of e2) then
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (e1_sym, e1_sym_pat, e1_sym_pe)          ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (e2_sym, e2_sym_pat, e2_sym_pe)          ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (obj1_sym, obj1_sym_pat, obj1_sym_pe)    ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (obj2_sym, obj2_sym_pat, obj2_sym_pe)    ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (memop_sym, memop_sym_pat, memop_sym_pe) ->
          
          (* NOTE: by Ail typing we can just use the referenced type of either operand *)
          (* TODO: check that, we "only" know that their referenced types are compatible *)
          let diff_ty_pe = match (ctype_of e1) with
            | Ctype.Ctype _ (Ctype.Pointer _ ref_ty1) ->
                Caux.mk_ail_ctype_pe ref_ty1
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "ptrdiff"
          end in
          E.return $
            C.Expr [Annot.Astd "§6.5.6"] (
              C.Ewseq (Caux.mk_tuple_pat [e1_sym_pat; e2_sym_pat]) (Caux.mk_unseq [core_e1; core_e2]) (
                Caux.mk_case_e (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
                  [ ( Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_sym_pat
                                        ; Caux.mk_specified_pat obj2_sym_pat ]
                    , (* Both operand are specified *)
                      Caux.mk_wseq_e memop_sym_pat
                        (C.Expr [] (C.Ememop Mem_common.Ptrdiff [diff_ty_pe; obj1_sym_pe; obj2_sym_pe]))
                        begin
                          Caux.mk_pure_e begin
                            Caux.mk_if_pe_ [Annot.Anot_explode] (stdlib.mkcall_is_representable memop_sym_pe Ctype.ptrdiff_t)
                              (Caux.mk_specified_pe memop_sym_pe)
                              (Caux.mk_undef_pe loc Undefined.UB050_pointers_subtraction_not_representable)
                          end
                        end )
                  ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded C.OTy_pointer; C.BTy_loaded C.OTy_pointer])
                    , Caux.mk_pure_e (Caux.mk_undef_pe loc Undefined.UB050_pointers_subtraction_not_representable) ) ]
              )
            )

else
            (* Here one of the operand is pointer *)
            let (ptr_ty, ptr_core_e, integer_core_e) =
              if AilTypesAux.is_arithmetic (ctype_of e1) then
                (ctype_of e2, core_e2, core_e1)
              else
                (ctype_of e1, core_e1, core_e2) in
            
            let ref_ty = match AilTypesAux.referenced_type ptr_ty with
              | (*BISECT-IGNORE*) Nothing ->
                  illTypedAil loc "A.AilEbinary (A.Arithmetic A.Sub), one is pointer"
              | Just ref_ty ->
                  ref_ty
            end in
            
            let ptr_sym = Symbol.fresh () in
            let integer_sym = Symbol.fresh () in
            let ptr_obj_sym = Symbol.fresh () in
            let integer_obj_sym = Symbol.fresh () in
            let ptr_sym_pe         = Caux.mk_sym_pe ptr_sym         in
            let ptr_obj_sym_pe     = Caux.mk_sym_pe ptr_obj_sym     in
            let integer_sym_pe     = Caux.mk_sym_pe integer_sym     in
            let integer_obj_sym_pe = Caux.mk_sym_pe integer_obj_sym in
            E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (res_sym, res_sym_pat, res_sym_pe) ->
            E.return $
              C.Expr [Annot.Astd "§6.5.6"] (
                C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat ptr_sym     (C.BTy_loaded C.OTy_pointer)
                                           ; Caux.mk_sym_pat integer_sym (C.BTy_loaded C.OTy_integer) ])
                  (Caux.mk_unseq [ptr_core_e; integer_core_e]) (
                    Caux.mk_case_e (Caux.mk_tuple_pe [ptr_sym_pe; integer_sym_pe])
                        [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat ptr_obj_sym (C.BTy_object C.OTy_pointer))
                                           ; Caux.mk_specified_pat (Caux.mk_sym_pat integer_obj_sym (C.BTy_object C.OTy_integer)) ],
                         (* Both operand are specified *)
if Global.has_strict_pointer_arith () || Global.is_CHERI || Global.is_PNVI () then
                        Caux.mk_wseq_e res_sym_pat
                          (C.Expr [] (C.Ememop Mem_common.PtrArrayShift [ptr_obj_sym_pe; Caux.mk_ail_ctype_pe ref_ty; (Caux.mk_neg_pe integer_obj_sym_pe)]))
                          (Caux.mk_pure_e (Caux.mk_specified_pe res_sym_pe))
else
                        Caux.mk_pure_e $ Caux.mk_specified_pe (
                          Caux.mk_std_pe "§6.5.6#8, sentences 2-3" $ Caux.mk_array_shift ptr_obj_sym_pe ref_ty (Caux.mk_neg_pe integer_obj_sym_pe)
                        ) )
(* end if *)
                        ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded C.OTy_pointer; C.BTy_loaded C.OTy_integer])
                          , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY "unspecified array_shift (sub)")) ) ]
                  )
              )
      
      | A.AilEbinary e1 (A.Lt as bop) e2 ->
          translate_relational_operator
            self usual_arithmetic_conversion
            result_ty bop e1 e2
      | A.AilEbinary e1 (A.Gt as bop) e2 ->
          translate_relational_operator
            self usual_arithmetic_conversion
            result_ty bop e1 e2
      | A.AilEbinary e1 (A.Le as bop) e2 ->
          translate_relational_operator
            self usual_arithmetic_conversion
            result_ty bop e1 e2
      | A.AilEbinary e1 (A.Ge as bop) e2 ->
          translate_relational_operator
            self usual_arithmetic_conversion
            result_ty bop e1 e2
      
      | A.AilEbinary e1 (A.Eq as bop) e2 ->
          translate_equality_operator loc
            self usual_arithmetic_conversion
            result_ty bop e1 e2
      | A.AilEbinary e1 (A.Ne as bop) e2 ->
          translate_equality_operator loc
            self usual_arithmetic_conversion
            result_ty bop e1 e2
      
      | A.AilEbinary e1 (A.Arithmetic (A.Band as aop)) e2 ->
          translate_bitwise_operator
            loc self usual_arithmetic_conversion stdlib
            result_ty aop e1 e2
      | A.AilEbinary e1 (A.Arithmetic (A.Bxor as aop)) e2 ->
          translate_bitwise_operator
            loc self usual_arithmetic_conversion stdlib
            result_ty aop e1 e2
      | A.AilEbinary e1 (A.Arithmetic (A.Bor as aop)) e2 ->
          translate_bitwise_operator
            loc self usual_arithmetic_conversion stdlib
            result_ty aop e1 e2
      
      | A.AilEbinary e1 A.And e2 ->
          (* TODO: this is hackish, but on the other hand it factorise code ... *)
          (* Also it follows the phrasing of the std *)
          (* Desugaring e1 && e2 ===> (e1 == 0) ? 0 : (e2 != 0) *)
          self begin
            A.AnnotatedExpression
              (GenTypes.GenRValueType signedInt_gty) [] loc
              (A.AilEcond (mkTestExpression TestEq e1) zeroAil_tau (mkTestExpression TestNe e2))
          end
(*
          let () = Debug.warn [Debug.DB_elaboration] (fun () -> "TODO: make the elab of A.And use mkTestExpression") in
          self e1        >>= fun core_e1  ->
          self e2        >>= fun core_e2  ->
          E.fresh_symbol >>= fun e1_sym   ->
          E.fresh_symbol >>= fun e2_sym   ->
          E.fresh_symbol >>= fun obj1_sym ->
          E.fresh_symbol >>= fun obj2_sym ->
          (* The object type on which the Core operator is going to work on. *)
          (* By typing it is enough to look at the type of one of the operand (see STD §6.5.8#2) *)
          let oTy = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
          let e1_sym_pe        = Caux.mk_sym_pe e1_sym        in
          let e2_sym_pe        = Caux.mk_sym_pe e2_sym        in
          let obj1_sym_pe      = Caux.mk_sym_pe obj1_sym      in
          let obj2_sym_pe      = Caux.mk_sym_pe obj2_sym      in
          E.return $
            C.Expr [Annot.Astd "§6.5.13"] (
              C.Ewseq (Caux.mk_sym_pat e1_sym (C.BTy_loaded oTy)) core_e1 (
                Caux.mk_case_e e1_sym_pe
                  [ ( Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy))
                    , C.Expr [Annot.Astd "§6.5.13#4"] (
                        C.Eif (Caux.mk_op_pe C.OpEq obj1_sym_pe (Caux.mk_integer_pe 0))
                          (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_integer_pe 0)))
                          begin
                            Caux.mk_wseq_e (Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy)) core_e2 (
                              Caux.mk_pure_e (
                                Caux.mk_case_pe e2_sym_pe
                                  [ ( Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy))
                                    , Caux.mk_specified_pe (
                                        Caux.mk_std_pe "§6.5.13#3" $
                                          Caux.mk_if_pe (Caux.mk_op_pe C.OpEq obj2_sym_pe (Caux.mk_integer_pe 0))
                                            (Caux.mk_integer_pe 0) (Caux.mk_integer_pe 1)
                                      ) )
                                  ; ( Caux.mk_empty_pat (C.BTy_loaded oTy)
                                    , (* TODO: check with Peter *)
                                      Caux.mk_unspecified_pe (result_ty) ) ]
                              )
                            )
                          end
                      ) )
                  ; ( Caux.mk_empty_pat (C.BTy_loaded oTy)
                    , (* TODO: check with Peter *)
                      Caux.mk_pure_e (Caux.mk_unspecified_pe (result_ty)) ) ]
              )
            )
*)
      
      | A.AilEbinary e1 A.Or e2 ->
          (* TODO: this is hackish, but on the other hand it factorise code ... *)
          (* Also it follows the phrasing of the std *)
          (* Desugaring e1 || e2 ===> (e1 == 0) ? (e2 != 0) : 0 *)
          self begin
            A.AnnotatedExpression
              (GenTypes.GenRValueType signedInt_gty) [] loc
              (A.AilEcond (mkTestExpression TestEq e1) (mkTestExpression TestNe e2) oneAil_tau)
          end
(*
          let () = Debug.warn [Debug.DB_elaboration] (fun () -> "TODO: make the elab of A.Or use mkTestExpression") in
          self e1        >>= fun core_e1  ->
          self e2        >>= fun core_e2  ->
          E.fresh_symbol >>= fun e1_sym   ->
          E.fresh_symbol >>= fun e2_sym   ->
          E.fresh_symbol >>= fun obj1_sym ->
          E.fresh_symbol >>= fun obj2_sym ->
          (* The object type on which the Core operator is going to work on. *)
          (* By typing it is enough to look at the type of one of the operand (see STD §6.5.8#2) *)
          let oTy = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
          let e1_sym_pe        = Caux.mk_sym_pe e1_sym        in
          let e2_sym_pe        = Caux.mk_sym_pe e2_sym        in
          let obj1_sym_pe      = Caux.mk_sym_pe obj1_sym      in
          let obj2_sym_pe      = Caux.mk_sym_pe obj2_sym      in
          E.return $
            C.Expr [Annot.Astd "§6.5.14"] (
              C.Ewseq (Caux.mk_sym_pat e1_sym (C.BTy_loaded oTy)) core_e1 (
                Caux.mk_case_e e1_sym_pe
                  [ ( Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy))
                    , C.Expr [Annot.Astd "§6.5.14#4"] (
                        C.Eif (Caux.mk_not_pe (Caux.mk_op_pe C.OpEq obj1_sym_pe (Caux.mk_integer_pe 0)))
                          (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_integer_pe 1)))
                          begin
                            Caux.mk_wseq_e (Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy)) core_e2 (
                              Caux.mk_pure_e (
                                Caux.mk_case_pe e2_sym_pe
                                  [ ( Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy))
                                    , Caux.mk_specified_pe (
                                        Caux.mk_std_pe "§6.5.14#3" $
                                          Caux.mk_if_pe (Caux.mk_op_pe C.OpEq obj2_sym_pe (Caux.mk_integer_pe 0))
                                            (Caux.mk_integer_pe 0) (Caux.mk_integer_pe 1)
                                      ) )
                                  ; ( Caux.mk_empty_pat (C.BTy_loaded oTy)
                                    , (* TODO: check with Peter *)
                                      Caux.mk_unspecified_pe (result_ty) ) ]
                              )
                            )
                          end
                      ) )
                ; ( Caux.mk_empty_pat (C.BTy_loaded oTy)
                  , (* TODO: check with Peter *)
                    Caux.mk_pure_e (Caux.mk_unspecified_pe (result_ty)) ) ]
              )
            )
*)
      
      | A.AilEcond e1 e2 e3 ->
          (* STD §6.5.15 *)
          (* NOTE: Ail typechecker guarantees that e1 is scalar *)
          let e1_oTy = force_core_object_type_of_ctype (ctype_of e1) in
          E.wrapped_fresh_symbol (C.BTy_loaded e1_oTy) >>= fun (_, e1_sym_pat  , e1_sym_pe  ) ->
          E.wrapped_fresh_symbol (C.BTy_object e1_oTy) >>= fun (_, obj1_sym_pat, obj1_sym_pe) ->
          self (mkTestExpression TestEq e1) >>= fun core_e1 ->
          
          let apply_implicit_conversions e =
            let e_ty = ctype_of e in
            self e >>= fun core_e ->
            if AilTypesAux.is_integer result_ty then begin
              let e_oTy = force_core_object_type_of_ctype e_ty in
              E.wrapped_fresh_symbol (C.BTy_loaded e_oTy) >>= fun (_, e_sym_pat, e_sym_pe  ) ->
              (* NOTE: e_ty must then be an integer *)
              E.return begin
                Caux.mk_sseq_e e_sym_pat core_e
                  (Caux.mk_pure_e (stdlib.mkcall_conv_loaded_int result_ty e_sym_pe))
              end
            end else if AilTypesAux.is_floating result_ty then begin
              if AilTypesAux.is_integer e_ty then
                let e_oTy = force_core_object_type_of_ctype e_ty in
                E.wrapped_fresh_symbol (C.BTy_loaded e_oTy) >>= fun (_, e_sym_pat, e_sym_pe  ) ->
                E.return begin
                  Caux.mk_sseq_e e_sym_pat core_e
                    (Caux.mk_pure_e (stdlib.mkcall_loaded_fvfromint result_ty e_sym_pe))
                end
              else
                E.return core_e (* TODO floating conversion *)
            end else if AilTypesAux.is_pointer result_ty then begin
              if AilTypesAux.is_integer e_ty then begin
                if AilSyntaxAux.is_null_pointer_constant e then
                  match AilTypesAux.referenced_type result_ty with
                    | Just ref_ty ->
                        E.return $
                          Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_nullptr_pe ref_ty))
                    | _ ->
                        error "AilEcond: a pointer must have a referenced type"
                  end
                else
                  error "AilEcond: invalid implicit conversion from integer to pointer"
              end else if AilTypesAux.is_pointer e_ty then begin
                  E.return core_e
              end else begin
                  error "AilEcond: invalid implicit conversion to a pointer type"
              end
            end else begin
                (* NOTE: typechecker guarantees that e_ty = result_ty in this case *)
                E.return core_e
            end
          in
          apply_implicit_conversions e2 >>= fun conv_e2 ->
          apply_implicit_conversions e3 >>= fun conv_e3 ->
          
          E.return $ C.Expr [Annot.Astd "§6.5.15#4, sentence 1"]
            (* STD (§6.5.15#4, sentence 2) says there is a sequenced point between the
               evaluation of e1 and the e2/e3. Hence the strong sequencing *)
            (C.Esseq e1_sym_pat core_e1
              (Caux.mk_case_e e1_sym_pe
                [ (Caux.mk_specified_pat obj1_sym_pat,
                   C.Expr [Annot.Astd "§6.5.15#4, sentence 2"] (
                     C.Eif (Caux.mk_op_pe C.OpEq obj1_sym_pe (Caux.mk_integer_pe 0)) conv_e2 conv_e3
                   ) )
                ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                   Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY "unspecified AilEcond"))) ]
            ))
      
      | A.AilEassign e1 e2 ->
          (* STD §6.5.16 *)
          let () = Debug.warn [Debug.DB_elaboration] (fun () -> "TODO: AilEassign overlap UB (see §6.5.16.1#3)") in
          self e1                                             >>= fun core_e1                          ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (e1_sym, e1_sym_pat, e1_sym_pe)  ->
          let core_ty_pe1 = Caux.mk_ail_ctype_pe $ AilTypesAux.rvalue_coercion (snd (from_lvalue_type e1)) in
          
          let e2_sym = Symbol.fresh () in
          let ty1 = ctype_of e1 in
          let ty2 = ctype_of e2 in
          begin
if AilTypesAux.atomic_qualified_unqualified AilTypesAux.is_arithmetic ty1 && AilTypesAux.is_arithmetic ty2 then
            self e2 >>= fun core_e ->
            E.return (
              force_core_object_type_of_ctype ty2,
              core_e,
              conv_loaded_arith stdlib ty2 (Ctype.unatomic ty1)
            )

else if AilTypesAux.atomic_qualified_unqualified AilTypesAux.is_struct_or_union ty1 then
            (* TODO(check): I don't think that any conversion is needed here. *)
            (* TODO2: if we have multiple translation units, then maybe there should be a conversion? *)
            self e2 >>= fun core_e ->
            E.return (
              force_core_object_type_of_ctype ty2,
              core_e,
              fun z -> z
            )

(* NOTE: we apply unatomic to ty1 because the left operand may be an atomic pointer to ... (STD §6.5.16.1#1, bullet 3) *)
else match AilTypesAux.referenced_type (Ctype.unatomic ty1) with
  | Just ref_ty ->
        if Aaux.is_null_pointer_constant e2 then
            E.return (
              C.OTy_pointer,
              Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_nullptr_pe ref_ty)),
              fun z -> z
            )
        else
            self e2 >>= fun core_e ->
            E.return (
              force_core_object_type_of_ctype ty2,
              core_e,
              fun z -> z
           )
  | Nothing ->
        (* By Ail typing, e1 must have type _Bool and e2 must be a pointer *)
        let _ = Debug.print_debug 1 [] (fun _ -> "E2 can have type function: " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers ty2) in (* TODO *)
        self e2 >>= fun core_e2 ->
        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (_, e2_sym_pat, e2_sym_pe) ->
        E.return (
          C.OTy_integer,
          Caux.mk_wseq_e e2_sym_pat core_e2 (stdlib.mkproc_loaded_pointer_to_Bool e2_sym_pe),
          fun z -> z
        )
end
          end >>= fun (oTy2, core_e2, mk_stored_pe) ->
          
          let object_pe =
            Caux.mk_std_pe "§6.5.16#3, sentence 1" e1_sym_pe in
          let stored_pe =
            Caux.mk_std_pe "§6.5.16.1#2, conversion" (
              mk_stored_pe (Caux.mk_sym_pe e2_sym)
            ) in
          
          let mo =
            if AilTypesAux.is_atomic ty1 then
              (* STD §6.2.6.1#9 *)
              Cmm.Seq_cst
            else
              Cmm.NA in
          E.return $
            C.Expr [Annot.Astd "§6.5.16#3, sentence 4"] (
              C.Ewseq (Caux.mk_tuple_pat [ e1_sym_pat
                                         ; Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy2) ])
                (C.Expr [Annot.Astd "§6.5.16#3, sentence 5"] (C.Eunseq [core_e1; core_e2])) (
                Caux.mk_wseq_e (Caux.mk_empty_pat C.BTy_unit)
                   (C.Expr [Annot.Astd "§6.5.16.1#2, store"] (
                     C.Eaction (C.Paction C.Neg (C.Action loc default (C.Store false(* not locking *) core_ty_pe1 object_pe stored_pe mo)))
                   ))
                   (Caux.mk_pure_e stored_pe)
              )
            )
      
      | A.AilEbinary e1 A.Comma e2 ->
          (* STD §6.5.17 *)
          self e1 >>= fun core_e1 ->
          self e2 >>= fun core_e2 ->
          let oTy = force_core_object_type_of_ctype (ctype_of e1) in
          (* STD (§6.5.17, sentence 2) says there is a sequence point between the
             evaluation of the two operand. Hence the strong sequencing *)
          E.return $
            C.Expr [Annot.Astd "§6.5.17#2, sentence 2"] (
              C.Esseq (Caux.mk_empty_pat (C.BTy_loaded oTy)) core_e1 core_e2
          )
      
      | A.AilEcompoundAssign e1 aop e2 ->
          error "Translation ==> AilEcompoundAssign" (* currently the desugaring translates E1 op= E2 into E1 = E1 op E2 *)
(*
          (* TODO: in C11/C17 this is a seq_cst RMW for atomic types *)
          (* NOTE: but if I read N2329 correctly, in C2X this will not be an RMW for the atomic case (but seq_cst) *)
          let () = Debug.print_debug 1 [] (fun () ->
            "HACK!!!! => AilEcompoundAssign is WIP and only doing +=  ==>  memory order is also wrong"
          ) in
          (* TODO: check sequencing with respect to indet function calls *)
          self e1 >>= fun core_e1 ->
          self e2 >>= fun core_e2 ->
          let lvalue_ty = AilTypesAux.rvalue_coercion (snd (from_lvalue_type e1)) in
          let lvalue_oTy = force_core_object_type_of_ctype lvalue_ty in
          
          (*let oTy1 = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e2)) in*)
          let oTy2 = force_core_object_type_of_ctype (ctype_of e2) in
          
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, l1_sym_pat   , l1_sym_pe  ) ->
          E.wrapped_fresh_symbol (C.BTy_loaded lvalue_oTy)    >>= fun (_, v1_sym_pat   , v1_sym_pe  ) ->
          E.wrapped_fresh_symbol (C.BTy_loaded oTy2)          >>= fun (_, v2_sym_pat   , v2_sym_pe  ) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, z1_sym_pat   , z1_sym_pe  ) ->
          E.wrapped_fresh_symbol (C.BTy_loaded lvalue_oTy)    >>= fun (_, z2_sym_pat   , z2_sym_pe  ) ->

          let lvalue_ty_pe = Caux.mk_ail_ctype_pe lvalue_ty in
          
          E.wrapped_fresh_symbol (C.BTy_object lvalue_oTy)    >>= fun (_, obj1_sym_pat   , obj1_sym_pe  ) ->
          E.wrapped_fresh_symbol (C.BTy_object oTy2)          >>= fun (_, obj2_sym_pat   , obj2_sym_pe  ) ->
          let stored_pe =
            Caux.mk_case_pe (Caux.mk_tuple_pe [v1_sym_pe; v2_sym_pe])
              [ ( Caux.mk_tuple_pat [Caux.mk_specified_pat obj1_sym_pat; Caux.mk_specified_pat obj2_sym_pat]
                , Caux.mk_specified_pe (Caux.mk_op_pe C.OpAdd obj1_sym_pe obj2_sym_pe) ) ] in
          
          E.return begin
            Caux.mk_wseq_e (Caux.mk_tuple_pat [Caux.mk_tuple_pat [l1_sym_pat; v1_sym_pat]; v2_sym_pat]) begin
              Caux.mk_unseq_e
                [ Caux.mk_wseq_e z1_sym_pat core_e1 begin
                    Caux.mk_wseq_e z2_sym_pat (Caux.pload loc lvalue_ty_pe z1_sym_pe Cmm.NA)
                      (Caux.mk_pure_e (Caux.mk_tuple_pe [z1_sym_pe; z2_sym_pe]))
                  end
                ; core_e2 ]
            end
            begin
              C.Expr []
                (C.Eaction (C.Paction C.Neg (C.Action loc default (C.Store false(* not locking *) lvalue_ty_pe l1_sym_pe stored_pe Cmm.NA))))
            end
          end
*)


(*
          E.return begin
            Caux.mk_wseq_e (Caux.mk_tuple_pat ) begin
              Caux.mk_unseq_e
                [ Caux.mk_wseq_e e1_sym_pat core_e1 begin
                    Caux.mk_wseq_e load_sym_pat (Caux.pload loc lvalue_ty_pe e1_sym_pe Cmm.NA) begin
                      Caux.mk_pure_e (Caux.mk_tuple_pe [e1_sym_pe; load_sym_pe])
                    end
                  end
                ; core_e2 ]
            end
            match aop with
              | A.Mul ->
                  (* translate_mul_operator *)
              | A.Div | A.Mod ->
                  (* translate_div_mod_operator *)
              | A.Add ->
                  
              | A.Sub ->
                  
              | Shl ->
                  
              | Shr ->
                  
              | Band | Bxor | Bor ->
                  translate_bitwise_operator
            end


              C.Expr []
                (C.Eaction (C.Paction C.Neg (C.Action loc default (C.Store lvalue_ty_pe object_pe stored_pe Cmm.NA))))
            end
          end
          *)
(*
(*      
      (*
         (std: A compound assignment of the form E1 op = E2 is equivalent to the simple assignment
         expression E1 = E1 op (E2), except that the lvalue E1 is evaluated only once, and with respect
         to an indeterminately-sequenced function call, the operation of a compound) *)
      | A.AilEcompoundAssign e1 aop e2 ->
          (* TODO: this is a TEMPORARY HACK *)
          let A.AnnotatedExpression annot2 loc' _ = e2 in
          self $
            A.AnnotatedExpression annot loc (A.AilEassign e1 (A.AnnotatedExpression annot2 loc' (A.AilEbinary e1 (A.Arithmetic aop) e2)))
*)
      
      (* TODO: conv_int on e2 and e2 !!!!!!! *)
      
*)

(*
      | A.AilEcompoundAssign e1 aop e2 ->
          self e1 >>= fun core_e1 ->
          self e2 >>= fun core_e2 ->
          E.return $
            C.Ewseq (Caux.mk_tuple_pat [e1_sym_pat; e2_sym_pat]) (C.Eunseq [core_e1; core_e2]) (
              C.Easeq (Just (atom_sym, bTy) (Caux.pstore loc TODO_ty_pe e1_sym_pe))
            )
*)

(*
 | Easeq of maybe ('sym * core_base_type) * (generic_action 'a 'bty 'sym) * (generic_paction 'a 'bty 'sym) (* atomic sequencing *)
*)
      






      
(*
      (* TODO: a bit hackish *)
      | A.AilEcall (A.AnnotatedExpression _ (A.AilEbuiltin str)) es ->
          match (str, es) with
            | ("atomic_load_explicit", [object_e; order_e]) ->
                (* TODO: for now we don't allow complicated expressions for order_e *)
                E.return $
                  E.fresh_symbol >>= fun a_object ->
                  self e
                  C.
          end
*)
     | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin (A.AilBatomic A.AilBAstore))) [lobject_e; desired_e; order_e] ->
         (* TODO: be more permissive for the memory order *)
         let mo = translate_memory_order order_e in
         let ref_ty = match ctype_of lobject_e with
           | Ctype.Ctype _ (Ctype.Pointer _ ref_ty) ->
               ref_ty
           | (*BISECT-IGNORE*) _ ->
               illTypedAil loc "AilEcall atomic_store_explicit"
         end in
         let oTy = force_core_object_type_of_ctype (ctype_of desired_e) in
         self lobject_e >>= fun lobject_core_e  ->
         self desired_e >>= fun desired_core_e ->
         E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (_, loaded_sym_pat, loaded_sym_pe)   ->
         E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, object_sym_pat, object_sym_pe)   ->
         E.wrapped_fresh_symbol (C.BTy_loaded oTy)           >>= fun (_, desired_sym_pat, desired_sym_pe) ->
         E.return begin
           Caux.mk_sseq_e (Caux.mk_tuple_pat [loaded_sym_pat; desired_sym_pat])
             begin
               Caux.mk_unseq_e [lobject_core_e; desired_core_e]
             end
             begin
               Caux.mk_case_e loaded_sym_pe
                 [ (Caux.mk_specified_pat object_sym_pat,
                    Caux.pstore loc (Caux.mk_ail_ctype_pe ref_ty) object_sym_pe desired_sym_pe mo)
                 ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                    Caux.mk_pure_e (Caux.mk_undef_pe loc Undefined.UB_unspecified_lvalue)) ]
             end
         end
     
     | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin (A.AilBatomic A.AilBAload))) [lobject_e; order_e] ->
         (* TODO: be more permissive for the memory order *)
         let mo = translate_memory_order order_e in
         let ref_ty = match ctype_of lobject_e with
           | Ctype.Ctype _ (Ctype.Pointer _ ref_ty) ->
               ref_ty
           | (*BISECT-IGNORE*) _ ->
               illTypedAil loc "AilEcall atomic_load_explicit"
         end in
         self lobject_e  >>= fun lobject_core_e  ->
         E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (_, loaded_sym_pat, loaded_sym_pe) ->
         E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, object_sym_pat, object_sym_pe) ->
         E.return begin
           Caux.mk_sseq_e loaded_sym_pat lobject_core_e
             begin
               Caux.mk_case_e loaded_sym_pe
                 [ (Caux.mk_specified_pat object_sym_pat,
                    Caux.pload loc (Caux.mk_ail_ctype_pe ref_ty) object_sym_pe mo)
                 ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                    Caux.mk_pure_e (Caux.mk_undef_pe loc Undefined.UB_unspecified_lvalue)) ]
             end
         end
     
     (* TODO: allow non trivial call to atomic_thread_fence() ... *)
     | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEident (Symbol.Symbol _ _ (Symbol.SD_Id "atomic_thread_fence")))) [order_e] ->
         (* TODO: be more permissive for the memory order *)
         let mo = translate_memory_order order_e in
         E.return $
           C.Expr [] (C.Eaction (C.Paction C.Pos (C.Action loc () (C.Fence mo))))

    | A.AilEcall
          (A.AnnotatedExpression _ _ _
              (A.AilEbuiltin (A.AilBatomic A.AilBAcompare_exchange_strong)))
          [object_e; expected_e; desired_e; order_success_e; order_failure_e] ->
      let mo_success = translate_memory_order order_success_e in
      let mo_failure = translate_memory_order order_failure_e in
      let (ty1,ty2) = match (ctype_of object_e, ctype_of expected_e) with
        | (Ctype.Ctype _ (Ctype.Pointer _ ty1), Ctype.Ctype _ (Ctype.Pointer _ ty2)) -> (ty1,ty2)
        | _ ->
          illTypedAil loc "AilEcall atomic_compare_exchange_strong_explicit"
      end in
      let oTy = force_core_object_type_of_ctype
                    (ctype_of desired_e) in

      self object_e   >>= fun core_object_e ->
      self expected_e >>= fun core_expected_e ->
      self desired_e  >>= fun core_desired_e ->
      E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer)
                 >>= fun (_, loaded_object_sym_pat, loaded_object_sym_pe) ->
      E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer)
                 >>= fun (_, object_sym_pat, object_sym_pe) ->
      E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer)
                 >>= fun (_, loaded_expected_sym_pat, loaded_expected_sym_pe) ->
      E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer)
                 >>= fun (_, expected_sym_pat, expected_sym_pe) ->
      E.wrapped_fresh_symbol (C.BTy_loaded oTy)
                 >>= fun (_, desired_sym_pat, desired_sym_pe) ->
      (* TODO: conversion? *)
      E.return begin
        Caux.mk_sseq_e
          (Caux.mk_tuple_pat [loaded_object_sym_pat
                             ;loaded_expected_sym_pat
                             ;desired_sym_pat])
          (Caux.mk_unseq_e [core_object_e
                           ;core_expected_e
                           ;core_desired_e])
          (Caux.mk_case_e (Caux.mk_tuple_pe [loaded_object_sym_pe
                                            ;loaded_expected_sym_pe])
              [ (Caux.mk_tuple_pat [Caux.mk_specified_pat object_sym_pat
                                   ;Caux.mk_specified_pat expected_sym_pat],
                 Caux.pcompare_exchange_strong
                    loc (Caux.mk_ail_ctype_pe (Ctype.Ctype [] (Ctype.unatomic_ ty1)))
                    object_sym_pe expected_sym_pe desired_sym_pe
                    mo_success mo_failure
                )
              ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded C.OTy_pointer
                                                ;C.BTy_loaded C.OTy_pointer]),
                 Caux.mk_pure_e
                   (Caux.mk_undef_pe loc Undefined.UB_unspecified_lvalue)
                )
              ]
          )
      end
    | A.AilEcall
          (A.AnnotatedExpression _ _ _
              (A.AilEbuiltin (A.AilBatomic A.AilBAcompare_exchange_weak)))
          [object_e; expected_e; desired_e; order_success_e; order_failure_e] ->
      let mo_success = translate_memory_order order_success_e in
      let mo_failure = translate_memory_order order_failure_e in
      let (ty1,ty2) = match (ctype_of object_e, ctype_of expected_e) with
        | (Ctype.Ctype _ (Ctype.Pointer _ ty1), Ctype.Ctype _ (Ctype.Pointer _ ty2)) -> (ty1,ty2)
        | _ ->
          illTypedAil loc "AilEcall atomic_compare_exchange_weak_explicit"
      end in
      let oTy = force_core_object_type_of_ctype
                    (ctype_of desired_e) in

      self object_e   >>= fun core_object_e ->
      self expected_e >>= fun core_expected_e ->
      self desired_e  >>= fun core_desired_e ->
      E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer)
                 >>= fun (_, loaded_object_sym_pat, loaded_object_sym_pe) ->
      E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer)
                 >>= fun (_, object_sym_pat, object_sym_pe) ->
      E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer)
                 >>= fun (_, loaded_expected_sym_pat, loaded_expected_sym_pe) ->
      E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer)
                 >>= fun (_, expected_sym_pat, expected_sym_pe) ->
      E.wrapped_fresh_symbol (C.BTy_loaded oTy)
                 >>= fun (_, desired_sym_pat, desired_sym_pe) ->
      (* TODO: conversion? *)
      E.return begin
        Caux.mk_sseq_e
          (Caux.mk_tuple_pat [loaded_object_sym_pat
                             ;loaded_expected_sym_pat
                             ;desired_sym_pat])
          (Caux.mk_unseq_e [core_object_e
                           ;core_expected_e
                           ;core_desired_e])
          (Caux.mk_case_e (Caux.mk_tuple_pe [loaded_object_sym_pe
                                            ;loaded_expected_sym_pe])
              [ (Caux.mk_tuple_pat [Caux.mk_specified_pat object_sym_pat
                                   ;Caux.mk_specified_pat expected_sym_pat],
                 Caux.pcompare_exchange_weak
                    loc (Caux.mk_ail_ctype_pe (Ctype.Ctype [] (Ctype.unatomic_ ty1)))
                    object_sym_pe expected_sym_pe desired_sym_pe
                    mo_success mo_failure
                )
              ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded C.OTy_pointer
                                                ;C.BTy_loaded C.OTy_pointer]),
                 Caux.mk_pure_e
                   (Caux.mk_undef_pe loc Undefined.UB_unspecified_lvalue)
                )
              ]
          )
      end
     | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin (A.AilBlinux A.AilBLfence))) [order_e] ->
        let mo = translate_linux_memory_order order_e in
         E.return $
           C.Expr [] (C.Eaction (C.Paction C.Pos (C.Action loc () (C.LinuxFence mo))))
     | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin (A.AilBlinux A.AilBLread))) [lobject_e; order_e] ->
         (* TODO: remove code duplication *)
         let mo = translate_linux_memory_order order_e in
         let ref_ty = match ctype_of lobject_e with
           | Ctype.Ctype _ (Ctype.Pointer _ ref_ty) ->
               ref_ty
           | (*BISECT-IGNORE*) _ ->
               illTypedAil loc "AilEcall linux_read"
         end in
         self lobject_e  >>= fun lobject_core_e  ->
         E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (_, loaded_sym_pat, loaded_sym_pe) ->
         E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, object_sym_pat, object_sym_pe) ->
         E.return begin
           Caux.mk_sseq_e loaded_sym_pat lobject_core_e
             begin
               Caux.mk_case_e loaded_sym_pe
                 [ (Caux.mk_specified_pat object_sym_pat,
                    Caux.plinux_load loc (Caux.mk_ail_ctype_pe ref_ty) object_sym_pe mo)
                 ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                    Caux.mk_pure_e (Caux.mk_undef_pe loc Undefined.UB_unspecified_lvalue)) ]
             end
         end
      | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin (A.AilBlinux A.AilBLwrite))) [lobject_e; desired_e; order_e] ->
         let mo = translate_linux_memory_order order_e in
         let ref_ty = match ctype_of lobject_e with
           | Ctype.Ctype _ (Ctype.Pointer _ ref_ty) ->
               ref_ty
           | (*BISECT-IGNORE*) _ ->
               illTypedAil loc "AilEcall linux_write"
         end in
         let oTy = force_core_object_type_of_ctype (ctype_of desired_e) in
         self lobject_e >>= fun lobject_core_e  ->
         self desired_e >>= fun desired_core_e ->
         E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (_, loaded_sym_pat, loaded_sym_pe)   ->
         E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, object_sym_pat, object_sym_pe)   ->
         E.wrapped_fresh_symbol (C.BTy_loaded oTy)           >>= fun (_, desired_sym_pat, desired_sym_pe) ->
         E.return begin
           Caux.mk_sseq_e (Caux.mk_tuple_pat [loaded_sym_pat; desired_sym_pat])
             begin
               Caux.mk_unseq_e [lobject_core_e; desired_core_e]
             end
             begin
               Caux.mk_case_e loaded_sym_pe
                 [ (Caux.mk_specified_pat object_sym_pat,
                    Caux.plinux_store loc (Caux.mk_ail_ctype_pe ref_ty) object_sym_pe desired_sym_pe mo)
                 ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                    Caux.mk_pure_e (Caux.mk_undef_pe loc Undefined.UB_unspecified_lvalue)) ]
             end
         end
      | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin (A.AilBlinux A.AilBLrmw))) [lobject_e; desired_e; order_e] ->
         let mo = translate_linux_memory_order order_e in
         let ref_ty = match ctype_of lobject_e with
           | Ctype.Ctype _ (Ctype.Pointer _ ref_ty) ->
               ref_ty
           | (*BISECT-IGNORE*) _ ->
               illTypedAil loc "AilEcall linux_rmw"
         end in
         let oTy = force_core_object_type_of_ctype (ctype_of desired_e) in
         self lobject_e >>= fun lobject_core_e  ->
         self desired_e >>= fun desired_core_e ->
         E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (_, loaded_sym_pat, loaded_sym_pe)   ->
         E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, object_sym_pat, object_sym_pe)   ->
         E.wrapped_fresh_symbol (C.BTy_loaded oTy)           >>= fun (_, desired_sym_pat, desired_sym_pe) ->
         E.return begin
           Caux.mk_sseq_e (Caux.mk_tuple_pat [loaded_sym_pat; desired_sym_pat])
             begin
               Caux.mk_unseq_e [lobject_core_e; desired_core_e]
             end
             begin
               Caux.mk_case_e loaded_sym_pe
                 [ (Caux.mk_specified_pat object_sym_pat,
                    Caux.plinux_rmw loc (Caux.mk_ail_ctype_pe ref_ty) object_sym_pe desired_sym_pe mo)
                 ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                    Caux.mk_pure_e (Caux.mk_undef_pe loc Undefined.UB_unspecified_lvalue)) ]
             end
         end


      | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin A.AilBcopy_alloc_id)) [from_e; to_e] ->
          self from_e >>= fun from_e  ->
          self to_e   >>= fun to_e    ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun (_, loaded_from_sym_pat, loaded_from_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, object_from_sym_pat, object_from_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (_, loaded_to_sym_pat  , loaded_to_sym_pe  ) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, object_to_sym_pat  , object_to_sym_pe  ) ->
          E.return begin
            Caux.mk_sseq_e (Caux.mk_tuple_pat [loaded_from_sym_pat; loaded_to_sym_pat])
              begin
                Caux.mk_unseq_e [from_e; to_e]
              end
              begin
                Caux.mk_case_e (Caux.mk_tuple_pe [loaded_from_sym_pe; loaded_to_sym_pe])
                  [ ( Caux.mk_tuple_pat [Caux.mk_specified_pat object_from_sym_pat; Caux.mk_specified_pat object_to_sym_pat]
                    , Caux.mk_memop_e Mem_common.Copy_alloc_id [object_from_sym_pe; object_to_sym_pe] )
                  ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded C.OTy_integer; C.BTy_loaded C.OTy_pointer])
                    , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY "unspec, copy_alloc_id()"))) ]
              end
          end



(*
     | A.AilEcall (A.AnnotatedExpression _ _ (A.AilEbuiltin "atomic_compare_exchange_strong_explicit")) [object_e; expected_e; desired_e; order_success_e; order_failure_e] ->
         let mo_success = translate_memory_order order_success_e in
         let mo_failure = translate_memory_order order_failure_e in
         let ty = match ctype_of object_e with
           | Ctype.Pointer _ ty ->
               ty
           | _ ->
               error "Translation.translate_expression, AilEcall atomic_compare_exchange_strong_explicit: Ail type error"
         end in
         
         error "WIP: atomic_compare_exchange_strong_explicit"
(*
         E.fresh_symbol              >>= fun sym_object       ->
         E.fresh_symbol              >>= fun sym_expected_ptr ->
         E.fresh_symbol              >>= fun sym_expected_val ->
         E.fresh_symbol              >>= fun sym_desired      ->
         self object_e   >>= fun core_object_e    ->
         self expected_e >>= fun core_expected_e  ->
         self desired_e  >>= fun core_desired_e   ->
         E.return $
           (* TODO: weak or strong seq? *)
           C.Esseq [Just sym_object; Just sym_expected_ptr; Just sym_desired] (C.Eunseq [core_object_e; core_expected_e; core_desired_e])
             (C.Esseq [Just sym_expected_val] (Caux.pload loc (Caux.mk_ail_ctype_pe (Ctype.unatomic_ ty)) (C.PEsym sym_expected_ptr) Cmm.NA)
                (Caux.prmw loc (Caux.mk_ail_ctype_pe (Ctype.unatomic_ ty)) (C.PEsym sym_object) (C.PEsym sym_expected_val) (C.PEsym sym_desired)
                   mo_success mo_failure)
             )
*)

(*
             (C.Eaction (C.Paction C.Pos (C.Action loc ()
               (C.CompareExchangeStrong (Caux.mk_ail_ctype_pe ty) (C.PEsym sym_object) (C.PEsym sym_expected) (C.PEsym sym_desired) mo_success mo_failure))))
*)


      (* TODO:
           * (§6.5.2.2#6) since we don't support prototype-less functions, we don't do
                          "default argument promotions"
       *)

      | A.AilEcall (A.AnnotatedExpression _ _ (A.AilEident (Symbol.Symbol _ (Just "malloc")))) [e] ->
          self e >>= fun core_e ->
          E.fresh_typed_symbol true (ctype_of e) >>= fun sym_ty_e ->
          E.return $
            C.Esseq [Just sym_ty_e] core_e
              (C.Eaction (C.Paction C.Pos (C.Action loc () (
                C.Alloc (C.PEval (C.Vobject (C.OVinteger (Mem.alignof_ival Cty.unsigned_char)))) (C.PEsym sym_ty_e) (Symbol.PrefOther "malloc")
              ))))

*)

(* TODO ==> FUNCTION CALLS

  §6.5.2.2#6 is very stange, in particular this bit:
    
    "If the function is defined with a type that includes a prototype, and either the prototype ends with an ellipsis (, ...) or the types of the arguments after promotion are not compatible with the types of the parameters, the behavior is undefined."
    
    apparently this has to do with old-style function declaration which we don't
    support (doesn't even parse). So the elab doesn't need to do anything here ? (CHECK !!!)


TODO: check the prototype vs no prototype stufff (ARGGGGGG)

TODO: #9
*)
      (* LAST nov2016 *)
      | A.AilEcall e [] -> (* NOTE: if there are no arguments, we don't need all the temporary object creation stuff *)
          (* STD §6.5.2.2 *)
          let ret_ty = match ctype_of e with
            | Ctype.Ctype _ (Ctype.Pointer _ (Ctype.Ctype _ (Ctype.Function (_, ret_ty) params isVariadic))) ->
                if List.length params = 0 && (not isVariadic) then
                  ret_ty
                else
                  illTypedAil loc "AilEcall"
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "AilEcall"
          end in
          self e >>= fun core_e ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (fun_sym, fun_sym_pat, fun_sym_pe) ->
          E.wrapped_fresh_symbol C.BTy_ctype >>= fun (ret_sym, ret_sym_pat, ret_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_list C.BTy_ctype) >>= fun (params_sym, params_sym_pat, params_sym_pe) ->
          E.return $
            Caux.mk_sseq_e fun_sym_pat core_e
            (Caux.mk_sseq_e
              (Caux.mk_tuple_pat [ret_sym_pat; params_sym_pat; Caux.mk_empty_pat C.BTy_boolean; Caux.mk_empty_pat C.BTy_boolean])
              (Caux.mk_pure_e (Caux.mk_cfunction_pe fun_sym_pe))
              (Caux.mk_if_e_ [Annot.Anot_explode]
                (Caux.mk_op_pe C.OpEq (stdlib.mkcall_params_length params_sym_pe) (Caux.mk_integer_pe 0))
                (Caux.mk_if_e_ [Annot.Anot_explode]
                  (Caux.mk_are_compatible (Caux.mk_ail_ctype_pe ret_ty) ret_sym_pe)
                  (Caux.mk_ccall_e (Caux.mk_ail_ctype_pe (ctype_of e)) fun_sym_pe [])
                  (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#9" Undefined.UB041_function_not_compatible))
                )
                (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#6, sentence 3" Undefined.UB038_number_of_args))
              )
            )
      
      | A.AilEcall e es ->
          (* TODO: This is ignoring has_proto, §6.5.2.2#6 is not being considered! *)
          (* STD §6.5.2.2 *)
          let (expect_ret_ty, expect_params, expect_is_variadic) = match ctype_of e with
            | Ctype.Ctype _ (Ctype.Pointer _ (Ctype.Ctype _ (Ctype.Function (_, ret_ty) qs_tys is_variadic))) ->
                (ret_ty, qs_tys, is_variadic)
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "AilEcall"
          end in
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (fun_sym, fun_sym_pat, fun_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (call_sym, call_sym_pat, call_sym_pe) ->
          E.wrapped_fresh_symbol C.BTy_ctype >>= fun (ret_sym, ret_sym_pat, ret_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_list C.BTy_ctype) >>= fun (params_sym, params_sym_pat, params_sym_pe) ->
          E.wrapped_fresh_symbol C.BTy_boolean >>= fun (is_variadic_sym, is_variadic_sym_pat, is_variadic_sym_pe) ->
          E.wrapped_fresh_symbol C.BTy_boolean >>= fun (has_proto_sym, has_proto_sym_pat, has_proto_sym_pe) ->
          (* elaborate expression that denotes the called function *)
          self e >>= fun core_e ->
          (* symbolic names for the arguments temporary objects *)
          let n_args = List.length es in
          let arg_ptr_syms = mapi (fun i arg_e -> Symbol.fresh_funarg (locOf arg_e) i) es in
          let arg_ptr_sym_pats = match arg_ptr_syms with
            | [sym] -> Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer)
            | _ -> Caux.mk_tuple_pat $ List.map (fun sym -> Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer)) arg_ptr_syms
          end in
          let arg_ptr_sym_pes = List.map Caux.mk_sym_pe arg_ptr_syms in
          (* elaborate each argument *)
          E.foldlM (fun (arg_sym_pats, core_arg_es, args_info) arg_e ->
            let arg_bTy = C.BTy_loaded (force_core_object_type_of_ctype (ctype_of arg_e)) in
            E.wrapped_fresh_symbol arg_bTy >>= fun (_, arg_sym_pat, arg_sym_pe) ->
            self arg_e >>= fun core_arg_e ->
            E.return (arg_sym_pat :: arg_sym_pats, core_arg_e :: core_arg_es
                     , (ctype_of arg_e, Aaux.is_null_pointer_constant arg_e, arg_sym_pe) :: args_info)
          ) ([], [], []) es >>= fun (rev_arg_sym_pats, rev_core_arg_es, rev_args_info) ->
          (* create parameters and convert them *)
          let (args_info, variadic_args_info) = List.splitAt (List.length expect_params) (List.reverse rev_args_info) in
          (* standard arguments *)
          E.foldlM (fun (n, rev_core_creates) ((_, expect_param_ty, _), (arg_ty, arg_is_null, arg_sym_pe)) ->
            E.wrapped_fresh_symbol C.BTy_ctype >>= fun (param_ty_sym, param_ty_sym_pat, param_ty_sym_pe) ->
            E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, arg_ptr_sym_pat, arg_ptr_sym_pe) ->
            E.return $
              (n+1,
                (Caux.mk_let_e param_ty_sym_pat (stdlib.mkcall_params_nth params_sym_pe (Caux.mk_integer_pe n))
                (Caux.mk_if_e_ [Annot.Anot_explode]
                  (Caux.mk_not_pe (Caux.mk_are_compatible (Caux.mk_ail_ctype_pe expect_param_ty) param_ty_sym_pe))
                  (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#9" Undefined.UB041_function_not_compatible))
                  (let conv_value =
                      (* NOTE: since expected type is compatible with the parameter type, if one is an integer or
                        floating, the other one must also be an integer or floating (respectively) *)
                      if AilTypesAux.is_integer expect_param_ty then
                        if AilTypesAux.is_integer arg_ty then
                          stdlib.mkcall_conv_loaded_int_ param_ty_sym_pe arg_sym_pe
                        else
                          stdlib.mkcall_loaded_ivfromfloat_ param_ty_sym_pe arg_sym_pe
                      else if AilTypesAux.is_floating expect_param_ty then
                        if AilTypesAux.is_integer arg_ty then
                          stdlib.mkcall_loaded_fvfromint_ param_ty_sym_pe arg_sym_pe
                        else
                          arg_sym_pe
                      else if AilTypesAux.is_pointer expect_param_ty && arg_is_null then (*TODO: probably not completely right*)
                        Caux.mk_specified_pe (Caux.mk_nullptr_pe expect_param_ty)
                      else
                        arg_sym_pe in
                  let mo =
                    if AilTypesAux.is_atomic expect_param_ty then
                      (* STD §6.2.6.1#9 *)
                      Cmm.Seq_cst
                    else
                      Cmm.NA in
                    (Caux.add_std "§6.5.2.2#7, sentence 1"
                      (Caux.mk_wseq_e arg_ptr_sym_pat
                        (Caux.pcreate loc (Caux.mk_alignof_pe param_ty_sym_pe) param_ty_sym_pe (Symbol.PrefFunArg loc (Symbol.digest ()) (intFromInteger n)))
                        (Caux.mk_wseq_e (Caux.mk_empty_pat C.BTy_unit)
                          (Caux.pstore loc param_ty_sym_pe arg_ptr_sym_pe conv_value mo)
                          (Caux.mk_pure_e arg_ptr_sym_pe)
                        )
                      )
                    )
                  )
                )) :: rev_core_creates
              )
          ) (0,[]) (List.zip expect_params args_info) >>= fun (_, rev_core_creates) ->
          (* variadic arguments *)
          E.foldlM (fun (rev_arg_tys, rev_arg_ty_pes, rev_variadic_core_creates) (arg_ty, arg_is_null, arg_sym_pe) ->
            let (conv_ty, conv_value) =
              if AilTypesAux.is_integer arg_ty then
                let prom_ty = fromJust "translation: default arguments promotion" (AilTypesAux.promotion integerImpl arg_ty) in
                (prom_ty, stdlib.mkcall_conv_loaded_int prom_ty arg_sym_pe)
              else if AilTypesAux.is_floating arg_ty then
                (Ctype.Ctype [] (Ctype.Basic (Ctype.Floating (Ctype.RealFloating Ctype.Double))), arg_sym_pe) (* TODO: convert this to double *)
              else (* TODO: should I add the case for pointers as well? *)
                (arg_ty, arg_sym_pe)
            in E.return ( conv_ty :: rev_arg_tys
                        , Caux.mk_ail_ctype_pe conv_ty :: rev_arg_ty_pes
                        , (Caux.add_std "§6.5.2.2#7, sentences 2 and 3" $
                            stdlib.mkproc_create_and_store (Caux.mk_ail_ctype_pe conv_ty) conv_value
                          ) :: rev_variadic_core_creates)
          ) ([], [],[]) variadic_args_info >>= fun (rev_arg_tys, rev_arg_ty_pes, rev_variadic_core_creates) ->
          (* function call result *)
          let call_bTy = maybe C.BTy_unit C.BTy_loaded (Caux.core_object_type_of_ctype expect_ret_ty) in
          E.wrapped_fresh_symbol call_bTy >>= fun (call_ret_sym, call_ret_sym_pat, call_ret_sym_pe) ->
          (* kill temporary objects *)
          let killall_pat =
            if List.length arg_ptr_syms < 2 then
              Caux.mk_empty_pat C.BTy_unit
            else
              Caux.mk_empty_pat $ C.BTy_tuple (List.replicate (List.length arg_ptr_syms) C.BTy_unit)
          in
          (* STD (§6.5.2.2#10, sentence 1) says there is sequence "point after the
           evaluations of the function designator and the actual arguments but before
           the actual call." *)
          E.return $
            Caux.add_std "§6.5.2.2#10, sentence 1"
            (Caux.mk_wseq_e
              (Caux.mk_tuple_pat $
                (Caux.mk_tuple_pat [call_sym_pat; Caux.mk_tuple_pat [ret_sym_pat; params_sym_pat; is_variadic_sym_pat;
                                                                     has_proto_sym_pat]])
                :: (List.reverse rev_arg_sym_pats)
              )
              (Caux.add_std "§6.5.2.2#4, sentence 2" $
                Caux.mk_unseq_e
                (Caux.mk_sseq_e fun_sym_pat core_e
                  (Caux.mk_pure_e (Caux.mk_tuple_pe [fun_sym_pe; Caux.mk_cfunction_pe fun_sym_pe]))
                  :: (List.reverse rev_core_arg_es))
              )
begin if expect_is_variadic then
              (* check number of parameters *)
              (Caux.mk_if_e_ [Annot.Anot_explode]
                (Caux.mk_not_pe (Caux.mk_op_pe C.OpLe (stdlib.mkcall_params_length params_sym_pe)
                                                      (Caux.mk_integer_pe (integerFromNat n_args))))
                (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#6, sentence 3" Undefined.UB038_number_of_args))
                (* check if function types are compatible *)
                (Caux.mk_if_e_ [Annot.Anot_explode]
                  (Caux.mk_op_pe C.OpOr (Caux.mk_not_pe is_variadic_sym_pe)
                                 (Caux.mk_not_pe (Caux.mk_are_compatible (Caux.mk_ail_ctype_pe expect_ret_ty) ret_sym_pe)))
                  (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#9" Undefined.UB041_function_not_compatible))
                  (Caux.mk_sseq_e arg_ptr_sym_pats
                    (* create temporary object *)
                    (Caux.mk_unseq $ List.reverse rev_core_creates ++ List.reverse rev_variadic_core_creates)
                    (Caux.mk_sseq_e call_ret_sym_pat
                      (* do the function call *)
                      (Caux.mk_ccall_e (Caux.mk_ail_ctype_pe (ctype_of e)) call_sym_pe
                        (let (arg_pes, vararg_pes) = List.splitAt (List.length expect_params) arg_ptr_sym_pes in
                         let varargs_ty_pes =
                            List.map (fun (ty_pe, pe) -> Caux.mk_tuple_pe [ty_pe; pe])
                                     (List.zip (List.reverse rev_arg_ty_pes) vararg_pes) in
                         let varargs_ty_pes_type = 
                           C.BTy_tuple [C.BTy_ctype; (C.BTy_object C.OTy_pointer)] in
                         arg_pes ++ [Caux.mk_list_pe varargs_ty_pes_type varargs_ty_pes]
                        )
                      )
                      (Caux.mk_sseq_e killall_pat
                        (* kill temporary objects *)
                        (let arg_ptr_syms_tys =
                          List.zip arg_ptr_syms
                                   (List.map (fun (_, ty, _) -> ty) expect_params ++ List.reverse rev_arg_tys) in
                         Caux.mk_unseq (List.map (fun (sym,ct) -> Caux.pkill loc (C.Static ct) (Caux.mk_sym_pe sym)) arg_ptr_syms_tys))
                        (* return function call result *)
                        (Caux.mk_pure_e call_ret_sym_pe)
                      )
                    )
                  )
                )
              )
else
              (* check number of parameters *)
              (Caux.mk_if_e_ [Annot.Anot_explode]
                (Caux.mk_not_pe (Caux.mk_op_pe C.OpEq (stdlib.mkcall_params_length params_sym_pe)
                                                      (Caux.mk_integer_pe (integerFromNat n_args))))
                (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#6, sentence 3" Undefined.UB038_number_of_args))
                (* check if function types are compatible *)
                (Caux.mk_if_e_ [Annot.Anot_explode]
                  (Caux.mk_op_pe C.OpOr is_variadic_sym_pe
                                 (Caux.mk_not_pe (Caux.mk_are_compatible (Caux.mk_ail_ctype_pe expect_ret_ty) ret_sym_pe)))
                  (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#9" Undefined.UB041_function_not_compatible))
                  (Caux.mk_sseq_e arg_ptr_sym_pats
                    (* create temporary object *)
                    (Caux.mk_unseq $ List.reverse rev_core_creates)
                    (Caux.mk_sseq_e call_ret_sym_pat
                      (* do the function call *)
                      (Caux.mk_ccall_e (Caux.mk_ail_ctype_pe (ctype_of e)) call_sym_pe arg_ptr_sym_pes)
                      (Caux.mk_sseq_e killall_pat
                        (* kill temporary objects *)
                        (let arg_ptr_syms_tys = List.map (fun (sym, (_, ty, _)) -> (sym, ty)) (List.zip arg_ptr_syms expect_params) in
                         Caux.mk_unseq (List.map (fun (sym,ct) -> Caux.pkill loc (C.Static ct) (Caux.mk_sym_pe sym)) arg_ptr_syms_tys))
                        (* return function call result *)
                        (Caux.mk_pure_e call_ret_sym_pe)
                      )
                    )
                  )
                )
              )
end
            )
      
      | A.AilEassert e ->
          (* TODO: this is temporary *)
          (* TODO: should do something more sensible when the expression is unspecified *)
          let oTy = force_core_object_type_of_ctype (ctype_of e) in
          E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun (_, e_sym_pat    , e_sym_pe    ) ->
          E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun (_, obj_sym_pat  , obj_sym_pe  ) ->
          E.wrapped_fresh_symbol C.BTy_boolean      >>= fun (_, memop_sym_pat, memop_sym_pe) ->
          self e         >>= fun core_e  ->
          E.return $
            Caux.mk_sseq_e e_sym_pat core_e (
if AilTypesAux.is_arithmetic (ctype_of e) then
              let zero_pe =
                if AilTypesAux.is_integer (ctype_of e) then
                  Caux.mk_integer_pe 0
                else
                  Caux.mk_floating_value_pe Mem.zero_fval in
              Caux.mk_pure_e (
                Caux.mk_case_pe e_sym_pe
                  [ (Caux.mk_specified_pat obj_sym_pat,
                     Caux.mk_if_pe_ [Annot.Anot_explode] (Caux.mk_op_pe C.OpEq obj_sym_pe zero_pe)
                       (Caux.mk_error_pe "assert() failure" Caux.mk_unit_pe)
                      Caux.mk_unit_pe
                     )
                  ; (Caux.mk_empty_pat (C.BTy_loaded oTy),
                     Caux.mk_error_pe "assert() unspecified" Caux.mk_unit_pe) ]
              )
else (* is_pointer *)
              Caux.mk_case_e e_sym_pe
                [ (Caux.mk_specified_pat obj_sym_pat,
                   Caux.mk_wseq_e memop_sym_pat
                     (C.Expr [] (C.Ememop Mem_common.PtrEq [obj_sym_pe; Caux.mk_nullptr_pe Cty.void]))
                     begin
                       Caux.mk_pure_e begin
                         Caux.mk_if_pe_ [Annot.Anot_explode] memop_sym_pe
                           (Caux.mk_error_pe "assert() failure" Caux.mk_unit_pe)
                           Caux.mk_unit_pe
                       end
                     end)
                ; (Caux.mk_empty_pat (C.BTy_loaded oTy),
                   Caux.mk_pure_e (Caux.mk_error_pe "assert() unspecified" Caux.mk_unit_pe)) ]
            )
      | A.AilEoffsetof ty membr_ident ->
          let tag_sym = match ty with
            | Ctype.Ctype _ (Ctype.Struct x) ->
                x
            | Ctype.Ctype _ (Ctype.Union x) ->
                x
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "AilEoffsetof"
          end in
          E.return $
            Caux.mk_pure_e (C.Pexpr [] () (C.PEval (C.Vloaded
              (C.LVspecified (C.OVinteger (Mem.offsetof_ival tagDefs tag_sym membr_ident))))))
      
      | A.AilEgeneric _ _ ->
          error ((Loc.stringFromLocation (Loc.locOf a_expr)) ^ ": C11 generics not yet supported")
      
      | A.AilEarray _ _ e_opts ->
          let elem_ty = match result_ty with
            | Ctype.Ctype _ (Ctype.Array ty _) ->
                ty
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "AilEarray"
          end in
          E.foldlM (fun (acc, mk_expr) e_opt ->
             match e_opt with
               | Just e ->
                   let e_sym = Symbol.fresh () in
                   self e >>= fun core_e ->
                   let bTy =
                     C.BTy_loaded (force_core_object_type_of_ctype (ctype_of e)) in
                   let elem_pe =
                     if AilTypesAux.is_pointer elem_ty && Aaux.is_null_pointer_constant e then
                       (* the member is a null pointer constant *)
                       match elem_ty with
                         | Cty.Ctype _ (Cty.Pointer _ ref_ty) ->
                             Caux.mk_specified_pe (Caux.mk_nullptr_pe ref_ty)
                         | (*BISECT-IGNORE*) _ ->
                             illTypedAil loc "AilEarray, Just null_pointer_constant"
                       end
                     (* TODO: check + std quote *)
                     else if AilTypesAux.is_arithmetic elem_ty && AilTypesAux.is_arithmetic (ctype_of e) then
                       conv_loaded_arith stdlib (ctype_of e) elem_ty (Caux.mk_sym_pe e_sym)
                     else
                       (* TODO: other conversions? *)
                       Caux.mk_sym_pe e_sym in 
                   E.return
                     (elem_pe :: acc, (Caux.mk_wseq_e (Caux.mk_sym_pat e_sym bTy) core_e) -| mk_expr)
               | Nothing ->
                   E.return
                     (Caux.mk_unspecified_pe elem_ty :: acc, mk_expr)
             end
          ) ([], id) e_opts >>= fun (rev_pes, mk_expr) ->
          E.return $
             mk_expr (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_array_pe (List.reverse rev_pes))))
      
      | A.AilEstruct tag_sym ident_e_opts ->
          (* TODO(check) ignoring the potential flexible array member, because it should not be part of a struct as value *)
          let ident_tys = match Map.lookup tag_sym tagDefs with
            | Just (Cty.StructDef z _) ->
                z
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "AilEstruct"
          end in
          E.foldlM (fun (acc, mk_core) (ident, e_opt) ->
            match e_opt with
              | Just e ->
                  let (_, _, memb_ty) = fromJust "Translation.translate_expression, AilEstruct 2" $ List.lookup ident ident_tys in
                  let oTy = force_core_object_type_of_ctype memb_ty in
                  begin
                    if AilTypesAux.is_pointer memb_ty && Aaux.is_null_pointer_constant e then
                      (* the member is a null pointer constant *)
                      match memb_ty with
                        | Cty.Ctype _ (Cty.Pointer _ ref_ty) ->
                            E.return (
                              (ident, Caux.mk_specified_pe (Caux.mk_nullptr_pe ref_ty)) :: acc,
                              mk_core
                            )
                        | (*BISECT-IGNORE*) _ ->
                            illTypedAil loc "AilEstruct, Just null_pointer_constant"
                      end
                    else
                      E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun (_, e_sym_pat, e_sym_pe) ->
                      self e                                    >>= fun core_e                   ->
                      E.return (
                        ( ident,
                          if AilTypesAux.is_integer memb_ty then
                            stdlib.mkcall_conv_loaded_int memb_ty e_sym_pe
                          else
                            e_sym_pe ) :: acc ,
                        fun z -> Caux.mk_sseq_e e_sym_pat core_e (mk_core z)
                      )
                  end
              | Nothing ->
                  let (_, _, ty) = fromJust "Translation.translate_expression, AilEstruct 3" $ List.lookup ident ident_tys in
                  E.return (
                    (ident, Caux.mk_unspecified_pe ty) :: acc,
                    mk_core
                  )
            end
          ) ([], fun z -> z) ident_e_opts >>= fun (core_xs_rev, mk_core) ->
          E.return $
            mk_core (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_struct_pe tag_sym (List.reverse core_xs_rev))))
      
      | A.AilEcompound qs ty e ->
          (* TODO: only using weak sequencing for now, not sure about this *)
          (* TODO: what if the type is atomic? *)
          let core_ty = Caux.mk_ail_ctype_pe ty in
          let oTy = force_core_object_type_of_ctype (ctype_of e) in
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, obj_sym_pat, obj_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun (e_sym, e_sym_pat, e_sym_pe) ->
          self e >>= fun core_e ->
          let () = Debug.print_debug 1 [] (fun () ->
             "TODO!!!! the lifetime of block scoped AilEcompound ends with the block (right now there is no kill)"
          ) in
          (* STD §6.5.2.5#3 *)
          E.return begin
            Caux.mk_wseq_e obj_sym_pat
              (* TODO: if qs has const, we must probably use a create_readonly *)
              (Caux.pcreate loc (Caux.mk_alignof_pe core_ty) core_ty (Symbol.PrefCompoundLiteral (locOf e) (Symbol.digest_of_sym e_sym))) begin
            (* TODO: probably needs a conversion *)
            Caux.mk_wseq_e e_sym_pat core_e begin
            Caux.mk_wseq_e (Caux.mk_empty_pat C.BTy_unit) (Caux.pstore loc core_ty obj_sym_pe e_sym_pe Cmm.NA) begin
              (* STD §6.5.2.5#5, sentence 1 *)
              Caux.mk_pure_e obj_sym_pe
            end end end
          end
      
      | A.AilEunion tag_sym memb_ident e_opt ->
          match Map.lookup tag_sym tagDefs with
            | (*BISECT-IGNORE*) Nothing ->
                illTypedAil loc "AilEunion: couldn't find the definition"
            | (*BISECT-IGNORE*) Just (Cty.StructDef _ _) ->
                illTypedAil loc "AilEunion: found a struct definition"
            | Just (Cty.UnionDef ident_tys) ->
                match List.lookup memb_ident ident_tys with
                  | (*BISECT-IGNORE*) Nothing ->
                      illTypedAil loc "AilEunion: couldn't find a union definition"
                  | Just (_, _, memb_ty) ->
                      let oTy = force_core_object_type_of_ctype memb_ty in
                      match e_opt with
                        | Nothing ->
                            E.return (
                              Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_union_pe tag_sym memb_ident (Caux.mk_unspecified_pe memb_ty)))
                            )
                        | Just e ->
                            E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun (_, e_sym_pat, e_sym_pe) ->
                            self e                                    >>= fun core_e                   ->
                            E.return $
                              Caux.mk_wseq_e e_sym_pat core_e (
                                Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_union_pe tag_sym memb_ident e_sym_pe))
                              )
                            
                      end
                 end
          end
      
(* TODO: atomic undef *)
      | A.AilEmemberof e ident ->
          (* STD §6.5.2.3 *)
          let (tag_sym, oTy) = match ctype_of e with
            | Ctype.Ctype _ (Ctype.Struct tag_sym) ->
                (tag_sym, C.OTy_struct tag_sym)
            | Ctype.Ctype _ (Ctype.Atomic (Ctype.Ctype _ (Ctype.Struct tag_sym))) ->
                (tag_sym, C.OTy_struct tag_sym)
            | Ctype.Ctype _ (Ctype.Union tag_sym) ->
                (tag_sym, C.OTy_union tag_sym)
            | Ctype.Ctype _ (Ctype.Atomic (Ctype.Ctype _ (Ctype.Union tag_sym))) ->
                (tag_sym, C.OTy_union tag_sym)
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "AilEmemberof"
          end in
          E.wrapped_fresh_symbol (if is_lvalue then C.BTy_object C.OTy_pointer else C.BTy_loaded oTy) >>= fun (e_sym, e_sym_pat, e_sym_pe) ->
          self e >>= fun core_e ->
          
          if not is_lvalue then
             E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun (obj_sym, obj_sym_pat, obj_sym_pe) ->
             E.return begin
               Caux.mk_sseq_e e_sym_pat core_e begin
                 Caux.mk_pure_e begin
                   Caux.mk_case_pe e_sym_pe
                     [ ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                       , Caux.mk_undef_pe loc (Undefined.DUMMY "Elab, rvalue AilEmemberof (unspec)") ) (* TODO: better undef *) (* TODO: check with P *)
                     ; ( Caux.mk_specified_pat obj_sym_pat
                       , Caux.mk_memberof_pe tag_sym ident obj_sym_pe ) ]
                 end
               end
             end
          else
            E.return begin
              C.Expr [Annot.Astd "§6.5.2.3#3, sentence 2"] (
                C.Esseq e_sym_pat core_e (
begin if Global.has_strict_pointer_arith () || Global.is_CHERI () || Global.is_PNVI () then
                    (Caux.mk_memop_e (Mem_common.PtrMemberShift tag_sym ident) [e_sym_pe])
else
                    Caux.mk_pure_e (Caux.mk_member_shift_pe e_sym_pe tag_sym ident)
end
                )
              )
            end
      
      | A.AilEmemberofptr e ident ->
          (* STD §6.5.2.3 *)
          let (ref_ty, tag_sym) = match ctype_of e with
            | Ctype.Ctype _ (Ctype.Pointer _ (Ctype.Ctype _ (Ctype.Struct tag_sym) as ref_ty)) ->
                (ref_ty, tag_sym)
            | Ctype.Ctype _ (Ctype.Pointer _ (Ctype.Ctype _ (Ctype.Atomic (Ctype.Ctype _ (Ctype.Struct tag_sym))) as ref_ty)) ->
                (ref_ty, tag_sym)
            | Ctype.Ctype _ (Ctype.Pointer _ (Ctype.Ctype _ (Ctype.Union tag_sym) as ref_ty))  ->
                (ref_ty, tag_sym)
            | Ctype.Ctype _ (Ctype.Pointer _ (Ctype.Ctype _ (Ctype.Atomic (Ctype.Ctype _ (Ctype.Union tag_sym))) as ref_ty)) ->
                (ref_ty, tag_sym)
            | (*BISECT-IGNORE*) _ -> illTypedAil loc "AilEmemberofptr"
          end in
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (_      , e_sym_pat   , e_sym_pe   ) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_      , obj_sym_pat , obj_sym_pe ) ->
          E.wrapped_fresh_symbol C.BTy_boolean                >>= fun (_      , test_sym_pat, test_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (res_sym, res_sym_pat , res_sym_pe ) ->
          self e >>= fun core_e ->
          E.return begin
            Caux.add_std "§6.5.2.3#4, sentence 2" $
              Caux.mk_sseq_e e_sym_pat core_e begin
                Caux.mk_case_e e_sym_pe
                  [ ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                    , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY "Elab, AilEmemberofptr")) ) (* TODO: better undef *)
                  ; ( Caux.mk_specified_pat obj_sym_pat
                    , if Global.has_strict_pointer_arith () || Global.is_CHERI () then
                        Caux.mk_wseq_e test_sym_pat
                          (Caux.mk_memop_e Mem_common.PtrValidForDeref [Caux.mk_ail_ctype_pe ref_ty; obj_sym_pe])
                      begin if Global.is_CHERI () then
                        Caux.mk_if_e test_sym_pe
                          begin
                            Caux.mk_wseq_e res_sym_pat
                              (Caux.mk_memop_e (Mem_common.PtrMemberShift tag_sym ident) [obj_sym_pe])
                              (Caux.mk_pure_e res_sym_pe)
                          end
                          (* TODO: make a new UB for this particular case *)
                          (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.3.3#4, sentence 4" Undefined.UB043_indirection_invalid_value))
                          
                      else
                          begin
                            Caux.mk_pure_e begin
                              Caux.mk_if_pe_ [Annot.Anot_explode] test_sym_pe
                                (Caux.mk_member_shift_pe obj_sym_pe tag_sym ident)
                                (* TODO: make a new UB for this particular case *)
                                (Caux.mk_std_undef_pe loc "§6.5.3.3#4, sentence 4" Undefined.UB043_indirection_invalid_value)
                            end
                          end
                      end
                      else
                        (* NON-ISO: allowing member_shift on "invalid pointer values" *)
                        Caux.mk_pure_e (Caux.mk_member_shift_pe obj_sym_pe tag_sym ident) ) ]
              end
          end
      
      | A.AilEconst cst ->
          E.return (Caux.mk_pure_e (translate_constant cst))
      
      | A.AilEbuiltin b ->
        match b with
          | A.AilBatomic _ ->
            error ((Loc.stringFromLocation (Loc.with_cursor loc)) ^ ": atomic builtins must be directly called")
          | A.AilBlinux _ ->
            error ((Loc.stringFromLocation (Loc.with_cursor loc)) ^ ": atomic linux builtins must be directly called")
          | A.AilBcopy_alloc_id ->
            error ((Loc.stringFromLocation (Loc.with_cursor loc)) ^ ": copy_alloc_id() must be directly called")
          (* NOTE: other builtins might be legally desugared here *)
        end
      
      (* TODO: prefix + check, §6.4.5#6 *)
      | A.AilEstr (pref_opt, strs) ->
          let strs = List.concat (List.map snd strs) in (* FIXME *)
          let elem_ty = match pref_opt with
            | Nothing ->
                (* STD §6.4.5#6, sentence 3 *)
                Cty.char
            | Just A.Enc_u8 ->
                (* STD §6.4.5#6, sentence 4 *)
                Cty.char
            | Just A.Enc_u ->
                (* STD §6.4.5#6, sentence 6 *)
                Cty.char16_t
            | Just A.Enc_U ->
                (* STD §6.4.5#6, sentence 6 *)
                Cty.char32_t
            | Just A.Enc_L ->
                (* STD §6.4.5#6, sentence 5 *)
                Cty.wchar_t
          end in
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (lit_sym, _, lit_sym_pe) ->
          (* TODO: making an implementation fix here (ASCII), not doing prefix properly *)
(*
          let elem_lvals = List.map (fun c_str ->
            C.LVspecified (C.OVinteger (Mem.integer_ival (Decode.decode_character_constant c_str)))
          ) strs ++ [C.LVspecified (C.OVinteger (Mem.integer_ival 0))] in
          E.register_string_literal loc lit_sym (Cty.Array elem_ty (Just (integerFromNat $ List.length elem_lvals)))
            (C.Pexpr [] () (C.PEval (C.Vloaded (C.LVspecified (C.OVarray elem_lvals))))) >>
*)
          (* TODO(check): here we convert the string elements to the type of the array *)
          let elem_pes = List.map (fun c_str ->
             Caux.mk_specified_pe (
               stdlib.mkcall_conv_int elem_ty
                 (Caux.mk_integer_pe (Decode.decode_character_constant c_str))
             )
          ) strs ++ [Caux.mk_specified_pe (Caux.mk_integer_pe 0)] in
          E.register_string_literal loc lit_sym (Cty.Ctype [] (Cty.Array elem_ty (Just (integerFromNat $ List.length elem_pes))))
            (Caux.mk_specified_pe (Caux.mk_array_pe elem_pes))  >>
          E.return (
            Caux.mk_pure_e lit_sym_pe
          )
(*

(*

n := | str |

let strong a  = create("char[n+1]", <alignof>("char[n+1]")) in
store("char[n+1]", a, array(...)) ;
a


          E.return (C.Econst $ C.Cstring (String.toCharList str)) (* TODO: this is a hack, this should be a pointer to a global char pointer *)
*)
      
      
*)
      | A.AilEsizeof _ (Ctype.Ctype _ (Ctype.Basic (Ctype.Integer Ctype.Char))) ->
          E.return begin
            C.Expr [Annot.Astd "§6.5.3.4#4, sentence 1"] (
              C.Epure (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
            )
          end
      | A.AilEsizeof _ (Ctype.Ctype _ (Ctype.Basic (Ctype.Integer (Ctype.Signed Ctype.Ichar)))) ->
          E.return begin
            C.Expr [Annot.Astd "§6.5.3.4#4, sentence 1"] (
              C.Epure (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
            )
          end
      | A.AilEsizeof _ (Ctype.Ctype _ (Ctype.Basic (Ctype.Integer (Ctype.Unsigned Ctype.Ichar)))) ->
          E.return begin
            C.Expr [Annot.Astd "§6.5.3.4#4, sentence 1"] (
              C.Epure (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
            )
          end
      | A.AilEsizeof _ ty ->
          E.return begin
            Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_sizeof_pe (Caux.mk_ail_ctype_pe ty)))
          end
      
      | A.AilEsizeof_expr e ->
          (* TODO: check qualifiers *)
          self (A.AnnotatedExpression annot std_annots loc (A.AilEsizeof Ctype.no_qualifiers (ctype_of e)))
      
      | A.AilEalignof _ ty ->
          E.return begin
            Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_alignof_pe $ Caux.mk_ail_ctype_pe ty))
          end
      
      | A.AilEannot _ e ->
          self e
      
      | A.AilEva_start _ last_sym ->
          let (variadic_sym, last_arg_sym) =
            match variadic_env with
            | (Just var_sym, Just last_sym) -> (var_sym, last_sym)
            | _ -> error ((Loc.stringFromLocation (Loc.locOf a_expr)) ^ ": va_start not in a variadic function")
            end in
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, va_sym_pat, va_sym_pe ) ->
          E.return $
            if last_sym = last_arg_sym then
              Caux.mk_sseq_e va_sym_pat (C.Expr [] (C.Ememop Mem_common.Va_start [Caux.mk_sym_pe variadic_sym]))
                (Caux.mk_pure_e (Caux.mk_specified_pe va_sym_pe))
            else
              error ((Loc.stringFromLocation (Loc.locOf a_expr)) ^ " : " ^ show last_sym ^ " is not the last argument") (* it should be UB I think *)
      
      | A.AilEva_copy _ e ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun (_, e_sym_pat, e_sym_pe ) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, case_sym_pat, case_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, va_sym_pat, va_sym_pe ) ->
          self e >>= fun core_e ->
          E.return $
            Caux.mk_sseq_e e_sym_pat core_e
              (Caux.mk_case_e e_sym_pe
                [ (Caux.mk_specified_pat case_sym_pat,
                    Caux.mk_sseq_e va_sym_pat (C.Expr [] (C.Ememop Mem_common.Va_copy [case_sym_pe]))
                      (Caux.mk_pure_e (Caux.mk_specified_pe va_sym_pe)))
                ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                    Caux.mk_pure_e (Caux.mk_undef_exceptional_condition loc)) ] )
      
      | A.AilEva_arg e ty ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun (_, e_sym_pat, e_sym_pe ) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, ptr_sym_pat, ptr_sym_pe ) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, case_sym_pat, case_sym_pe) ->
          self e >>= fun core_e ->
          E.return $
            Caux.mk_sseq_e e_sym_pat core_e
              (Caux.mk_sseq_e ptr_sym_pat
                (Caux.mk_case_e e_sym_pe
                  [ (Caux.mk_specified_pat case_sym_pat,
                      (C.Expr [] (C.Ememop Mem_common.Va_arg [case_sym_pe; Caux.mk_ail_ctype_pe ty])))
                  ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                      Caux.mk_pure_e (Caux.mk_undef_exceptional_condition loc)) ] )
                (Caux.pload loc (Caux.mk_ail_ctype_pe ty) ptr_sym_pe Cmm.NA))
      
      | A.AilEva_end e ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun (_, e_sym_pat, e_sym_pe ) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, case_sym_pat, case_sym_pe) ->
          self e >>= fun core_e ->
          E.return $
            Caux.mk_sseq_e e_sym_pat core_e
              (Caux.mk_case_e e_sym_pe
                [ (Caux.mk_specified_pat case_sym_pat,
                    (C.Expr [] (C.Ememop Mem_common.Va_end [case_sym_pe])))
                ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                    Caux.mk_pure_e (Caux.mk_undef_exceptional_condition loc)) ] )
      
      | A.AilEprint_type e ->
          let (qs, ty) = qualified_ctype_of e in
          let () = Debug.print_debug 1 [] (fun () ->
            "PRINT_TYPE: " ^ Loc.stringFromLocation loc ^ " -- " ^ Pp.stringFromAil_ctype qs ty
          ) in
          self e
      | A.AilEbmc_assume e ->
          let oTy = force_core_object_type_of_ctype (ctype_of e) in
          E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun (_, e_sym_pat    , e_sym_pe    ) ->
          E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun (_, obj_sym_pat  , obj_sym_pe  ) ->
          E.wrapped_fresh_symbol C.BTy_boolean      >>= fun (_, memop_sym_pat, memop_sym_pe) ->
          self e         >>= fun core_e  ->
          E.return $
            Caux.mk_sseq_e e_sym_pat core_e (
if AilTypesAux.is_arithmetic (ctype_of e) then
              let zero_pe =
                if AilTypesAux.is_integer (ctype_of e) then
                  Caux.mk_integer_pe 0
                else
                  Caux.mk_floating_value_pe Mem.zero_fval in
              Caux.mk_pure_e (
                Caux.mk_case_pe e_sym_pe
                  [ (Caux.mk_specified_pat obj_sym_pat,
                     (C.Pexpr [Annot.Aloc loc] () (C.PEbmc_assume (Caux.mk_not_pe
                          (Caux.mk_op_pe C.OpEq obj_sym_pe zero_pe)))))
                  ; (Caux.mk_empty_pat (C.BTy_loaded oTy),
                     Caux.mk_error_pe "__bmc_assume() unspecified" Caux.mk_unit_pe) ]
              )
else (* is_pointer *)
              Caux.mk_case_e e_sym_pe
                [ (Caux.mk_specified_pat obj_sym_pat,
                   Caux.mk_wseq_e memop_sym_pat
                     (C.Expr [] (C.Ememop Mem_common.PtrEq [obj_sym_pe; Caux.mk_nullptr_pe Cty.void]))
                     begin
                       Caux.mk_pure_e begin
                         (C.Pexpr [] () (C.PEbmc_assume (memop_sym_pe)))
                       end
                     end)
                ; (Caux.mk_empty_pat (C.BTy_loaded oTy),
                   Caux.mk_pure_e (Caux.mk_error_pe "__bmc_assume() unspecified" Caux.mk_unit_pe)) ]
            )

      | A.AilEreg_load r ->
          error "TODO: victor"

      
      | A.AilErvalue e ->
          let mo =
            if AilTypesAux.is_atomic (ctype_of e) then
              (* STD §6.2.6.1#9 *)
              Cmm.Seq_cst
            else
              Cmm.NA in
          (* TODO: check + I don't like have a wseq here *)
          self e >>= fun core_e ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer)
            >>= fun (_, e_sym_pat, e_sym_pe ) ->
          E.return (
            C.Expr [] (
              C.Ewseq ( (* Caux.mk_specified_pat *) e_sym_pat) core_e (
                Caux.pload loc (Caux.mk_ail_ctype_pe result_ty) e_sym_pe mo
              )
            )
          )
      | A.AilEarray_decay e ->
          match GenTypes.genTypeCategoryOf e with
            | GenTypes.GenLValueType _ _ _ ->
                (* by Ail typing, [e] is a lvalue. Hence the corresponding Core has a non-loaded type *)
                self e >>= fun core_e ->
                E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, e_sym_pat, e_sym_pe ) ->
                E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (res_sym, res_sym_pat, res_sym_pe) ->
                E.return (
                  Caux.mk_wseq_e e_sym_pat core_e (
                    match AilTypesAux.referenced_type result_ty with
                      | (*BISECT-IGNORE*) Nothing ->
                          illTypedAil loc "AilEarray_decay, result_ty not a pointer"
                      | Just ref_ty ->
                          C.Expr [Annot.Astd "§6.3.2.1#3"] (
if Global.has_strict_pointer_arith () || Global.is_CHERI () || Global.is_PNVI () then
                            C.Ewseq res_sym_pat
                            (C.Expr [] (C.Ememop Mem_common.PtrArrayShift [e_sym_pe; Caux.mk_ail_ctype_pe ref_ty; Caux.mk_integer_pe 0]))
                            (Caux.mk_pure_e (Caux.mk_specified_pe res_sym_pe))
else
                            C.Epure (
                              Caux.mk_specified_pe (Caux.mk_array_shift e_sym_pe
                                ref_ty (Caux.mk_integer_pe 0)
                              )
                            )
                          )
                    end
                  )
                )
            | GenTypes.GenRValueType _ ->
                error "TODO: AilEarray_decay, rvalue"
          end
      | A.AilEfunction_decay e ->
          translate_function_designator ctx variadic_env stdlib tagDefs e
      | A.AilEgcc_statement ->
          error ((Loc.stringFromLocation loc) ^ ": GCC statements as expressions not yet supported")
    end







(* translate_stmt Pmap.empty ail_sigma program.A.main C.Constants.return s *)

(* TODO[über HACK] `lasts' is the last of symbolic names saving the last statement for each block we are in
                   we need to remember them to annotate Erun/Esave coming from a C label/goto because these symbols
                   MAY (the fact it is a may is pretty disgusting) be in the continuations of the generated Esave (...)

RAAAAAAAAHHH: this doesn't work when the label is in a block the goto doesn't belong to ......
*)

module St = State
let inline (>>=) = St.bind
let inline (>>) m1 m2 = St.bind m1 (fun _ -> m2)
let inline (<$>) = State.fmap
let inline (<*>) = State.app

type collect_cases_state = <|
  found_default: bool;
  case_csts: list A.integerConstant;
|>

val     collect_cases_: A.statement GenTypes.genTypeCategory -> St.stateM unit collect_cases_state
let rec collect_cases_ (A.AnnotatedStatement loc _ stmt) =
  let register_case ic_n =
    St.update (fun s -> <| s with case_csts= ic_n :: s.case_csts |>) in
  let register_default =
    St.update (fun s -> <| s with found_default= true |>) in
  match stmt with
    | A.AilSskip ->
        St.return ()
    | A.AilSexpr _ ->
        St.return ()
    | A.AilSblock binds ss ->
        St.mapM_ collect_cases_ ss
    | A.AilSif _ s1 s2 ->
        collect_cases_ s1 >> collect_cases_ s2
    | A.AilSwhile _ s _ ->
        collect_cases_ s
    | A.AilSdo s _ _ ->
        collect_cases_ s
    | A.AilSbreak ->
        St.return ()
    | A.AilScontinue ->
        St.return ()
    | A.AilSreturnVoid ->
        St.return ()
    | A.AilSreturn _ ->
        St.return ()
    | A.AilSswitch _ _ ->
        St.return ()
    | A.AilScase ic_n s ->
        register_case ic_n >> collect_cases_ s
    | A.AilSdefault s ->
        register_default >> collect_cases_ s
    | A.AilSlabel _ s _ ->
        collect_cases_ s
    | A.AilSgoto _ ->
        St.return ()
    | A.AilSdeclaration _ ->
        St.return ()
    | A.AilSpar ss ->
        (* TODO: check *)
        St.mapM_ collect_cases_ ss
    | A.AilSreg_store _ _ ->
        St.return ()
    | A.AilSpack _ _ ->
        St.return ()
    | A.AilSunpack _ _ ->
        St.return ()
    | A.AilShave _ _ ->
        St.return ()
    | A.AilSshow _ _ ->
        St.return ()
  end
let collect_cases s =
  snd $ St.runStateM (collect_cases_ s) <| found_default= false; case_csts= [] |>


type collect_visibles_state = <|
  visible_syms: list (Symbol.sym * Ctype.ctype);
  label_visibles_: map Symbol.sym (list (Symbol.sym * Ctype.ctype));
|>



type erase_loop_control_state = <|
  elc_continue: maybe Symbol.sym;
  elc_break: maybe Symbol.sym;
|>

val     erase_loop_control_aux: A.statement GenTypes.genTypeCategory -> St.stateM (A.statement GenTypes.genTypeCategory) erase_loop_control_state
let rec erase_loop_control_aux (A.AnnotatedStatement loc attrs stmt_) =
  let with_fresh_labels mf =
    fun st ->
      let continue_sym = Symbol.fresh_pretty_with_id (fun x -> "continue_" ^ show x) in
      let break_sym    = Symbol.fresh_pretty_with_id (fun x -> "break_" ^ show x) in
      let (ret, st')   = mf <| elc_continue= Just continue_sym; elc_break= Just break_sym |> in
      ((continue_sym, break_sym, ret), st) in 
  A.AnnotatedStatement loc attrs <$> match stmt_ with
    | A.AilSskip ->
        St.return stmt_
    | A.AilSexpr _ ->
        St.return stmt_
    | A.AilSblock binds ss ->
        A.AilSblock binds <$> St.mapM erase_loop_control_aux ss
    | A.AilSif e s1 s2 ->
        A.AilSif e <$> erase_loop_control_aux s1 <*> erase_loop_control_aux s2
    | A.AilSwhile e s loop_id ->
        (* STD §6.8.6.2#2 and §6.8.6.3#2 *)
        with_fresh_labels (erase_loop_control_aux s) >>= fun (continue_sym, break_sym, s') ->
        St.return $
          A.AilSblock []
            [ A.AnnotatedStatement loc Annot.no_attributes (A.AilSwhile e (A.AnnotatedStatement loc Annot.no_attributes (A.AilSblock []
                [s'; A.AnnotatedStatement loc Annot.no_attributes (A.AilSlabel continue_sym (A.AnnotatedStatement loc Annot.no_attributes A.AilSskip) (Just (Annot.LAloop_continue loop_id)))])) loop_id)
            ; A.AnnotatedStatement loc Annot.no_attributes (A.AilSlabel break_sym (A.AnnotatedStatement loc Annot.no_attributes A.AilSskip) (Just (Annot.LAloop_break loop_id))) ]

    | A.AilSdo s e loop_id ->
        (* STD §6.8.6.2#2 and §6.8.6.3#2 *)
        with_fresh_labels (erase_loop_control_aux s) >>= fun (continue_sym, break_sym, s') ->
        St.return $
          A.AilSblock []
            [ A.AnnotatedStatement loc Annot.no_attributes (A.AilSdo (A.AnnotatedStatement loc Annot.no_attributes (A.AilSblock []
                [s'; A.AnnotatedStatement loc Annot.no_attributes (A.AilSlabel continue_sym (A.AnnotatedStatement loc Annot.no_attributes A.AilSskip) (Just (Annot.LAloop_continue loop_id)))])) e loop_id)
            ; A.AnnotatedStatement loc Annot.no_attributes (A.AilSlabel break_sym (A.AnnotatedStatement loc Annot.no_attributes A.AilSskip) (Just (Annot.LAloop_break loop_id))) ]
    | A.AilSbreak ->
        St.get >>= function
          | <| elc_break= Just break_sym |> ->
             St.return (A.AilSgoto break_sym)
          | (*BISECT-IGNORE*) _ ->
              illTypedAil loc "AilSbreak"
        end
    | A.AilScontinue ->
        St.get >>= function
          | <| elc_continue= Just continue_sym |> ->
             St.return (A.AilSgoto continue_sym)
          | (*BISECT-IGNORE*) _ ->
              illTypedAil loc "AilScontinue"
        end
    | A.AilSreturnVoid ->
        St.return stmt_
    | A.AilSreturn _ ->
        St.return stmt_
    | A.AilSswitch e s ->
        with_fresh_labels (erase_loop_control_aux s) >>= fun (_, break_sym, s') ->
        St.return $
          A.AilSblock []
            [ A.AnnotatedStatement loc Annot.no_attributes (A.AilSswitch e (A.AnnotatedStatement loc Annot.no_attributes (A.AilSblock []
                [ A.AnnotatedStatement loc Annot.no_attributes (A.AilSgoto break_sym); s' ])))
            ; A.AnnotatedStatement loc Annot.no_attributes (A.AilSlabel break_sym (A.AnnotatedStatement loc Annot.no_attributes A.AilSskip) (Just Annot.LAswitch)) ]
    | A.AilScase iCst s ->
        A.AilScase iCst <$> erase_loop_control_aux s
    | A.AilSdefault s ->
        A.AilSdefault <$> erase_loop_control_aux s
        (* TODO: not sure about this
        error "WIP: erase_loop_control_aux, AilSdefault" *)
    | A.AilSlabel sym s m_loop_annot ->
        erase_loop_control_aux s >>= fun s ->
        St.return $ A.AilSlabel sym s m_loop_annot
    | A.AilSgoto _ ->
        St.return stmt_
    | A.AilSdeclaration _ ->
        St.return stmt_
    | A.AilSpar ss ->
        A.AilSpar <$> St.mapM erase_loop_control_aux ss
    | A.AilSreg_store _ _ ->
        St.return stmt_
    | A.AilSpack _ _ ->
        St.return stmt_
    | A.AilSunpack _ _ ->
        St.return stmt_
    | A.AilShave _ _ ->
        St.return stmt_
    | A.AilSshow _ _ ->
        St.return stmt_
  end


let erase_loop_control stmt =
  let (stmt', _) = State.runStateM (erase_loop_control_aux stmt) <|
    elc_continue= Nothing;
    elc_break= Nothing;
  |> in stmt'



val     collect_visibles_: A.statement GenTypes.genTypeCategory -> St.stateM unit collect_visibles_state
let rec collect_visibles_ (A.AnnotatedStatement loc _ stmt) =
  match stmt with
    | A.AilSskip ->
        St.return ()
    | A.AilSexpr _ ->
        St.return ()
    | A.AilSblock binds ss ->
        St.get >>= fun st ->
        let saved_syms = st.visible_syms in
        St.update (fun st ->
          <| st with visible_syms= List.map (fun (sym, (_, _, ty)) -> (sym ,ty)) binds ++ st.visible_syms |>
        ) >>
        St.mapM_ collect_visibles_ ss >>
        St.update (fun st ->
          <| st with visible_syms= saved_syms |>
        )
    | A.AilSif _ s1 s2 ->
        collect_visibles_ s1 >> collect_visibles_ s2
    | A.AilSwhile _ s _ ->
        collect_visibles_ s
    | A.AilSdo s _ _ ->
        collect_visibles_ s
    | A.AilSbreak ->
        St.return ()
    | A.AilScontinue ->
        St.return ()
    | A.AilSreturnVoid ->
        St.return ()
    | A.AilSreturn _ ->
        St.return ()
    | A.AilSswitch _ s ->
        collect_visibles_ s
    | A.AilScase _ s ->
        collect_visibles_ s
    | A.AilSdefault s ->
        collect_visibles_ s
    | A.AilSlabel label s _ ->
        St.update (fun st -> <| st with
          label_visibles_= Map.insert label st.visible_syms st.label_visibles_
        |>) >>
        collect_visibles_ s
    | A.AilSgoto label ->
        St.return ()
    | A.AilSdeclaration _ ->
        St.return ()
    | A.AilSpar ss ->
        (* TODO: check *)
        St.mapM_ collect_visibles_ ss
    | A.AilSreg_store _ _ ->
        St.return ()
    | A.AilSpack _ _ ->
        St.return ()
    | A.AilSunpack _ _ ->
        St.return ()
    | A.AilShave _ _ ->
        St.return ()
    | A.AilSshow _ _ ->
        St.return ()
  end

val collect_visibles: A.statement GenTypes.genTypeCategory -> collect_visibles_state
let collect_visibles stmt =
    snd $ State.runStateM (collect_visibles_ stmt) <|
      visible_syms= []
    ; label_visibles_= Map.empty |>





(* TODO: morally the kills and creates should be unseq() *)
val mk_run_e: Loc.t -> Symbol.sym -> list (Symbol.sym * Ctype.ctype) -> list (Symbol.sym * Ctype.ctype) -> list C.pexpr -> C.expr unit
let translation_mk_run_e loc sym visibles_before visibles_after pes =
  let killed_syms_tys =
    List.filter (fun (sym,_ty) ->
      Maybe.isNothing (List.lookup sym visibles_after)
    ) visibles_before in
  
  let mk_kills_e =
    Caux.mk_unit_sseq (
      List.map (fun (sym,ty) ->
        Caux.pkill loc (C.Static ty) (Caux.mk_sym_pe sym)
      ) killed_syms_tys
    ) in
  
  let created_sym_tys =
    List.filter (fun (sym, _) ->
      not (List.any (fun (sym',_) -> sym = sym') visibles_before)
    ) visibles_after in
  
  let mk_creates_e =
    Caux.mk_sseqs $
      List.map (fun (sym, ty) ->
        (C.Pattern [] (C.CaseBase (Just sym, C.BTy_object C.OTy_pointer)),
         let core_ty = Caux.mk_ail_ctype_pe ty in
         Caux.pcreate loc (Caux.mk_alignof_pe core_ty) core_ty (Symbol.PrefSource loc [(*f; *)sym]))
      ) created_sym_tys in
  mk_kills_e (mk_creates_e (Caux.mk_run_e sym ((List.map (fun (sym, _) -> Caux.mk_sym_pe sym) visibles_after) ++ pes)))
let inline mk_run_e = translation_mk_run_e


open Operators

type translate_stmt_env = <|
  return_ty: Ctype.ctype;
  is_Noreturn: bool;
  
  variadic_sym_opt: maybe Symbol.sym;
  last_arg_sym_opt: maybe Symbol.sym;

  return_lab  : Symbol.sym;
  default_lab : maybe Symbol.sym;
  case_labs   : list (A.integerConstant * Symbol.sym);
  
  (* The lists are the objects visible from the loop and break labels *)
  loop:  maybe (
             Symbol.sym (* loop continuation symbol *)
           * Symbol.sym (* continue continuation symbol *)
           * Symbol.sym (* break continuation symbol *)
           * list (Symbol.sym * Ctype.ctype)
  );
  break: maybe (Symbol.sym * list (Symbol.sym * Ctype.ctype));
  
  label_visibles: map Symbol.sym (list (Symbol.sym * Ctype.ctype));
|>


val translate_stmt:
  translation_stdlib ->
  C.core_tag_definitions ->
  A.ail_identifier ->
  translate_stmt_env ->
  A.statement GenTypes.genTypeCategory ->
  E.elabM (C.expr unit)

let rec translate_stmt stdlib tagDefs f env (A.AnnotatedStatement loc _ stmt) : E.elabM (C.expr unit) =
  let translate_expression = translate_expression ECTX_other (env.variadic_sym_opt, env.last_arg_sym_opt) stdlib tagDefs in
  let translate_cases_block case_labs default_lab =
    translate_stmt stdlib tagDefs f <| env with case_labs=   case_labs;
                                                default_lab= default_lab |>
  in
  let self = translate_stmt stdlib tagDefs f env in
  
  Caux.add_loc loc <$> match stmt with
    | A.AilSskip ->
        E.return Caux.mk_skip_e
    
    | A.AilSexpr e ->
        (* TODO: the indirection is a temporary hack in order to
           generate well typed core. The better solution would be to have the elab of AilSblock
           not always use the unit type in the bindings of the sseq operators. *)
        translate_expression e >>= fun core_e ->
        E.return (
          (* ASK: this annotation looks wrong!! is this really implementing 6.5#2 ? *)
          C.Expr [Annot.Astd "§6.5#2"] begin
            C.Esseq (Caux.mk_empty_pat (maybe C.BTy_unit C.BTy_loaded (Caux.core_object_type_of_ctype (ctype_of e))))
              (* TODO: Ebound index *)
              (C.Expr [] (C.Ebound 0 core_e))
              (Caux.mk_pure_e Caux.mk_unit_pe)
          end
        )
    
    | A.AilSblock [] ss ->
        E.mapM self ss >>= fun core_ss ->
        E.return (Caux.mk_unit_sseq core_ss Caux.mk_skip_e)
    
    | A.AilSblock [(sym, ((ident_loc, _, _), qs, ty))] ss ->
        let c_ty = Caux.mk_ail_ctype_pe ty in
        E.with_block_objects [(sym, (qs, ty))] $
          E.mapM self ss >>= fun core_ss ->
        let new_loc = Loc.with_cursor_from loc ident_loc in
        E.return begin
          Caux.mk_sseq_e (Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer))
             (Caux.pcreate new_loc (Caux.mk_alignof_pe c_ty) c_ty (Symbol.PrefSource ident_loc [f; sym])) (
            List.foldr (fun core_s acc ->
              Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit) core_s acc
            ) (Caux.pkill new_loc (C.Static ty) (Caux.mk_sym_pe sym)) core_ss
          )
        end
    
    | A.AilSblock binds ss ->
        let decls_with_loc = [ (sym, ident_loc, (qs, ty)) | forall ((sym, ((ident_loc, _, _), qs, ty)) MEM binds ) | true ] in
        let decls = List.map (fun (sym, _, qs_ty) -> (sym, qs_ty)) decls_with_loc in
        (* the symbolic names and create actions for the local variables *)
        let (pats, core_creates) : list C.pattern * list (C.expr unit) =
          mapUnzip (fun (sym, ident_loc, (qs, ty)) ->
            let c_ty = Caux.mk_ail_ctype_pe ty in
            ( Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer)
            , Caux.pcreate (Loc.with_cursor_from loc ident_loc) (Caux.mk_alignof_pe c_ty) c_ty (Symbol.PrefSource ident_loc [f; sym]) )
          ) decls_with_loc in
        E.with_block_objects decls $
          (* TODO: doing the kills here is now redundant if there is are returns before all exit point.
             but it may be nasty to do the check.
             For non-void function however we know (?) that their must be these returns ?? so we could drop the kills here *)
          (* the kill actions for the local variables *)
          let core_kills : list (C.expr unit) =
            List.map (fun (sym, ident_loc, ty) ->
              Caux.pkill (Loc.with_cursor_from loc ident_loc) (C.Static (snd ty)) (Caux.mk_sym_pe sym)
            ) decls_with_loc in
          E.mapM self ss >>= fun core_ss ->
        
        E.return (
          let () = Debug.warn [Debug.DB_elaboration] (fun () -> "Translation, AilSblock: sequencing the creates and kills") in
          Caux.mk_sseqs (List.zip pats core_creates) begin
            Caux.mk_unit_sseq (core_ss ++ core_kills)
              Caux.mk_skip_e
          end
        )
    
    | A.AilSif e s1 s2 ->
        E.wrapped_fresh_symbol C.BTy_boolean                >>= fun (_, do_then_sym_pat, do_then_sym_pe) ->
        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun (_, test_sym_pat, test_sym_pe)       ->
        E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, case_sym_pat, case_sym_pe)       ->
        translate_expression (mkTestExpression TestEq e)    >>= fun core_test                            ->
        self s1                                             >>= fun core_s1                              ->
        self s2                                             >>= fun core_s2                              ->
        (* NOTE: here we fix the strictness of unspecified values *)
        E.return begin
          (* NOTE: the case-of producing a boolean (instead of directly doing the control
             with the case) is to prevent possible combinatorial explosions of the generated Core code *)
          Caux.mk_sseq_e test_sym_pat core_test begin
            Caux.mk_sseq_e do_then_sym_pat begin
              Caux.mk_case_e test_sym_pe
                [ ( Caux.mk_specified_pat case_sym_pat
                  , Caux.mk_pure_e begin
                      Caux.mk_if_pe_ [Annot.Anot_explode] (Caux.mk_not_pe (Caux.mk_op_pe C.OpEq case_sym_pe (Caux.mk_integer_pe 1)))
                        (Caux.mk_boolean_pe true) (Caux.mk_boolean_pe false)
                    end )
                  (* non-deterministic branching if the test expression had unspecified value *)
                ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                  , Caux.mk_nd_e [Caux.mk_pure_e (Caux.mk_boolean_pe true); Caux.mk_pure_e (Caux.mk_boolean_pe false)] ) ]
            end
            (Caux.mk_if_e do_then_sym_pe core_s1 core_s2)
          end
        end
    
    | A.AilSwhile e s loop_id ->
        (* NOTE: the object type is OTy_integer since we are using mkTestExpression which turns [e] into [e == 0] *)
        let sym_loop = Symbol.fresh_pretty_with_id (fun x ->  "while_" ^ show x) in
        let sym_loop_body = Symbol.fresh_pretty_with_id (fun x ->  "while_body_" ^ show x) in
        E.wrapped_fresh_symbol C.BTy_boolean                >>= fun (_, do_loop_sym_pat, do_loop_sym_pe) ->
        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun (_, test_sym_pat, test_sym_pe)       ->
        E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, case_sym_pat, case_sym_pe)       ->
        translate_expression (mkTestExpression TestEq e)    >>= fun core_test                            ->
        self s                                              >>= fun core_s                               ->
        E.get_visible_objects                               >>= fun visible_syms                         ->
        (* TODO: the types of the annotations in Esave are dummy, but this is not observable for now *)
        let core_s_loop =
          Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit) core_s
            (Caux.mk_run_e sym_loop [ Caux.mk_sym_pe sym | forall (sym MEM visible_syms) | true ]) in
        E.mapM (fun sym ->
          E.resolve_object_type sym >>= fun (_, ty) ->
          E.return (sym, ((C.BTy_object C.OTy_pointer, Just (ty, true)), Caux.mk_sym_pe sym))
        ) visible_syms >>= fun args ->
        E.return begin
          Caux.mk_save_e_ [Annot.Alabel (Annot.LAloop_prebody loop_id)] (sym_loop, C.BTy_unit) args begin
            Caux.mk_sseq_e test_sym_pat core_test begin
              Caux.mk_sseq_e do_loop_sym_pat begin
                Caux.mk_case_e test_sym_pe
                  [ ( Caux.mk_specified_pat case_sym_pat
                    , Caux.mk_pure_e begin
                        Caux.mk_if_pe_ [Annot.Anot_explode] (Caux.mk_not_pe (Caux.mk_op_pe C.OpEq case_sym_pe (Caux.mk_integer_pe 1)))
                          (Caux.mk_boolean_pe true) (Caux.mk_boolean_pe false)
                      end )
                    (* non-deterministic branching if the test expression had unspecified value *)
                  ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                    , Caux.mk_nd_e [Caux.mk_pure_e (Caux.mk_boolean_pe true); Caux.mk_pure_e (Caux.mk_boolean_pe false)] ) ]
              end
                (Caux.mk_if_e do_loop_sym_pe 
                   begin                      
                     Caux.mk_save_e_ [Annot.Alabel (Annot.LAloop_body loop_id)] (sym_loop_body, C.BTy_unit) args
                       core_s_loop 
                   end 
                   Caux.mk_skip_e)
            end
          end
        end
    
    | A.AilSdo s e loop_id ->
        let () = Debug.warn [Debug.DB_elaboration] (fun () -> "TODO: make the elab of AilSdo use mkTestExpression") in
        let sym_loop = Symbol.fresh_pretty_with_id (fun x ->  "do_" ^ show x) in
        let sym_case = Symbol.fresh () in
        let sym_e    = Symbol.fresh () in
        translate_expression e    >>= fun core_e       ->
        self s                    >>= fun core_s       ->
        E.get_visible_objects     >>= fun visible_syms ->
        
        let core_loop =
          Caux.mk_run_e sym_loop [ Caux.mk_sym_pe sym | forall (sym MEM visible_syms) | true ] in

        E.mapM (fun sym ->
            E.resolve_object_type sym >>= fun (_, ty) ->            
            E.return (sym, ((C.BTy_object C.OTy_pointer, Just (ty, true)), Caux.mk_sym_pe sym))
          ) visible_syms >>= fun args ->
        E.return begin
          Caux.mk_save_e_ [Annot.Alabel (Annot.LAloop_body loop_id)] (sym_loop, C.BTy_unit) args (
            (* loop body *)
            Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit) core_s
              (* controlling expression *)
              begin
                Caux.mk_sseq_e (Caux.mk_sym_pat sym_e (C.BTy_loaded C.OTy_integer)) core_e (
                  Caux.mk_case_e (Caux.mk_sym_pe sym_e)
                    [ (Caux.mk_specified_pat (Caux.mk_sym_pat sym_case (C.BTy_object C.OTy_integer)),
                       Caux.mk_if_e (Caux.mk_not_pe (Caux.mk_op_pe C.OpEq (Caux.mk_sym_pe sym_case) (Caux.mk_integer_pe 0)))
                         core_loop Caux.mk_skip_e)
                      (* non-deterministic branching if the test expression had unspecified value *)
                    ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                       (* Caux.mk_nd_e [core_loop; Caux.mk_skip_e] *)
                       Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY "unspecified AilSdo"))) ]
                   )
              end
          )
        end
    
    | (*BISECT-IGNORE*) A.AilSbreak ->
        (* erase_loop_control must be called first, so this case is impossible. *)
        error "Translation.translate_stmt, found a break"
    
    | (*BISECT-IGNORE*) A.AilScontinue ->
        (* erase_loop_control must be called first, so this case is impossible. *)
        error "Translation.translate_stmt, found a continue"
    
    | A.AilSreturnVoid ->
        E.get_visible_objects >>= fun visible_syms ->
        E.mapM (fun sym ->
            E.resolve_object_type sym >>= fun (_, ty) ->
            E.return (sym, ty)
          ) visible_syms >>= fun visible_syms_tys ->
        E.return begin
          if env.is_Noreturn then
            Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.7.4#8" Undefined.UB071_noreturn)
          else
            let bTy =
              if List.length visible_syms < 2 then
                C.BTy_unit
              else
                C.BTy_tuple (List.replicate (List.length visible_syms) C.BTy_unit) in
            Caux.mk_sseq_e (Caux.mk_empty_pat bTy)
              (Caux.mk_unseq (List.map (fun (sym,ty) -> Caux.pkill loc (C.Static ty) (Caux.mk_sym_pe sym)) visible_syms_tys))
              (* TODO: check the symbols *)
              (Caux.mk_run_e env.return_lab [Caux.mk_unit_pe])
        end
    
    | A.AilSreturn e ->
        let oTy = force_core_object_type_of_ctype (ctype_of e) in
        translate_expression e                    >>= fun core_e                       ->
        E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun (e_sym, e_sym_pat, e_sym_pe) ->
        E.get_visible_objects                     >>= fun visible_syms                 ->
        E.mapM (fun sym ->
            E.resolve_object_type sym >>= fun (_, ty) ->
            E.return (sym, ty)
          ) visible_syms >>= fun visible_syms_tys ->
        
        (* TODO: typing is not enough (should do like assignments) *)
        let ret_pe =
          if AilTypesAux.is_arithmetic env.return_ty && AilTypesAux.is_arithmetic (ctype_of e) then
             conv_loaded_arith stdlib (ctype_of e) env.return_ty e_sym_pe
          else if AilTypesAux.is_pointer env.return_ty && Aaux.is_null_pointer_constant e then
            Caux.mk_specified_pe (Caux.mk_nullptr_pe env.return_ty)
          else
            e_sym_pe in
        
        (* All the visible objects from the current function need to be killed. *)
        (* TODO: Ebound index *)
        E.return begin
          if env.is_Noreturn then
            Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.7.4#8" Undefined.UB071_noreturn)
          else
            Caux.mk_sseq_e e_sym_pat (C.Expr [] (C.Ebound 0 core_e))
              (mk_run_e loc env.return_lab visible_syms_tys [] [ret_pe])
        end

    | A.AilSswitch e s ->
        (* Translate the controlling expression *)
        translate_expression e >>= fun core_e ->
        let oTy = force_core_object_type_of_ctype (ctype_of e) in
        E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun (e_sym, e_pat, e_sym_pe) ->
        (* Case in specified values *)
        E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun (control_sym, control_pat, control_sym_pe) ->
        (* Integer promotion *)
        (* STD §6.8.4.2#5, sentence 1 *)
        (* TODO: check whether this is a correct integer promotion *)
        E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun (promoted_sym, promoted_pat, promoted_sym_pe) ->
        let promoted_pe =
          Caux.mk_std_pe "§6.8.4.2#5, sentence 1" (
            stdlib.mkcall_conv_int (fromJust "Translation.translate_stmt: switch expr promotion"
              (AilTypesAux.promotion integerImpl (ctype_of e))) control_sym_pe
          ) in
        (* Create case symbols and translate cases block *)
        let cases    = collect_cases s in
        let nb_cases = List.length cases.case_csts in
        let case_syms = list_init nb_cases (fun _ -> Symbol.fresh_pretty_with_id (fun x -> "case_" ^ show x)) in
        let default_sym = Symbol.fresh_pretty_with_id (fun x -> "default_" ^ show x) in
        let case_labs = List.zip cases.case_csts case_syms in
        translate_cases_block case_labs (Just default_sym) s >>= fun core_s ->
        E.get_visible_objects >>= fun visible_syms ->
        let visible_pes = List.map (fun sym -> Caux.mk_sym_pe sym) visible_syms in
        (* Build translated switch *)
        E.return
          (* Get control expression *)
          (Caux.mk_sseq_e e_pat core_e
            (* Check if unspecified *)
            (Caux.mk_case_e e_sym_pe
              [ ( Caux.mk_specified_pat control_pat
                , (* Do integer promotion *)
                  Caux.mk_sseq_e promoted_pat
                    (Caux.mk_pure_e promoted_pe)
                    (* For every case.... *)
                    (List.foldl (fun acc (iCst, case_lab) ->
                      Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit)
                        (* Check if equal to the constant expression *)
                        (Caux.mk_if_e (Caux.mk_op_pe C.OpEq promoted_sym_pe (translate_integerConstant iCst))
                          (* TODO: not sure if the visible afters are the same *)
                          (Caux.mk_run_e case_lab visible_pes)
                          (Caux.mk_skip_e))
                        acc)
                    (* default branch *)
                    (Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit) 
                      (if cases.found_default then
                        Caux.mk_run_e default_sym visible_pes
                        else
                        Caux.mk_skip_e)
                      core_s)
                    case_labs) )
                 (* UB if unspecified *)
               ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                 , Caux.mk_pure_e (Caux.mk_undef_exceptional_condition loc) ) ]))
    
    | A.AilScase iCst s ->
        self s                >>= fun core_s       ->
        E.get_visible_objects >>= fun visible_syms ->
        E.mapM (fun sym ->
            E.resolve_object_type sym >>= fun (_, ty) ->
            E.return (sym, ((C.BTy_object C.OTy_pointer, Just (ty, true)), Caux.mk_sym_pe sym))
          ) visible_syms >>= fun visible_pes ->
        match List.lookup iCst env.case_labs with
          | Just lab ->
              E.return (Caux.mk_save_e (lab, C.BTy_unit) visible_pes core_s)
          | (*BISECT-IGNORE*) Nothing ->
              error "Translation.translate_stmt: case label not found."
        end
    
    | A.AilSdefault s ->
        self s >>= fun core_s ->
        match env.default_lab with
          | Just lab ->
              E.return (Caux.mk_save_e (lab, C.BTy_unit) [] core_s)
          | (*BISECT-IGNORE*) Nothing ->
              error "Translation.translate_stmt: default label not found."
        end
    
    | A.AilSlabel sym s m_label_annot ->
        self s                >>= fun core_s       ->
        E.get_visible_objects >>= fun visible_syms ->
        E.mapM (fun sym ->
            E.resolve_object_type sym >>= fun (_, ty) ->
            E.return (sym, ((C.BTy_object C.OTy_pointer, Just (ty, true)), Caux.mk_sym_pe sym))
          ) visible_syms >>= fun args ->
        let annots = match m_label_annot with
          | Just loop_annot -> [Annot.Alabel loop_annot]
          | Nothing -> []
        end in
        E.return (Caux.mk_save_e_ annots (sym, C.BTy_unit) args core_s)
    
    | A.AilSgoto sym ->
        E.get_visible_objects >>= fun visible_syms ->
        E.mapM (fun sym ->
            E.resolve_object_type sym >>= fun (_, ty) ->
            E.return (sym, ty)
        ) visible_syms >>= fun visible_syms_tys ->
        let visibles_after = fromJust "Translation.translation_statement, AilSgoto" (Map.lookup sym env.label_visibles) in
        E.return (mk_run_e loc sym visible_syms_tys visibles_after [])
    
    | A.AilSdeclaration sym_es ->
        (* This pass translates the declarations *)
        E.mapM (fun (ptr_sym, e) ->
          let ptr_sym_e = Caux.mk_sym_pe ptr_sym in
          E.resolve_object_type ptr_sym >>= fun (qs, ty) ->
          let oTy = force_core_object_type_of_ctype (ctype_of e) in
          E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun (_, e_sym_pat, e_sym_pe) ->
          match Ctype.unatomic_ ty with
            | Ctype.Pointer _ ref_ty ->
                let mk_store =
                  if qs.Ctype.const then Caux.pstore_lock else Caux.pstore in
                if Aaux.is_null_pointer_constant e then
                  E.return (
                    mk_store loc (Caux.mk_ail_ctype_pe ty) ptr_sym_e
                      (Caux.mk_specified_pe (Caux.mk_nullptr_pe ref_ty)) Cmm.NA
                  )
                  else
                    translate_expression e >>= fun core_e ->
                    E.return (
                      Caux.mk_sseq_e e_sym_pat core_e
                        (mk_store loc (Caux.mk_ail_ctype_pe ty) ptr_sym_e e_sym_pe Cmm.NA)
                    )
            | ty ->
                let mk_store =
                  if qs.Ctype.const then Caux.pstore_lock else Caux.pstore in
                (* we are not dealing with a pointer initialisation *)
                let cty = Ctype.Ctype [] ty in
                translate_expression e >>= fun core_e ->
                if Global.is_CHERI () && Ctype.is_ptr_t cty && not (Ctype.is_ptr_t (ctype_of e)) then
                  E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun (_, obj_sym_pat, obj_sym_pe) ->
                  E.return begin
                    Caux.mk_sseq_e e_sym_pat core_e begin
                      Caux.mk_case_e e_sym_pe
                        [ ( Caux.mk_specified_pat obj_sym_pat
                          , mk_store loc (Caux.mk_ail_ctype_pe cty) ptr_sym_e begin
                              let is_signed = AilTypesAux.is_signed_integer_type cty in
                              Caux.mk_specified_pe begin
                                Caux.mk_memop_pe Mem_common.CapAssignValue
                                  [Caux.mk_nullcap_pe is_signed; conv_arith stdlib (ctype_of e) cty obj_sym_pe]
                              end
                            end Cmm.NA )
                        ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                          , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY "AilSdeclaration")) ) ]
                    end
                  end
                else
                  E.return begin
                    Caux.mk_sseq_e e_sym_pat core_e
                      (mk_store loc (Caux.mk_ail_ctype_pe cty) ptr_sym_e
                        (if AilTypesAux.is_arithmetic cty then conv_loaded_arith stdlib (ctype_of e) cty e_sym_pe else e_sym_pe) Cmm.NA)
                  end
          end
        ) sym_es >>= fun z ->
        
        (* This pass combines the translated declarations *)
        match z with
          | [] ->
              E.return Caux.mk_skip_e
          | z::zs' ->
              E.foldlM (fun x y -> E.return (Caux.concat_sseq x y)) z zs'
        end
    
    | A.AilSpar ss ->
        E.mapM self ss >>= fun core_ss ->
        E.return begin
          Caux.mk_wseq_e (Caux.mk_empty_pat (C.BTy_tuple (List.replicate (List.length ss) C.BTy_unit)))
            (C.Expr [] (C.Epar core_ss))
            Caux.mk_skip_e
        end

    | A.AilSreg_store _ _ ->
        error "TODO: translate_stmt AilSreg_store"
    | A.AilSpack id es ->
       (* copying and adapting code from that for AilEcall *)
        E.foldlM (fun (arg_sym_pats_and_arg_core_es, arg_sym_pes) arg_e ->
          let arg_bTy = C.BTy_loaded (force_core_object_type_of_ctype (ctype_of arg_e)) in
          E.wrapped_fresh_symbol arg_bTy >>= fun (_, arg_sym_pat, arg_sym_pe) ->
          translate_expression arg_e >>= fun arg_core_e ->
          E.return ((arg_sym_pat, arg_core_e) :: arg_sym_pats_and_arg_core_es, 
                    arg_sym_pe :: arg_sym_pes)
          ) ([],[]) es >>= fun (arg_sym_pats_and_arg_core_es, arg_sym_pes) ->
        let e = 
          List.foldr (fun (arg_sym_pat, arg_core_e) e ->
              Caux.mk_sseq_e arg_sym_pat arg_core_e e
            ) 
            (C.Expr [Annot.Aloc loc] (C.Epack id arg_sym_pes))
            arg_sym_pats_and_arg_core_es
        in
        E.return e
    | A.AilSunpack id es ->
       (* copying and adapting code from that for AilEcall *)
        E.foldlM (fun (arg_sym_pats_and_arg_core_es, arg_sym_pes) arg_e ->
          let arg_bTy = C.BTy_loaded (force_core_object_type_of_ctype (ctype_of arg_e)) in
          E.wrapped_fresh_symbol arg_bTy >>= fun (_, arg_sym_pat, arg_sym_pe) ->
          translate_expression arg_e >>= fun arg_core_e ->
          E.return ((arg_sym_pat, arg_core_e) :: arg_sym_pats_and_arg_core_es, 
                    arg_sym_pe :: arg_sym_pes)
          ) ([],[]) es >>= fun (arg_sym_pats_and_arg_core_es, arg_sym_pes) ->
        let e = 
          List.foldr (fun (arg_sym_pat, arg_core_e) e ->
              Caux.mk_sseq_e arg_sym_pat arg_core_e e
            ) 
            (C.Expr [Annot.Aloc loc] (C.Eunpack id arg_sym_pes))
            arg_sym_pats_and_arg_core_es
        in
        E.return e
    | A.AilShave id es ->
       (* copying and adapting code from that for AilEcall *)
        E.foldlM (fun (arg_sym_pats_and_arg_core_es, arg_sym_pes) arg_e ->
          let arg_bTy = C.BTy_loaded (force_core_object_type_of_ctype (ctype_of arg_e)) in
          E.wrapped_fresh_symbol arg_bTy >>= fun (_, arg_sym_pat, arg_sym_pe) ->
          translate_expression arg_e >>= fun arg_core_e ->
          E.return ((arg_sym_pat, arg_core_e) :: arg_sym_pats_and_arg_core_es, 
                    arg_sym_pe :: arg_sym_pes)
          ) ([],[]) es >>= fun (arg_sym_pats_and_arg_core_es, arg_sym_pes) ->
        let e = 
          List.foldr (fun (arg_sym_pat, arg_core_e) e ->
              Caux.mk_sseq_e arg_sym_pat arg_core_e e
            ) 
            (C.Expr [Annot.Aloc loc] (C.Ehave id arg_sym_pes))
            arg_sym_pats_and_arg_core_es
        in
        E.return e
    | A.AilSshow id es ->
       (* copying and adapting code from that for AilEcall *)
        E.foldlM (fun (arg_sym_pats_and_arg_core_es, arg_sym_pes) arg_e ->
          let arg_bTy = C.BTy_loaded (force_core_object_type_of_ctype (ctype_of arg_e)) in
          E.wrapped_fresh_symbol arg_bTy >>= fun (_, arg_sym_pat, arg_sym_pe) ->
          translate_expression arg_e >>= fun arg_core_e ->
          E.return ((arg_sym_pat, arg_core_e) :: arg_sym_pats_and_arg_core_es, 
                    arg_sym_pe :: arg_sym_pes)
          ) ([],[]) es >>= fun (arg_sym_pats_and_arg_core_es, arg_sym_pes) ->
        let e = 
          List.foldr (fun (arg_sym_pat, arg_core_e) e ->
              Caux.mk_sseq_e arg_sym_pat arg_core_e e
            ) 
            (C.Expr [Annot.Aloc loc] (C.Eshow id arg_sym_pes))
            arg_sym_pats_and_arg_core_es
        in
        E.return e        
  end


val translate_tag_definitions:
  list (A.ail_identifier * (Annot.attributes * Ctype.tag_definition)) ->
  C.core_tag_definitions
let translate_tag_definitions ctx =
  Map.fromList (List.map (fun (x, (_, y)) -> (x, y)) ctx)


val translate_program:
  translation_stdlib ->
  maybe Symbol.sym * A.sigma GenTypes.genTypeCategory ->
  E.elabM (  C.core_tag_definitions
           * list (Symbol.sym * (C.generic_globs unit unit))
           * C.generic_fun_map unit unit
           * map Symbol.sym (Loc.t * Annot.attributes * Ctype.ctype * list (maybe Symbol.sym * Ctype.ctype) * bool * bool) )

let translate_program stdlib (startup_sym_opt, sigm) =
  let core_tagDefs = translate_tag_definitions sigm.A.tag_definitions in
  
  E.foldlM (fun (gacc, facc, finfoacc) (sym, (loc, decl_attrs, decl)) ->
    (* for each Ail declaration *)
    match decl with
      | A.Decl_object _ qs ty ->
          (* elaboration of a global variables *)
          let core_ty     = Caux.mk_ail_ctype_pe ty in
          let core_create = Caux.pcreate loc (Caux.mk_alignof_pe core_ty) core_ty (Symbol.PrefSource loc [sym]) in
          let sym_global  = Symbol.fresh () in
          
          let () = Debug.print_debug 2 [Debug.DB_elaboration] (fun () -> "(translate_program) CREATE for global: " ^ show sym_global) in
          match List.lookup sym sigm.A.object_definitions with
            | Nothing ->
                (* we are dealing with an external object *)
                E.return ( (sym, C.GlobalDecl (C.BTy_object C.OTy_pointer, ty)) :: gacc, facc, finfoacc )
            
            | Just expr ->
                begin
                  if AilTypesAux.is_pointer ty && Aaux.is_null_pointer_constant expr then
                    E.return (
                      C.BTy_loaded C.OTy_pointer,
                      Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_nullptr_pe ty))
                    )
                  else
                    translate_expression (ECTX_glob sym sym_global)
                      ((Nothing: maybe Symbol.sym), (Nothing: maybe Symbol.sym)) stdlib core_tagDefs expr >>= fun core ->
                    E.return (
                      C.BTy_loaded (force_core_object_type_of_ctype (ctype_of expr)),
                      core
                    )
                end >>= fun (e_bTy, core_e) ->
                let e_sym = Symbol.fresh () in
                let core_init_e =
                  if AilTypesAux.is_integer ty || AilTypesAux.is_floating ty then
                    conv_loaded_arith stdlib (ctype_of expr) ty (Caux.mk_sym_pe e_sym)
                  else
                    Caux.mk_sym_pe e_sym in
                let mk_store =
                  (* const-qualified globals are made read-only *)
                  if qs.Ctype.const then Caux.pstore_lock else Caux.pstore in
                let core_e =
                  Caux.add_loc (locOf core_e) begin
                    Caux.mk_sseq_e (Caux.mk_sym_pat sym_global (C.BTy_object C.OTy_pointer)) core_create (
                      Caux.mk_sseq_e (Caux.mk_sym_pat e_sym e_bTy) core_e (
                       Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit)
                         (* TODO: proper memory order *)
                         (mk_store loc core_ty (Caux.mk_sym_pe sym_global) core_init_e Cmm.NA)
                         (Caux.mk_pure_e (Caux.mk_sym_pe sym_global))
                      ))
                  end in
                E.return
                  ( (sym, C.GlobalDef (C.BTy_object C.OTy_pointer, ty) core_e) :: gacc
                  , facc, finfoacc )
          end
      
      | A.Decl_function has_proto (_, return_ty) params is_variadic is_inline is_Noreturn ->
          (* elaboration of a function *)
          let ret_bTy =
            if AilTypesAux.is_void return_ty then
              C.BTy_unit
            else
              C.BTy_loaded (force_core_object_type_of_ctype return_ty) in
          match List.lookup sym sigm.A.function_definitions with
            | Nothing ->
                (* if the function has no definition, we create a Core procedure declaration *)
                let finfo =     (* TODO: plug in non-empty attributes *)
                  ( loc, decl_attrs, return_ty
                    (* TODO: check if we need qualifiers too *)
                  , List.map (fun (_, ty, _) -> (Nothing, ty)) params
                  , is_variadic, has_proto ) in
                E.return
                  ( gacc
                  , Map.insert sym (C.ProcDecl loc ret_bTy (List.map (fun _ -> C.BTy_object C.OTy_pointer) params)) facc
                    (* get the correct symbol if a proxy exists *)
                  , match sym with
                      | Symbol.Symbol _ _ (Symbol.SD_Id str) ->
                          match Map.lookup str stdlib.ailnames with
                            | Just sym_proxy -> Map.insert sym_proxy finfo finfoacc
                            | Nothing -> Map.insert sym finfo finfoacc
                          end
                      | _ -> Map.insert sym finfo finfoacc
                    end )
            
            | Just (loc, _, param_syms, stmt) ->
                (* making the argument variables visible *)
(* TODO: WIP                E.with_block_objects param_syms *)
                (* TODO: variadic!! *)
                let finfo =
                  (* NOTE: the attributes in the Ail function declarations includes the ones only present on both
                     the Cabs function declaration and definition *)
                  ( loc, decl_attrs, return_ty
                  (* TODO: check if we need qualifiers too *)
                  , List.map (fun (sym, (_, ty, _)) -> (Just sym, ty)) (List.zip param_syms params)
                  , is_variadic, has_proto ) in
                let ret_label = Symbol.fresh_pretty_with_id (fun x -> "ret_" ^ show x) in
                let stmt = erase_loop_control stmt in
                let visibles = collect_visibles stmt in
                let (variadic_sym_opt, last_arg_sym_opt) =
                  if is_variadic then
                    match List.reverse param_syms with
                      | [] -> error "variadic functions need to have at least one parameter"
                      | sym::_ -> (Just (Symbol.fresh ()), Just sym)
                    end
                  else
                    (Nothing, Nothing)
                in
                (translate_stmt stdlib core_tagDefs sym <|
                   return_ty= return_ty;
                   return_lab= ret_label;
                   variadic_sym_opt= variadic_sym_opt;
                   last_arg_sym_opt= last_arg_sym_opt;
                   is_Noreturn= is_Noreturn;
                   default_lab= Nothing;
                   case_labs= [];
                   loop= Nothing;
                   break= Nothing;
                   label_visibles= visibles.label_visibles_;
                 |> stmt) >>= fun core_body ->
                let ret_sym = Symbol.fresh () in
                let core_return =
                  let ret_pe =
                    if startup_sym_opt = Just sym then
                      (* STD §5.1.2.2.3#1 sentence 1*)
                      (* TODO: "If the return type is not compatible with int" *)
                      Caux.mk_specified_pe (Caux.mk_integer_pe 0)
                    else if AilTypesAux.is_void return_ty && is_Noreturn then
                      Caux.mk_std_undef_pe loc "§6.7.4#8" Undefined.UB071_noreturn
                    else if AilTypesAux.is_void return_ty then
                      Caux.mk_unit_pe
                    else
                      Caux.mk_std_undef_pe loc "§6.9.1#12" Undefined.UB088_reached_end_of_function in
                  Caux.mk_save_e_ [Annot.Alabel Annot.LAreturn]
                                  (ret_label, ret_bTy) 
                                  [(ret_sym, ((ret_bTy, Just (return_ty, false)), ret_pe))]
                    (Caux.mk_pure_e (Caux.mk_sym_pe ret_sym))
                in
                let variadic_arg_type =
                  match variadic_sym_opt with
                    | Just sym -> [(sym, C.BTy_list (C.BTy_tuple [C.BTy_ctype; C.BTy_object C.OTy_pointer]))]
                    | Nothing -> []
                  end
                in
                E.return
                  ( gacc
                  , Map.insert sym
                     (C.Proc loc (ret_bTy (* C.BTy_loaded (if AilTypesAux.is_pointer return_ty then C.OTy_pointer else C.OTy_integer)*))
                             (List.map (fun sym -> (sym, C.BTy_object C.OTy_pointer)) param_syms ++ variadic_arg_type)
                             (Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit) core_body core_return)
                     ) facc
                  , Map.insert sym finfo finfoacc )
          end
    end
  ) ([], Map.empty, Map.empty) (List.reverse sigm.A.declarations) >>= fun (globs, cfuns, funinfo) ->
  
  (* adding string literals as Core globals *)
  E.get_string_literals >>= fun xs ->
  E.foldlM (fun acc (loc, sym, ty, e_init) ->
    let expr =
      Caux.pcreate_readonly loc
        (Caux.mk_alignof_pe (Caux.mk_ctype_pe ty))
        (Caux.mk_ctype_pe ty)
        e_init
        (Symbol.PrefStringLiteral loc (Symbol.digest_of_sym sym)) in
    E.return ((sym, C.GlobalDef (C.BTy_object C.OTy_pointer, ty) expr) :: acc)
  ) globs (List.reverse xs) >>= fun globs' ->
  E.return (core_tagDefs, globs', cfuns, funinfo)


let translate_extern_map (_, sigm) =
  Map.map (fun (sym, kind) ->
    match kind with
    | A.IK_declaration -> ([sym], C.LK_none)
    | A.IK_tentative -> ([sym], C.LK_tentative sym)
    | A.IK_definition -> ([sym], C.LK_normal sym)
    end) sigm.A.extern_idmap


(* This is the entry function (called from main.ml) *)
val translate:
    (map string Symbol.sym) * C.fun_map unit ->
    C.impl -> 
    A.ail_program GenTypes.genTypeCategory ->
    C.file unit

let translate (ailnames, stdlib_fun_map) impl prog =
  let translation_stdlib = mk_translation_stdlib (ailnames, stdlib_fun_map) in
  
  (* TODO: this is ugly, we shouldn't expose the internals and properly use the Undefined *)
  (* TODO2: not sure what that comment is refering too ... *)
  let ((core_tagDefs, cglobs, (*cdecls, *) cfuns, funinfo), st) =
    E.runStateM (translate_program translation_stdlib prog) (E.elab_init ())
  in
  <| C.main= fst prog;
     C.tagDefs= core_tagDefs;
     C.stdlib= stdlib_fun_map;
     C.impl= impl;
     C.globs= Core_linking.merge_globs cglobs [] []; (* topological sort *)
     C.funs= cfuns;
     C.extern = translate_extern_map prog;
     C.funinfo= funinfo;
     C.loop_attributes= (snd prog).A.loop_attributes; |>
