open import Pervasives Utils Loc String_extra Num
import Global

import State Undefined Translation_effect Loc List_extra
open import Translation_aux
import AilSyntax AilSyntaxAux Ctype AilTypesAux
import Ctype GenTypes
import Core Core_aux Core_typing Core_linking

import Builtins Annot Decode

import Cmm_csem Mem
import Linux


module A    = AilSyntax
module Aaux = AilSyntaxAux


module C    = Core
module Cty  = struct 
  include import Ctype
  include import Ctype_aux
end
module Caux = Core_aux
module U    = Undefined

module Cmm = Cmm_csem


module E = Translation_effect
module Operators = struct
  let inline (>>=)      = E.bind
  let inline (>>) m f   = E.bind m (fun _ -> f)
  let inline (<$>) f ma = E.bind ma (fun a -> E.return (f a))
  let inline (<*>) mf m = E.bind mf (fun f -> f <$> m)
end
open Operators


(* NOTE: this function only fails on function types and unspecified sized arrays *)
let force_core_object_type_of_ctype ty =
  match Caux.core_object_type_of_ctype ty with
    | Just oTy ->
        oTy
    | (*BISECT-IGNORE*) Nothing ->
        error "Translation.force_core_object_type_of_ctype: Nothing"
  end


let floating_conversion_TODO to_ty from_ty z =
  (* NOTE: our current implementation of floating types has them all behave like double *)
  let () = Debug.warn [Debug.DB_elaboration] (fun () ->
    "casts between floating types is currently a NOP: " ^
    Pp.stringFromCore_ctype to_ty ^ " <== " ^
    Pp.stringFromCore_ctype from_ty
  ) in
  z


let with_wrapI_or_catch_exceptional_condition result_ty iop promoted1_pe promoted2_pe default_pe_opt =
  match Cty.match_integer_ctype result_ty with
    | Cty.MatchedItySigned ity ->
        Caux.mk_catch_exceptional_condition_pe ity iop promoted1_pe promoted2_pe
    | Cty.MatchedItyUnsigned ity ->
        Caux.mk_wrapI_pe ity iop promoted1_pe promoted2_pe
    | Cty.NotMatchedIty ->
        match default_pe_opt with
          | Just default_pe ->
              default_pe
          | Nothing ->
              error "Translation.with_wrapI_or_catch_exceptional_condition: result_ty is not an integer type, but given no default_pe"
        end
  end


(* STD §6.5.13#3, sentence 1 *)
(* STD §6.5.14#3, sentence 1 *)
(* STD §6.5.15#4, sentence 2 *)
(* STD §6.7.10#2 *)
(* STD §6.8.4.1#2, sentence 1-2 *)
(* STD §6.8.5#4, sentence 1 *)
(* Some C constructs perform tests on scalar expression, with dynamic semantics
   varying on whether its value "compares equal to 0". The semantics of the quoted
   sentence implicitly refers to that of the C binary equality operator.
   This function turns a [e] scalar expression into a [e == 0], so that elaboration
   of the equality operator can be reused *)

type test_operator =
  | TestEq
  | TestNe

val mkTestExpression: forall 'a. test_operator -> A.expression GenTypes.genTypeCategory -> A.expression GenTypes.genTypeCategory
let mkTestExpression op (A.AnnotatedExpression gty annots _ _ as a_expr) =
  let loc = locOf a_expr in
  let gtc =
    (* STD §6.5.9#3, sentence 1 *)
    GenTypes.GenRValueType GenTypes.signedInt_gty in
  let bop = match op with
    | TestEq -> A.Eq
    | TestNe -> A.Ne
  end in
  let zero_const =
    if AilTypesAux.is_integer (ctype_of a_expr) then
      A.ConstantInteger (A.IConstant 0 A.Octal Nothing)
    else if AilTypesAux.is_floating (ctype_of a_expr) then
      A.ConstantFloating ("0.0", Nothing)
    else if AilTypesAux.is_pointer (ctype_of a_expr) then
      A.ConstantNull
    else
      (*BISECT-IGNORE*) error "[Translation.mkTestExpression] must be called on scalar expression" in
  A.AnnotatedExpression gtc annots loc
    (A.AilEbinary a_expr bop (A.AnnotatedExpression gty annots loc (A.AilEconst zero_const)))


val zeroAil_tau: A.expression GenTypes.genTypeCategory
let zeroAil_tau =
  A.AnnotatedExpression
    (GenTypes.GenRValueType GenTypes.signedInt_gty) [] Loc.unknown
    (A.AilEconst (A.ConstantInteger (A.IConstant 0 A.Octal Nothing)))

val oneAil_tau: A.expression GenTypes.genTypeCategory
let oneAil_tau =
  A.AnnotatedExpression
    (GenTypes.GenRValueType GenTypes.signedInt_gty) [] Loc.unknown
    (A.AilEconst (A.ConstantInteger (A.IConstant 1 A.Decimal Nothing)))


val mk_cheri_derive_and_assign_cap: bool -> Mem_common.derivecap_op -> C.pexpr * C.pexpr -> C.pexpr -> C.pexpr
let mk_cheri_derive_and_assign_cap is_signed cap_op (obj1_sym_pe, obj2_sym_pe) core_pe =
  let cap_pe =
    Caux.mk_memop_pe (Mem_common.DeriveCap cap_op is_signed) [obj1_sym_pe; obj2_sym_pe] in
  Caux.mk_memop_pe Mem_common.CapAssignValue [cap_pe; core_pe]

val translate_integerConstant: A.integerConstant -> C.pexpr
let translate_integerConstant iCst =
  Caux.mk_value_pe begin
    C.Vobject begin
      C.OVinteger begin
        match iCst with
          | A.IConstant n _ _ ->
              Mem.integer_ival n
          | A.IConstantMax ity ->
              Mem.max_ival ity
          | A.IConstantMin ity ->
              Mem.min_ival ity
        end
      end
    end
  end


val translate_memory_order: A.expression GenTypes.genTypeCategory -> Cmm.memory_order
let translate_memory_order (A.AnnotatedExpression _ _ _ expr as a_expr) =
  (* NOTE: we only support constant directly matching a memory order  *)
  match expr with
    | A.AilEconst (A.ConstantInteger (A.IConstant n _ _)) ->
        match Builtins.decode_memory_order (natFromInteger n) with
          | Just mo -> mo
          | Nothing ->
              error ("Translation.translate_memory_order: " ^ show n)
        end
    | (*BISECT-IGNORE*) _ ->
        error ("Translation.translate_memory_order: " ^ Pp.stringFromAil_expression a_expr)
  end


val translate_linux_memory_order: A.expression GenTypes.genTypeCategory -> Linux.linux_memory_order
let translate_linux_memory_order (A.AnnotatedExpression _ _ _ expr as a_expr) =
  match expr with
    | A.AilEconst (A.ConstantInteger (A.IConstant n _ _)) ->
        match natFromInteger n with
          | 0 -> Linux.Once
          | 1 -> Linux.LAcquire
          | 2 -> Linux.LRelease
          | 3 -> Linux.Rmb
          | 4 -> Linux.Wmb
          | 5 -> Linux.Mb
          | 6 -> Linux.RbDep
          | 7 -> Linux.RcuLock
          | 8 -> Linux.RcuUnlock
          | 9 -> Linux.SyncRcu
          | (*BISECT-IGNORE*) _ ->
              error ("Translation.translate_linux_memory_order: " ^ show n)
        end
    | (*BISECT-IGNORE*) _ ->
        error ("Translation.translate_linux_memory_order: " ^ Pp.stringFromAil_expression a_expr)
  end


val     translate_constant: A.constant -> C.pexpr
let rec translate_constant cst =
  match cst with
    | A.ConstantIndeterminate ty ->
        (* NOTE: we assume the lack of trap representation *)
        Caux.mk_unspecified_pe ty
    | A.ConstantNull ->
        Caux.mk_specified_pe (Caux.mk_nullptr_pe Cty.void)
    | A.ConstantInteger (A.IConstant n _ _) ->
        Caux.mk_value_pe (C.Vloaded (C.LVspecified (C.OVinteger (Mem.integer_ival n))))
    | A.ConstantInteger (A.IConstantMax ity) ->
        Caux.mk_value_pe (C.Vloaded (C.LVspecified (C.OVinteger (Mem.max_ival ity))))
    | A.ConstantInteger (A.IConstantMin ity) ->
        Caux.mk_value_pe (C.Vloaded (C.LVspecified (C.OVinteger (Mem.min_ival ity))))
    | A.ConstantFloating (str, _) ->
        (* TODO: when we support float vs double, we'll need to inspect the suffix *)
        Caux.mk_value_pe (C.Vloaded (C.LVspecified (C.OVfloating (Mem.str_fval str))))
    | A.ConstantCharacter (_, str) ->
        (* NOTE: making an implementation fix here (ASCII) *)
        Caux.mk_value_pe (C.Vloaded (C.LVspecified (C.OVinteger (Mem.integer_ival (Decode.decode_character_constant str)))))
    | A.ConstantArray _ csts ->
        Caux.mk_specified_pe (Caux.mk_array_pe (List.map translate_constant csts))
    | A.ConstantStruct tag_sym xs ->
        Caux.mk_specified_pe begin
          Caux.mk_struct_pe tag_sym begin
            List.map (fun (memb_ident, cst) -> (memb_ident, translate_constant cst)) xs
          end
        end
    | A.ConstantUnion tag_sym memb_ident pe ->
        Caux.mk_specified_pe (Caux.mk_union_pe tag_sym memb_ident (translate_constant pe))
    | A.ConstantPredefined A.PConstantFalse ->
        (* STD C23 §6.4.4.5#3 *)
        Caux.mk_value_pe (C.Vloaded (C.LVspecified (C.OVinteger (Mem.integer_ival 0))))
    | A.ConstantPredefined A.PConstantTrue ->
        (* STD C23 §6.4.4.5#3 *)
        Caux.mk_value_pe (C.Vloaded (C.LVspecified (C.OVinteger (Mem.integer_ival 1))))
  end


val translate_function_designator:
  (A.expression GenTypes.genTypeCategory -> E.elabM (C.expr unit)) ->
  translation_stdlib ->
  A.expression GenTypes.genTypeCategory ->
  E.elabM (C.expr unit)
let translate_function_designator translate_expr stdlib (A.AnnotatedExpression _ _ _ expr as a_expr) =
  let (Ctype.Ctype _ cty as ty) = ctype_of a_expr in
  match (cty, expr) with
    | (Ctype.Function _ params is_variadic, A.AilEunary A.Indirection e) ->
        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun fun_wrp ->
        translate_expr e                                    >>= fun core_e  ->
        E.return (Caux.mk_sseq_e fun_wrp.E.sym_pat core_e (Caux.mk_pure_e fun_wrp.E.sym_pe))
    | (Ctype.Function _ params is_variadic, A.AilEident fid) ->
        let fid_pe = match fid with
          | Symbol.Symbol _ _ (Symbol.SD_Id str) ->
              match Map.lookup str stdlib.ailnames with
                | Just sym ->
                    Caux.mk_value_pe (Core.Vloaded (C.LVspecified (Core.OVpointer (Mem.fun_ptrval sym))))
                | Nothing ->
                    Caux.mk_value_pe (Core.Vloaded (C.LVspecified (Core.OVpointer (Mem.fun_ptrval fid))))
              end
          | _ ->
              Caux.mk_value_pe (Core.Vloaded (C.LVspecified (Core.OVpointer (Mem.fun_ptrval fid))))
        end in
        E.return (Caux.mk_pure_e fid_pe)
    | (*BISECT-IGNORE*) _ ->
        error ("[Translation.translate_function_designator] wildcard case ==> " ^
               Pp.stringFromAil_expression a_expr ^ " and type= " ^ Pp.stringFromAil_ctype Ctype.no_qualifiers ty)
  end


(* STD §6.5.5 Multiplicative operators *)
val translate_mul_operator:
  Loc.t ->
  (A.expression GenTypes.genTypeCategory -> E.elabM (C.expr unit)) ->
  (Ctype.ctype -> Ctype.ctype -> C.pexpr -> C.pexpr -> C.pexpr * C.pexpr) ->
  translation_stdlib ->
  Ctype.ctype ->
  A.expression GenTypes.genTypeCategory ->
  A.expression GenTypes.genTypeCategory ->
  E.elabM (C.expr unit)
let translate_mul_operator loc translate_expr usual_arithmetic_conversion stdlib result_ty e1 e2 =
  let oTy1 = force_core_object_type_of_ctype (ctype_of e1) in
  let oTy2 = force_core_object_type_of_ctype (ctype_of e2) in
  translate_expr e1                                   >>= fun core_e1  ->
  translate_expr e2                                   >>= fun core_e2  ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy1)          >>= fun e1_wrp   ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy2)          >>= fun e2_wrp   ->
  E.wrapped_fresh_symbol (C.BTy_object oTy1)          >>= fun obj1_wrp ->
  E.wrapped_fresh_symbol (C.BTy_object oTy2)          >>= fun obj2_wrp ->
  E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun cap_wrp  -> (* (_, cap_sym_pat, cap_sym_pe) -> *)
  let (promoted1_pe, promoted2_pe) =
    Caux.mk_std_pair_pe "§6.5.5#3"
      (usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_wrp.E.sym_pe obj2_wrp.E.sym_pe) in
  E.return begin
    Caux.add_std "§6.5.5" (
      Caux.mk_wseq_e (Caux.mk_tuple_pat [ e1_wrp.E.sym_pat; e2_wrp.E.sym_pat ]) (Caux.mk_unseq [core_e1; core_e2]) (
        Caux.mk_pure_e (
          Caux.mk_case_pe (Caux.mk_tuple_pe [e1_wrp.E.sym_pe; e2_wrp.E.sym_pe])
            [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_wrp.E.sym_pat
                                 ; Caux.mk_specified_pat obj2_wrp.E.sym_pat ],
               (* Both operand are specified *)
               let core_mul = Caux.mk_std_pe "§6.5.5#4" (Caux.mk_op_pe C.OpMul promoted1_pe promoted2_pe) in
               Caux.mk_specified_pe begin
if Global.is_CHERI () && Ctype.is_ptr_t result_ty then
                  Caux.mk_let_pe cap_wrp.E.sym_pat
                    (Caux.mk_memop_pe (Mem_common.DeriveCap (Mem_common.DCbinary (A.Arithmetic A.Mul)) (AilTypesAux.is_signed_integer_type result_ty))
                      [obj1_wrp.E.sym_pe; obj2_wrp.E.sym_pe])
                    (Caux.mk_memop_pe Mem_common.CapAssignValue
                      [cap_wrp.E.sym_pe; stdlib.mkcall_wrapI result_ty core_mul])

(* else if AilTypesAux.is_signed_integer_type result_ty then
                 stdlib.mkcall_catch_exceptional_condition result_ty core_mul
else if AilTypesAux.is_integer result_ty then
                 stdlib.mkcall_wrapI result_ty core_mul
else
                 core_mul *)
else
                  Caux.mk_std_pe "§6.5.5#4" begin
                    with_wrapI_or_catch_exceptional_condition result_ty C.IOpMul
                      promoted1_pe promoted2_pe (Just core_mul)
                  end
               end )
            ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy1; C.BTy_loaded oTy2]),
               (* If either operand is unspecified, the result is also unspecified is the
                  result type of unsigned. Otherwise it is undef, since the multiplication
                  may overflow *)
if AilTypesAux.is_unsigned_integer_type result_ty then
               Caux.mk_unspecified_pe result_ty
else
               Caux.mk_undef_exceptional_condition loc) ]
        )
      )
    )
  end


val translate_div_mod_operator:
  Loc.t ->
  (A.expression GenTypes.genTypeCategory -> E.elabM (C.expr unit)) ->
  (Ctype.ctype -> Ctype.ctype -> C.pexpr -> C.pexpr -> C.pexpr * C.pexpr) ->
  translation_stdlib ->
  Ctype.ctype ->
  A.arithmeticOperator -> (* MUST BE A.Div or A.Mod *)
  A.expression GenTypes.genTypeCategory ->
  A.expression GenTypes.genTypeCategory ->
  E.elabM (C.expr unit)
let translate_div_mod_operator loc translate_expr usual_arithmetic_conversion stdlib result_ty aop e1 e2 =
  (* STD "§6.5.5" *)
  let oTy1    = force_core_object_type_of_ctype (ctype_of e1) in
  let oTy2    = force_core_object_type_of_ctype (ctype_of e2) in
  let oTy_res = force_core_object_type_of_ctype result_ty     in
  let zero_pe = match oTy_res with
    | C.OTy_integer ->
        Caux.mk_integer_pe 0
    | C.OTy_floating ->
        Caux.mk_floating_value_pe Mem.zero_fval
    | (*BISECT-IGNORE*) _ ->
      illTypedAil loc "AilEbinary Div, Mod"
  end in
  translate_expr e1                             >>= fun core_e1   ->
  translate_expr e2                             >>= fun core_e2   ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy1)    >>= fun e1_wrp    ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy2)    >>= fun e2_wrp    ->
  E.wrapped_fresh_symbol (C.BTy_object oTy1)    >>= fun obj1_wrp  ->
  E.wrapped_fresh_symbol (C.BTy_object oTy2)    >>= fun obj2_wrp  ->
  E.wrapped_fresh_symbol (C.BTy_object oTy_res) >>= fun conv1_wrp ->
  E.wrapped_fresh_symbol (C.BTy_object oTy_res) >>= fun conv2_wrp ->
  let (promoted1_pe, promoted2_pe) = Caux.mk_std_pair_pe "§6.5.5#3"
    (usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_wrp.E.sym_pe obj2_wrp.E.sym_pe) in
  let (ub, core_pe) = match aop with
    | A.Div ->
        ( Undefined.UB045a_division_by_zero
        , Caux.mk_op_pe C.OpDiv promoted1_pe conv2_wrp.E.sym_pe )
    | A.Mod ->
        ( Undefined.UB045b_modulo_by_zero
        , Caux.mk_op_pe C.OpRem_t conv1_wrp.E.sym_pe conv2_wrp.E.sym_pe )
    | (*BISECT-IGNORE*) _ ->
        error "[Translation.translate_div_mod_operator], 'aop' must be multiplicative"
  end in
  E.return begin
    Caux.add_std "§6.5.5" (
      Caux.mk_wseq_e (Caux.mk_tuple_pat [ e1_wrp.E.sym_pat; e2_wrp.E.sym_pat ]) (Caux.mk_unseq [core_e1; core_e2]) (
        Caux.mk_pure_e (
          Caux.mk_case_pe (Caux.mk_tuple_pe [e1_wrp.E.sym_pe; e2_wrp.E.sym_pe])
            [ ( Caux.mk_tuple_pat [ Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                                  ; Caux.mk_empty_pat (C.BTy_loaded oTy2) ]
              ,
if AilTypesAux.is_signed_integer_type result_ty then
                Caux.mk_undef_exceptional_condition loc
else
                Caux.mk_unspecified_pe result_ty )

            ; ( Caux.mk_tuple_pat [ Caux.mk_empty_pat (C.BTy_loaded oTy1)
                                  ; Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype) ]
              , Caux.mk_std_undef_pe loc "§6.5.5#5, sentence 2" ub )

            ; ( Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_wrp.E.sym_pat
                                  ; Caux.mk_specified_pat obj2_wrp.E.sym_pat ]
              , Caux.mk_let_pe conv1_wrp.E.sym_pat promoted1_pe (
                  Caux.mk_let_pe conv2_wrp.E.sym_pat promoted2_pe (
                    Caux.mk_if_pe (Caux.mk_op_pe C.OpEq conv2_wrp.E.sym_pe zero_pe)
                      (Caux.mk_std_undef_pe loc "§6.5.5#5, sentence 2" ub)
                      (* if a/b is representable *)
                      ( Caux.mk_if_pe (stdlib.mkcall_is_representable (Caux.mk_op_pe C.OpDiv promoted1_pe conv2_wrp.E.sym_pe) result_ty)
                          begin
                            Caux.mk_specified_pe (Caux.mk_std_pe "§6.5.5#5, sentence 1" begin
                              if AilTypesAux.is_signed_integer_type result_ty then
                                stdlib.mkcall_catch_exceptional_condition result_ty core_pe
                              else if AilTypesAux.is_integer result_ty then
                                stdlib.mkcall_wrapI result_ty core_pe
                              else
                                core_pe
                            end)
                          end
                          (Caux.mk_undef_pe loc Undefined.UB045c_quotient_not_representable) )
                    )
                  ) ) ]
          )
        )
      )
    end


(* STD §6.5.8 Relational operators *)
val translate_relational_operator:
  (A.expression GenTypes.genTypeCategory -> E.elabM (C.expr unit)) ->
  (Ctype.ctype -> Ctype.ctype -> C.pexpr -> C.pexpr -> C.pexpr * C.pexpr) ->
  Ctype.ctype ->
  A.binaryOperator -> (* MUST BE in { A.Lt, A.Gt. A.Le, A.Ge } *)
  A.expression GenTypes.genTypeCategory ->
  A.expression GenTypes.genTypeCategory ->
  E.elabM (C.expr unit)
let translate_relational_operator translate_expr usual_arithmetic_conversion result_ty bop e1 e2 =
  (* STD "§6.5.8" *)
  let oTy1 = force_core_object_type_of_ctype (ctype_of e1) in
  let oTy2 = force_core_object_type_of_ctype (ctype_of e2) in
  translate_expr e1                          >>= fun core_e1   ->
  translate_expr e2                          >>= fun core_e2   ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy1) >>= fun e1_wrp    ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy2) >>= fun e2_wrp    ->
  E.wrapped_fresh_symbol (C.BTy_object oTy1) >>= fun obj1_wrp  ->
  E.wrapped_fresh_symbol (C.BTy_object oTy2) >>= fun obj2_wrp  ->
  E.wrapped_fresh_symbol C.BTy_boolean       >>= fun memop_wrp ->
  (* The object type on which the Core operator is going to work on. *)
  (* From Ail's typing it is enough to look at the type of one of the operand (see STD §6.5.8#2) *)
  let real_bop = match bop with
    | A.Lt -> C.OpLt
    | A.Gt -> C.OpGt
    | A.Le -> C.OpLe
    | A.Ge -> C.OpGe
    | (*BISECT-IGNORE*) _ ->
        error "[Translation.translate_relational_operator], 'bop' must be relational"
  end in
  E.return begin
    Caux.add_std "§6.5.8" (
      Caux.mk_wseq_e (Caux.mk_tuple_pat [ e1_wrp.E.sym_pat; e2_wrp.E.sym_pat ]) (Caux.mk_unseq [core_e1; core_e2]) (
        Caux.mk_case_e (Caux.mk_tuple_pe [e1_wrp.E.sym_pe; e2_wrp.E.sym_pe])
            [ ( Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_wrp.E.sym_pat
                                  ; Caux.mk_specified_pat obj2_wrp.E.sym_pat ]
              ,
begin if AilTypesAux.is_real (ctype_of e1) then
                let (promoted1_pe, promoted2_pe) =
                  Caux.mk_std_pair_pe "§6.5.8#3"
                    (usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_wrp.E.sym_pe obj2_wrp.E.sym_pe) in
                Caux.add_std "§6.5.8#6" (
                  Caux.mk_pure_e (
                    Caux.mk_if_pe (Caux.mk_op_pe real_bop promoted1_pe promoted2_pe)
                      (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
                      (Caux.mk_specified_pe (Caux.mk_integer_pe 0))
                  )
                )
else
                let memop = match bop with
                  | A.Lt -> Mem_common.PtrLt
                  | A.Gt -> Mem_common.PtrGt
                  | A.Le -> Mem_common.PtrLe
                  | A.Ge -> Mem_common.PtrGe
                  | (*BISECT-IGNORE*) _ -> error "[Translation.translate_relational_operator], 'bop' must be relational"
                end in
                Caux.mk_wseq_e memop_wrp.E.sym_pat (C.Expr [] (C.Ememop memop [obj1_wrp.E.sym_pe; obj2_wrp.E.sym_pe])) (
                  Caux.add_std "§6.5.8#6" (
                    Caux.mk_pure_e (
                      Caux.mk_if_pe memop_wrp.E.sym_pe
                        (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
                        (Caux.mk_specified_pe (Caux.mk_integer_pe 0))
                    )
                  )
                )
end           )
            ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy1; C.BTy_loaded oTy2])
              , Caux.mk_pure_e (Caux.mk_unspecified_pe result_ty) ) ]
      )
   )
  end


(* STD §6.5.9 Equality operators *)
val translate_equality_operator:
  Loc.t -> 
  (A.expression GenTypes.genTypeCategory -> E.elabM (C.expr unit)) ->
  (Ctype.ctype -> Ctype.ctype -> C.pexpr -> C.pexpr -> C.pexpr * C.pexpr) ->
  Ctype.ctype ->
  A.binaryOperator -> (* MUST BE in { A.Eq, A.Ne } *)
  A.expression GenTypes.genTypeCategory ->
  A.expression GenTypes.genTypeCategory ->
  E.elabM (C.expr unit)
let translate_equality_operator loc translate_expr usual_arithmetic_conversion result_ty bop e1 e2 =
      (* STD §6.5.9 *)
if    Aaux.is_null_pointer_constant e1 && AilTypesAux.is_pointer (ctype_of e2)
   || AilTypesAux.is_pointer (ctype_of e1) && Aaux.is_null_pointer_constant e2 then
  (* equality test between a null pointer constant and pointer *)
  let e = if Aaux.is_null_pointer_constant e1 then e2 else e1 in
  let nullptr_pe = Caux.mk_std_pe "§6.5.9#5, sentence 2" (Caux.mk_nullptr_pe (ctype_of e)) in
  translate_expr e                                    >>= fun core_e    ->
  E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun e_wrp     ->
  E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun obj_wrp   ->
  E.wrapped_fresh_symbol C.BTy_boolean                >>= fun memop_wrp ->
  let memop = match bop with
    | A.Eq -> Mem_common.PtrEq
    | A.Ne -> Mem_common.PtrNe
    | (*BISECT-IGNORE*) _ ->
        error "[Translation.translate_equality_operator], 'bop' must be an equality operator"
  end in
  E.return begin
    Caux.mk_wseq_e e_wrp.E.sym_pat core_e begin
      Caux.mk_case_e e_wrp.E.sym_pe
        [ ( Caux.mk_specified_pat obj_wrp.E.sym_pat
          , Caux.mk_wseq_e memop_wrp.E.sym_pat (Caux.mk_memop_e memop [obj_wrp.E.sym_pe; nullptr_pe]) begin
              Caux.add_std "§6.5.9#3" begin
                Caux.mk_pure_e begin
                  Caux.mk_if_pe memop_wrp.E.sym_pe
                    (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
                    (Caux.mk_specified_pe (Caux.mk_integer_pe 0))
                end
              end
            end )
          ; ( Caux.mk_empty_pat (C.BTy_loaded C.OTy_pointer)
            , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.UB_CERB004_unspecified Undefined.UB_unspec_equality_ptr_vs_NULL)) ) ]
    end
  end

else (* operands both have arithmetic or pointer types *)
  (* The object type on which the Core operator is going to work on. *)
  let oTy1 = force_core_object_type_of_ctype (ctype_of e1) in
  let oTy2 = force_core_object_type_of_ctype (ctype_of e2) in
  E.wrapped_fresh_symbol (C.BTy_loaded oTy1) >>= fun e1_wrp    ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy2) >>= fun e2_wrp    ->
  E.wrapped_fresh_symbol (C.BTy_object oTy1) >>= fun obj1_wrp  ->
  E.wrapped_fresh_symbol (C.BTy_object oTy2) >>= fun obj2_wrp  ->
  E.wrapped_fresh_symbol C.BTy_boolean       >>= fun memop_wrp ->
  translate_expr e1                          >>= fun core_e1   ->
  translate_expr e2                          >>= fun core_e2   ->
  E.return begin
    Caux.mk_wseq_e (Caux.mk_tuple_pat [e1_wrp.E.sym_pat; e2_wrp.E.sym_pat]) (Caux.mk_unseq [core_e1; core_e2]) begin
if AilTypesAux.is_arithmetic (ctype_of e1) && AilTypesAux.is_arithmetic (ctype_of e2) then
  let mk_op_pe = match bop with
    | A.Eq -> Caux.mk_op_pe C.OpEq
    | A.Ne -> fun x y -> Caux.mk_not_pe (Caux.mk_op_pe C.OpEq x y)
    | (*BISECT-IGNORE*) _ ->
        error "[Translation.translate_equality_operator], 'bop' must be an equality operator"
  end in
      Caux.mk_pure_e begin
        Caux.mk_case_pe (Caux.mk_tuple_pe [e1_wrp.E.sym_pe; e2_wrp.E.sym_pe])
          [ ( Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_wrp.E.sym_pat; Caux.mk_specified_pat obj2_wrp.E.sym_pat ]
            , let (promoted1_pe, promoted2_pe) =
                Caux.mk_std_pair_pe "§6.5.9#4, sentence 1"
                  (usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_wrp.E.sym_pe obj2_wrp.E.sym_pe) in
              Caux.mk_std_pe "§6.5.9#3" begin
                Caux.mk_if_pe (Caux.mk_std_pe "§6.5.9#4, sentence 3" (mk_op_pe promoted1_pe promoted2_pe))
                  (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
                  (Caux.mk_specified_pe (Caux.mk_integer_pe 0))
              end )
          ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy1; C.BTy_loaded oTy2])
            , Caux.mk_unspecified_pe result_ty ) ]
      end

else (* both operand have pointer type *)
  let memop = match bop with
  | A.Eq -> Mem_common.PtrEq
  | A.Ne -> Mem_common.PtrNe
  | (*BISECT-IGNORE*) _ ->
      error "[Translation.translate_equality_operator], 'bop' must be an equality operator"
  end in
     (* NOTE: our modelling of ptr <-> ptr casting is the identity,
              so nothing is done here for (§6.5.9#5 sentence 3) *)
      Caux.mk_case_e (Caux.mk_tuple_pe [e1_wrp.E.sym_pe; e2_wrp.E.sym_pe])
        [ ( Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_wrp.E.sym_pat; Caux.mk_specified_pat obj2_wrp.E.sym_pat ]
          , Caux.mk_wseq_e memop_wrp.E.sym_pat (C.Expr [] (C.Ememop memop [obj1_wrp.E.sym_pe; obj2_wrp.E.sym_pe])) begin
              Caux.mk_pure_e begin
                Caux.mk_std_pe "§6.5.9#3" begin
                  Caux.mk_if_pe memop_wrp.E.sym_pe
                    (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
                    (Caux.mk_specified_pe (Caux.mk_integer_pe 0))
                end
              end
            end )
        ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy1; C.BTy_loaded oTy2])
          , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.UB_CERB004_unspecified Undefined.UB_unspec_equality_both_arith_or_ptr)) ) ]
    end
  end


(* STD §6.5.10  Bitwise AND operator          *)
(* STD §6.5.11  Bitwise exclusive OR operator *)
(* STD §6.5.12  Bitwise inclusive OR operator *)
val translate_bitwise_operator:
  Loc.t -> 
  (A.expression GenTypes.genTypeCategory -> E.elabM (C.expr unit)) ->
  (Ctype.ctype -> Ctype.ctype -> C.pexpr -> C.pexpr -> C.pexpr * C.pexpr) ->
  translation_stdlib ->
  Ctype.ctype ->
  A.arithmeticOperator -> (* MUST BE in { A.Band, A.Bxor, A.Bor } *)
  A.expression GenTypes.genTypeCategory ->
  A.expression GenTypes.genTypeCategory ->
  E.elabM (C.expr unit)
let translate_bitwise_operator loc translate_expr usual_arithmetic_conversion stdlib result_ty aop e1 e2 =
  let (std_id, stdlib_call) = match aop with
    | A.Band -> ("§6.5.10", (fun ty pe1 pe2 -> C.Pexpr [] () (C.PEctor C.CivAND [Caux.mk_ail_ctype_pe ty; pe1; pe2])))
    | A.Bxor -> ("§6.5.11", (fun ty pe1 pe2 -> C.Pexpr [] () (C.PEctor C.CivXOR [Caux.mk_ail_ctype_pe ty; pe1; pe2])))
    | A.Bor  -> ("§6.5.12", (fun ty pe1 pe2 -> C.Pexpr [] () (C.PEctor C.CivOR  [Caux.mk_ail_ctype_pe ty; pe1; pe2])))
    | (*BISECT-IGNORE*) _ ->
        error "[Translation.translate_bitwise_operator], 'bop' must be a bitwise operator"
  end in
  E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun e1_wrp   ->
  E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun e2_wrp   ->
  E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun obj1_wrp ->
  E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun obj2_wrp ->
  translate_expr e1                                   >>= fun core_e1  ->
  translate_expr e2                                   >>= fun core_e2  ->
  let (promoted1_pe, promoted2_pe) =
    Caux.mk_std_pair_pe (std_id ^ "#3")
      (usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_wrp.E.sym_pe obj2_wrp.E.sym_pe) in
  let core_bop = stdlib_call result_ty promoted1_pe promoted2_pe in
  E.return begin
    Caux.add_std std_id begin
      Caux.mk_wseq_e (Caux.mk_tuple_pat [ e1_wrp.E.sym_pat; e2_wrp.E.sym_pat ]) (Caux.mk_unseq_e [core_e1; core_e2]) begin
        Caux.mk_pure_e begin
          Caux.mk_case_pe (Caux.mk_tuple_pe [e1_wrp.E.sym_pe; e2_wrp.E.sym_pe])
            [ ( Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_wrp.E.sym_pat ; Caux.mk_specified_pat obj2_wrp.E.sym_pat ]
              , (* Both operand are specified *)
                Caux.mk_specified_pe (Caux.mk_std_pe (std_id ^ "#4") begin
                  if Global.is_CHERI () && Ctype.is_ptr_t result_ty then
                    mk_cheri_derive_and_assign_cap
                      (AilTypesAux.is_signed_integer_type result_ty)
                      (Mem_common.DCbinary (A.Arithmetic aop))
                      (obj1_wrp.E.sym_pe, obj2_wrp.E.sym_pe)
                      core_bop
                  else
                    core_bop
                end) )
            ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded C.OTy_integer; C.BTy_loaded C.OTy_integer])
              , Caux.mk_unspecified_pe result_ty ) ]
        end
      end
    end
  end


val translate_postfix:
  Loc.t -> 
  (A.expression GenTypes.genTypeCategory -> E.elabM (C.expr unit)) ->
  translation_stdlib ->
  Ctype.ctype ->
  A.unaryOperator -> (* MUST BE in { A.PostfixIncr, A.PostfixDecr } *)
  A.expression GenTypes.genTypeCategory ->
  E.elabM (C.expr unit)
let translate_postfix loc translate_expr stdlib result_ty op e =
  (* TODO: use atomic RMW if the type is atomic *)
  (* NOTE: if I read N2329 correctly, in C2X this will not be an RMW for the atomic case (but a do while
           with compare_exchange_weak with seq_cst, seq_cst) *)
  let (std_para, core_op, int_op, ptr_shift_const) =
    match op with
      | A.PostfixIncr ->
          ("#2", C.OpAdd, C.IOpAdd, 1)
      | A.PostfixDecr ->
          ("#3", C.OpSub, C.IOpSub, 0 - 1)
      | (*BISECT-IGNORE*) _ ->
          error "[Translation.translate_postfix], 'op' must be a postfix operator"
    end in
  let std_sentence_n (n: nat) = "§6.5.2.4" ^ std_para ^ ", sentence " ^ show n in
  (* STD §6.5.2.4 *)
  warn_atomic_elaboration (AilTypesAux.is_atomic (ctype_of e)) >>= fun () ->
  let ty  = AilTypesAux.rvalue_coercion (snd (from_lvalue_type e)) in
  let oTy = force_core_object_type_of_ctype ty    in
  let core_ty_e = Caux.mk_ail_ctype_pe ty in
  E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun lvalue_wrp ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy)           >>= fun load_wrp   ->
  E.wrapped_fresh_symbol (C.BTy_object oTy)           >>= fun obj_wrp    ->
  translate_expr e                                    >>= fun core_e     ->
  let mk_common () =
    E.return begin
      Caux.add_stds ["§6.5.2.4"; std_sentence_n 1; std_sentence_n 3] begin
        Caux.mk_wseq_e lvalue_wrp.E.sym_pat core_e begin
          Caux.seq_rmw loc false(* return the value of the load *) core_ty_e oTy lvalue_wrp.E.sym_pe load_wrp.E.sym_sym begin
            Caux.mk_case_pe load_wrp.E.sym_pe
              [ ( Caux.mk_specified_pat obj_wrp.E.sym_pat
                , Caux.mk_specified_pe begin
                    Caux.mk_std_pe (std_sentence_n 2)
match Ctype.unatomic_ ty with
  | Ctype.Basic (Ctype.Integer _) ->
                      (* TODO: check again *)
                      let mk_cheri pe =
                        let is_signed = AilTypesAux.is_signed_integer_type result_ty in
                        if Global.is_CHERI () && Ctype.is_ptr_t result_ty then
                          mk_cheri_derive_and_assign_cap is_signed
                          (Mem_common.DCunary op)
                          (obj_wrp.E.sym_pe, Caux.mk_nullcap_pe is_signed)
                          pe
                        else
                          pe in
                      let core_postfix = Caux.mk_op_pe core_op obj_wrp.E.sym_pe (Caux.mk_integer_pe 1) in
                      let promoted_ty =
                        fromJust "Translation.translate_postfix promotion"
                          (AilTypesAux.promotion (Implementation.integerImpl ()) (ctype_of e)) in
                      let promoted_e = stdlib.mkcall_conv_int promoted_ty obj_wrp.E.sym_pe in
                      stdlib.mkcall_conv_int result_ty begin
      mk_cheri begin
        with_wrapI_or_catch_exceptional_condition promoted_ty int_op
          promoted_e (Caux.maybe_annotate_integer_type_pexpr promoted_ty (Caux.mk_integer_pe 1))
          (Just core_postfix)
      end
                      end
  | Ctype.Basic (Ctype.Floating (Ctype.RealFloating _)) ->
                      (* NOTE: we are not modelling floating UBs *)
                      Caux.mk_op_pe core_op obj_wrp.E.sym_pe (Caux.mk_floating_value_pe Mem.one_fval)
  | Ctype.Pointer _ ref_ty ->
                      Caux.mk_array_shift obj_wrp.E.sym_pe ref_ty (Caux.mk_integer_pe ptr_shift_const)
  | (*BISECT-IGNORE*) _ ->
      illTypedAil loc "AilEunary PostfixIncr|PostfixDecr"
end
                  end )
              ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                , Caux.mk_unspecified_pe ty ) ]
          end
        end
      end
    end in
if Global.is_CHERI () then
  match Ctype.unatomic_ ty with
    | Ctype.Pointer _ ref_ty ->
        (* for CHERI we use the effectful array_shift operator *)
        (* TODO: the load + store are NOT atomic ==> need a new operator in the memory interface ... *)
        E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun shift_wrp ->
        E.return begin
          Caux.add_stds ["§6.5.2.4"; std_sentence_n 1; std_sentence_n 3] begin
            Caux.mk_wseq_e lvalue_wrp.E.sym_pat core_e begin
            Caux.mk_wseq_e load_wrp.E.sym_pat (Caux.pload loc core_ty_e lvalue_wrp.E.sym_pe Cmm.NA) begin
              Caux.mk_case_e load_wrp.E.sym_pe
                [ ( Caux.mk_specified_pat obj_wrp.E.sym_pat
                  , Caux.mk_wseq_e shift_wrp.E.sym_pat
                      (Caux.mk_memop_e Mem_common.PtrArrayShift [obj_wrp.E.sym_pe; Caux.mk_ail_ctype_pe ref_ty; Caux.mk_integer_pe ptr_shift_const])
                      begin
                        Caux.mk_wseq_e (Caux.mk_empty_pat C.BTy_unit)
                          begin
                            C.Expr [Annot.Astd (std_sentence_n 4)]
                              (C.Eaction (C.Paction C.Neg (C.Action loc default (C.Store false(* not locking *) core_ty_e lvalue_wrp.E.sym_pe (Caux.mk_specified_pe shift_wrp.E.sym_pe) Cmm.NA))))
                          end
                          (Caux.mk_pure_e load_wrp.E.sym_pe)
                      end )
                ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                  , Caux.mk_pure_e (Caux.mk_unspecified_pe ty) ) ]
            end end
          end
        end
    | _ ->
        mk_common ()
  end
else
  mk_common ()


val translate_assignment_conversion:
  (A.expression GenTypes.genTypeCategory -> E.elabM (C.expr unit)) ->
  translation_stdlib ->
  Ctype.ctype ->
  A.expression GenTypes.genTypeCategory ->
  E.elabM (C.core_object_type * C.expr unit * (C.pexpr -> C.pexpr))
let translate_assignment_conversion translate_expr stdlib ty1 e2 =
  let ty2 = Ctype.unatomic (ctype_of e2) in
  begin
    if AilTypesAux.atomic_qualified_unqualified AilTypesAux.is_array ty1 then
      translate_expr e2 >>= fun core_e2 ->
      E.return
        ( force_core_object_type_of_ctype ty2
        , core_e2
        , fun z -> z )
    else if AilTypesAux.atomic_qualified_unqualified AilTypesAux.is_arithmetic ty1 && AilTypesAux.is_arithmetic ty2 then
      translate_expr e2 >>= fun core_e2 ->
      E.return
        ( force_core_object_type_of_ctype ty2
        , core_e2
        , conv_loaded_arith stdlib ty2 (Ctype.unatomic ty1) )
    else if AilTypesAux.atomic_qualified_unqualified AilTypesAux.is_struct_or_union ty1 then
    (* NOTE: the two struct/union types could be from two different translation units,
             but as far as I can things are sufficiently restricted such that no conversion is needed here *)
      translate_expr e2 >>= fun core_e2 ->
      E.return
        ( force_core_object_type_of_ctype ty2
        , core_e2
        , fun z -> z )
    (* NOTE: we apply unatomic to ty1 because the left operand may be an atomic pointer to ... (STD §6.5.16.1#1, bullet 3) *)
    else match AilTypesAux.referenced_type (Ctype.unatomic ty1) with
      | Just ref_ty ->
          begin if Aaux.is_null_pointer_constant e2 then
            E.return
              ( C.OTy_pointer
              , Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_nullptr_pe ref_ty))
              , fun z -> z )
          else
            translate_expr e2 >>= fun core_e2 ->
            E.return
              ( (*C.OTy_pointer*) force_core_object_type_of_ctype ty2
              , core_e2
              , fun z -> z )
          end
      | Nothing ->
          (* By Ail's typing, e1 must have type _Bool and e2 must be a pointer *)
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun conv_wrp ->
          translate_expr e2 >>= fun core_e2 ->
          E.return
            ( C.OTy_integer
            , Caux.mk_wseq_e conv_wrp.E.sym_pat core_e2 (stdlib.mkproc_loaded_pointer_to_Bool conv_wrp.E.sym_pe)
            , fun z -> z )
    end
  end


val translate_function_call:
  Loc.t ->
  bool -> (* is_used *)
  (A.expression GenTypes.genTypeCategory -> E.elabM (C.expr unit)) ->
  translation_stdlib ->
  A.expression GenTypes.genTypeCategory ->
  list (A.expression GenTypes.genTypeCategory) ->
  E.elabM (C.expr unit)
let translate_function_call loc is_used translate_expr stdlib e es =
  (* TODO: is_used_pe is commented out because it requires some changes to CN to support it.
      But as a result currently a non-void function missing a return statement is deemed UB even when
      the value of the function call is NOT used by the caller. (which is explicitly excluded from the UB by the STD) *)
  (* let is_used_pe = Caux.mk_boolean_pe is_used in *)
  let (expect_ret_ty, expect_params, expect_is_variadic) =
    match ctype_of e with
      | Ctype.Ctype _ (Ctype.Pointer _ (Ctype.Ctype _ (Ctype.Function (_, ret_ty) qs_tys is_variadic))) ->
          (ret_ty, qs_tys, is_variadic)
      | (*BISECT-IGNORE*) _ ->
          illTypedAil loc "AilEcall"
    end in
  let expect_param_is_Bool n =
    match List.index expect_params n with
      | Just (_, ty, _) ->
        AilTypesAux.atomic_qualified_unqualified AilTypesAux.is_Bool ty
      | Nothing ->
          false
    end in
  E.get_calling_convention >>= fun callconv ->
  (* TODO: This is ignoring has_proto, §6.5.2.2#6 is not being considered! *)
  (* STD §6.5.2.2 *)
  E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun fun_wrp         ->
  E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun call_wrp        ->
  E.wrapped_fresh_symbol C.BTy_ctype                  >>= fun ret_wrp         ->
  E.wrapped_fresh_symbol (C.BTy_list C.BTy_ctype)     >>= fun params_wrp      ->
  E.wrapped_fresh_symbol C.BTy_boolean                >>= fun is_variadic_wrp ->
  E.wrapped_fresh_symbol C.BTy_boolean                >>= fun has_proto_wrp   ->
  (* elaborate the expression that denotes the called function *)
  translate_expr e >>= fun core_e ->
  (* symbolic names for the arguments temporary objects *)
  let n_args = List.length es in
  let arg_ptr_syms = mapi (fun i arg_e -> Symbol.fresh_funarg (locOf arg_e) i) es in
  let arg_ptr_sym_pats = List.map (fun sym -> Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer)) arg_ptr_syms in
  let arg_ptr_sym_pes = List.map Caux.mk_sym_pe arg_ptr_syms in
  (* elaborate each argument *)
  E.foldlM (fun (n, arg_sym_pats, core_arg_es, args_info) arg_e ->
    begin if expect_param_is_Bool n && AilTypesAux.is_pointer (ctype_of arg_e) then
      E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun conv_wrp ->
      E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun arg_wrp  ->
      translate_expr arg_e                                >>= fun core_e   ->
      E.return
        ( arg_wrp
        , Caux.mk_wseq_e conv_wrp.E.sym_pat core_e (stdlib.mkproc_loaded_pointer_to_Bool conv_wrp.E.sym_pe) )
    else
      let arg_bTy = C.BTy_loaded (force_core_object_type_of_ctype (ctype_of arg_e)) in
      E.wrapped_fresh_symbol arg_bTy >>= fun arg_wrp ->
      translate_expr arg_e           >>= fun core_e  ->
      E.return (arg_wrp, core_e)
    end >>= fun (arg_wrp, core_arg_e) ->
    E.return  ( (n+1)
              , arg_wrp.E.sym_pat :: arg_sym_pats, core_arg_e :: core_arg_es
              , (ctype_of arg_e, Aaux.is_null_pointer_constant arg_e, arg_wrp.E.sym_pe) :: args_info )
  ) (0, [], [], []) es >>= fun (_, rev_arg_sym_pats, rev_core_arg_es, rev_args_info) ->
  (* create parameters and convert them *)
  let (args_info, variadic_args_info) = List.splitAt (List.length expect_params) (List.reverse rev_args_info) in
  (* standard arguments *)
  E.foldlM (fun (n, rev_core_creates) ((_, expect_param_ty, _), (arg_ty, arg_is_null, arg_sym_pe)) ->
    E.wrapped_fresh_symbol C.BTy_ctype                  >>= fun param_ty_wrp ->
    E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun arg_ptr_wrp  ->
    let expect_param_ty_pe = Caux.mk_ail_ctype_pe expect_param_ty in
    E.return
      ( n+1
      , (Caux.mk_let_e param_ty_wrp.E.sym_pat (stdlib.mkcall_params_nth params_wrp.E.sym_pe (Caux.mk_integer_pe n))
        (Caux.mk_if_e_ []
          (Caux.mk_not_pe (Caux.mk_are_compatible expect_param_ty_pe param_ty_wrp.E.sym_pe))
          (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#9" Undefined.UB041_function_not_compatible))
          begin
            let conv_value =
              if AilTypesAux.atomic_qualified_unqualified AilTypesAux.is_Bool expect_param_ty && AilTypesAux.is_pointer arg_ty then
                arg_sym_pe
              (* NOTE: since the expected type is compatible with the parameter type, if one is an integer or
                floating, the other one must also be an integer or floating (respectively) *)
              else if AilTypesAux.is_integer expect_param_ty then
                if AilTypesAux.is_integer arg_ty then
                  stdlib.mkcall_conv_loaded_int_ expect_param_ty_pe arg_sym_pe
                else
                  stdlib.mkcall_loaded_ivfromfloat_ expect_param_ty_pe arg_sym_pe
              else if AilTypesAux.is_floating expect_param_ty then
                if AilTypesAux.is_integer arg_ty then
                  stdlib.mkcall_loaded_fvfromint_ expect_param_ty_pe arg_sym_pe
                else
                  arg_sym_pe
              else if AilTypesAux.is_pointer expect_param_ty && arg_is_null then
                Caux.mk_specified_pe (Caux.mk_nullptr_pe expect_param_ty)
              else
                arg_sym_pe in
            let mo =
              if AilTypesAux.is_atomic expect_param_ty then
                (* STD §6.2.6.1#9 *)
                Cmm.Seq_cst
              else
                Cmm.NA in
            Caux.add_std "§6.5.2.2#7, sentence 1" begin
              Caux.mk_wseq_e arg_ptr_wrp.E.sym_pat
                (Caux.pcreate loc (Caux.mk_alignof_pe expect_param_ty_pe) expect_param_ty_pe (Symbol.PrefFunArg loc (Symbol.digest ()) (intFromInteger n)))
                begin
                  Caux.mk_wseq_e (Caux.mk_empty_pat C.BTy_unit)
                    (Caux.pstore loc expect_param_ty_pe arg_ptr_wrp.E.sym_pe conv_value mo)
                    (Caux.mk_pure_e arg_ptr_wrp.E.sym_pe)
                end
            end
          end
        )) :: rev_core_creates )
  ) (0,[]) (List.zip expect_params args_info) >>= fun (_, rev_core_creates) ->
  match callconv with
  | C.Inner_arg_callconv ->
    (* standard arguments (CN elaboration switch) *)
    E.foldlM (fun (n, cn_core_args) ((_, expect_param_ty, _), (arg_ty, arg_is_null, arg_sym_pe)) ->
      E.wrapped_fresh_symbol C.BTy_ctype                  >>= fun param_ty_wrp ->
      E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun arg_ptr_wrp ->
      let expect_param_ty_pe = Caux.mk_ail_ctype_pe expect_param_ty in
      E.return
        ( n+1
        , (Caux.mk_let_pe param_ty_wrp.E.sym_pat (stdlib.mkcall_params_nth params_wrp.E.sym_pe (Caux.mk_integer_pe n))
          (Caux.mk_if_pe
            (Caux.mk_not_pe (Caux.mk_are_compatible expect_param_ty_pe param_ty_wrp.E.sym_pe))
            (Caux.mk_std_undef_pe loc "§6.5.2.2#9" Undefined.UB041_function_not_compatible)
            begin
              (* NOTE: since the expected type is compatible with the parameter type,
                if one is an integer or floating, the other one must also be an integer or floating (respectively) *)
              if AilTypesAux.is_integer expect_param_ty then
                if AilTypesAux.is_integer arg_ty then
                  stdlib.mkcall_conv_loaded_int_ expect_param_ty_pe arg_sym_pe
                else
                  stdlib.mkcall_loaded_ivfromfloat_ expect_param_ty_pe arg_sym_pe
              else if AilTypesAux.is_floating expect_param_ty then
                if AilTypesAux.is_integer arg_ty then
                  stdlib.mkcall_loaded_fvfromint_ expect_param_ty_pe arg_sym_pe
                else
                  arg_sym_pe
              else if AilTypesAux.is_pointer expect_param_ty && arg_is_null then
                Caux.mk_specified_pe (Caux.mk_nullptr_pe expect_param_ty)
              else
                arg_sym_pe
            end
          )) :: cn_core_args )
    ) (0,[]) (List.zip expect_params args_info)
  | C.Normal_callconv ->
    (* dummy empty list we are not using *)
    E.return (0, [])
  end >>= fun (_, rev_cn_core_args) ->
  (* variadic arguments *)
  E.foldlM (fun (rev_arg_tys, rev_arg_ty_pes, rev_variadic_core_creates) (arg_ty, arg_is_null, arg_sym_pe) ->
    let (conv_ty, conv_value) =
      if AilTypesAux.is_integer arg_ty then
        let prom_ty = fromJust "translation: default arguments promotion" (AilTypesAux.promotion (Implementation.integerImpl ()) arg_ty) in
        (prom_ty, stdlib.mkcall_conv_loaded_int prom_ty arg_sym_pe)
      else if AilTypesAux.is_floating arg_ty then
        (Ctype.Ctype [] (Ctype.Basic (Ctype.Floating (Ctype.RealFloating Ctype.Double))), arg_sym_pe)
      else
        (arg_ty, arg_sym_pe)
    in E.return ( conv_ty :: rev_arg_tys
                , Caux.mk_ail_ctype_pe conv_ty :: rev_arg_ty_pes
                , Caux.add_std "§6.5.2.2#7, sentences 2 and 3" begin
                    stdlib.mkproc_create_and_store (Caux.mk_ail_ctype_pe conv_ty) conv_value
                  end :: rev_variadic_core_creates)
  ) ([], [],[]) variadic_args_info >>= fun (rev_arg_tys, rev_arg_ty_pes, rev_variadic_core_creates) ->
  (* function call result *)
  let call_bTy = maybe C.BTy_unit C.BTy_loaded (Caux.core_object_type_of_ctype expect_ret_ty) in
  E.wrapped_fresh_symbol call_bTy >>= fun call_ret_wrp ->
  (* kill temporary objects *)
  let killall_pat =
    if List.length arg_ptr_syms < 2 then
      Caux.mk_empty_pat C.BTy_unit
    else
      Caux.mk_empty_pat (C.BTy_tuple (List.replicate (List.length arg_ptr_syms) C.BTy_unit))
  in
  (* STD (§6.5.2.2#10, sentence 1) says there is sequence "point after the
    evaluations of the function designator and the actual arguments but before
    the actual call." *)
  E.return begin
    Caux.add_std "§6.5.2.2#10, sentence 1"
    (Caux.mk_sseq_e
      (Caux.mk_tuple_pat begin
        (Caux.mk_tuple_pat  [ call_wrp.E.sym_pat
                            ; Caux.mk_tuple_pat [ret_wrp.E.sym_pat; params_wrp.E.sym_pat; is_variadic_wrp.E.sym_pat; has_proto_wrp.E.sym_pat]])
          :: (List.reverse rev_arg_sym_pats)
      end)
      begin
        Caux.add_std "§6.5.2.2#4, sentence 2" begin
          Caux.mk_unseq_e begin
            (Caux.mk_sseq_e fun_wrp.E.sym_pat core_e
              (Caux.mk_pure_e (Caux.mk_tuple_pe [fun_wrp.E.sym_pe; Caux.mk_cfunction_pe fun_wrp.E.sym_pe])))
            :: (List.reverse rev_core_arg_es)
          end
        end
      end
begin if expect_is_variadic then
      (* check number of parameters *)
      (Caux.mk_if_e_ []
        (Caux.mk_not_pe (Caux.mk_op_pe C.OpLe (stdlib.mkcall_params_length params_wrp.E.sym_pe)
                                              (Caux.mk_integer_pe (integerFromNat n_args))))
        (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#6, sentence 3" Undefined.UB038_number_of_args))
        (* check if function types are compatible *)
        (Caux.mk_if_e_ []
          (Caux.mk_op_pe C.OpOr (Caux.mk_not_pe is_variadic_wrp.E.sym_pe)
                          (Caux.mk_not_pe (Caux.mk_are_compatible (Caux.mk_ail_ctype_pe expect_ret_ty) ret_wrp.E.sym_pe)))
          (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#9" Undefined.UB041_function_not_compatible))
match callconv with
| C.Inner_arg_callconv ->
    let (_, varg_ptr_sym_pats) = List.splitAt (List.length expect_params) arg_ptr_sym_pats in
          (Caux.mk_sseqs
            (* create temporary object for the additional arguments *)
            (List.zip varg_ptr_sym_pats (List.reverse rev_variadic_core_creates))
            (Caux.mk_sseq_e call_ret_wrp.E.sym_pat
              (* do the function call *)
              (Caux.mk_ccall_e (Caux.mk_ail_ctype_pe (ctype_of e)) call_wrp.E.sym_pe
                (let (_, varg_ptr_sym_pes) = List.splitAt (List.length expect_params) arg_ptr_sym_pes in
                  let varargs_ty_pes =
                    List.map (fun (ty_pe, pe) -> Caux.mk_tuple_pe [ty_pe; pe])
                      (List.zip (List.reverse rev_arg_ty_pes) varg_ptr_sym_pes) in
                  let varargs_ty_pes_type = 
                    C.BTy_tuple [C.BTy_ctype; (C.BTy_object C.OTy_pointer)] in
                  (*is_used_pe :: *) List.reverse rev_cn_core_args ++ [Caux.mk_list_pe varargs_ty_pes_type varargs_ty_pes]
                )
              )
              (
                let arg_ptr_syms_tys =
                  List.zip (snd (List.splitAt (List.length expect_params) arg_ptr_syms))
                    ((*List.map (fun (_, ty, _) -> ty) expect_params ++ *) List.reverse rev_arg_tys) in
                let killall_pat =
                  let len = List.length arg_ptr_syms_tys in
                  if len < 2 then
                    Caux.mk_empty_pat C.BTy_unit
                  else
                    Caux.mk_empty_pat (C.BTy_tuple (List.replicate len C.BTy_unit)) in
                Caux.mk_sseq_e killall_pat
                  (* kill temporary objects *)
                  (Caux.mk_unseq (List.map (fun (sym,ct) -> Caux.pkill loc (C.Static ct) (Caux.mk_sym_pe sym)) arg_ptr_syms_tys))
                  (* return function call result *)
                  (Caux.mk_pure_e call_ret_wrp.E.sym_pe)
              )
            )
          )
| C.Normal_callconv ->
          (Caux.mk_sseqs
            (* create temporary object *)
            (List.zip arg_ptr_sym_pats (List.reverse rev_core_creates ++ List.reverse rev_variadic_core_creates))
            (Caux.mk_sseq_e call_ret_wrp.E.sym_pat
              (* do the function call *)
              (Caux.mk_ccall_e (Caux.mk_ail_ctype_pe (ctype_of e)) call_wrp.E.sym_pe
                (let (arg_pes, vararg_pes) = List.splitAt (List.length expect_params) arg_ptr_sym_pes in
                  let varargs_ty_pes =
                    List.map (fun (ty_pe, pe) -> Caux.mk_tuple_pe [ty_pe; pe])
                      (List.zip (List.reverse rev_arg_ty_pes) vararg_pes) in
                  let varargs_ty_pes_type = 
                    C.BTy_tuple [C.BTy_ctype; (C.BTy_object C.OTy_pointer)] in
                  (*is_used_pe :: *) arg_pes ++ [Caux.mk_list_pe varargs_ty_pes_type varargs_ty_pes]
                )
              )
              (Caux.mk_sseq_e killall_pat
                (* kill temporary objects *)
                (let arg_ptr_syms_tys =
                  List.zip arg_ptr_syms
                    (List.map (fun (_, ty, _) -> ty) expect_params ++ List.reverse rev_arg_tys) in
                  Caux.mk_unseq (List.map (fun (sym,ct) -> Caux.pkill loc (C.Static ct) (Caux.mk_sym_pe sym)) arg_ptr_syms_tys))
                (* return function call result *)
                (Caux.mk_pure_e call_ret_wrp.E.sym_pe)
              )
            )
          )
end
        )
      )
else
      (* check number of parameters *)
      (Caux.mk_if_e_ []
        (Caux.mk_not_pe (Caux.mk_op_pe C.OpEq (stdlib.mkcall_params_length params_wrp.E.sym_pe)
                                              (Caux.mk_integer_pe (integerFromNat n_args))))
        (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#6, sentence 3" Undefined.UB038_number_of_args))
        (* check if function types are compatible *)
        (Caux.mk_if_e_ []
          (Caux.mk_op_pe C.OpOr is_variadic_wrp.E.sym_pe
                          (Caux.mk_not_pe (Caux.mk_are_compatible (Caux.mk_ail_ctype_pe expect_ret_ty) ret_wrp.E.sym_pe)))
          (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#9" Undefined.UB041_function_not_compatible))
match callconv with
| C.Inner_arg_callconv ->
          (Caux.mk_ccall_e (Caux.mk_ail_ctype_pe (ctype_of e)) call_wrp.E.sym_pe ((*is_used_pe :: *)List.reverse rev_cn_core_args))
| C.Normal_callconv ->
            (* create temporary object *)
            (Caux.mk_sseqs (List.zip arg_ptr_sym_pats (List.reverse rev_core_creates))
            (Caux.mk_sseq_e call_ret_wrp.E.sym_pat
              (* do the function call *)
              (Caux.mk_ccall_e (Caux.mk_ail_ctype_pe (ctype_of e)) call_wrp.E.sym_pe
              
              
            (
              let (arg_pes, vararg_pes) = List.splitAt (List.length expect_params) arg_ptr_sym_pes in
              let varargs_ty_pes =
                List.map (fun (ty_pe, pe) -> Caux.mk_tuple_pe [ty_pe; pe])
                  (List.zip (List.reverse rev_arg_ty_pes) vararg_pes) in
              let varargs_ty_pes_type =
                C.BTy_tuple [C.BTy_ctype; (C.BTy_object C.OTy_pointer)] in
              if expect_is_variadic then
                (*is_used_pe :: *) arg_pes ++ [Caux.mk_list_pe varargs_ty_pes_type varargs_ty_pes]
              else
                (*is_used_pe :: *) arg_pes
            )
              )
              (Caux.mk_sseq_e killall_pat
                (* kill temporary objects *)
                (let arg_ptr_syms_tys = List.map (fun (sym, (_, ty, _)) -> (sym, ty)) (List.zip arg_ptr_syms expect_params) in
                  Caux.mk_unseq (List.map (fun (sym,ct) -> Caux.pkill loc (C.Static ct) (Caux.mk_sym_pe sym)) arg_ptr_syms_tys))
                (* return function call result *)
                (Caux.mk_pure_e call_ret_wrp.E.sym_pe)
              )
            )
          )
end
        )
      )
end
    )
  end

type atomic_explicit =
  | AtomicStoreExplicit
  | AtomicLoadExplicit
  | AtomicThreadFence
  | AtomicCompareExchangeStrongExplicit
  | AtomicCompareExchangeWeakExplicit
  | LinuxStore
  | LinuxLoad
  | LinuxFence
  | LinuxRMW

let translate_atomic_explicit loc translate_expr atomic_op args =
  match (atomic_op, args) with
    | (AtomicStoreExplicit, [lobject_e; desired_e; order_e]) ->
        let mo = translate_memory_order order_e in
        let ref_ty = match ctype_of lobject_e with
          | Ctype.Ctype _ (Ctype.Pointer _ ref_ty) ->
              ref_ty
          | (*BISECT-IGNORE*) _ ->
              illTypedAil loc "AilEcall atomic_store_explicit"
        end in
        let oTy = force_core_object_type_of_ctype (ctype_of desired_e) in
        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun loaded_wrp     ->
        E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun object_wrp     ->
        E.wrapped_fresh_symbol (C.BTy_loaded oTy)           >>= fun desired_wrp    ->
        translate_expr lobject_e                            >>= fun lobject_core_e ->
        translate_expr desired_e                            >>= fun desired_core_e ->
        E.return begin
          Caux.mk_sseq_e (Caux.mk_tuple_pat [loaded_wrp.E.sym_pat; desired_wrp.E.sym_pat])
            begin
              Caux.mk_unseq_e [lobject_core_e; desired_core_e]
            end
            begin
              Caux.mk_case_e loaded_wrp.E.sym_pe
                [ ( Caux.mk_specified_pat object_wrp.E.sym_pat
                  , Caux.pstore loc (Caux.mk_ail_ctype_pe ref_ty) object_wrp.E.sym_pe desired_wrp.E.sym_pe mo )
                ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                  , Caux.mk_pure_e (Caux.mk_undef_pe loc Undefined.UB_unspecified_lvalue) ) ]
            end
        end
    | (AtomicLoadExplicit, [lobject_e; order_e]) ->
        let mo = translate_memory_order order_e in
        let ref_ty = match ctype_of lobject_e with
          | Ctype.Ctype _ (Ctype.Pointer _ ref_ty) ->
              ref_ty
          | (*BISECT-IGNORE*) _ ->
              illTypedAil loc "AilEcall atomic_load_explicit"
        end in
        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun loaded_wrp     ->
        E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun object_wrp     ->
        translate_expr lobject_e                            >>= fun lobject_core_e ->
        E.return begin
          Caux.mk_sseq_e loaded_wrp.E.sym_pat lobject_core_e
            begin
              Caux.mk_case_e loaded_wrp.E.sym_pe
                [ ( Caux.mk_specified_pat object_wrp.E.sym_pat
                  , Caux.pload loc (Caux.mk_ail_ctype_pe ref_ty) object_wrp.E.sym_pe mo )
                ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                  , Caux.mk_pure_e (Caux.mk_undef_pe loc Undefined.UB_unspecified_lvalue) ) ]
            end
        end
    | (AtomicThreadFence, [order_e]) ->
        (* TODO: allow non trivial call to atomic_thread_fence() ... *)
        let mo = translate_memory_order order_e in
        E.return begin
          C.Expr [] (C.Eaction (C.Paction C.Pos (C.Action loc () (C.Fence mo))))
        end
    | (AtomicCompareExchangeStrongExplicit, [object_e; expected_e; desired_e; order_success_e; order_failure_e]) ->
        let mo_success = translate_memory_order order_success_e in
        let mo_failure = translate_memory_order order_failure_e in
        let (ty1,ty2) = match (ctype_of object_e, ctype_of expected_e) with
          | (Ctype.Ctype _ (Ctype.Pointer _ ty1), Ctype.Ctype _ (Ctype.Pointer _ ty2)) ->
              (ty1,ty2)
          | (*BISECT-IGNORE*) _ ->
              illTypedAil loc "AilEcall atomic_compare_exchange_strong_explicit"
        end in
        let oTy = force_core_object_type_of_ctype (ctype_of desired_e) in
        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun loaded_object_wrp   ->
        E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun object_wrp          ->
        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun loaded_expected_wrp ->
        E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun expected_wrp        ->
        E.wrapped_fresh_symbol (C.BTy_loaded oTy)           >>= fun desired_wrp         ->
        translate_expr object_e                             >>= fun core_object_e       ->
        translate_expr expected_e                           >>= fun core_expected_e     ->
        translate_expr desired_e                            >>= fun core_desired_e      ->
        (* NOTE: we don't need to convert the arguments because the Ail typing has added casts *)
        E.return begin
          Caux.mk_sseq_e (Caux.mk_tuple_pat [ loaded_object_wrp.E.sym_pat; loaded_expected_wrp.E.sym_pat; desired_wrp.E.sym_pat ])
            (Caux.mk_unseq_e [ core_object_e; core_expected_e; core_desired_e ])
            begin
              Caux.mk_case_e (Caux.mk_tuple_pe [ loaded_object_wrp.E.sym_pe; loaded_expected_wrp.E.sym_pe ])
                [ ( Caux.mk_tuple_pat [ Caux.mk_specified_pat object_wrp.E.sym_pat
                                      ; Caux.mk_specified_pat expected_wrp.E.sym_pat ]
                  , Caux.pcompare_exchange_strong
                      loc (Caux.mk_ail_ctype_pe (Ctype.Ctype [] (Ctype.unatomic_ ty1)))
                      object_wrp.E.sym_pe expected_wrp.E.sym_pe desired_wrp.E.sym_pe
                      mo_success mo_failure )
                ; ( Caux.mk_empty_pat (C.BTy_tuple [ C.BTy_loaded C.OTy_pointer
                                                   ; C.BTy_loaded C.OTy_pointer ])
                  , Caux.mk_pure_e
                      (Caux.mk_undef_pe loc Undefined.UB_unspecified_lvalue) ) ]
            end
        end
    | (AtomicCompareExchangeWeakExplicit, [object_e; expected_e; desired_e; order_success_e; order_failure_e]) ->
      let mo_success = translate_memory_order order_success_e in
      let mo_failure = translate_memory_order order_failure_e in
      let (ty1,ty2) = match (ctype_of object_e, ctype_of expected_e) with
        | (Ctype.Ctype _ (Ctype.Pointer _ ty1), Ctype.Ctype _ (Ctype.Pointer _ ty2)) ->
            (ty1,ty2)
        | (*BISECT-IGNORE*) _ ->
            illTypedAil loc "AilEcall atomic_compare_exchange_weak_explicit"
      end in
      let oTy = force_core_object_type_of_ctype (ctype_of desired_e) in
      E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun loaded_object_wrp   ->
      E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun object_wrp          ->
      E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun loaded_expected_wrp ->
      E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun expected_wrp        ->
      E.wrapped_fresh_symbol (C.BTy_loaded oTy)           >>= fun desired_wrp         ->
      translate_expr object_e                             >>= fun core_object_e       ->
      translate_expr expected_e                           >>= fun core_expected_e     ->
      translate_expr desired_e                            >>= fun core_desired_e      ->
      (* NOTE: we don't need to convert the arguments because the Ail typing has added casts *)
      E.return begin
        Caux.mk_sseq_e (Caux.mk_tuple_pat [ loaded_object_wrp.E.sym_pat; loaded_expected_wrp.E.sym_pat; desired_wrp.E.sym_pat ])
          (Caux.mk_unseq_e [ core_object_e; core_expected_e; core_desired_e ])
          begin
            Caux.mk_case_e (Caux.mk_tuple_pe [ loaded_object_wrp.E.sym_pe; loaded_expected_wrp.E.sym_pe ])
              [ ( Caux.mk_tuple_pat [ Caux.mk_specified_pat object_wrp.E.sym_pat
                                    ; Caux.mk_specified_pat expected_wrp.E.sym_pat ]
                , Caux.pcompare_exchange_weak
                    loc (Caux.mk_ail_ctype_pe (Ctype.Ctype [] (Ctype.unatomic_ ty1)))
                    object_wrp.E.sym_pe expected_wrp.E.sym_pe desired_wrp.E.sym_pe
                    mo_success mo_failure )
              ; ( Caux.mk_empty_pat (C.BTy_tuple [ C.BTy_loaded C.OTy_pointer
                                                 ; C.BTy_loaded C.OTy_pointer ])
                , Caux.mk_pure_e (Caux.mk_undef_pe loc Undefined.UB_unspecified_lvalue) ) ]
          end
      end
    | (LinuxStore, [lobject_e; desired_e; order_e]) ->
        let mo = translate_linux_memory_order order_e in
        let ref_ty = match ctype_of lobject_e with
          | Ctype.Ctype _ (Ctype.Pointer _ ref_ty) ->
              ref_ty
          | (*BISECT-IGNORE*) _ ->
              illTypedAil loc "AilEcall linux_write"
        end in
        let oTy = force_core_object_type_of_ctype (ctype_of desired_e) in
        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun loaded_wrp     ->
        E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun object_wrp     ->
        E.wrapped_fresh_symbol (C.BTy_loaded oTy)           >>= fun desired_wrp    ->
        translate_expr lobject_e                            >>= fun lobject_core_e ->
        translate_expr desired_e                            >>= fun desired_core_e ->
        E.return begin
          Caux.mk_sseq_e (Caux.mk_tuple_pat [loaded_wrp.E.sym_pat; desired_wrp.E.sym_pat])
            begin
              Caux.mk_unseq_e [lobject_core_e; desired_core_e]
            end
            begin
              Caux.mk_case_e loaded_wrp.E.sym_pe
                [ ( Caux.mk_specified_pat object_wrp.E.sym_pat
                  , Caux.plinux_store loc (Caux.mk_ail_ctype_pe ref_ty) object_wrp.E.sym_pe desired_wrp.E.sym_pe mo )
                ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                  , Caux.mk_pure_e (Caux.mk_undef_pe loc Undefined.UB_unspecified_lvalue) ) ]
            end
        end
    | (LinuxLoad, [lobject_e; order_e]) ->
         let mo = translate_linux_memory_order order_e in
         let ref_ty = match ctype_of lobject_e with
           | Ctype.Ctype _ (Ctype.Pointer _ ref_ty) ->
               ref_ty
           | (*BISECT-IGNORE*) _ ->
               illTypedAil loc "AilEcall linux_read"
         end in
         E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun loaded_wrp     ->
         E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun object_wrp     ->
         translate_expr lobject_e                            >>= fun lobject_core_e ->
         E.return begin
           Caux.mk_sseq_e loaded_wrp.E.sym_pat lobject_core_e
             begin
               Caux.mk_case_e loaded_wrp.E.sym_pe
                 [ ( Caux.mk_specified_pat object_wrp.E.sym_pat
                   , Caux.plinux_load loc (Caux.mk_ail_ctype_pe ref_ty) object_wrp.E.sym_pe mo )
                 ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                   , Caux.mk_pure_e (Caux.mk_undef_pe loc Undefined.UB_unspecified_lvalue) ) ]
             end
         end
    | (LinuxFence, [order_e]) ->
        let mo = translate_linux_memory_order order_e in
        E.return begin
          C.Expr [] (C.Eaction (C.Paction C.Pos (C.Action loc () (C.LinuxFence mo))))
        end
    | (LinuxRMW, [lobject_e; desired_e; order_e]) ->
        let mo = translate_linux_memory_order order_e in
        let ref_ty = match ctype_of lobject_e with
          | Ctype.Ctype _ (Ctype.Pointer _ ref_ty) ->
              ref_ty
          | (*BISECT-IGNORE*) _ ->
              illTypedAil loc "AilEcall linux_rmw"
        end in
        let oTy = force_core_object_type_of_ctype (ctype_of desired_e) in
        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun loaded_wrp     ->
        E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun object_wrp     ->
        E.wrapped_fresh_symbol (C.BTy_loaded oTy)           >>= fun desired_wrp    ->
        translate_expr lobject_e                            >>= fun lobject_core_e ->
        translate_expr desired_e                            >>= fun desired_core_e ->
        E.return begin
          Caux.mk_sseq_e (Caux.mk_tuple_pat [loaded_wrp.E.sym_pat; desired_wrp.E.sym_pat])
            (Caux.mk_unseq_e [lobject_core_e; desired_core_e])
            begin
              Caux.mk_case_e loaded_wrp.E.sym_pe
                [ ( Caux.mk_specified_pat object_wrp.E.sym_pat
                  , Caux.plinux_rmw loc (Caux.mk_ail_ctype_pe ref_ty) object_wrp.E.sym_pe desired_wrp.E.sym_pe mo )
                ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                  , Caux.mk_pure_e (Caux.mk_undef_pe loc Undefined.UB_unspecified_lvalue) ) ]
            end
        end
    | (*BISECT-IGNORE*) _ ->
        error "Translation.translate_explicit_atomic"
  end


type expr_ctx =
  | ECTX_glob of Symbol.sym * Symbol.sym
  | ECTX_logical_operator (* when elborating the desugaring of && or || *)
  | ECTX_other

val translate_expression:
  bool -> (* whether the value of the expression is used (i.e. the expression is directly applied to AilSexpr) *)
  expr_ctx ->
  (maybe Symbol.sym * maybe Symbol.sym) ->
  translation_stdlib ->
  Core.core_tag_definitions ->
  A.expression GenTypes.genTypeCategory ->
  E.elabM (C.expr unit)
let rec translate_expression is_used ctx variadic_env stdlib tagDefs a_expr =
  let self = translate_expression true ctx variadic_env stdlib tagDefs in
  let is_lvalue = match GenTypes.genTypeCategoryOf a_expr with
    | GenTypes.GenLValueType _ _ _ ->
        true
    | GenTypes.GenRValueType _ ->
        false
  end in
  let integer_promotion_and_type (ty: Ctype.ctype) : (C.pexpr -> C.pexpr) * Ctype.integerType =
    let promoted_ty = fromJust "Translation_aux.integer_promotion" (AilTypesAux.promotion (Implementation.integerImpl ()) ty) in
    let promoted_ity = match promoted_ty with
      | Ctype.Ctype _ (Ctype.Basic (Ctype.Integer ity)) -> ity
      | _ -> Assert_extra.failwith "impossible"
    end in
    (stdlib.mkcall_conv_int promoted_ty, promoted_ity) in
  let integer_promotion ty e = 
    let (mk_conversion, promoted_type) = integer_promotion_and_type ty in
    mk_conversion e in
  (* STD §6.3.1.8 *)
  let usual_arithmetic_conversion_aux is_TMP_new (ty1: Ctype.ctype) (ty2: Ctype.ctype) (e1: C.pexpr) (e2: C.pexpr) : C.pexpr * C.pexpr =
    match (AilTypesAux.corresponding_real_type ty1, AilTypesAux.corresponding_real_type ty2) with
      (* TODO/NOTE: we convert (long double, double and float) to Ocaml float! This is not the C11 behaviour! *)
      | (Just _, Just _) ->
          (e1, e2)
      | (Just _, _) ->
          (e1, C.Pexpr [] () (C.PEctor C.Cfvfromint [e2]))
      | (_, Just _) ->
          (C.Pexpr [] () (C.PEctor C.Cfvfromint [e1]), e2)
      | (Nothing, Nothing) ->
          let mk_conv_int ity pe =
            if is_TMP_new then
              Caux.mk_conv_int_pe ity pe
            else
              stdlib.mkcall_conv_int (Ctype.Ctype [] (Ctype.Basic (Ctype.Integer ity))) pe in
          (* STD §6.3.1.8#1, bullet 4 *)
          match (AilTypesAux.promotion (Implementation.integerImpl ()) ty1, AilTypesAux.promotion (Implementation.integerImpl ()) ty2) with
            | (Just (Ctype.Ctype _ (Ctype.Basic (Ctype.Integer ity1')) as ty1'), Just (Ctype.Ctype _ (Ctype.Basic (Ctype.Integer ity2')) as ty2')) ->
                (* "If both operants have the same type, then no further conversion is needed." *)
                if ty1' = ty2' then
                  (mk_conv_int ity1' e1, mk_conv_int ity2' e2)
                (* "Otherwise, if both operands have signed integer types or both have unsigned integer types,
                    the operand with the type of lesser integer conversion rank is converted to the type
                    of the operand with greater rank." *)
                else if   (AilTypesAux.is_signed_integer_type ty1' && AilTypesAux.is_signed_integer_type ty2')
                       || (AilTypesAux.is_unsigned_integer_type ty1' && AilTypesAux.is_unsigned_integer_type ty2') then
                  if AilTypesAux.lt_integer_rank ity1' ity2' then
                    (mk_conv_int ity2' e1, mk_conv_int ity2' e2)
                  else
                    (mk_conv_int ity1' e1, mk_conv_int ity1' e2)
                (* "Otherwise, if the operand that has unsigned type has rank greater or equal to the rank of the
                    rank of the type of the other operand, then the operand with signed integer type is converted
                    to the type of the operand with unsigned integer type." *)
                else if AilTypesAux.is_unsigned_integer_type ty1' && AilTypesAux.ge_integer_rank ity1' ity2' then
                  (mk_conv_int ity1' e1, mk_conv_int ity1' e2)
                else if AilTypesAux.is_unsigned_integer_type ty2' && AilTypesAux.ge_integer_rank ity2' ity1' then
                  (mk_conv_int ity2' e1, mk_conv_int ity2' e2)
                (* "Otherwise, if the type of the operand with signed integer type can represent all of the values
                    of the type of the operand with unsigned integer type, then the operand with unsigned integer
                    type is converted to the type of the operand with signed integer type." *)
                else if AilTypesAux.is_signed_integer_type ty1' then
                  (Caux.mk_if_pe (stdlib.mkcall_all_values_representable_in ty2' ty1')
                     (mk_conv_int ity1' e1)
                     (* "Otherwise, both operands are converted to the unsigned integer type corresponding to the type
                         of the operand with signed integer type". *)
                     (mk_conv_int (AilTypesAux.make_corresponding_unsigned ity1') e1)
                  ,
                  Caux.mk_if_pe (stdlib.mkcall_all_values_representable_in ty2' ty1')
                     (mk_conv_int ity1' e2)
                     (mk_conv_int (AilTypesAux.make_corresponding_unsigned ity1') e2)
                  )
                else
                  (Caux.mk_if_pe (stdlib.mkcall_all_values_representable_in ty1' ty2')
                     (mk_conv_int ity2' e1)
                     (mk_conv_int (AilTypesAux.make_corresponding_unsigned ity2') e1)
                  ,
                  Caux.mk_if_pe (stdlib.mkcall_all_values_representable_in ty1' ty2')
                     (mk_conv_int ity2' e2)
                     (mk_conv_int (AilTypesAux.make_corresponding_unsigned ity2') e2)
                  )
            | _ ->
                error "Translation.usual_arithmetic_conversion: not (integer vs integer)"
          end
      end in
  let usual_arithmetic_conversion = usual_arithmetic_conversion_aux false in
  let usual_arithmetic_conversion_TMP_new = usual_arithmetic_conversion_aux true in
  let result_ty = ctype_of a_expr in
  if AilTypesAux.is_pointer result_ty && Aaux.is_null_pointer_constant a_expr then
    (* NOTE: this is a bit tasteless as it makes the case AilEconst, ConstantNull unreachable *)
    E.return (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_nullptr_pe result_ty)))
  else
    let A.AnnotatedExpression annot std_annots loc expr = a_expr in
    (comb (comb (Caux.add_loc loc) Caux.add_expr)
          (if is_lvalue then (fun z -> z) else Caux.maybe_annotate_integer_type result_ty)) <$>
      match expr with
      | A.AilEunary A.Plus e ->
          (* STD §6.5.3.3#2 *)
          let (oTy, mk_conversion) =
            if AilTypesAux.is_integer result_ty then
              (C.OTy_integer, integer_promotion (ctype_of e))
            else
              (C.OTy_floating, fun z -> z) in
          E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun obj_wrp ->
          E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun e_wrp   ->
          self e                                    >>= fun core_e  ->
          E.return begin
            Caux.add_std "§6.5.3.3#2" begin
              Caux.mk_wseq_e e_wrp.E.sym_pat core_e begin
                Caux.mk_pure_e begin
                  Caux.mk_case_pe e_wrp.E.sym_pe
                    [ ( Caux.mk_specified_pat obj_wrp.E.sym_pat
                      , Caux.mk_specified_pe (mk_conversion obj_wrp.E.sym_pe) )
                    ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                      , Caux.mk_unspecified_pe result_ty ) ]
                end
              end
            end
          end
      
      | A.AilEunary A.Minus e ->
          (* STD §6.5.3.3#3 *)
          let (oTy, zero_pe, mk_conversion) =
            if AilTypesAux.is_integer result_ty then
              let (mk_conversion, promoted_ty) = integer_promotion_and_type (ctype_of e) in
              (C.OTy_integer, Caux.annotate_integer_type_pexpr promoted_ty (Caux.mk_integer_pe 0), mk_conversion)
            else
              (C.OTy_floating, Caux.mk_floating_value_pe Mem.zero_fval, fun z -> z) in
          E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun obj_wrp ->
          E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun e_wrp   ->
          self e                                    >>= fun core_e  ->
          E.return begin
            Caux.add_std "§6.5.3.3#3" begin
              Caux.mk_wseq_e e_wrp.E.sym_pat core_e begin
                Caux.mk_pure_e begin
                  Caux.mk_case_pe e_wrp.E.sym_pe
                    [ ( Caux.mk_specified_pat obj_wrp.E.sym_pat
                      , let expr =
                          Caux.mk_op_pe C.OpSub zero_pe (mk_conversion obj_wrp.E.sym_pe) in
                        Caux.mk_specified_pe (
                          with_wrapI_or_catch_exceptional_condition result_ty C.IOpSub
                            zero_pe (mk_conversion obj_wrp.E.sym_pe) (Just expr)
                        ) )
                    ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                      , Caux.mk_unspecified_pe result_ty ) ]
                end
              end
            end
          end
      
      | A.AilEunary A.Bnot e ->
          (* STD §6.5.3.3#4 *)
          let oTy = force_core_object_type_of_ctype (ctype_of e) in
          E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun e_wrp   ->
          E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun obj_wrp ->
          self e                                    >>= fun core_e  ->
          let promoted_e = Caux.mk_std_pe "§6.5.3.3#4, sentence 2" (integer_promotion (ctype_of e) obj_wrp.E.sym_pe) in
          let core_bnot =
            (* NOTE: result_ty == promoted type of e *)
            if AilTypesAux.is_unsigned_integer_type result_ty then begin
              (* STD §6.5.3.3#4, sentence 3 *)
              let max_pe = Caux.mk_ivmax_pe (Caux.mk_ail_ctype_pe result_ty) in
              Caux.mk_std_pe "§6.5.3.3#4, sentence 3"
                (with_wrapI_or_catch_exceptional_condition result_ty C.IOpSub
                  max_pe promoted_e (Just (Caux.mk_op_pe C.OpSub max_pe promoted_e)))
            end else
              Caux.bitwise_complement_pe (Caux.mk_ail_ctype_pe result_ty) promoted_e in
          let is_signed = AilTypesAux.is_signed_integer_type result_ty in
          E.return begin
            Caux.add_std "§6.5.3.3#4" begin
              Caux.mk_wseq_e e_wrp.E.sym_pat core_e begin
                Caux.mk_pure_e begin
                  Caux.mk_case_pe e_wrp.E.sym_pe
                    [ ( Caux.mk_specified_pat obj_wrp.E.sym_pat
                      , (* NOTE: result_ty == promoted type of e *)
                        Caux.mk_specified_pe begin
                          if Global.is_CHERI () && Ctype.is_ptr_t result_ty then
                            mk_cheri_derive_and_assign_cap is_signed
                              (Mem_common.DCunary A.Bnot)
                              (obj_wrp.E.sym_pe, Caux.mk_nullcap_pe is_signed)
                              core_bnot
                          else 
                            core_bnot
                        end )
                      (* , let promoted_e = Caux.mk_std_pe "§6.5.3.3#4, sentence 2" (integer_promotion (ctype_of e) obj_wrp.E.sym_pe) in
                        (* NOTE: result_ty == promoted type of e *)
                        Caux.mk_specified_pe begin if AilTypesAux.is_unsigned_integer_type result_ty then
                          (* STD §6.5.3.3#4, sentence 3 *)
                          Caux.mk_std_pe "§6.5.3.3#4, sentence 3" (Caux.mk_op_pe C.OpSub (Caux.mk_ivmax_pe (Caux.mk_ail_ctype_pe result_ty)) promoted_e)
                        else
                          Caux.bitwise_complement_pe (Caux.mk_ail_ctype_pe result_ty) promoted_e
                        end ) *)
                    ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                      , Caux.mk_unspecified_pe result_ty ) ]
                end
              end
            end
          end
      
      | A.AilEunary A.Address (A.AnnotatedExpression _ _ _ (A.AilEunary A.Indirection e)) ->
          (* STD §6.5.3.2#3, sentence 3 *)
          (* NOTE: footnote 102 makes it clear that this is valid even if 'e' evaluates to a null pointer *)
          Caux.add_std "§6.5.3.2#3, sentence 3" <$> self e
      
      | A.AilEunary A.Address e ->
          (* STD §6.5.3.2#3, sentence 5 *)
          if AilTypesAux.is_object (ctype_of e) then
            E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun ptr_wrp ->
            self e                                              >>= fun core_e  ->
            E.return begin
              Caux.add_std "§6.5.3.2#3, sentence 5" begin
                Caux.mk_wseq_e ptr_wrp.E.sym_pat core_e begin
                  Caux.mk_pure_e (Caux.mk_specified_pe ptr_wrp.E.sym_pe)
                end
              end
            end
          else
            translate_function_designator self stdlib e
      
      | A.AilEunary A.PostfixIncr e ->
          translate_postfix loc self stdlib result_ty A.PostfixIncr e
      | A.AilEunary A.PostfixDecr e ->
          translate_postfix loc self stdlib result_ty A.PostfixDecr e
      
      | A.AilEunary A.Indirection e ->
if AilTypesAux.is_pointer_to_function (ctype_of e) then
          (* STD 6.5.3.2#4 *)
          translate_function_designator self stdlib e
else match AilTypesAux.referenced_type (ctype_of e) with
  | (*BISECT-IGNORE*) Nothing ->
      illTypedAil loc "AilEunary Indirection, not a pointer type"
  | Just ref_ty ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun e_wrp    ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun obj_wrp  ->
          E.wrapped_fresh_symbol C.BTy_boolean                >>= fun test_wrp ->
          self e                                              >>= fun core_e   ->
          E.return begin
            Caux.add_std "§6.5.3.2" begin
              Caux.mk_wseq_e e_wrp.E.sym_pat core_e begin
                Caux.mk_case_e e_wrp.E.sym_pe
                  [ ( Caux.mk_specified_pat obj_wrp.E.sym_pat
                    , Caux.mk_wseq_e test_wrp.E.sym_pat
                        (Caux.mk_memop_e Mem_common.PtrValidForDeref [Caux.mk_ail_ctype_pe ref_ty; obj_wrp.E.sym_pe]) begin
                          Caux.mk_pure_e begin
                            Caux.mk_if_pe test_wrp.E.sym_pe
                              obj_wrp.E.sym_pe
                              (Caux.mk_std_undef_pe loc "§6.5.3.3#4, sentence 4" Undefined.UB043_indirection_invalid_value)
                          end
                        end )
                  ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                    , Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.3.3#4, sentence 4" Undefined.UB043_indirection_invalid_value) ) ]
              end
            end
          end
end
      
      | A.AilEbinary e1 (A.Arithmetic A.Shl) e2 ->
          (* STD §6.5.7 *)
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun e1_wrp        ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun e2_wrp        ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun obj1_wrp      ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun obj2_wrp      ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun promoted1_wrp ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun promoted2_wrp ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun res_wrp       ->
          self e1                                             >>= fun core_e1       ->
          self e2                                             >>= fun core_e2       ->
          (* (STD §6.5.7#3 and #4) the PROMOTED type of the left operand is used as the result
             type of the left shift, and decides whether the shift has signed semantics
             (overflow is undefined) or unsigned (overflow is defined as wrapping). *)
          let is_unsigned_shift = AilTypesAux.is_unsigned_integer_type result_ty in
          E.return begin
            Caux.add_std "§6.5.7" begin
              Caux.mk_wseq_e (Caux.mk_tuple_pat [ e1_wrp.E.sym_pat; e2_wrp.E.sym_pat ]) (Caux.mk_unseq [core_e1; core_e2]) begin
                Caux.mk_pure_e begin
                  Caux.mk_case_pe (Caux.mk_tuple_pe [e1_wrp.E.sym_pe; e2_wrp.E.sym_pe])
                    [ ( Caux.mk_tuple_pat [ Caux.mk_empty_pat (C.BTy_loaded C.OTy_integer)
                                          ; Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype) ]
                      , Caux.mk_undef_exceptional_condition loc )
                    ; ( Caux.mk_tuple_pat [ Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                                          ; Caux.mk_empty_pat (C.BTy_loaded C.OTy_integer) ]
                      ,
begin if is_unsigned_shift then
                        Caux.mk_unspecified_pe result_ty
else
                        Caux.mk_undef_exceptional_condition loc
end
                      )
                    ; ( Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_wrp.E.sym_pat; Caux.mk_specified_pat obj2_wrp.E.sym_pat ]
                      , let (mk_promoted2_def, promoted2_ity) = integer_promotion_and_type (ctype_of e2) in
                        let promoted2_def = mk_promoted2_def obj2_wrp.E.sym_pe in
                        Caux.mk_let_pe promoted1_wrp.E.sym_pat
                          (Caux.mk_std_pe "§6.5.7#3, sentence 1" (integer_promotion (ctype_of e1) obj1_wrp.E.sym_pe))
                        (Caux.mk_let_pe promoted2_wrp.E.sym_pat
                          (Caux.mk_std_pe "§6.5.7#3, sentence 1" promoted2_def)
                        (* (§6.5.7#2) if promoted2 < 0 then undef *)
                        (Caux.mk_if_pe (Caux.mk_op_pe C.OpLt promoted2_wrp.E.sym_pe (Caux.mk_integer_pe 0))
                          (Caux.mk_std_undef_pe loc "§6.5.7#3, sentence 3" Undefined.UB051a_negative_shift)
                        (* ctype_width(result_ty) <= promoted2 *)
                        (Caux.mk_if_pe (Caux.mk_op_pe C.OpOr 
                              (Caux.mk_op_pe C.OpLt (Caux.annotate_integer_type_pexpr promoted2_ity (stdlib.mkcall_ctype_width result_ty)) promoted2_wrp.E.sym_pe)
                              (Caux.mk_op_pe C.OpEq (Caux.annotate_integer_type_pexpr promoted2_ity (stdlib.mkcall_ctype_width result_ty)) promoted2_wrp.E.sym_pe))
                          (Caux.mk_std_undef_pe loc "§6.5.7#4, sentence 3" Undefined.UB51b_shift_too_large)
begin
let result_ity = match result_ty with
  | Cty.Ctype _ (Cty.Basic (Cty.Integer ity)) -> ity
  | _ -> illTypedAil loc "A.Shl result type should be an integer type"
end in
if is_unsigned_shift then
      let core_shl =
        Caux.mk_std_pe "§6.5.7#4, sentence 2" begin
          Caux.mk_op_pe C.OpRem_t (Caux.mk_op_pe C.OpMul promoted1_wrp.E.sym_pe (Caux.mk_op_pe C.OpExp (Caux.mk_integer_pe 2) promoted2_wrp.E.sym_pe))
            (Caux.mk_op_pe C.OpAdd (Caux.mk_ivmax_pe (Caux.mk_ail_ctype_pe result_ty)) (Caux.mk_integer_pe 1))
        end in
      begin if Global.is_CHERI () && Ctype.is_ptr_t result_ty then
                          Caux.mk_specified_pe begin
                            Caux.mk_memop_pe Mem_common.CapAssignValue
                              [ Caux.mk_memop_pe
                                  (Mem_common.DeriveCap (Mem_common.DCbinary (A.Arithmetic A.Shl)) (AilTypesAux.is_signed_integer_type result_ty))
                                  [obj1_wrp.E.sym_pe; obj2_wrp.E.sym_pe]
                              ; core_shl ]
                          end
      else if Global.backend_name () = "Cn" then
                          Caux.mk_specified_pe (Caux.mk_wrapI_pe result_ity C.IOpShl promoted1_wrp.E.sym_pe promoted2_wrp.E.sym_pe)
      else
                          Caux.mk_specified_pe core_shl
      end
else
                        Caux.mk_std_pe "§6.5.7#4, sentence 3"
                          (Caux.mk_if_pe (Caux.mk_op_pe C.OpLt promoted1_wrp.E.sym_pe (Caux.mk_integer_pe 0))
                            (Caux.mk_std_undef_pe loc "§6.5.7#3, sentence 3" Undefined.UB052a_negative_left_shift)
  begin if Global.backend_name () = "Cn" then
                          Caux.mk_specified_pe (Caux.mk_catch_exceptional_condition_pe result_ity C.IOpShl promoted1_wrp.E.sym_pe promoted2_wrp.E.sym_pe)
  else
                          (Caux.mk_let_pe res_wrp.E.sym_pat
                            (Caux.mk_op_pe C.OpMul promoted1_wrp.E.sym_pe (Caux.mk_op_pe C.OpExp (Caux.mk_integer_pe 2) promoted2_wrp.E.sym_pe))
                          (Caux.mk_if_pe (stdlib.mkcall_is_representable res_wrp.E.sym_pe result_ty)
    begin if Global.is_CHERI () && Ctype.is_ptr_t result_ty then
                          Caux.mk_specified_pe begin
                            Caux.mk_memop_pe Mem_common.CapAssignValue
                              [ Caux.mk_memop_pe
                                  (Mem_common.DeriveCap (Mem_common.DCbinary (A.Arithmetic A.Shl)) (AilTypesAux.is_signed_integer_type result_ty))
                                  [obj1_wrp.E.sym_pe; obj2_wrp.E.sym_pe]
                              ; res_wrp.E.sym_pe ]
                          end
    else
                            (Caux.mk_specified_pe res_wrp.E.sym_pe)
    end
                            (Caux.mk_std_undef_pe loc "§6.5.7#3, sentence 3" Undefined.UB052b_non_representable_left_shift)))
  end)
end
                           )))) ]
                end
              end
            end
          end
      
      | A.AilEbinary e1 (A.Arithmetic A.Shr) e2 ->
          (* STD §6.5.7 *)
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun e1_wrp        ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun e2_wrp        ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun obj1_wrp      ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun obj2_wrp      ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun promoted1_wrp ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun promoted2_wrp ->
          self e1                                             >>= fun core_e1       ->
          self e2                                             >>= fun core_e2       ->
          E.return begin
            Caux.add_std "§6.5.7" begin
              Caux.mk_wseq_e (Caux.mk_tuple_pat [ e1_wrp.E.sym_pat; e2_wrp.E.sym_pat ]) (Caux.mk_unseq [core_e1; core_e2]) begin
                Caux.mk_pure_e begin
                  Caux.mk_case_pe (Caux.mk_tuple_pe [e1_wrp.E.sym_pe; e2_wrp.E.sym_pe])
                    [ ( Caux.mk_tuple_pat [ Caux.mk_empty_pat (C.BTy_loaded C.OTy_integer)
                                          ; Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype) ]
                      , Caux.mk_undef_exceptional_condition loc )
                    ; ( Caux.mk_tuple_pat [ Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                                          ; Caux.mk_empty_pat (C.BTy_loaded C.OTy_integer) ]
                      , Caux.mk_unspecified_pe (result_ty) )
                    ; ( Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_wrp.E.sym_pat
                                          ; Caux.mk_specified_pat obj2_wrp.E.sym_pat ]
                      , let (mk_promoted2_def, promoted2_ity) = integer_promotion_and_type (ctype_of e2) in
                        let promoted2_def = mk_promoted2_def obj2_wrp.E.sym_pe in
                        Caux.mk_let_pe promoted1_wrp.E.sym_pat (integer_promotion (ctype_of e1) obj1_wrp.E.sym_pe)
                        (Caux.mk_let_pe promoted2_wrp.E.sym_pat promoted2_def
                        (* (§6.5.7#2) if promoted2 < 0 then undef *)
                        (Caux.mk_if_pe (Caux.mk_op_pe C.OpLt promoted2_wrp.E.sym_pe (Caux.mk_integer_pe 0))
                          (Caux.mk_std_undef_pe loc "§6.5.7#3, sentence 3" Undefined.UB051a_negative_shift)
                        (* ctype_width(result_ty) <= promoted2 *)
                        (Caux.mk_if_pe (Caux.mk_op_pe C.OpOr 
                                  (Caux.mk_op_pe C.OpLt (Caux.annotate_integer_type_pexpr promoted2_ity (stdlib.mkcall_ctype_width result_ty)) promoted2_wrp.E.sym_pe)
                                  (Caux.mk_op_pe C.OpEq (Caux.annotate_integer_type_pexpr promoted2_ity (stdlib.mkcall_ctype_width result_ty)) promoted2_wrp.E.sym_pe))
                          (Caux.mk_std_undef_pe loc "§6.5.7#3, sentence 3" Undefined.UB51b_shift_too_large)
                          begin
                            let expr = Caux.mk_op_pe C.OpDiv promoted1_wrp.E.sym_pe (Caux.mk_op_pe C.OpExp (Caux.mk_integer_pe 2) promoted2_wrp.E.sym_pe) in
                            Caux.mk_specified_pe begin
begin if Global.is_CHERI () && Ctype.is_ptr_t result_ty then
    fun z ->
      Caux.mk_memop_pe Mem_common.CapAssignValue
      [ Caux.mk_memop_pe
          (Mem_common.DeriveCap (Mem_common.DCbinary (A.Arithmetic A.Shr)) (AilTypesAux.is_signed_integer_type result_ty))
          [obj1_wrp.E.sym_pe; obj2_wrp.E.sym_pe]
      ; z ]
  else
    fun z -> z
end
begin
let result_ity = match result_ty with
  | Cty.Ctype _ (Cty.Basic (Cty.Integer ity)) -> ity
  | _ -> illTypedAil loc "A.Shr result type should be an integer type"
end in
if AilTypesAux.is_unsigned_integer_type result_ty then
                              Caux.mk_std_pe "6.5.7#5, sentence 2"
  begin if Global.backend_name () = "Cn" then
                                Caux.mk_wrapI_pe result_ity C.IOpShr promoted1_wrp.E.sym_pe promoted2_wrp.E.sym_pe
  else
                                expr
  end
else
                               Caux.mk_std_pe "6.5.7#5, sentence 3" begin
                                Caux.mk_if_pe (Caux.mk_op_pe C.OpGe promoted1_wrp.E.sym_pe (Caux.mk_integer_pe 0))
  begin if Global.backend_name () = "Cn" then
                                  Caux.mk_catch_exceptional_condition_pe result_ity C.IOpShr promoted1_wrp.E.sym_pe promoted2_wrp.E.sym_pe
  else
                                  expr
  end
                                  (Caux.mk_call_pe (C.Impl Implementation.SHR_signed_negative)
                                    [Caux.mk_ail_ctype_pe result_ty; promoted1_wrp.E.sym_pe; promoted2_wrp.E.sym_pe])
                               end
end
end                       end))) ) ]
                end
              end
            end
          end
      
      | A.AilEident sym ->
          E.cheri_const_alias_map >>= fun alias_map ->
          let sym_alias_if_CHERI =
            if Global.is_CHERI () then
              match Map.lookup sym alias_map with
                | Just cheri_sym -> cheri_sym
                | Nothing        -> sym
              end
            else
              sym in
          let normalised_sym =
            match ctx with
              | ECTX_glob glob_sym sym' ->
                  if sym = glob_sym then
                    sym'
                  else
                    sym_alias_if_CHERI
              | _ (* ECTX_other *) ->
                  sym_alias_if_CHERI
            end in
          E.return (Caux.mk_pure_e (Caux.mk_sym_pe normalised_sym))
      
      | A.AilEcast _ cast_ty e ->
          let e_ty = ctype_of e in
          let oTy = force_core_object_type_of_ctype e_ty in
          E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun e_wrp   ->
          E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun obj_wrp ->
          (* STD §6.3.2.1#2 "lvalue conversion" *)
          self e    >>= fun core_e  ->
          let let_sym = Symbol.fresh () in
          E.return $
            Caux.add_std "§6.5.4" (
if AilTypesAux.is_void cast_ty then
              Caux.mk_wseq_e e_wrp.E.sym_pat core_e
                Caux.mk_skip_e

else if AilTypesAux.is_pointer cast_ty && Aaux.is_null_pointer_constant e then
  match AilTypesAux.referenced_type cast_ty with
    | (*BISECT-IGNORE*) Nothing ->
              illTypedAil loc "AilEcast, pointer vs null_pointer_constant"
    | Just ref_ty ->
              Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_nullptr_pe ref_ty))
  end

else if AilTypesAux.is_arithmetic cast_ty && AilTypesAux.is_arithmetic e_ty then
  if AilTypesAux.is_integer cast_ty then
    if AilTypesAux.is_integer e_ty then
      if Global.is_CHERI () && not (Ctype.is_ptr_t (ctype_of e)) && Ctype.is_ptr_t cast_ty then
              Caux.mk_wseq_e e_wrp.E.sym_pat core_e begin
                Caux.mk_pure_e begin
                  Caux.mk_case_pe e_wrp.E.sym_pe
                    [ ( Caux.mk_specified_pat obj_wrp.E.sym_pat
                      , Caux.mk_specified_pe begin
                          let is_signed = AilTypesAux.is_signed_integer_type cast_ty in
                          Caux.mk_memop_pe Mem_common.CapAssignValue [Caux.mk_nullcap_pe is_signed; stdlib.mkcall_conv_int cast_ty obj_wrp.E.sym_pe]
                        end )
                    ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                      , Caux.mk_undef_pe loc (Undefined.DUMMY "integer to [u]intptr_t cast") ) ]
                end
              end
      else if Global.is_CHERI () && Ctype.is_ptr_t (ctype_of e) && not (Ctype.is_ptr_t cast_ty) then
              Caux.mk_wseq_e e_wrp.E.sym_pat core_e begin
                Caux.mk_pure_e begin
                  Caux.mk_case_pe e_wrp.E.sym_pe
                    [ ( Caux.mk_specified_pat obj_wrp.E.sym_pat
                      , Caux.mk_specified_pe (stdlib.mkcall_conv_int cast_ty (Caux.mk_memop_pe Mem_common.Ptr_tIntValue [obj_wrp.E.sym_pe])) )
                    ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                      , Caux.mk_undef_pe loc (Undefined.DUMMY "[u]intptr_t to integer cast") ) ]
                end
              end
      else
              Caux.mk_wseq_e e_wrp.E.sym_pat core_e (
                Caux.mk_pure_e (stdlib.mkcall_conv_loaded_int cast_ty e_wrp.E.sym_pe)
              )
    else (* cast_ty is floating since it is an arithmetic type *)
              Caux.mk_wseq_e e_wrp.E.sym_pat core_e (
                Caux.mk_pure_e (stdlib.mkcall_loaded_ivfromfloat cast_ty e_wrp.E.sym_pe)
              )
  else
    if AilTypesAux.is_integer e_ty then
              Caux.mk_wseq_e e_wrp.E.sym_pat core_e (
                Caux.mk_pure_e (stdlib.mkcall_loaded_fvfromint cast_ty e_wrp.E.sym_pe)
              )
    else (* cast_ty is floating since it is an arithmetic type *)
              floating_conversion_TODO cast_ty e_ty core_e

else if AilTypesAux.is_pointer cast_ty && AilTypesAux.is_arithmetic e_ty then
            (* making a pointer from an integer *)
              let ref_ty = fromJust "Translation.translate_expression, AilEcast 1" (AilTypesAux.referenced_type cast_ty) in
              Caux.mk_wseq_e e_wrp.E.sym_pat core_e (
                Caux.mk_case_e e_wrp.E.sym_pe
                  [ ( Caux.mk_specified_pat obj_wrp.E.sym_pat
                    , Caux.mk_wseq_e (Caux.mk_sym_pat let_sym (C.BTy_object C.OTy_pointer))
                        (C.Expr [] (C.Ememop Mem_common.PtrFromInt [Caux.mk_ail_ctype_pe e_ty; Caux.mk_ail_ctype_pe ref_ty; obj_wrp.E.sym_pe]))
                        (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_sym_pe let_sym))) )
                  ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                    , (* Casting an unspecified integer to a pointer type gives an unspecified pointer *)
                      Caux.mk_pure_e (Caux.mk_unspecified_pe cast_ty) ) ]
              )

else if AilTypesAux.is_arithmetic cast_ty && AilTypesAux.is_pointer e_ty then
              (* making an integer from a pointer *)
              if AilTypesAux.atomic_qualified_unqualified AilTypesAux.is_Bool cast_ty then
                (* STD §6.3.1.2#1 *)
                Caux.mk_wseq_e e_wrp.E.sym_pat core_e (stdlib.mkproc_loaded_pointer_to_Bool e_wrp.E.sym_pe)
              else
                let ref_ty = fromJust "Translation.translate_expression, AilEcast 2" (AilTypesAux.referenced_type e_ty) in
                Caux.mk_wseq_e e_wrp.E.sym_pat core_e (
                    Caux.mk_case_e e_wrp.E.sym_pe
                      [ ( Caux.mk_specified_pat obj_wrp.E.sym_pat
                        , Caux.mk_wseq_e (Caux.mk_sym_pat let_sym (C.BTy_object C.OTy_integer))
                            (C.Expr [] (C.Ememop Mem_common.IntFromPtr [Caux.mk_ail_ctype_pe ref_ty; Caux.mk_ail_ctype_pe cast_ty; obj_wrp.E.sym_pe]))
                            (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_sym_pe let_sym))) )
                      ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                        , (* Casting an unspecified pointer to an integer type gives an unspecified integer *)
                          Caux.mk_pure_e (Caux.mk_unspecified_pe cast_ty) ) ]
                )

else (* pointer <-> pointer cast *)
              let () = Debug.warn [Debug.DB_elaboration] (fun () ->
                "the elaboration does the identity for casts between pointer types (this is different from ISO)"
              ) in
              let ub_pe = Caux.mk_undef_pe loc Undefined.UB025_misaligned_pointer_conversion in
              match AilTypesAux.referenced_type cast_ty with
                | Just cast_ref_ty ->
  if AilTypesAux.is_void cast_ref_ty || AilTypesAux.is_function cast_ref_ty then
                    core_e
  else
                    Caux.mk_wseq_e e_wrp.E.sym_pat core_e begin
                      Caux.mk_case_e e_wrp.E.sym_pe
                        [ ( Caux.mk_specified_pat obj_wrp.E.sym_pat
                          , Caux.mk_wseq_e (Caux.mk_sym_pat let_sym C.BTy_boolean)
                              (C.Expr [] (C.Ememop Mem_common.PtrWellAligned [Caux.mk_ail_ctype_pe cast_ref_ty; obj_wrp.E.sym_pe]))
                              (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_if_pe (Caux.mk_sym_pe let_sym) obj_wrp.E.sym_pe ub_pe))) )
                        ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                          , (* we are being daemonic (case where the resulting pointer would be misaligned) *)
                            Caux.mk_pure_e ub_pe ) ]
                    end
                | _ ->
                    error "Translation AilEcast, ptr vs ptr: just should be impossible"
              end
            )
      
      | A.AilEbinary e1 (A.Arithmetic A.Mul) e2 ->
          translate_mul_operator loc self usual_arithmetic_conversion stdlib
            result_ty e1 e2
      | A.AilEbinary e1 (A.Arithmetic (A.Div as aop)) e2 ->
          translate_div_mod_operator loc self usual_arithmetic_conversion stdlib
            result_ty aop e1 e2
      | A.AilEbinary e1 (A.Arithmetic (A.Mod as aop)) e2 ->
          translate_div_mod_operator loc self usual_arithmetic_conversion stdlib
            result_ty aop e1 e2
      
      | A.AilEbinary e1 (A.Arithmetic A.Add) e2 ->
if AilTypesAux.is_arithmetic (ctype_of e1) && AilTypesAux.is_arithmetic (ctype_of e2) then
            let oTy1 = force_core_object_type_of_ctype (ctype_of e1) in
            let oTy2 = force_core_object_type_of_ctype (ctype_of e2) in
            E.wrapped_fresh_symbol (C.BTy_loaded oTy1)          >>= fun e1_wrp   ->
            E.wrapped_fresh_symbol (C.BTy_loaded oTy2)          >>= fun e2_wrp   ->
            E.wrapped_fresh_symbol (C.BTy_object oTy1)          >>= fun obj1_wrp ->
            E.wrapped_fresh_symbol (C.BTy_object oTy2)          >>= fun obj2_wrp ->
            E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun cap_wrp  ->
            self e1                                             >>= fun core_e1  ->
            self e2                                             >>= fun core_e2  ->
            let (promoted1_pe, promoted2_pe) =
              Caux.mk_std_pair_pe "§6.5.6#4"
                (usual_arithmetic_conversion_TMP_new (ctype_of e1) (ctype_of e2) obj1_wrp.E.sym_pe obj2_wrp.E.sym_pe) in
            E.return begin
              Caux.add_std "§6.5.6" begin
                Caux.mk_wseq_e (Caux.mk_tuple_pat [ e1_wrp.E.sym_pat; e2_wrp.E.sym_pat ]) (Caux.mk_unseq [core_e1; core_e2]) begin
                  Caux.mk_pure_e begin
                    Caux.mk_case_pe (Caux.mk_tuple_pe [e1_wrp.E.sym_pe; e2_wrp.E.sym_pe])
                      [ ( Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_wrp.E.sym_pat
                                            ; Caux.mk_specified_pat obj2_wrp.E.sym_pat ]
                        , (* Both operand are specified *)
                          let core_add = Caux.mk_std_pe "§6.5.6#5" (Caux.mk_op_pe C.OpAdd promoted1_pe promoted2_pe) in
                          Caux.mk_specified_pe (
  if Global.is_CHERI () && Ctype.is_ptr_t result_ty then
                            Caux.mk_let_pe cap_wrp.E.sym_pat
                              (Caux.mk_memop_pe (Mem_common.DeriveCap (Mem_common.DCbinary (A.Arithmetic A.Add)) (AilTypesAux.is_signed_integer_type result_ty))
                                [obj1_wrp.E.sym_pe; obj2_wrp.E.sym_pe])
                              (Caux.mk_memop_pe Mem_common.CapAssignValue
                                [cap_wrp.E.sym_pe; stdlib.mkcall_wrapI result_ty core_add])
  (* else if AilTypesAux.is_signed_integer_type result_ty then
                            stdlib.mkcall_catch_exceptional_condition result_ty core_add
  else if AilTypesAux.is_integer result_ty then
                            stdlib.mkcall_wrapI result_ty core_add
  else
                            core_add) ) *)
  else
                            Caux.mk_std_pe "§6.5.6#5" begin
                              with_wrapI_or_catch_exceptional_condition result_ty C.IOpAdd
                                promoted1_pe promoted2_pe (Just core_add)
                            end
                          ) )
                      
                      ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy1; C.BTy_loaded oTy2])
                        , (* If either operand is unspecified, the result is also unspecified is the
                            result type of unsigned. Otherwise it is undef, since the addition
                            may overflow *)
  if AilTypesAux.is_unsigned_integer_type result_ty then
                          Caux.mk_unspecified_pe (result_ty)
  else
                          Caux.mk_undef_exceptional_condition loc) ]
                  end
                end
              end
            end
else (* Here one of the operands is a pointer *)
            E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun ptr_wrp         ->
            E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun ptr_obj_wrp     ->
            E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun integer_wrp     ->
            E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun integer_obj_wrp ->
            E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun res_wrp         ->
            self e1                                             >>= fun core_e1         ->
            self e2                                             >>= fun core_e2         ->
            let (ptr_ty, ptr_core_e, integer_core_e) =
  if AilTypesAux.is_arithmetic (ctype_of e1) then
              (ctype_of e2, core_e2, core_e1)
  else
              (ctype_of e1, core_e1, core_e2) in
            let ref_ty =
              match AilTypesAux.referenced_type ptr_ty with
                | (*BISECT-IGNORE*) Nothing ->
                    illTypedAil loc "A.AilEbinary (A.Arithmetic A.Add), one is pointer"
                | Just ref_ty ->
                    ref_ty
              end in
            E.return begin
              Caux.add_std "§6.5.6" begin
                Caux.mk_wseq_e (Caux.mk_tuple_pat [ ptr_wrp.E.sym_pat; integer_wrp.E.sym_pat ]) (Caux.mk_unseq [ptr_core_e; integer_core_e]) begin
                  Caux.mk_case_e (Caux.mk_tuple_pe [ptr_wrp.E.sym_pe; integer_wrp.E.sym_pe])
                    [ ( Caux.mk_tuple_pat [ Caux.mk_specified_pat ptr_obj_wrp.E.sym_pat
                                          ; Caux.mk_specified_pat integer_obj_wrp.E.sym_pat ]
                      , (* Both operand are specified *)
begin if Global.has_strict_pointer_arith () || Global.is_CHERI () || Global.is_PNVI () then
                        Caux.mk_wseq_e res_wrp.E.sym_pat
                          (Caux.mk_memop_e Mem_common.PtrArrayShift [ptr_obj_wrp.E.sym_pe; Caux.mk_ail_ctype_pe ref_ty; integer_obj_wrp.E.sym_pe])
                          (Caux.mk_pure_e (Caux.mk_specified_pe res_wrp.E.sym_pe))
else
                        Caux.mk_pure_e begin
                          Caux.mk_specified_pe begin
                            Caux.mk_std_pe "§6.5.6#8, sentences 2-3" (Caux.mk_array_shift ptr_obj_wrp.E.sym_pe ref_ty integer_obj_wrp.E.sym_pe)
                          end
                        end
end                   )
                    ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded C.OTy_pointer; C.BTy_loaded C.OTy_integer])
                      , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.UB_CERB004_unspecified Undefined.UB_unspec_pointer_add)) ) ]
                end
              end
            end
      
      | A.AilEbinary e1 (A.Arithmetic A.Sub) e2 ->
          self e1 >>= fun core_e1 ->
          self e2 >>= fun core_e2 ->
if AilTypesAux.is_arithmetic (ctype_of e1) && AilTypesAux.is_arithmetic (ctype_of e2) then
          let oTy1 = force_core_object_type_of_ctype (ctype_of e1) in
          let oTy2 = force_core_object_type_of_ctype (ctype_of e2) in
          E.wrapped_fresh_symbol (C.BTy_loaded oTy1)          >>= fun e1_wrp   ->
          E.wrapped_fresh_symbol (C.BTy_loaded oTy2)          >>= fun e2_wrp   ->
          E.wrapped_fresh_symbol (C.BTy_object oTy1)          >>= fun obj1_wrp ->
          E.wrapped_fresh_symbol (C.BTy_object oTy2)          >>= fun obj2_wrp ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun cap_wrp  ->
          let (promoted1_pe, promoted2_pe) =
            Caux.mk_std_pair_pe "§6.5.6#4"
              (usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_wrp.E.sym_pe obj2_wrp.E.sym_pe) in
          E.return begin
            C.Expr [Annot.Astd "§6.5.6"] (
              C.Ewseq (Caux.mk_tuple_pat [e1_wrp.E.sym_pat; e2_wrp.E.sym_pat]) (Caux.mk_unseq [core_e1; core_e2]) (
                Caux.mk_pure_e (
                  Caux.mk_case_pe (Caux.mk_tuple_pe [e1_wrp.E.sym_pe; e2_wrp.E.sym_pe])
                    [ ( Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_wrp.E.sym_pat
                                          ; Caux.mk_specified_pat obj2_wrp.E.sym_pat ]
                      , (* Both operand are specified *)
                        let core_sub = Caux.mk_std_pe "§6.5.6#6" (Caux.mk_op_pe C.OpSub promoted1_pe promoted2_pe) in
                        Caux.mk_specified_pe $
  if Global.is_CHERI () && Ctype.is_ptr_t result_ty then
                          Caux.mk_let_pe cap_wrp.E.sym_pat
                            (Caux.mk_memop_pe (Mem_common.DeriveCap (Mem_common.DCbinary (A.Arithmetic A.Sub)) (AilTypesAux.is_signed_integer_type result_ty))
                              [obj1_wrp.E.sym_pe; obj2_wrp.E.sym_pe])
                            (Caux.mk_memop_pe Mem_common.CapAssignValue
                              [cap_wrp.E.sym_pe; stdlib.mkcall_wrapI result_ty core_sub])
  (* else if AilTypesAux.is_signed_integer_type result_ty then
                          stdlib.mkcall_catch_exceptional_condition result_ty core_sub
  else if AilTypesAux.is_integer result_ty then
                          stdlib.mkcall_wrapI result_ty core_sub
  else
                          core_sub ) *)
else
                          Caux.mk_std_pe "§6.5.5#6" begin
                            with_wrapI_or_catch_exceptional_condition result_ty C.IOpSub
                              promoted1_pe promoted2_pe (Just core_sub)
                          end )
                    ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy1; C.BTy_loaded oTy2])
                      , (* If either operand is unspecified, the result is also unspecified is the
                           result type of unsigned. Otherwise it is undef, since the addition
                           may overflow *)
  if AilTypesAux.is_signed_integer_type result_ty then
                        Caux.mk_undef_exceptional_condition loc
  else
                        Caux.mk_unspecified_pe (result_ty) ) ]
                )
              )
            )
          end
else if AilTypesAux.is_pointer (ctype_of e1) && AilTypesAux.is_pointer (ctype_of e2) then
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun e1_wrp    ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun e2_wrp    ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun obj1_wrp  ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun obj2_wrp  ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun memop_wrp ->
          (* NOTE: by Ail typing we can just use the referenced type of either operand *)
          let diff_ty_pe = match (ctype_of e1) with
            | Ctype.Ctype _ (Ctype.Pointer _ ref_ty1) ->
                Caux.mk_ail_ctype_pe ref_ty1
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "ptrdiff"
          end in
          E.return begin
            C.Expr [Annot.Astd "§6.5.6"] (
              C.Ewseq (Caux.mk_tuple_pat [e1_wrp.E.sym_pat; e2_wrp.E.sym_pat]) (Caux.mk_unseq [core_e1; core_e2]) (
                Caux.mk_case_e (Caux.mk_tuple_pe [e1_wrp.E.sym_pe; e2_wrp.E.sym_pe])
                  [ ( Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_wrp.E.sym_pat
                                        ; Caux.mk_specified_pat obj2_wrp.E.sym_pat ]
                    , (* Both operand are specified *)
                      Caux.mk_wseq_e memop_wrp.E.sym_pat
                        (C.Expr [] (C.Ememop Mem_common.Ptrdiff [diff_ty_pe; obj1_wrp.E.sym_pe; obj2_wrp.E.sym_pe]))
                        begin
                          Caux.mk_pure_e begin
                            Caux.mk_if_pe (stdlib.mkcall_is_representable memop_wrp.E.sym_pe Ctype.ptrdiff_t)
                              (Caux.mk_specified_pe memop_wrp.E.sym_pe)
                              (Caux.mk_undef_pe loc Undefined.UB050_pointers_subtraction_not_representable)
                          end
                        end )
                  ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded C.OTy_pointer; C.BTy_loaded C.OTy_pointer])
                    , Caux.mk_pure_e (Caux.mk_undef_pe loc Undefined.UB050_pointers_subtraction_not_representable) ) ]
              )
            )
          end
else
            (* Here one of the operand is pointer *)
            let (ptr_ty, ptr_core_e, integer_core_e) =
              if AilTypesAux.is_arithmetic (ctype_of e1) then
                (ctype_of e2, core_e2, core_e1)
              else
                (ctype_of e1, core_e1, core_e2) in
            let ref_ty = match AilTypesAux.referenced_type ptr_ty with
              | (*BISECT-IGNORE*) Nothing ->
                  illTypedAil loc "A.AilEbinary (A.Arithmetic A.Sub), one is pointer"
              | Just ref_ty ->
                  ref_ty
            end in
            E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun ptr_wrp         ->
            E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun integer_wrp     ->
            E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun ptr_obj_wrp     ->
            E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun integer_obj_wrp ->  
            E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun res_wrp         ->
            E.return begin
              C.Expr [Annot.Astd "§6.5.6"] (
                C.Ewseq (Caux.mk_tuple_pat [ ptr_wrp.E.sym_pat; integer_wrp.E.sym_pat ])
                  (Caux.mk_unseq [ptr_core_e; integer_core_e]) (
                    Caux.mk_case_e (Caux.mk_tuple_pe [ptr_wrp.E.sym_pe; integer_wrp.E.sym_pe])
                        [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat (ptr_obj_wrp.E.sym_pat)
                                             ; Caux.mk_specified_pat (integer_obj_wrp.E.sym_pat) ],
                         (* Both operand are specified *)
begin if Global.has_strict_pointer_arith () || Global.is_CHERI () || Global.is_PNVI () then
                        Caux.mk_wseq_e res_wrp.E.sym_pat
                          (C.Expr [] (C.Ememop Mem_common.PtrArrayShift [ptr_obj_wrp.E.sym_pe; Caux.mk_ail_ctype_pe ref_ty; (Caux.mk_neg_pe integer_obj_wrp.E.sym_pe)]))
                          (Caux.mk_pure_e (Caux.mk_specified_pe res_wrp.E.sym_pe))
else
                        Caux.mk_pure_e begin
                          Caux.mk_specified_pe begin
                            Caux.mk_std_pe "§6.5.6#8, sentences 2-3" (Caux.mk_array_shift ptr_obj_wrp.E.sym_pe ref_ty (Caux.mk_neg_pe integer_obj_wrp.E.sym_pe))
                          end
                        end
end                       )
                        ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded C.OTy_pointer; C.BTy_loaded C.OTy_integer])
                          , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.UB_CERB004_unspecified Undefined.UB_unspec_pointer_sub)) ) ]
                  )
              )
            end
      
      | A.AilEbinary e1 (A.Lt as bop) e2 ->
          translate_relational_operator
            self usual_arithmetic_conversion
            result_ty bop e1 e2
      | A.AilEbinary e1 (A.Gt as bop) e2 ->
          translate_relational_operator
            self usual_arithmetic_conversion
            result_ty bop e1 e2
      | A.AilEbinary e1 (A.Le as bop) e2 ->
          translate_relational_operator
            self usual_arithmetic_conversion
            result_ty bop e1 e2
      | A.AilEbinary e1 (A.Ge as bop) e2 ->
          translate_relational_operator
            self usual_arithmetic_conversion
            result_ty bop e1 e2
      
      | A.AilEbinary e1 (A.Eq as bop) e2 ->
          translate_equality_operator loc
            self usual_arithmetic_conversion
            result_ty bop e1 e2
      | A.AilEbinary e1 (A.Ne as bop) e2 ->
          translate_equality_operator loc
            self usual_arithmetic_conversion
            result_ty bop e1 e2
      
      | A.AilEbinary e1 (A.Arithmetic (A.Band as aop)) e2 ->
          translate_bitwise_operator
            loc self usual_arithmetic_conversion stdlib
            result_ty aop e1 e2
      | A.AilEbinary e1 (A.Arithmetic (A.Bxor as aop)) e2 ->
          translate_bitwise_operator
            loc self usual_arithmetic_conversion stdlib
            result_ty aop e1 e2
      | A.AilEbinary e1 (A.Arithmetic (A.Bor as aop)) e2 ->
          translate_bitwise_operator
            loc self usual_arithmetic_conversion stdlib
            result_ty aop e1 e2
      
      | A.AilEbinary e1 A.And e2 ->
          (* Desugaring e1 && e2 ===> (e1 == 0) ? 0 : (e2 != 0) *)
          Caux.add_stds ["6.5.13#3"; "6.5.13#4"] <$>
            translate_expression true ECTX_logical_operator variadic_env stdlib tagDefs begin
              A.AnnotatedExpression
                (GenTypes.GenRValueType GenTypes.signedInt_gty) [] loc
                (A.AilEcond (mkTestExpression TestEq e1) (Just zeroAil_tau) (mkTestExpression TestNe e2))
            end
      
      | A.AilEbinary e1 A.Or e2 ->
          (* Desugaring e1 || e2 ===> (e1 == 0) ? (e2 != 0) : 0 *)
          Caux.add_stds ["6.5.14#3"; "6.5.14#4"] <$>
          translate_expression true ECTX_logical_operator variadic_env stdlib tagDefs begin
              A.AnnotatedExpression
                (GenTypes.GenRValueType GenTypes.signedInt_gty) [] loc
                (A.AilEcond (mkTestExpression TestEq e1) (Just (mkTestExpression TestNe e2)) oneAil_tau)
            end
      
      | A.AilEcond e1 Nothing e3 ->
          (* GNU ?: operator *)
          E.record_error_at loc "TODO: elaboration of ?: operator" >>= fun () ->
          E.return Caux.mk_skip_e
      
      | A.AilEcond e1 (Just e2) e3 ->
          let apply_implicit_conversions expr =
            let e_ty = ctype_of expr in
            self expr >>= fun core_e ->
            if AilTypesAux.is_integer result_ty then
              let e_oTy = force_core_object_type_of_ctype e_ty in
              E.wrapped_fresh_symbol (C.BTy_loaded e_oTy) >>= fun e_wrp ->
              (* NOTE: if result_ty is an integer type, then e2 and e2 are both integers (so e_ty must be too) *)
              E.return begin
                Caux.mk_sseq_e e_wrp.E.sym_pat core_e
                  (Caux.mk_pure_e (stdlib.mkcall_conv_loaded_int result_ty e_wrp.E.sym_pe))
              end
            else if AilTypesAux.is_floating result_ty then
              begin
                if AilTypesAux.is_integer e_ty then
                  let e_oTy = force_core_object_type_of_ctype e_ty in
                  E.wrapped_fresh_symbol (C.BTy_loaded e_oTy) >>= fun e_wrp ->
                  E.return begin
                    Caux.mk_sseq_e e_wrp.E.sym_pat core_e
                      (Caux.mk_pure_e (stdlib.mkcall_loaded_fvfromint result_ty e_wrp.E.sym_pe))
                  end
                else
                  E.return (floating_conversion_TODO result_ty e_ty core_e)
              end
            else if AilTypesAux.is_pointer result_ty then
              begin
                if AilTypesAux.is_integer e_ty && AilSyntaxAux.is_null_pointer_constant expr then
                  match AilTypesAux.referenced_type result_ty with
                    | Just ref_ty ->
                        E.return begin
                          Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_nullptr_pe ref_ty))
                        end
                    | _ ->
                        error "AilEcond: a pointer must have a referenced type"
                  end
                else if AilTypesAux.is_pointer e_ty then
                  E.return core_e
                else
                  error "AilEcond: invalid implicit conversion to a pointer type"
              end
            else
              (* NOTE: Ail's typing guarantees that e_ty = result_ty in this case *)
              E.return core_e
          in
          (* STD §6.5.15 *)
          (* NOTE: Ail's typing guarantees that e1 is scalar *)
          self (mkTestExpression TestEq e1) >>= fun core_e1 ->
          (* NOTE: the Core expression 'core_e1' has integer type because we elaborated an equality test *)
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun e1_wrp   ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun obj1_wrp ->
          apply_implicit_conversions e2                       >>= fun conv_e2  ->
          apply_implicit_conversions e3                       >>= fun conv_e3  ->
          let (seq_quote, test_quote) =
            match ctx with
              | ECTX_logical_operator ->
                  (* the AilEcond was produced as a desugaring of &&, so don't put STD quotes here *)
                  ([], [])
              | _ ->
                  (["§6.5.15#4, sentence 1"], ["§6.5.15#4, sentence 2"])
            end in
          E.return begin
            Caux.add_stds seq_quote begin
            (* STD (§6.5.15#4, sentence 1) says there is a sequenced point between the
               evaluation of e1 and the e2/e3. Hence the strong sequencing *)
              Caux.mk_sseq_e e1_wrp.E.sym_pat core_e1 begin
                Caux.mk_case_e e1_wrp.E.sym_pe
                  [ ( Caux.mk_specified_pat obj1_wrp.E.sym_pat
                    , Caux.add_stds test_quote begin
                        Caux.mk_if_e (Caux.mk_op_pe C.OpEq obj1_wrp.E.sym_pe (Caux.mk_integer_pe 0))
                          conv_e2
                          conv_e3
                      end )
                  ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                    , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.UB_CERB004_unspecified Undefined.UB_unspec_conditional)) ) ]
              end
            end
          end
      
      | A.AilEassign e1 e2 ->
          (* STD §6.5.16 *)
          (* TODO: model the non-exact overlap UB *)
          let () = Debug.warn [Debug.DB_elaboration] (fun () ->
            "Cerberus does not currently check the undefined behaviour for non-exactly overlapping assignments (see C11 §6.5.16.1#3)"
          ) in
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun e1_wrp  ->
          self e1                                             >>= fun core_e1 ->
          let ty1 = ctype_of e1 in
          let ty2 = Ctype.unatomic (ctype_of e2) in
          begin
if AilTypesAux.atomic_qualified_unqualified AilTypesAux.is_arithmetic ty1 && AilTypesAux.is_arithmetic ty2 then
  begin if Global.is_CHERI () &&
    (Ctype.is_ptr_t ty1 && not (Ctype.is_ptr_t ty2) || not (Ctype.is_ptr_t ty1) && Ctype.is_ptr_t ty2 ) then
            self (A.AnnotatedExpression (GenTypes.GenRValueType (GenTypes.inject_type ty1))
                    [] loc (A.AilEcast Ctype.no_qualifiers ty1 e2)) >>= fun core_e ->
            E.return
              ( force_core_object_type_of_ctype ty1
              , core_e
              , fun z -> z )
  else
            self e2 >>= fun core_e2 ->
            E.return
              ( force_core_object_type_of_ctype ty2
              , core_e2
              , conv_loaded_arith stdlib ty2 (Ctype.unatomic ty1) )
  end

else if AilTypesAux.atomic_qualified_unqualified AilTypesAux.is_struct_or_union ty1 then
            (* NOTE: the two struct/union types could be from two different translation units,
                     but as far as I can things are sufficiently restricted such that no
                     conversion is needed here *)
            self e2 >>= fun core_e2 ->
            E.return
              ( force_core_object_type_of_ctype ty2
              , core_e2
              , fun z -> z )

(* NOTE: we apply unatomic to ty1 because the left operand may be an atomic pointer to ... (STD §6.5.16.1#1, bullet 3) *)
else match AilTypesAux.referenced_type (Ctype.unatomic ty1) with
  | Just ref_ty ->
            self e2 >>= fun core_e2 ->
            E.return
              begin if Aaux.is_null_pointer_constant e2 then
                ( C.OTy_pointer
                , Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_nullptr_pe ref_ty))
                , fun z -> z )
              else
                ( force_core_object_type_of_ctype ty2
                , core_e2
                , fun z -> z )
              end
  | Nothing ->
            (* By Ail's typing, e1 must have type _Bool and e2 must be a pointer *)
            self e2 >>= fun core_e2 ->
            E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun conv_wrp ->
            E.return
            ( C.OTy_integer
            , Caux.mk_wseq_e conv_wrp.E.sym_pat core_e2 (stdlib.mkproc_loaded_pointer_to_Bool conv_wrp.E.sym_pe)
            , fun z -> z )
end
          end >>= fun (oTy2, core_e2, mk_stored_pe) ->
          E.wrapped_fresh_symbol (C.BTy_loaded oTy2) >>= fun e2_wrp ->
          let object_pe = Caux.mk_std_pe "§6.5.16#3, sentence 1" e1_wrp.E.sym_pe in
          let stored_pe = Caux.mk_std_pe "§6.5.16.1#2, conversion" (mk_stored_pe e2_wrp.E.sym_pe) in
          let core_ty_pe1 = Caux.mk_ail_ctype_pe (AilTypesAux.rvalue_coercion (snd (from_lvalue_type e1))) in
          let mo =
            if AilTypesAux.is_atomic ty1 then
              (* STD §6.2.6.1#9 *)
              Cmm.Seq_cst
            else
              Cmm.NA in
          E.return begin
            Caux.add_std "§6.5.16#3, sentence 4" begin
              Caux.mk_wseq_e (Caux.mk_tuple_pat [ e1_wrp.E.sym_pat; e2_wrp.E.sym_pat ])
                (Caux.add_std "§6.5.16#3, sentence 5" (Caux.mk_unseq_e [core_e1; core_e2])) begin
                  Caux.mk_wseq_e (Caux.mk_empty_pat C.BTy_unit)
                    (C.Expr [Annot.Astd "§6.5.16.1#2, store"] (
                      C.Eaction (C.Paction C.Neg (C.Action loc default (C.Store false(* not locking *) core_ty_pe1 object_pe stored_pe mo)))
                    ))
                    (Caux.mk_pure_e stored_pe)
              end
            end
          end
      
      | A.AilEbinary e1 A.Comma e2 ->
          (* STD §6.5.17 *)
          self e1 >>= fun core_e1 ->
          self e2 >>= fun core_e2 ->
          let bTy =
            let ty_e1 = ctype_of e1 in
            if AilTypesAux.is_void ty_e1 then
              C.BTy_unit
            else
              C.BTy_loaded (force_core_object_type_of_ctype ty_e1) in
          (* STD (§6.5.17, sentence 2) says there is a sequence point between the
             evaluation of the two operand. Hence the strong sequencing *)
          E.return begin
            Caux.add_std "§6.5.17#2, sentence 2" begin
              Caux.mk_sseq_e (Caux.mk_empty_pat bTy) core_e1 core_e2
            end
          end
      
      | A.AilEcompoundAssign e1 aop e2 ->
          (* TODO: this elaboration is wrong because it duplicates any side-effect in E1 *)
          (* TODO: and this is duplicating facts about the typing of Ail arithmetic binary operators *)
          let (e1_rvalue, arith_gty) = match (e1, e2) with
            | (A.AnnotatedExpression (GenTypes.GenLValueType _ ty _) std_annots loc _, A.AnnotatedExpression (GenTypes.GenRValueType gty2) _ _ _) ->
                let gty1 = GenTypes.inject_type (Ctype.unatomic ty) in
                let gtc1 = GenTypes.GenRValueType gty1 in
                ( A.AnnotatedExpression gtc1 std_annots loc (A.AilErvalue e1)
                , match aop with
                    | A.Add ->
                        if GenTypesAux.is_pointer gty1 then
                          gty1
                        else
                          GenTypesAux.usual_arithmetic gty1 gty2
                    | A.Sub ->
                        if GenTypesAux.is_pointer gty1 then
                          gty1
                        else
                          GenTypesAux.usual_arithmetic gty1 gty2
                    | _ ->
                        GenTypesAux.usual_arithmetic gty1 gty2
                  end )
            | _ ->
                illTypedAil loc "AilEcompoundAssign"
          end in
          self begin
            A.AnnotatedExpression annot [] loc (A.AilEassign e1 (A.AnnotatedExpression (GenTypes.GenRValueType arith_gty) [] loc (A.AilEbinary e1_rvalue (A.Arithmetic aop) e2)))
          end
      
      | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin (A.AilBatomic A.AilBAstore))) es ->
          translate_atomic_explicit loc self AtomicStoreExplicit es
      | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin (A.AilBatomic A.AilBAload))) es ->
          translate_atomic_explicit loc self AtomicLoadExplicit es
      | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEident (Symbol.Symbol _ _ (Symbol.SD_Id "atomic_thread_fence")))) es ->
          translate_atomic_explicit loc self AtomicThreadFence es
      | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin (A.AilBatomic A.AilBAcompare_exchange_strong))) es ->
          translate_atomic_explicit loc self AtomicCompareExchangeStrongExplicit es
      | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin (A.AilBatomic A.AilBAcompare_exchange_weak))) es ->
          translate_atomic_explicit loc self AtomicCompareExchangeWeakExplicit es
      | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin (A.AilBlinux A.AilBLwrite))) es ->
          translate_atomic_explicit loc self LinuxStore es
      | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin (A.AilBlinux A.AilBLread))) es ->
          translate_atomic_explicit loc self LinuxLoad es
      | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin (A.AilBlinux A.AilBLfence))) es ->
          translate_atomic_explicit loc self LinuxFence es
      | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin (A.AilBlinux A.AilBLrmw))) es ->
          translate_atomic_explicit loc self LinuxRMW es
      
      | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin A.AilBcopy_alloc_id)) [from_e; to_e] ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun loaded_from_wrp ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun object_from_wrp ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun loaded_to_wrp   ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun object_to_wrp   ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun memop_wrp       ->
          self from_e                                         >>= fun from_e          ->
          self to_e                                           >>= fun to_e            ->
          E.return begin
            Caux.mk_sseq_e (Caux.mk_tuple_pat [loaded_from_wrp.E.sym_pat; loaded_to_wrp.E.sym_pat])
              begin
                Caux.mk_unseq_e [from_e; to_e]
              end
              begin
                Caux.mk_case_e (Caux.mk_tuple_pe [loaded_from_wrp.E.sym_pe; loaded_to_wrp.E.sym_pe])
                  [ ( Caux.mk_tuple_pat [Caux.mk_specified_pat object_from_wrp.E.sym_pat; Caux.mk_specified_pat object_to_wrp.E.sym_pat]
                    , Caux.mk_wseq_e memop_wrp.E.sym_pat (Caux.mk_memop_e Mem_common.Copy_alloc_id [object_from_wrp.E.sym_pe; object_to_wrp.E.sym_pe])
                      (Caux.mk_pure_e (Caux.mk_specified_pe memop_wrp.E.sym_pe)) )
                  ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded C.OTy_integer; C.BTy_loaded C.OTy_pointer])
                    , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.UB_CERB004_unspecified Undefined.UB_unspec_copy_alloc_id))) ]
              end
          end

      | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin (A.AilBCHERI str))) [] ->
          E.return begin
            C.Expr [] (C.Ememop (Mem_common.CHERI_intrinsic str (result_ty, [])) [])
          end
      
      | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin (A.AilBCHERI str))) [e] ->
          self e >>= fun core_e ->
          let bTy_ret = maybe C.BTy_unit C.BTy_loaded (Caux.core_object_type_of_ctype result_ty) in
          let ty_e = ctype_of e in
          let oTy = force_core_object_type_of_ctype ty_e in
          let arg_bTy = C.BTy_loaded oTy in
          E.wrapped_fresh_symbol bTy_ret            >>= fun memop_wrp ->
          E.wrapped_fresh_symbol arg_bTy            >>= fun arg_wrp   ->
          E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun obj_wrp   ->
          let memop = Mem_common.CHERI_intrinsic str (result_ty, [ty_e]) in
          E.return begin
            Caux.mk_sseq_e arg_wrp.E.sym_pat core_e
            begin
              Caux.mk_case_e arg_wrp.E.sym_pe
                [ ( Caux.mk_specified_pat obj_wrp.E.sym_pat
                  , (C.Expr [] (C.Ememop memop [obj_wrp.E.sym_pe])) )
                ; ( Caux.mk_empty_pat arg_bTy
                  , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY "Elab, CHERI intrinsics (unspec)")) ) ]
            end
          end
      
      | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin (A.AilBCHERI str))) (_::_::_ as es) ->
          E.mapM self es >>= fun core_es ->
          let bTy_ret = maybe C.BTy_unit C.BTy_loaded (Caux.core_object_type_of_ctype result_ty) in
          let oTys = List.map (fun e -> force_core_object_type_of_ctype (ctype_of e)) es in
          E.wrapped_fresh_symbol bTy_ret >>= fun memop_wrp ->
          (* E.foldlM (fun (sym_pat_acc, sym_pe_acc, obj_pat_acc, obj_pe_acc) oTy ->
            E.wrapped_fresh_symbol (C.BTy_loaded oTy)  >>= fun (_, sym_pat, sym_pe) ->
            E.wrapped_fresh_symbol (C.BTy_object oTy)  >>= fun (_, obj_pat, obj_pe) ->
            E.return ( sym_pat :: sym_pat_acc
                     , sym_pe  :: sym_pe_acc
                     , obj_pat :: obj_pat_acc
                     , obj_pe  :: obj_pe_acc )
          ) ([], [], [], []) oTys >>= fun (rev_arg_sym_pats, rev_arg_sym_pes, rev_obj_sym_pats, rev_obj_sym_pes) -> *)
          let args_bTy = C.BTy_tuple (List.map C.BTy_loaded oTys) in
          E.wrapped_fresh_symbol args_bTy >>= fun args_wrp ->
          E.foldlM (fun (obj_pat_acc, obj_pe_acc) oTy ->
            E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun obj_wrp ->
            E.return ( obj_wrp.E.sym_pat :: obj_pat_acc
                     , obj_wrp.E.sym_pe  :: obj_pe_acc )
          ) ([], []) oTys >>= fun (rev_obj_sym_pats, rev_obj_sym_pes) ->
          let memop =
            Mem_common.CHERI_intrinsic str (result_ty, List.map ctype_of es) in
          E.return begin
            Caux.mk_sseq_e args_wrp.E.sym_pat (Caux.mk_unseq_e core_es)
            begin
              Caux.mk_case_e args_wrp.E.sym_pe
                [ ( Caux.mk_tuple_pat (List.map Caux.mk_specified_pat (List.reverse rev_obj_sym_pats))
                  , (C.Expr [] (C.Ememop memop (List.reverse rev_obj_sym_pes))) )
                ; ( Caux.mk_empty_pat args_bTy
                  , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY "Elab, CHERI intrinsics (unspec)")) ) ]
            end
          end
      
      | A.AilEcall e [] ->
          (* NOTE: when there are no arguments, we don't need all the temporary object creation stuff *)
          (* STD §6.5.2.2 *)
          let ret_ty = match ctype_of e with
            | Ctype.Ctype _ (Ctype.Pointer _ (Ctype.Ctype _ (Ctype.FunctionNoParams (_, ret_ty)))) ->
                ret_ty
            | Ctype.Ctype _ (Ctype.Pointer _ (Ctype.Ctype _ (Ctype.Function (_, ret_ty) params isVariadic))) ->
                if List.length params = 0 && (not isVariadic) then
                  ret_ty
                else
                  illTypedAil loc "AilEcall"
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "AilEcall"
          end in
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun fun_wrp    ->
          E.wrapped_fresh_symbol C.BTy_ctype                  >>= fun ret_wrp    ->
          E.wrapped_fresh_symbol (C.BTy_list C.BTy_ctype)     >>= fun params_wrp ->
          self e                                              >>= fun core_e     ->
          E.return begin
            (* STD §6.5.2.2#10 *)
            Caux.mk_sseq_e fun_wrp.E.sym_pat core_e begin
            Caux.mk_let_e
              (Caux.mk_tuple_pat [ret_wrp.E.sym_pat; params_wrp.E.sym_pat; Caux.mk_empty_pat C.BTy_boolean; Caux.mk_empty_pat C.BTy_boolean])
              (Caux.mk_cfunction_pe fun_wrp.E.sym_pe)
              begin
                Caux.mk_if_e_ []
                  (Caux.mk_op_pe C.OpEq (stdlib.mkcall_params_length params_wrp.E.sym_pe) (Caux.mk_integer_pe 0))
                    begin
                      Caux.mk_if_e_ []
                        (Caux.mk_are_compatible (Caux.mk_ail_ctype_pe ret_ty) ret_wrp.E.sym_pe)
                          (Caux.mk_ccall_e (Caux.mk_ail_ctype_pe (ctype_of e)) fun_wrp.E.sym_pe [(*Caux.mk_boolean_pe is_used*)])
                          (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#9" Undefined.UB041_function_not_compatible))
                    end
                    (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#6, sentence 3" Undefined.UB038_number_of_args))
              end
            end
          end
      
      | A.AilEcall e es ->
          translate_function_call loc is_used self stdlib e es
      
      | A.AilEassert e ->
          let oTy = force_core_object_type_of_ctype (ctype_of e) in
          E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun e_wrp     ->
          E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun obj_wrp   ->
          E.wrapped_fresh_symbol C.BTy_boolean      >>= fun memop_wrp ->
          self e                                    >>= fun core_e    ->
          E.return begin
            Caux.mk_sseq_e e_wrp.E.sym_pat core_e
begin if AilTypesAux.is_arithmetic (ctype_of e) then
              let zero_pe =
                if AilTypesAux.is_integer (ctype_of e) then
                  Caux.mk_integer_pe 0
                else
                  Caux.mk_floating_value_pe Mem.zero_fval in
              Caux.mk_pure_e begin
                Caux.mk_case_pe e_wrp.E.sym_pe
                  [ ( Caux.mk_specified_pat obj_wrp.E.sym_pat
                    , Caux.mk_if_pe (Caux.mk_op_pe C.OpEq obj_wrp.E.sym_pe zero_pe)
                       (Caux.mk_error_pe "assert() failure" Caux.mk_unit_pe)
                      Caux.mk_unit_pe )
                  ; ( Caux.mk_empty_pat (C.BTy_loaded oTy)
                    , Caux.mk_error_pe "assert() unspecified" Caux.mk_unit_pe ) ]
              end
else (* is_pointer *)
              Caux.mk_case_e e_wrp.E.sym_pe
                [ ( Caux.mk_specified_pat obj_wrp.E.sym_pat
                  , Caux.mk_wseq_e memop_wrp.E.sym_pat
                     (Caux.mk_memop_e Mem_common.PtrEq [obj_wrp.E.sym_pe; Caux.mk_nullptr_pe Cty.void])
                     begin
                       Caux.mk_pure_e begin
                         Caux.mk_if_pe memop_wrp.E.sym_pe
                           (Caux.mk_error_pe "assert() failure" Caux.mk_unit_pe)
                           Caux.mk_unit_pe
                       end
                     end )
                ; ( Caux.mk_empty_pat (C.BTy_loaded oTy)
                  , Caux.mk_pure_e (Caux.mk_error_pe "assert() unspecified" Caux.mk_unit_pe) ) ]
end
          end
      
      | A.AilEoffsetof ty membr_ident ->
          let tag_sym = match ty with
            | Ctype.Ctype _ (Ctype.Struct x) ->
                x
            | Ctype.Ctype _ (Ctype.Union x) ->
                x
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "AilEoffsetof"
          end in
          E.return begin
            Caux.mk_pure_e begin
              Caux.mk_value_pe begin
                C.Vloaded (C.LVspecified (C.OVinteger (Mem.offsetof_ival tagDefs tag_sym membr_ident)))
              end
            end
          end
      
      | A.AilEgeneric _ _ ->
          (* NOTE: this is already caught by the frontend *)
          E.record_error_at loc "TODO: elaboration of C11 generics" >>= fun () ->
          E.return Caux.mk_skip_e
      
      | A.AilEarray _ _ e_opts ->
          let elem_ty = match result_ty with
            | Ctype.Ctype _ (Ctype.Array ty _) ->
                ty
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "AilEarray"
          end in
          E.foldlM (fun (pe_acc, (pat_acc, core_e_acc)) e_opt ->
            match e_opt with
              | Just e ->
                  translate_assignment_conversion self stdlib elem_ty e >>= fun (conv_oTy, core_e, mk_conv_pe) ->
                  E.wrapped_fresh_symbol (C.BTy_loaded conv_oTy)       >>= fun e_wrp                          ->
                  E.return
                    ( mk_conv_pe e_wrp.E.sym_pe :: pe_acc
                    , (e_wrp.E.sym_pat :: pat_acc, core_e :: core_e_acc) )
              | Nothing ->
                  E.return
                   ( Caux.mk_unspecified_pe elem_ty :: pe_acc
                   , (pat_acc, core_e_acc) )
            end
          ) ([], ([], [])) e_opts >>= fun (rev_pes, (pat_acc, core_e_acc)) ->
          E.return begin 
            match (pat_acc, core_e_acc) with
              | ([pat], [core_e]) ->
                  Caux.mk_wseq_e pat core_e
              | (_ :: _, _ :: _) ->
                  (* STD (§6.7.9#23) the evaluations are unsequenced *)
                  Caux.mk_wseq_e (Caux.mk_tuple_pat pat_acc) (Caux.add_std "§6.7.9#23" (Caux.mk_unseq_e core_e_acc))
              | _ ->
                  (* this is not possible (the Ail would be illformed) *)
                  error "AilEarray"
            end
            begin
              Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_array_pe (List.reverse rev_pes)))
            end
          end
      
      | A.AilEstruct tag_sym ident_e_opts ->
          let ident_tys = match Map.lookup tag_sym tagDefs with
            | Just (_, Cty.StructDef z _) ->
                z
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "AilEstruct"
          end in
          E.foldlM (fun (acc, (pat_acc, core_e_acc)) (ident, e_opt) ->
            match e_opt with
              | Just e ->
                  let (_, _, _, memb_ty) = fromJust "Translation.translate_expression, AilEstruct 2" (List.lookup ident ident_tys) in
                  translate_assignment_conversion self stdlib memb_ty e >>= fun (conv_oTy, core_e, mk_conv_pe) ->
                  E.wrapped_fresh_symbol (C.BTy_loaded conv_oTy)       >>= fun e_wrp                          ->
                  E.return
                    ( (ident, mk_conv_pe e_wrp.E.sym_pe) :: acc
                    , (e_wrp.E.sym_pat :: pat_acc, core_e :: core_e_acc) )
              | Nothing ->
                  let (_, _, _, ty) = fromJust "Translation.translate_expression, AilEstruct 3" (List.lookup ident ident_tys) in
                  E.return
                    ( (ident, Caux.mk_unspecified_pe ty) :: acc
                    , (pat_acc, core_e_acc) )
            end
          ) ([], ([], [])) ident_e_opts >>= fun (core_xs_rev, (pat_acc, core_e_acc)) ->
          E.return begin 
            match (pat_acc, core_e_acc) with
              | ([pat], [core_e]) ->
                  Caux.mk_wseq_e pat core_e
              | (_ :: _, _ :: _) ->
                  (* STD (§6.7.9#23) the evaluations are unsequenced *)
                  Caux.mk_wseq_e (Caux.mk_tuple_pat pat_acc) (Caux.add_std "§6.7.9#23" (Caux.mk_unseq_e core_e_acc))
              | _ ->
                  (* this is not possible (the Ail would be illformed) *)
                  error "AilEstruct"
            end
            begin
              Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_struct_pe tag_sym (List.reverse core_xs_rev)))
            end
          end
      
      | A.AilEunion tag_sym memb_ident e_opt ->
          match Map.lookup tag_sym tagDefs with
            | (*BISECT-IGNORE*) Nothing ->
                illTypedAil loc "AilEunion: couldn't find the definition"
            | (*BISECT-IGNORE*) Just (_, Cty.StructDef _ _) ->
                illTypedAil loc "AilEunion: found a struct definition"
            | Just (_, Cty.UnionDef ident_tys) ->
                match List.lookup memb_ident ident_tys with
                  | (*BISECT-IGNORE*) Nothing ->
                      illTypedAil loc "AilEunion: couldn't find a union definition"
                  | Just (_, _, _, memb_ty) ->
                      match e_opt with
                        | Just e ->
                            translate_assignment_conversion self stdlib memb_ty e >>= fun (conv_oTy, core_e, mk_conv_pe) ->
                            E.wrapped_fresh_symbol (C.BTy_loaded conv_oTy)       >>= fun e_wrp                          ->
                            E.return begin
                              Caux.mk_wseq_e e_wrp.E.sym_pat core_e
                                (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_union_pe tag_sym memb_ident (mk_conv_pe e_wrp.E.sym_pe))))
                            end
                        | Nothing ->
                            E.return begin
                              Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_union_pe tag_sym memb_ident (Caux.mk_unspecified_pe memb_ty)))
                            end
                      end
                end
          end

      | A.AilEcompound qs ty e ->
          let core_ty = Caux.mk_ail_ctype_pe ty in
          let oTy = force_core_object_type_of_ctype (ctype_of e) in
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun obj_wrp ->
          E.wrapped_fresh_symbol (C.BTy_loaded oTy)           >>= fun e_wrp   ->
          self e                                              >>= fun core_e  ->
          (* STD §6.5.2.5#3 *)
          E.register_compound_literal loc (Symbol.PrefCompoundLiteral (locOf e) (Symbol.digest_of_sym e_wrp.E.sym_sym)) obj_wrp.E.sym_sym qs.Ctype.const ty >>= fun () ->
          E.return begin
            (* NOTE: the elaboration ensures [ty] and the type of [e] are the same *)
            Caux.mk_wseq_e e_wrp.E.sym_pat core_e begin
            Caux.mk_wseq_e (Caux.mk_empty_pat C.BTy_unit) (Caux.pstore loc core_ty obj_wrp.E.sym_pe e_wrp.E.sym_pe Cmm.NA) begin
              (* STD §6.5.2.5#5, sentence 1 *)
              Caux.mk_pure_e obj_wrp.E.sym_pe
            end end
          end
      
      | A.AilEmemberof e ident ->
          (* STD §6.5.2.3 *)
          let (tag_sym, oTy) = match ctype_of e with
            | Ctype.Ctype _ (Ctype.Struct tag_sym) ->
                (tag_sym, C.OTy_struct tag_sym)
            | Ctype.Ctype _ (Ctype.Atomic (Ctype.Ctype _ (Ctype.Struct tag_sym))) ->
                (tag_sym, C.OTy_struct tag_sym)
            | Ctype.Ctype _ (Ctype.Union tag_sym) ->
                (tag_sym, C.OTy_union tag_sym)
            | Ctype.Ctype _ (Ctype.Atomic (Ctype.Ctype _ (Ctype.Union tag_sym))) ->
                (tag_sym, C.OTy_union tag_sym)
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "AilEmemberof"
          end in
          let bTy = if is_lvalue then C.BTy_object C.OTy_pointer else C.BTy_loaded oTy in
          E.wrapped_fresh_symbol bTy >>= fun e_wrp  ->
          self e                     >>= fun core_e ->
          
          if not is_lvalue then
             E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun obj_wrp ->
             E.return begin
               Caux.mk_sseq_e e_wrp.E.sym_pat core_e begin
                 Caux.mk_pure_e begin
                   Caux.mk_case_pe e_wrp.E.sym_pe
                     [ ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                       , Caux.mk_undef_pe loc (Undefined.UB_CERB004_unspecified Undefined.UB_unspec_rvalue_memberof) )
                     ; ( Caux.mk_specified_pat obj_wrp.E.sym_pat
                       , Caux.mk_memberof_pe tag_sym ident obj_wrp.E.sym_pe ) ]
                 end
               end
             end
          else
            E.return begin
              C.Expr [Annot.Astd "§6.5.2.3#3, sentence 2"] (
                C.Esseq e_wrp.E.sym_pat core_e (
begin if Global.is_CHERI () then
                  (Caux.mk_memop_e (Mem_common.PtrMemberShift tag_sym ident) [e_wrp.E.sym_pe])
else
                  Caux.mk_pure_e (Caux.mk_member_shift_pe e_wrp.E.sym_pe tag_sym ident)
end
                )
              )
            end
      
      | A.AilEmemberofptr e ident ->
          (* STD §6.5.2.3 *)
          let (ref_ty, tag_sym) = match ctype_of e with
            | Ctype.Ctype _ (Ctype.Pointer _ (Ctype.Ctype _ (Ctype.Struct tag_sym) as ref_ty)) ->
                (ref_ty, tag_sym)
            | Ctype.Ctype _ (Ctype.Pointer _ (Ctype.Ctype _ (Ctype.Atomic (Ctype.Ctype _ (Ctype.Struct tag_sym))) as ref_ty)) ->
                (ref_ty, tag_sym)
            | Ctype.Ctype _ (Ctype.Pointer _ (Ctype.Ctype _ (Ctype.Union tag_sym) as ref_ty))  ->
                (ref_ty, tag_sym)
            | Ctype.Ctype _ (Ctype.Pointer _ (Ctype.Ctype _ (Ctype.Atomic (Ctype.Ctype _ (Ctype.Union tag_sym))) as ref_ty)) ->
                (ref_ty, tag_sym)
            | (*BISECT-IGNORE*) _ -> illTypedAil loc "AilEmemberofptr"
          end in
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun e_wrp    ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun obj_wrp  ->
          E.wrapped_fresh_symbol C.BTy_boolean                >>= fun test_wrp ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun res_wrp  ->
          self e                                              >>= fun core_e   ->
          E.return begin
            Caux.add_std "§6.5.2.3#4, sentence 2" begin
              Caux.mk_sseq_e e_wrp.E.sym_pat core_e begin
                Caux.mk_case_e e_wrp.E.sym_pe
                  [ ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                    , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.UB_CERB004_unspecified Undefined.UB_unspec_memberofptr)) )
                  ; ( Caux.mk_specified_pat obj_wrp.E.sym_pat
                    , if Global.has_strict_pointer_arith () || Global.is_CHERI () then
                        Caux.mk_wseq_e test_wrp.E.sym_pat
                          (Caux.mk_memop_e Mem_common.PtrValidForDeref [Caux.mk_ail_ctype_pe ref_ty; obj_wrp.E.sym_pe])
                      begin if Global.is_CHERI () then
                        Caux.mk_if_e test_wrp.E.sym_pe
                          begin
                            Caux.mk_wseq_e res_wrp.E.sym_pat
                              (Caux.mk_memop_e (Mem_common.PtrMemberShift tag_sym ident) [obj_wrp.E.sym_pe])
                              (Caux.mk_pure_e res_wrp.E.sym_pe)
                          end
                          (* TODO: make a new UB for this particular case *)
                          (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.3.3#4, sentence 4" Undefined.UB043_indirection_invalid_value))
                          
                      else
                          begin
                            Caux.mk_pure_e begin
                              Caux.mk_if_pe test_wrp.E.sym_pe
                                (Caux.mk_member_shift_pe obj_wrp.E.sym_pe tag_sym ident)
                                (Caux.mk_std_undef_pe loc "§6.5.2.3#4, sentence 4" Undefined.UB043_indirection_invalid_value)
                            end
                          end
                      end
                      else
                        (* NON-ISO: allowing member_shift on "invalid pointer values" *)
                        Caux.mk_pure_e (Caux.mk_member_shift_pe obj_wrp.E.sym_pe tag_sym ident) ) ]
              end
            end
          end
      
      | A.AilEconst cst ->
          E.return (Caux.mk_pure_e (translate_constant cst))
      
      | A.AilEbuiltin b ->
        match b with
          | A.AilBatomic _ ->
              E.record_error_at loc "atomic builtins must be directly called" >>= fun () ->
              E.return Caux.mk_skip_e
          | A.AilBlinux _ ->
              E.record_error_at loc "atomic linux builtins must be directly called" >>= fun () ->
              E.return Caux.mk_skip_e
          | A.AilBcopy_alloc_id ->
              E.record_error_at loc "copy_alloc_id() must be directly called" >>= fun () ->
              E.return Caux.mk_skip_e
          | A.AilBCHERI str ->
              E.record_error_at loc (str^"() must be directly called") >>= fun () ->
              E.return Caux.mk_skip_e
              (* NOTE: other builtins might be legally desugared here *)
        end
      
      | A.AilEstr (pref_opt, strs) ->
          let strs = List.concat (List.map snd strs) in
          let elem_ty = match pref_opt with
            | Nothing ->
                (* STD §6.4.5#6, sentence 3 *)
                Cty.char
            | Just A.Enc_u8 ->
                (* STD §6.4.5#6, sentence 4 *)
                Cty.char
            | Just A.Enc_u ->
                (* STD §6.4.5#6, sentence 6 *)
                Cty.char16_t
            | Just A.Enc_U ->
                (* STD §6.4.5#6, sentence 6 *)
                Cty.char32_t
            | Just A.Enc_L ->
                (* STD §6.4.5#6, sentence 5 *)
                Cty.wchar_t
          end in
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun lit_wrp ->
          let elem_pes = List.map (fun c_str ->
             Caux.mk_specified_pe (
               stdlib.mkcall_conv_int elem_ty
                 (Caux.mk_integer_pe (Decode.decode_character_constant c_str))
             )
          ) strs ++ [Caux.mk_specified_pe (Caux.mk_integer_pe 0)] in
          E.register_string_literal loc lit_wrp.E.sym_sym (Cty.Ctype [] (Cty.Array elem_ty (Just (integerFromNat (List.length elem_pes)))))
            (Caux.mk_specified_pe (Caux.mk_array_pe elem_pes))  >>
          E.return (
            Caux.mk_pure_e lit_wrp.E.sym_pe
          )
      
      | A.AilEsizeof _ ty ->
          E.return begin
            if AilTypesAux.is_character ty then
              Caux.add_std "§6.5.3.4#4, sentence 1" begin
                Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
              end
            else
              Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_sizeof_pe (Caux.mk_ail_ctype_pe ty)))
          end
      
      | A.AilEsizeof_expr e ->
          (* NOTE: from (§6.2.5#26, sentence 3) we know that qualifers do no affect the size of a type,
                   so we can use 'Ctype.no_qualifiers' *)
          self (A.AnnotatedExpression annot std_annots loc (A.AilEsizeof Ctype.no_qualifiers (ctype_of e)))
      
      | A.AilEalignof _ ty ->
          E.return begin
            Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_alignof_pe (Caux.mk_ail_ctype_pe ty)))
          end
      
      | A.AilEannot _ e ->
          self e
      
      | A.AilEva_start _ last_sym ->
          let (variadic_sym, last_arg_sym) =
          match variadic_env with
            | (Just var_sym, Just last_sym) -> (var_sym, last_sym)
            | _ ->
              error (Loc.stringFromLocation (Loc.locOf a_expr) ^ ": va_start not in a variadic function")
            end in
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun va_wrp ->
          E.return begin
            if last_sym = last_arg_sym then
              Caux.mk_sseq_e va_wrp.E.sym_pat (C.Expr [] (C.Ememop Mem_common.Va_start [Caux.mk_sym_pe variadic_sym]))
                (Caux.mk_pure_e (Caux.mk_specified_pe va_wrp.E.sym_pe))
            else
              error ((Loc.stringFromLocation (Loc.locOf a_expr)) ^ " : " ^ show last_sym ^ " is not the last argument") (* it should be UB I think *)
          end
      
      | A.AilEva_copy _ e ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun e_wrp    ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun case_wrp ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun va_wrp   ->
          self e                                              >>= fun core_e   ->
          E.return begin
            Caux.mk_sseq_e e_wrp.E.sym_pat core_e
              (Caux.mk_case_e e_wrp.E.sym_pe
                [ ( Caux.mk_specified_pat case_wrp.E.sym_pat
                  , Caux.mk_sseq_e va_wrp.E.sym_pat (C.Expr [] (C.Ememop Mem_common.Va_copy [case_wrp.E.sym_pe]))
                      (Caux.mk_pure_e (Caux.mk_specified_pe va_wrp.E.sym_pe)) )
                ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                  , Caux.mk_pure_e (Caux.mk_undef_exceptional_condition loc) ) ] )
          end
      
      | A.AilEva_arg e ty ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun e_wrp    ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun ptr_wrp  ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun case_wrp ->
          self e                                              >>= fun core_e   ->
          E.return begin
            Caux.mk_sseq_e e_wrp.E.sym_pat core_e
              (Caux.mk_sseq_e ptr_wrp.E.sym_pat
                (Caux.mk_case_e e_wrp.E.sym_pe
                  [ ( Caux.mk_specified_pat case_wrp.E.sym_pat
                    , (C.Expr [] (C.Ememop Mem_common.Va_arg [case_wrp.E.sym_pe; Caux.mk_ail_ctype_pe ty])) )
                  ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                    , Caux.mk_pure_e (Caux.mk_undef_exceptional_condition loc) ) ] )
                (Caux.pload loc (Caux.mk_ail_ctype_pe ty) ptr_wrp.E.sym_pe Cmm.NA))
          end
      
      | A.AilEva_end e ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun e_wrp    ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun case_wrp ->
          self e                                              >>= fun core_e   ->
          E.return begin
            Caux.mk_sseq_e e_wrp.E.sym_pat core_e
              (Caux.mk_case_e e_wrp.E.sym_pe
                [ ( Caux.mk_specified_pat case_wrp.E.sym_pat
                  , (C.Expr [] (C.Ememop Mem_common.Va_end [case_wrp.E.sym_pe])) )
                ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                  , Caux.mk_pure_e (Caux.mk_undef_exceptional_condition loc) ) ] )
          end
      
      | A.AilEprint_type e ->
          let (qs, ty) = qualified_ctype_of e in
          let () = Debug.print_debug_located 0 [] loc (fun () ->
            "PRINT_TYPE: " ^ Pp.stringFromAil_ctype qs ty
          ) in
          self e
      | A.AilEbmc_assume e ->
          let oTy = force_core_object_type_of_ctype (ctype_of e) in
          E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun e_wrp     ->
          E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun obj_wrp   ->
          E.wrapped_fresh_symbol C.BTy_boolean      >>= fun memop_wrp ->
          self e                                    >>= fun core_e    ->
          E.return begin
            Caux.mk_sseq_e e_wrp.E.sym_pat core_e (
if AilTypesAux.is_arithmetic (ctype_of e) then
              let zero_pe =
                if AilTypesAux.is_integer (ctype_of e) then
                  Caux.mk_integer_pe 0
                else
                  Caux.mk_floating_value_pe Mem.zero_fval in
              Caux.mk_pure_e (
                Caux.mk_case_pe e_wrp.E.sym_pe
                  [ (Caux.mk_specified_pat obj_wrp.E.sym_pat,
                     (C.Pexpr [Annot.Aloc loc] () (C.PEbmc_assume (Caux.mk_not_pe
                          (Caux.mk_op_pe C.OpEq obj_wrp.E.sym_pe zero_pe)))))
                  ; (Caux.mk_empty_pat (C.BTy_loaded oTy),
                     Caux.mk_error_pe "__bmc_assume() unspecified" Caux.mk_unit_pe) ]
              )
else (* is_pointer *)
              Caux.mk_case_e e_wrp.E.sym_pe
                [ (Caux.mk_specified_pat obj_wrp.E.sym_pat,
                   Caux.mk_wseq_e memop_wrp.E.sym_pat
                     (C.Expr [] (C.Ememop Mem_common.PtrEq [obj_wrp.E.sym_pe; Caux.mk_nullptr_pe Cty.void]))
                     begin
                       Caux.mk_pure_e begin
                         (C.Pexpr [] () (C.PEbmc_assume memop_wrp.E.sym_pe))
                       end
                     end)
                ; (Caux.mk_empty_pat (C.BTy_loaded oTy),
                   Caux.mk_pure_e (Caux.mk_error_pe "__bmc_assume() unspecified" Caux.mk_unit_pe)) ]
            )
          end

      | A.AilEreg_load r ->
          (* this is not yet emitted by the frontend *)
          error "TODO: translation of AilEreg_load"

      | A.AilErvalue e ->
          let mo =
            if AilTypesAux.is_atomic (ctype_of e) then
              (* STD §6.2.6.1#9 *)
              Cmm.Seq_cst
            else
              Cmm.NA in
          self e >>= fun core_e ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun e_wrp ->
          E.return begin
            Caux.mk_wseq_e e_wrp.E.sym_pat core_e begin
              Caux.pload loc (Caux.mk_ail_ctype_pe (ctype_of e)) e_wrp.E.sym_pe mo
            end
          end
      | A.AilEarray_decay e ->
          self e >>= fun core_e ->
          match GenTypes.genTypeCategoryOf e with
            | GenTypes.GenLValueType _ _ _ ->
                (* by Ail typing, [e] is a lvalue. Hence the corresponding Core has a non-loaded type *)
                E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun e_wrp   ->
                E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun res_wrp ->
                E.return (
                  Caux.mk_wseq_e e_wrp.E.sym_pat core_e (
                    match AilTypesAux.referenced_type result_ty with
                      | (*BISECT-IGNORE*) Nothing ->
                          illTypedAil loc "AilEarray_decay, result_ty not a pointer"
                      | Just ref_ty ->
                          C.Expr [Annot.Astd "§6.3.2.1#3"] (
if Global.has_strict_pointer_arith () || Global.is_CHERI () || Global.is_PNVI () then
                            C.Ewseq res_wrp.E.sym_pat
                            (C.Expr [] (C.Ememop Mem_common.PtrArrayShift [e_wrp.E.sym_pe; Caux.mk_ail_ctype_pe ref_ty; Caux.mk_integer_pe 0]))
                            (Caux.mk_pure_e (Caux.mk_specified_pe res_wrp.E.sym_pe))
else
                            C.Epure (
                              Caux.mk_specified_pe (Caux.mk_array_shift e_wrp.E.sym_pe
                                ref_ty (Caux.mk_integer_pe 0)
                              )
                            )
                          )
                    end
                  )
                )
            | GenTypes.GenRValueType _ ->
                (* TODO: this is different from what the standard says in two ways:
                    1. we should be allocating a object of the whole struct/union
                       that contains this array (rvalue array_decay only occur when there is such
                       a struct/union)
                    2. the allocation should happen at the evaluation of struct/union rvalue, not
                       at the beginning of the evaluation of the containing full expression *)
                let oTy = force_core_object_type_of_ctype (ctype_of e) in
                E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun e_wrp ->
                E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun res_wrp ->
                E.register_temporary_object res_wrp (ctype_of e) >>= fun () ->
                E.return begin
                  Caux.mk_wseq_e e_wrp.E.sym_pat core_e (
                    Caux.mk_wseq_e (Caux.mk_empty_pat C.BTy_unit)
                      (Caux.add_std "§6.2.4#8" (Caux.pstore_lock loc (Caux.mk_ail_ctype_pe (ctype_of e)) res_wrp.E.sym_pe e_wrp.E.sym_pe Cmm.NA))
                      (Caux.mk_pure_e (Caux.mk_specified_pe res_wrp.E.sym_pe))
                  )
                end
          end
      | A.AilEfunction_decay e ->
          translate_function_designator self stdlib e
      | A.AilEatomic e ->
          self e
      
      | A.AilEgcc_statement _ _ ->
          E.record_error_at loc "GCC statements as expressions not yet supported" >>= fun () ->
          E.return Caux.mk_skip_e
    end


module St = State
let inline (>>=) = St.bind
let inline (>>) m1 m2 = St.bind m1 (fun _ -> m2)
let inline (<$>) = State.fmap
let inline (<*>) = State.app

type collect_cases_state = <|
  found_default: bool;
  case_csts: list integer;
  case_ranges: list (integer * integer);
|>

val     collect_cases_: A.statement GenTypes.genTypeCategory -> St.stateM unit collect_cases_state
let rec collect_cases_ stmt =
  let register_case n =
    St.update (fun s -> <| s with case_csts= n :: s.case_csts |>) in
  let register_case_range n1 n2 =
    St.update (fun s -> <| s with case_ranges= (n1, n2) :: s.case_ranges |>) in
  let register_default =
    St.update (fun s -> <| s with found_default= true |>) in
  match stmt.A.node with
    | A.AilSskip ->
        St.return ()
    | A.AilSexpr _ ->
        St.return ()
    | A.AilSblock binds ss ->
        St.mapM_ collect_cases_ ss
    | A.AilSif _ s1 s2 ->
        collect_cases_ s1 >> collect_cases_ s2
    | A.AilSwhile _ s _ ->
        collect_cases_ s
    | A.AilSdo s _ _ ->
        collect_cases_ s
    | A.AilSbreak ->
        St.return ()
    | A.AilScontinue ->
        St.return ()
    | A.AilSreturnVoid ->
        St.return ()
    | A.AilSreturn _ ->
        St.return ()
    | A.AilSswitch _ _ ->
        St.return ()
    | A.AilScase n s ->
        register_case n >> collect_cases_ s
    | A.AilScase_rangeGNU n1 n2 s ->
        if n1 < n2 then
          register_case_range n1 n2 >> collect_cases_ s
        else
          (* the frontend should catch this *)
          error "Translation found a GNU case with empty range"
    | A.AilSdefault s ->
        register_default >> collect_cases_ s
    | A.AilSlabel _ s _ ->
        collect_cases_ s
    | A.AilSgoto _ ->
        St.return ()
    | A.AilSdeclaration _ ->
        St.return ()
    | A.AilSpar ss ->
        St.mapM_ collect_cases_ ss
    | A.AilSreg_store _ _ ->
        St.return ()
    | A.AilSmarker _ s ->
        collect_cases_ s
  end
let collect_cases s =
  snd (St.runStateM (collect_cases_ s) <| found_default= false; case_csts= []; case_ranges= [] |>)


type erase_loop_control_state = <|
  elc_continue: maybe Symbol.sym;
  elc_break: maybe Symbol.sym;
|>

val     erase_loop_control_aux: A.statement GenTypes.genTypeCategory -> St.stateM (A.statement GenTypes.genTypeCategory) erase_loop_control_state
let rec erase_loop_control_aux stmt =
  let loc = stmt.A.loc in
  let with_fresh_labels mf =
    fun st ->
      let continue_sym = Symbol.fresh_pretty_with_id (fun x -> "continue_" ^ show x) in
      let break_sym    = Symbol.fresh_pretty_with_id (fun x -> "break_" ^ show x) in
      let (ret, st')   = mf <| elc_continue= Just continue_sym; elc_break= Just break_sym |> in
      ((continue_sym, break_sym, ret), st) in 
  A.mk_statement_full loc stmt.A.is_forloop stmt.A.attrs <$> match stmt.A.node with
    | A.AilSskip ->
        St.return stmt.A.node
    | A.AilSexpr _ ->
        St.return stmt.A.node
    | A.AilSblock binds ss ->
        A.AilSblock binds <$> St.mapM erase_loop_control_aux ss
    | A.AilSif e s1 s2 ->
        A.AilSif e <$> erase_loop_control_aux s1 <*> erase_loop_control_aux s2
    | A.AilSwhile e s loop_id ->
        (* STD §6.8.6.2#2 and §6.8.6.3#2 *)
        with_fresh_labels (erase_loop_control_aux s) >>= fun (continue_sym, break_sym, s') ->
        St.return begin
          A.AilSblock []
            [ A.mk_statement loc (A.AilSwhile e (A.mk_statement loc (A.AilSblock []
                [s'; A.mk_statement loc (A.AilSlabel continue_sym (A.mk_statement loc A.AilSskip) (Just (Annot.LAloop_continue loop_id)))])) loop_id)
            ; A.mk_statement loc (A.AilSlabel break_sym (A.mk_statement loc A.AilSskip) (Just (Annot.LAloop_break loop_id))) ]
          end

    | A.AilSdo s e loop_id ->
        (* STD §6.8.6.2#2 and §6.8.6.3#2 *)
        with_fresh_labels (erase_loop_control_aux s) >>= fun (continue_sym, break_sym, s') ->
        St.return begin
          A.AilSblock []
            [ A.mk_statement loc (A.AilSdo (A.mk_statement loc (A.AilSblock []
                [s'; A.mk_statement loc (A.AilSlabel continue_sym (A.mk_statement loc A.AilSskip) (Just (Annot.LAloop_continue loop_id)))])) e loop_id)
            ; A.mk_statement loc (A.AilSlabel break_sym (A.mk_statement loc A.AilSskip) (Just (Annot.LAloop_break loop_id))) ]
          end
    | A.AilSbreak ->
        St.get >>= function
          | <| elc_break= Just break_sym |> ->
             St.return (A.AilSgoto break_sym)
          | (*BISECT-IGNORE*) _ ->
              illTypedAil loc "AilSbreak"
        end
    | A.AilScontinue ->
        St.get >>= function
          | <| elc_continue= Just continue_sym |> ->
             St.return (A.AilSgoto continue_sym)
          | (*BISECT-IGNORE*) _ ->
              illTypedAil loc "AilScontinue"
        end
    | A.AilSreturnVoid ->
        St.return stmt.A.node
    | A.AilSreturn _ ->
        St.return stmt.A.node
    | A.AilSswitch e s ->
        with_fresh_labels (erase_loop_control_aux s) >>= fun (_, break_sym, s') ->
        St.return begin
          A.AilSblock []
            [ A.mk_statement loc (A.AilSswitch e (A.mk_statement loc (A.AilSblock []
                [ A.mk_statement loc (A.AilSgoto break_sym); s' ])))
            ; A.mk_statement loc (A.AilSlabel break_sym (A.mk_statement loc A.AilSskip) (Just Annot.LAswitch)) ]
          end
    | A.AilScase n s ->
        A.AilScase n <$> erase_loop_control_aux s
    | A.AilScase_rangeGNU n1 n2 s ->
        A.AilScase_rangeGNU n1 n2 <$> erase_loop_control_aux s
    | A.AilSdefault s ->
        A.AilSdefault <$> erase_loop_control_aux s
    | A.AilSlabel sym s m_loop_annot ->
        erase_loop_control_aux s >>= fun s ->
        St.return (A.AilSlabel sym s m_loop_annot)
    | A.AilSgoto _ ->
        St.return stmt.A.node
    | A.AilSdeclaration _ ->
        St.return stmt.A.node
    | A.AilSpar ss ->
        A.AilSpar <$> St.mapM erase_loop_control_aux ss
    | A.AilSreg_store _ _ ->
        St.return stmt.A.node
    | A.AilSmarker id s ->
        A.AilSmarker id <$> erase_loop_control_aux s
  end

let erase_loop_control stmt =
  let (stmt', _) = State.runStateM (erase_loop_control_aux stmt) <|
    elc_continue= Nothing;
    elc_break= Nothing;
  |> in stmt'


type collect_visibles_state = <|
  visible_syms: list (Symbol.sym * Ctype.ctype);
  label_visibles_: map Symbol.sym (list (Symbol.sym * Ctype.ctype));
|>

val     collect_visibles_: A.statement GenTypes.genTypeCategory -> St.stateM unit collect_visibles_state
let rec collect_visibles_ stmt =
  match stmt.A.node with
    | A.AilSskip ->
        St.return ()
    | A.AilSexpr _ ->
        St.return ()
    | A.AilSblock binds ss ->
        St.get >>= fun st ->
        let saved_syms = st.visible_syms in
        St.update (fun st ->
          <| st with visible_syms= List.map (fun (sym, (_, _, _, ty)) -> (sym ,ty)) binds ++ st.visible_syms |>
        ) >>
        St.mapM_ collect_visibles_ ss >>
        St.update (fun st ->
          <| st with visible_syms= saved_syms |>
        )
    | A.AilSif _ s1 s2 ->
        collect_visibles_ s1 >> collect_visibles_ s2
    | A.AilSwhile _ s _ ->
        collect_visibles_ s
    | A.AilSdo s _ _ ->
        collect_visibles_ s
    | A.AilSbreak ->
        St.return ()
    | A.AilScontinue ->
        St.return ()
    | A.AilSreturnVoid ->
        St.return ()
    | A.AilSreturn _ ->
        St.return ()
    | A.AilSswitch _ s ->
        collect_visibles_ s
    | A.AilScase _ s ->
        collect_visibles_ s
    | A.AilScase_rangeGNU _ _ s ->
        collect_visibles_ s
    | A.AilSdefault s ->
        collect_visibles_ s
    | A.AilSlabel label s _ ->
        St.update (fun st -> <| st with
          label_visibles_= Map.insert label st.visible_syms st.label_visibles_
        |>) >>
        collect_visibles_ s
    | A.AilSgoto label ->
        St.return ()
    | A.AilSdeclaration _ ->
        St.return ()
    | A.AilSpar ss ->
        St.mapM_ collect_visibles_ ss
    | A.AilSreg_store _ _ ->
        St.return ()
    | A.AilSmarker _ s ->
        collect_visibles_ s
  end

val collect_visibles: A.statement GenTypes.genTypeCategory -> collect_visibles_state
let collect_visibles stmt =
    snd begin
      State.runStateM (collect_visibles_ stmt)
        <| visible_syms= []
         ; label_visibles_= Map.empty |>
    end


val mk_run_with_lifetime_e: Loc.t -> Symbol.sym -> list (Symbol.sym * Ctype.ctype) -> list (Symbol.sym * Ctype.ctype) -> list C.pexpr -> C.expr unit
let mk_run_with_lifetime_e loc sym visibles_before visibles_after pes =
  let killed_syms_tys =
    List.filter (fun (sym,_ty) ->
      Maybe.isNothing (List.lookup sym visibles_after)
    ) visibles_before in
  
  let mk_kills_e =
    Caux.mk_unit_sseq (
      List.map (fun (sym,ty) ->
        Caux.pkill loc (C.Static ty) (Caux.mk_sym_pe sym)
      ) killed_syms_tys
    ) in
  
  let created_sym_tys =
    List.filter (fun (sym, _) ->
      not (List.any (fun (sym',_) -> sym = sym') visibles_before)
    ) visibles_after in
  
  let mk_creates_e =
    Caux.mk_sseqs begin
      List.map (fun (sym, ty) ->
        (C.Pattern [] (C.CaseBase (Just sym, C.BTy_object C.OTy_pointer)),
         let core_ty = Caux.mk_ail_ctype_pe ty in
         Caux.pcreate loc (Caux.mk_alignof_pe core_ty) core_ty (Symbol.PrefSource loc [(*f; *)sym]))
      ) created_sym_tys
    end in
  mk_kills_e (mk_creates_e (Caux.mk_run_e sym ((List.map (fun (sym, _) -> Caux.mk_sym_pe sym) visibles_after) ++ pes)))


open Operators

type case_selector =
  | CaseSelectConstant of integer
  | CaseSelectRange of integer * integer

type translate_stmt_env = <|
  return_ty: Ctype.ctype;
  is_Noreturn: bool;
  
  variadic_sym_opt: maybe Symbol.sym;
  last_arg_sym_opt: maybe Symbol.sym;

  return_lab  : Symbol.sym;
  default_lab : maybe Symbol.sym;
  case_labs   : list (case_selector * Symbol.sym);
  
  (* The lists are the objects visible from the loop and break labels *)
  loop:  maybe (
             Symbol.sym (* loop continuation symbol *)
           * Symbol.sym (* continue continuation symbol *)
           * Symbol.sym (* break continuation symbol *)
           * list (Symbol.sym * Ctype.ctype)
  );
  break: maybe (Symbol.sym * list (Symbol.sym * Ctype.ctype));
  
  label_visibles: map Symbol.sym (list (Symbol.sym * Ctype.ctype));
|>


let wrapped_translate_expression is_used ctx variadic_env stdlib tagDefs e =
  E.track_temporary_objects begin
    translate_expression is_used ctx variadic_env stdlib tagDefs e
  end >>= fun (xs, core_e) ->
  let bound_core = C.Expr [Annot.Astd "§6.5#2"] (C.Ebound core_e) in
  match xs with
    | [] ->
        E.return bound_core
    | _ ->
        let loc = Loc.locOf e in
        let (core_creates, core_kills) : list (C.pattern * C.expr unit) * list (C.expr unit) =
          List.unzip begin
            List.map (fun (ptr_wrp, ty) ->
              ( ( ptr_wrp.E.sym_pat
                , let core_ty = Caux.mk_ail_ctype_pe ty in
                  Caux.pcreate loc (Caux.mk_alignof_pe core_ty) core_ty (Symbol.PrefTemporaryLifetime loc (Symbol.digest_of_sym ptr_wrp.E.sym_sym)) )
              , Caux.pkill loc (C.Static ty) ptr_wrp.E.sym_pe )
            ) xs
          end in
        E.wrapped_fresh_symbol (maybe C.BTy_unit C.BTy_loaded (Caux.core_object_type_of_ctype (ctype_of e))) >>= fun e_wrp ->
        E.return begin
          Caux.add_std "§6.2.4#8" begin
            Caux.mk_sseqs core_creates begin
              Caux.mk_sseq_e e_wrp.E.sym_pat bound_core
                (Caux.mk_unit_sseq core_kills (Caux.mk_pure_e e_wrp.E.sym_pe))
            end
          end
        end
  end


val translate_stmt:
  translation_stdlib ->
  C.core_tag_definitions ->
  A.ail_identifier ->
  translate_stmt_env ->
  A.statement GenTypes.genTypeCategory ->
  E.elabM (C.expr unit)

let rec translate_stmt stdlib tagDefs f env stmt : E.elabM (C.expr unit) =
  let loc = stmt.A.loc in
  let translate_expression is_used = wrapped_translate_expression is_used ECTX_other (env.variadic_sym_opt, env.last_arg_sym_opt) stdlib tagDefs in
  let translate_cases_block case_labs default_lab =
    translate_stmt stdlib tagDefs f <| env with case_labs=   case_labs;
                                                default_lab= default_lab |>
  in
  let self = translate_stmt stdlib tagDefs f env in
  let () = Debug.print_debug_located 1 [] loc (fun () ->
            "** TRANSLATING ** " ^
            Pp.stringFromAil_statement stmt
          ) in
  (Caux.add_loc loc -| Caux.add_stmt -| Caux.add_attrs stmt.A.attrs) <$>
  match stmt.A.node with
    | A.AilSskip ->
        E.return Caux.mk_skip_e
    
    | A.AilSexpr e ->
        translate_expression false e >>= fun core_e ->
        E.return (
          Caux.mk_sseq_e (Caux.mk_empty_pat (maybe C.BTy_unit C.BTy_loaded (Caux.core_object_type_of_ctype (ctype_of e))))
            core_e
            (Caux.mk_pure_e Caux.mk_unit_pe)
        )
    
    (* | A.AilSblock [] ss ->
        E.with_block_objects [] (E.mapM self ss) >>= fun (_, core_ss) ->
        E.return (Caux.mk_unit_sseq core_ss Caux.mk_skip_e)
    
    | A.AilSblock [(sym, ((ident_loc, _, _), align_opt, qs, ty))] ss ->
        let c_ty = Caux.mk_ail_ctype_pe ty in
        let align_ival  =
        match align_opt with
          | Just (Ctype.AlignInteger n) ->
              Caux.mk_integer_pe n
          | Just (Ctype.AlignType al_ty) ->
              Caux.mk_alignof_pe (Caux.mk_ail_ctype_pe al_ty)
          | Nothing ->
              Caux.mk_alignof_pe c_ty
        end in
        E.with_block_objects [(sym, (qs, ty))] begin
          E.mapM self ss
        end >>= fun (_, core_ss) ->
        let new_loc = Loc.with_cursor_from loc ident_loc in
        E.return begin
          Caux.mk_sseq_e (Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer))
             (Caux.pcreate new_loc align_ival c_ty (Symbol.PrefSource ident_loc [f; sym])) (
            List.foldr (fun core_s acc ->
              Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit) core_s acc
            ) (Caux.pkill new_loc (C.Static ty) (Caux.mk_sym_pe sym)) core_ss
          )
        end *)
    
    | A.AilSblock binds ss ->
        let decls_with_loc = [ (sym, ident_loc, (align_opt, qs, ty)) | forall ((sym, ((ident_loc, _, _), align_opt, qs, ty)) MEM binds ) | true ] in
        let decls = List.map (fun (sym, _, (_, qs, ty)) -> (sym, (qs, ty))) decls_with_loc in
        E.with_block_objects decls begin
          E.mapM self ss
        end >>= fun (const_aliases, compound_lits, core_ss) ->
        let lit_pats_core_creates : list (C.pattern * C.expr unit) =
          List.map (fun (loc, prefix, sym, is_const, ty) ->
            let core_ty = Caux.mk_ail_ctype_pe ty in
            ( Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer)
            , Caux.pcreate loc (Caux.mk_alignof_pe core_ty) core_ty prefix )
          ) compound_lits
        in
        (* the symbolic names and create actions for the local variables *)
        let pats_core_creates : list (C.pattern * C.expr unit) =
          List.map (fun (sym, ident_loc, (align_opt, qs, ty)) ->
            let c_ty = Caux.mk_ail_ctype_pe ty in
            let align_ival  =
            match align_opt with
              | Just (Ctype.AlignInteger n) ->
                  Caux.mk_integer_pe n
              | Just (Ctype.AlignType al_ty) ->
                  Caux.mk_alignof_pe (Caux.mk_ail_ctype_pe al_ty)
              | Nothing ->
                  Caux.mk_alignof_pe c_ty
            end in    
            ( Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer)
            , Caux.pcreate (Loc.with_cursor_from loc ident_loc) align_ival c_ty (Symbol.PrefSource ident_loc [f; sym]) )
          ) decls_with_loc in
        let cheri_const_intrinsic =
          if Global.is_CHERI () then
            List.map (fun (sym, (qs, ty, sym')) ->
            (* TODO: the partial pattern match in the lets is tasteless (even though the memop()
                never evaluates to an unspecified value) *)
            let ptr_ty = Ctype.mk_ctype_pointer qs ty in
            ( Caux.mk_specified_pat (Caux.mk_sym_pat sym' (C.BTy_object C.OTy_pointer))
            , cheri_readonly_perms ptr_ty (Caux.mk_sym_pe sym) )
            ) const_aliases
          else
            [] in
        let pat_core_kills : list (C.expr unit) =
          List.map (fun (loc, _, sym, _, ty) ->
            Caux.pkill (Loc.with_cursor_from loc loc) (C.Static ty) (Caux.mk_sym_pe sym)
          ) compound_lits in
        (* NOTE: doing the kills here is now redundant if there is are returns before all exit point.
            but it may be nasty to do the check.
            For non-void function however we know (?) that their must be these returns ?? so we could drop the kills here *)
        (* the kill actions for the local variables *)
        let core_kills : list (C.expr unit) =
          List.map (fun (sym, ident_loc, (_, _, ty)) ->
            Caux.pkill (Loc.with_cursor_from loc ident_loc) (C.Static ty) (Caux.mk_sym_pe sym)
          ) decls_with_loc in
        E.return (
          (* NOTE: we sequence (left-to-right) the creates and kills of the block-scoped objects *)
          Caux.mk_sseqs (lit_pats_core_creates ++ pats_core_creates ++ cheri_const_intrinsic) begin
            Caux.mk_unit_sseq (core_ss ++ core_kills ++ pat_core_kills)
              Caux.mk_skip_e
          end
        )
    
    | A.AilSif e s1 s2 ->
        E.wrapped_fresh_symbol C.BTy_boolean                  >>= fun do_then_wrp ->
        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer)   >>= fun test_wrp    ->
        E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer)   >>= fun case_wrp    ->
        translate_expression true (mkTestExpression TestEq e) >>= fun core_test   ->
        self s1                                               >>= fun core_s1     ->
        self s2                                               >>= fun core_s2     ->
        (* NOTE: here we fix the strictness of unspecified values *)
        E.return begin
          (* NOTE: the case-of producing a boolean (instead of directly doing the control
             with the case) is to prevent possible combinatorial explosions of the generated Core code *)
          Caux.mk_sseq_e test_wrp.E.sym_pat core_test begin
            Caux.mk_sseq_e do_then_wrp.E.sym_pat begin
              Caux.mk_case_e test_wrp.E.sym_pe
                [ ( Caux.mk_specified_pat case_wrp.E.sym_pat
                  , Caux.mk_pure_e begin
                      Caux.mk_if_pe (Caux.mk_not_pe (Caux.mk_op_pe C.OpEq case_wrp.E.sym_pe (Caux.mk_integer_pe 1)))
                        (Caux.mk_boolean_pe true) (Caux.mk_boolean_pe false)
                    end )
                  (* non-deterministic branching if the test expression had unspecified value *)
                ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                  , Caux.mk_nd_e [Caux.mk_pure_e (Caux.mk_boolean_pe true); Caux.mk_pure_e (Caux.mk_boolean_pe false)] ) ]
            end
            (Caux.mk_if_e do_then_wrp.E.sym_pe core_s1 core_s2)
          end
        end
    
    | A.AilSwhile e s loop_id ->
        (* NOTE: the object type is OTy_integer since we are using mkTestExpression which turns [e] into [e == 0] *)
        let sym_loop = Symbol.fresh_pretty_with_id (fun x ->  "while_" ^ show x) in
        E.wrapped_fresh_symbol C.BTy_boolean                  >>= fun do_loop_wrp  ->
        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer)   >>= fun test_wrp     ->
        E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer)   >>= fun case_wrp     ->
        translate_expression true (mkTestExpression TestEq e) >>= fun core_test    ->
        self s                                                >>= fun core_s       ->
        E.get_visible_objects                                 >>= fun visible_syms ->
        (* TODO: the types of the annotations in Esave are dummy, but this is not observable for now *)
        let core_s_loop =
          Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit) core_s
            (Caux.mk_run_e sym_loop [ Caux.mk_sym_pe sym | forall (sym MEM visible_syms) | true ]) in
        E.mapM (fun sym ->
          E.resolve_object_type sym >>= fun (_, ty) ->
          E.return (sym, ((C.BTy_object C.OTy_pointer, Just (ty, C.By_pointer)), Caux.mk_sym_pe sym))
        ) visible_syms >>= fun args ->
        E.return begin
          Caux.mk_save_e_ [Annot.Alabel (Annot.LAloop loop_id)] (sym_loop, C.BTy_unit) args begin
            Caux.mk_sseq_e test_wrp.E.sym_pat core_test begin
              Caux.mk_sseq_e do_loop_wrp.E.sym_pat begin
                Caux.mk_case_e test_wrp.E.sym_pe
                  [ ( Caux.mk_specified_pat case_wrp.E.sym_pat
                    , Caux.mk_pure_e begin
                        Caux.mk_if_pe (Caux.mk_not_pe (Caux.mk_op_pe C.OpEq case_wrp.E.sym_pe (Caux.mk_integer_pe 1)))
                          (Caux.mk_boolean_pe true) (Caux.mk_boolean_pe false)
                      end )
                    (* non-deterministic branching if the test expression had unspecified value *)
                  ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                    , Caux.mk_nd_e [Caux.mk_pure_e (Caux.mk_boolean_pe true); Caux.mk_pure_e (Caux.mk_boolean_pe false)] ) ]
              end
                (Caux.mk_if_e do_loop_wrp.E.sym_pe core_s_loop Caux.mk_skip_e)
            end
          end
        end
    
    | A.AilSdo s e loop_id ->
        (* TODO: make the elab of AilSdo use mkTestExpression *)
        let sym_loop = Symbol.fresh_pretty_with_id (fun x ->  "do_" ^ show x) in
        let sym_case = Symbol.fresh () in
        let sym_e    = Symbol.fresh () in
        translate_expression true e >>= fun core_e       ->
        self s                      >>= fun core_s       ->
        E.get_visible_objects       >>= fun visible_syms ->
        
        let core_loop =
          Caux.mk_run_e sym_loop [ Caux.mk_sym_pe sym | forall (sym MEM visible_syms) | true ] in

        E.mapM (fun sym ->
            E.resolve_object_type sym >>= fun (_, ty) ->            
            E.return (sym, ((C.BTy_object C.OTy_pointer, Just (ty, C.By_pointer)), Caux.mk_sym_pe sym))
          ) visible_syms >>= fun args ->
        E.return begin
          Caux.mk_save_e_ [Annot.Alabel (Annot.LAloop loop_id)] (sym_loop, C.BTy_unit) args (
            (* loop body *)
            Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit) core_s
              (* controlling expression *)
              begin
                Caux.mk_sseq_e (Caux.mk_sym_pat sym_e (C.BTy_loaded C.OTy_integer)) core_e (
                  Caux.mk_case_e (Caux.mk_sym_pe sym_e)
                    [ ( Caux.mk_specified_pat (Caux.mk_sym_pat sym_case (C.BTy_object C.OTy_integer))
                      , Caux.mk_if_e (Caux.mk_not_pe (Caux.mk_op_pe C.OpEq (Caux.mk_sym_pe sym_case) (Caux.mk_integer_pe 0)))
                          core_loop Caux.mk_skip_e )
                      (* non-deterministic branching if the test expression had unspecified value *)
                    ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                      , (* Caux.mk_nd_e [core_loop; Caux.mk_skip_e] *)
                        Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY "unspecified AilSdo")) ) ]
                   )
              end
          )
        end
    
    | (*BISECT-IGNORE*) A.AilSbreak ->
        (* erase_loop_control must be called first, so this case is impossible. *)
        error "Translation.translate_stmt, found a break"
    
    | (*BISECT-IGNORE*) A.AilScontinue ->
        (* erase_loop_control must be called first, so this case is impossible. *)
        error "Translation.translate_stmt, found a continue"
    
    | A.AilSreturnVoid ->
        E.get_visible_objects >>= fun visible_syms ->
        E.mapM (fun sym ->
            E.resolve_object_type sym >>= fun (_, ty) ->
            E.return (sym, ty)
          ) visible_syms >>= fun visible_syms_tys ->
        E.return begin
          if env.is_Noreturn then
            Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.7.4#8" Undefined.UB071_noreturn)
          else
            let bTy =
              if List.length visible_syms < 2 then
                C.BTy_unit
              else
                C.BTy_tuple (List.replicate (List.length visible_syms) C.BTy_unit) in
            Caux.mk_sseq_e (Caux.mk_empty_pat bTy)
              (Caux.mk_unseq (List.map (fun (sym,ty) -> Caux.pkill loc (C.Static ty) (Caux.mk_sym_pe sym)) visible_syms_tys))
              (Caux.mk_run_e env.return_lab [Caux.mk_unit_pe])
        end
    
    | A.AilSreturn e ->
        E.get_visible_objects >>= fun visible_syms ->
        E.mapM (fun sym ->
            E.resolve_object_type sym >>= fun (_, ty) ->
            E.return (sym, ty)
        ) visible_syms >>= fun visible_syms_tys ->
        if env.is_Noreturn then
          E.return (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.7.4#8" Undefined.UB071_noreturn))
        else if AilTypesAux.atomic_qualified_unqualified AilTypesAux.is_pointer env.return_ty && Aaux.is_null_pointer_constant e then
          E.return begin
            mk_run_with_lifetime_e loc env.return_lab visible_syms_tys [] [Caux.mk_specified_pe (Caux.mk_nullptr_pe env.return_ty)]
          end
        else
          let oTy = force_core_object_type_of_ctype (ctype_of e) in
          translate_expression true e               >>= fun core_e ->
          E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun e_wrp  ->
        (* All the visible objects from the current function need to be killed. *)
        if AilTypesAux.atomic_qualified_unqualified AilTypesAux.is_Bool env.return_ty && AilTypesAux.is_pointer (ctype_of e) then
            (* By Ail's typing we know that [e] is a pointer *)
            E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun conv_wrp ->
            E.return begin
              Caux.mk_sseq_e e_wrp.E.sym_pat core_e begin
                Caux.mk_sseq_e conv_wrp.E.sym_pat (stdlib.mkproc_loaded_pointer_to_Bool e_wrp.E.sym_pe)
                (mk_run_with_lifetime_e loc env.return_lab visible_syms_tys [] [conv_wrp.E.sym_pe])
              end
            end
        else
          let ret_pe =
            if AilTypesAux.atomic_qualified_unqualified AilTypesAux.is_arithmetic env.return_ty && AilTypesAux.is_arithmetic (ctype_of e) then
                conv_loaded_arith stdlib (ctype_of e) env.return_ty e_wrp.E.sym_pe
            else
              e_wrp.E.sym_pe in   
          E.return begin 
            Caux.mk_sseq_e e_wrp.E.sym_pat core_e begin
              mk_run_with_lifetime_e loc env.return_lab visible_syms_tys [] [ret_pe]
            end
          end

    | A.AilSswitch e s ->
        (* Translate the controlling expression *)
        translate_expression true e >>= fun core_e ->
        let oTy = force_core_object_type_of_ctype (ctype_of e) in
        E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun e_wrp ->
        (* Case in specified values *)
        E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun control_wrp ->
        (* Integer promotion *)
        (* STD §6.8.4.2#5, sentence 1 *)
        E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun promoted_wrp ->
        let promoted_pe =
          Caux.mk_std_pe "§6.8.4.2#5, sentence 1" (
            stdlib.mkcall_conv_int (fromJust "Translation.translate_stmt: switch expr promotion"
              (AilTypesAux.promotion (Implementation.integerImpl ()) (ctype_of e))) control_wrp.E.sym_pe
          ) in
        (* Create case symbols and translate cases block *)
        let cases    = collect_cases s in
        let nb_cases = List.length (cases.case_csts) + List.length (cases.case_ranges) in
        let case_syms = list_init nb_cases (fun _ -> Symbol.fresh_pretty_with_id (fun x -> "case_" ^ show x)) in
        let default_sym = Symbol.fresh_pretty_with_id (fun x -> "default_" ^ show x) in
        let case_labs =
          List.zip
            begin
              (List.map (fun n -> CaseSelectConstant n) cases.case_csts) ++
              (List.map (fun (n1, n2) -> CaseSelectRange n1 n2) cases.case_ranges)
            end case_syms in
        translate_cases_block case_labs (Just default_sym) s >>= fun core_s ->
        E.get_visible_objects >>= fun visible_syms ->
        let visible_pes = List.map (fun sym -> Caux.mk_sym_pe sym) visible_syms in
        (* Build translated switch *)
        E.return
          (* Get control expression *)
          (Caux.mk_sseq_e e_wrp.E.sym_pat core_e
            (* Check if unspecified *)
            (Caux.mk_case_e e_wrp.E.sym_pe
              [ ( Caux.mk_specified_pat control_wrp.E.sym_pat
                , (* Do integer promotion *)
                  Caux.mk_sseq_e promoted_wrp.E.sym_pat
                    (Caux.mk_pure_e promoted_pe)
                    (* For every case.... *)
                    (List.foldl (fun acc (case_select, case_lab) ->
                      let select_test =
                        match case_select with
                          | CaseSelectConstant case_n ->
                              Caux.mk_op_pe C.OpEq promoted_wrp.E.sym_pe (Caux.mk_value_pe (C.Vobject (C.OVinteger (Mem.integer_ival case_n))))
                          | CaseSelectRange case_n1 case_n2 ->
                              Caux.mk_op_pe C.OpAnd
                                (Caux.mk_op_pe C.OpLe (Caux.mk_value_pe (C.Vobject (C.OVinteger (Mem.integer_ival case_n1)))) promoted_wrp.E.sym_pe)
                                (Caux.mk_op_pe C.OpLe promoted_wrp.E.sym_pe (Caux.mk_value_pe (C.Vobject (C.OVinteger (Mem.integer_ival case_n2)))))
                        end in
                      Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit)
                        (* Check if equal to the constant expression *)
                        (Caux.mk_if_e select_test
                          (* TODO: not sure if the visible afters are the same *)
                          (Caux.mk_run_e case_lab visible_pes)
                          (Caux.mk_skip_e))
                        acc)
                    (* default branch *)
                    (Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit) 
                      (if cases.found_default then
                        Caux.mk_run_e default_sym visible_pes
                        else
                        Caux.mk_skip_e)
                      core_s)
                    case_labs) )
                 (* UB if unspecified *)
               ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                 , Caux.mk_pure_e (Caux.mk_undef_exceptional_condition loc) ) ]))
    
    | A.AilScase n s ->
        self s                >>= fun core_s       ->
        E.get_visible_objects >>= fun visible_syms ->
        E.mapM (fun sym ->
            E.resolve_object_type sym >>= fun (_, ty) ->
            E.return (sym, ((C.BTy_object C.OTy_pointer, Just (ty, C.By_pointer)), Caux.mk_sym_pe sym))
          ) visible_syms >>= fun visible_pes ->
        match List.lookup (CaseSelectConstant n) env.case_labs with
          | Just lab ->
              E.return (Caux.mk_save_e_ [Annot.Alabel (Annot.LAcase)] (lab, C.BTy_unit) visible_pes core_s)
          | (*BISECT-IGNORE*) Nothing ->
              error "Translation.translate_stmt: case label not found."
        end

    | A.AilScase_rangeGNU n1 n2 s ->
        self s                >>= fun core_s       ->
        E.get_visible_objects >>= fun visible_syms ->
        E.mapM (fun sym ->
            E.resolve_object_type sym >>= fun (_, ty) ->
            E.return (sym, ((C.BTy_object C.OTy_pointer, Just (ty, C.By_pointer)), Caux.mk_sym_pe sym))
          ) visible_syms >>= fun visible_pes ->
        match List.lookup (CaseSelectRange n1 n2) env.case_labs with
          | Just lab ->
              E.return (Caux.mk_save_e_ [Annot.Alabel (Annot.LAcase)] (lab, C.BTy_unit) visible_pes core_s)
          | (*BISECT-IGNORE*) Nothing ->
              error "Translation.translate_stmt: case label not found."
        end
    
    | A.AilSdefault s ->
        self s >>= fun core_s ->
        E.get_visible_objects >>= fun visible_syms ->
        E.mapM (fun sym ->
            E.resolve_object_type sym >>= fun (_, ty) ->
            E.return (sym, ((C.BTy_object C.OTy_pointer, Just (ty, C.By_pointer)), Caux.mk_sym_pe sym))
          ) visible_syms >>= fun visible_pes ->
        match env.default_lab with
          | Just lab ->
              E.return (Caux.mk_save_e_ [Annot.Alabel (Annot.LAdefault)] (lab, C.BTy_unit) visible_pes core_s)
          | (*BISECT-IGNORE*) Nothing ->
              error "Translation.translate_stmt: default label not found."
        end
    
    | A.AilSlabel sym s m_label_annot ->
        self s                >>= fun core_s       ->
        E.get_visible_objects >>= fun visible_syms ->
        E.mapM (fun sym ->
            E.resolve_object_type sym >>= fun (_, ty) ->
            E.return (sym, ((C.BTy_object C.OTy_pointer, Just (ty, C.By_pointer)), Caux.mk_sym_pe sym))
          ) visible_syms >>= fun args ->
        (* Some AilSlabel's are added by cabs-to-ail: continue labels 
           created for different kinds of loops. Those will have an
           m_label_annot of the form `Just`, rather than `Nothing`. 
           Those AilSlabel's that were not introduced by cabs-to-ail
           should all be proper labels in the C source, and with `Nothing`
           for m_label_annot. So for these, we add the corresponding label
           annotation here. *)
        let annots = match m_label_annot with
          | Just loop_annot -> [Annot.Alabel loop_annot]
          | Nothing -> [Annot.Alabel Annot.LAactual_label]
        end in
        E.return (Caux.mk_save_e_ annots (sym, C.BTy_unit) args core_s)
    
    | A.AilSgoto sym ->
        E.get_visible_objects >>= fun visible_syms ->
        E.mapM (fun sym ->
            E.resolve_object_type sym >>= fun (_, ty) ->
            E.return (sym, ty)
        ) visible_syms >>= fun visible_syms_tys ->
        let visibles_after = fromJust "Translation.translation_statement, AilSgoto" (Map.lookup sym env.label_visibles) in
        E.return (mk_run_with_lifetime_e loc sym visible_syms_tys visibles_after [])
    
    | A.AilSdeclaration sym_es ->
        (* This pass translates the declarations *)
        E.mapM (fun (ptr_sym, e_opt) ->
          E.resolve_object_type ptr_sym >>= fun (qs, ty) ->
          let ptr_sym_e = Caux.mk_sym_pe ptr_sym in
          let mk_store =
            (if qs.Ctype.const then Caux.pstore_lock else Caux.pstore)
              loc (Caux.mk_ail_ctype_pe ty) ptr_sym_e in
          match e_opt with
            | Nothing ->
                if Global.backend_name () = "Cn" then
                  (* CN does not support unspecified values *)
                  E.return Caux.mk_skip_e
                else
                E.return begin
                  Caux.add_std "§6.2.4#6"
                    (mk_store (Caux.mk_unspecified_pe ty) Cmm.NA)
                end
            | Just e ->
                let oTy = force_core_object_type_of_ctype (ctype_of e) in
                E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun e_wrp ->
                  match (* Ctype.unatomic_ *) Ctype.proj_ctype_ ty with
                  | Ctype.Pointer _ ref_ty ->
                      if Aaux.is_null_pointer_constant e then
                        E.return (
                          mk_store (Caux.mk_specified_pe (Caux.mk_nullptr_pe ref_ty)) Cmm.NA
                        )
                        else
                          translate_expression true e >>= fun core_e ->
                          E.return (
                            Caux.mk_sseq_e e_wrp.E.sym_pat core_e (mk_store e_wrp.E.sym_pe Cmm.NA)
                          )
                  | _ ->
                      translate_expression true e >>= fun core_e ->
                      if AilTypesAux.is_pointer (ctype_of e) then
                        (* we are dealing with the case {_Bool} = {pointer} *)
                        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun conv_wrp ->
                        E.return begin
                          Caux.mk_sseq_e e_wrp.E.sym_pat core_e begin
                            Caux.mk_sseq_e conv_wrp.E.sym_pat (stdlib.mkproc_loaded_pointer_to_Bool e_wrp.E.sym_pe)
                              (mk_store conv_wrp.E.sym_pe Cmm.NA)
                          end
                        end
                      else
                        (* we are not dealing with a pointer on either sides *)
                      if Global.is_CHERI () && Ctype.is_ptr_t ty && not (Ctype.is_ptr_t (ctype_of e)) then
                        E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun obj_wrp ->
                        E.return begin
                          Caux.mk_sseq_e e_wrp.E.sym_pat core_e begin
                            Caux.mk_case_e e_wrp.E.sym_pe
                              [ ( Caux.mk_specified_pat obj_wrp.E.sym_pat
                                , mk_store begin
                                    let is_signed = AilTypesAux.is_signed_integer_type ty in
                                    Caux.mk_specified_pe begin
                                      Caux.mk_memop_pe Mem_common.CapAssignValue
                                        [Caux.mk_nullcap_pe is_signed; conv_arith stdlib (ctype_of e) ty obj_wrp.E.sym_pe]
                                    end
                                  end Cmm.NA )
                              ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                                , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY "AilSdeclaration")) ) ]
                          end
                        end
                      else if Global.is_CHERI () && not (Ctype.is_ptr_t ty) && Ctype.is_ptr_t (ctype_of e) then
                        E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun obj_wrp ->
                        E.return begin
                          Caux.mk_sseq_e e_wrp.E.sym_pat core_e begin
                            Caux.mk_case_e e_wrp.E.sym_pe
                              [ ( Caux.mk_specified_pat obj_wrp.E.sym_pat
                                , mk_store begin
                                    Caux.mk_specified_pe (conv_arith stdlib (ctype_of e) ty (Caux.mk_memop_pe Mem_common.Ptr_tIntValue [obj_wrp.E.sym_pe]))
                                  end Cmm.NA )
                              ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                                , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY "[u]intptr_t to integer/floating AilSdeclaration")) ) ]
                          end
                        end
                      else
                        E.return begin
                          Caux.mk_sseq_e e_wrp.E.sym_pat core_e
                            (mk_store
                              (if AilTypesAux.is_arithmetic ty then conv_loaded_arith stdlib (ctype_of e) ty e_wrp.E.sym_pe else e_wrp.E.sym_pe) Cmm.NA)
                        end
                end
          end
        ) sym_es >>= fun z ->
        
        (* This pass combines the translated declarations *)
        match z with
          | [] ->
              E.return Caux.mk_skip_e
          | z::zs' ->
              E.foldlM (fun x y -> E.return (Caux.concat_sseq x y)) z zs'
        end
    
    | A.AilSpar ss ->
        E.mapM self ss >>= fun core_ss ->
        E.return begin
          Caux.mk_wseq_e (Caux.mk_empty_pat (C.BTy_tuple (List.replicate (List.length ss) C.BTy_unit)))
            (C.Expr [] (C.Epar core_ss))
            Caux.mk_skip_e
        end

    | A.AilSreg_store _ _ ->
        (* the frontend doesn't yet emit this *)
        error "TODO: translate_stmt AilSreg_store"

    | A.AilSmarker id s ->
        self s >>= fun core_s ->
        E.record_object_types_marker () >>= fun id2 ->
        E.return begin
          Caux.add_annots [Annot.Amarker_object_types id2; Annot.Amarker id] begin
            Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit) (Caux.mk_pure_e (Caux.mk_unit_pe))
              core_s
          end
        end

  end


val translate_tag_definitions:
  list (A.ail_identifier * (Loc.t * Annot.attributes * Ctype.tag_definition)) ->
  C.core_tag_definitions
let translate_tag_definitions ctx =
  Map.fromList (List.map (fun (x, (loc, _, y)) -> (x, (loc, y))) ctx)

import Cerb_attributes

val translate_program:
  translation_stdlib ->
  maybe Symbol.sym * A.sigma GenTypes.genTypeCategory ->
  E.elabM (  C.core_tag_definitions
           * list (Symbol.sym * (C.generic_globs unit unit))
           * C.generic_fun_map unit unit
           * map Symbol.sym (Loc.t * Annot.attributes * Ctype.ctype * list (maybe Symbol.sym * Ctype.ctype) * bool * bool) )

let translate_program stdlib (startup_sym_opt, sigm) =
  let core_tagDefs = translate_tag_definitions sigm.A.tag_definitions in
  
  E.foldlM (fun (gacc, facc, finfoacc) (sym, (loc, decl_attrs, decl)) ->
    (* for each Ail declaration *)
    match decl with
      | A.Decl_object _ align qs ty ->
          (* elaboration of a global variables *)
          let core_ty     = Caux.mk_ail_ctype_pe ty in
          let align_ival  =
            match align with
              | Just (Ctype.AlignInteger n) ->
                  Caux.mk_integer_pe n
              | Just (Ctype.AlignType al_ty) ->
                  Caux.mk_alignof_pe (Caux.mk_ail_ctype_pe al_ty)
              | Nothing ->
                  Caux.mk_alignof_pe (Caux.mk_ail_ctype_pe ty)
            end in
          let core_create =
            match Cerb_attributes.decode_with_address decl_attrs with
              | Right (Just addr) ->
                  Caux.add_annot (Annot.Acerb (Annot.ACerb_with_address addr))
              | _ ->
                  (fun z -> z)
            end (Caux.pcreate loc align_ival core_ty (Symbol.PrefSource loc [sym])) in
          let sym_global  = Symbol.fresh () in

          match List.lookup sym sigm.A.object_definitions with
            | Nothing ->
                (* we are dealing with an external object *)
                E.return ( (sym, C.GlobalDecl (C.BTy_object C.OTy_pointer, ty)) :: gacc, facc, finfoacc )
            
            | Just expr ->
                begin
                  if AilTypesAux.is_pointer ty && Aaux.is_null_pointer_constant expr then
                    E.return (
                      C.BTy_loaded C.OTy_pointer,
                      Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_nullptr_pe ty))
                    )
                  else
                    (* NOTE: we use `with_block_objects`, for the compound_literal tracking *)
                    E.with_block_objects [] begin
                      wrapped_translate_expression true (ECTX_glob sym sym_global) ((Nothing: maybe Symbol.sym), (Nothing: maybe Symbol.sym)) stdlib core_tagDefs expr
                    end >>= fun (_, compound_lits, core) ->
                    let lit_pats_core_creates : list (C.pattern * C.expr unit) =
                      List.map (fun (loc, prefix, sym, is_const, ty) ->
                        let core_ty = Caux.mk_ail_ctype_pe ty in
                        ( Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer)
                        , Caux.pcreate loc (Caux.mk_alignof_pe core_ty) core_ty prefix )
                      ) compound_lits in
                    E.return (
                      C.BTy_loaded (force_core_object_type_of_ctype (ctype_of expr)),
                      Caux.mk_sseqs lit_pats_core_creates core
                    )
                end >>= fun (e_bTy, core_e) ->
                let e_sym = Symbol.fresh () in
                let core_init_e =
                  if AilTypesAux.is_integer ty || AilTypesAux.is_floating ty then
                    conv_loaded_arith stdlib (ctype_of expr) ty (Caux.mk_sym_pe e_sym)
                  else
                    Caux.mk_sym_pe e_sym in
                let mk_store =
                  (* const-qualified globals are made read-only *)
                  if qs.Ctype.const then Caux.pstore_lock else Caux.pstore in
                let core_e =
                  Caux.add_loc (locOf core_e) begin
                    Caux.mk_sseq_e (Caux.mk_sym_pat sym_global (C.BTy_object C.OTy_pointer)) core_create (
                      Caux.mk_sseq_e (Caux.mk_sym_pat e_sym e_bTy) core_e (
                       Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit)
                         (* TODO: proper memory order *)
                         (mk_store loc core_ty (Caux.mk_sym_pe sym_global) core_init_e Cmm.NA)
                         (Caux.mk_pure_e (Caux.mk_sym_pe sym_global))
                      ))
                  end in
                E.return
                  ( (sym, C.GlobalDef (C.BTy_object C.OTy_pointer, ty) core_e) :: gacc
                  , facc, finfoacc )
          end
      
      | A.Decl_function has_proto (_, return_ty) params is_variadic is_inline is_Noreturn ->
          let is_using_inner_arg_temps =
            (* NOTE: we exclude main because the driver allocates the objects for argc and argvs *)
            (* with this switch the argument temporary objects are allocated in the function *)
            Global.has_switch Global.SW_inner_arg_temps in
          (* elaboration of a function *)
          let ret_bTy =
            if AilTypesAux.is_void return_ty then
              C.BTy_unit
            else
              C.BTy_loaded (force_core_object_type_of_ctype return_ty) in
          let param_bTys =
            if is_using_inner_arg_temps then
              List.map (fun (_, ty, _) -> C.BTy_loaded (force_core_object_type_of_ctype ty)) params
            else
              List.replicate (List.length params) (C.BTy_object C.OTy_pointer) in
          match List.lookup sym sigm.A.function_definitions with
            | Nothing ->
                (* if the function has no definition, we create a Core procedure declaration *)
                let finfo =     (* TODO: plug in non-empty attributes *)
                  ( loc, decl_attrs, return_ty
                    (* TODO: check if we need qualifiers too *)
                  , List.map (fun (_, ty, _) -> (Nothing, ty)) params
                  , is_variadic, has_proto ) in
                E.return
                  ( gacc
                  , Map.insert sym (C.ProcDecl loc ret_bTy param_bTys) facc
                    (* get the correct symbol if a proxy exists *)
                  , match sym with
                      | Symbol.Symbol _ _ (Symbol.SD_Id str) ->
                          match Map.lookup str stdlib.ailnames with
                            | Just sym_proxy -> Map.insert sym_proxy finfo finfoacc
                            | Nothing -> Map.insert sym finfo finfoacc
                          end
                      | _ -> Map.insert sym finfo finfoacc
                    end )
            
            | Just (loc, mrk, _, param_syms, stmt) ->
                E.mapM (fun (s, bTy) ->
                  let descr = 
                    if not (Global.has_switch Global.SW_inner_arg_temps) then Symbol.SD_None else
                      match Symbol.symbol_description s with
                      | Symbol.SD_ObjectAddress v -> Symbol.SD_FunArgValue v
                      | _ -> Assert_extra.failwith "function argument does not have SD_ObjectAddress description"
                      end
                  in
                  E.wrapped_fresh_symbol_ descr bTy >>= fun (sym, _, sym_pe) ->
                  E.return (sym, sym_pe)
                ) (List.zip param_syms param_bTys) >>= fun arg_value_decls ->
                let finfo =
                  (* NOTE: the attributes in the Ail function declarations includes the ones only present on both
                     the Cabs function declaration and definition *)
                  ( loc, decl_attrs, return_ty
                  (* TODO: check if we need qualifiers too *)
                  , List.map (fun (sym, (_, ty, _)) -> 
                        if Global.has_switch Global.SW_inner_arg_temps then 
                          let descr = match Symbol.symbol_description sym with
                            | Symbol.SD_ObjectAddress v -> Symbol.SD_FunArgValue v
                            | _ -> Assert_extra.failwith "function argument does not have SD_ObjectAddress description"
                          end in
                          (Just (Symbol.set_symbol_description sym descr), ty)
                        else
                          (Just sym, ty)
                      ) (List.zip param_syms params)
                  , is_variadic, has_proto ) in
                let ret_label = Symbol.fresh_pretty_with_id (fun x -> "ret_" ^ show x) in
                let stmt = erase_loop_control stmt in
                let visibles = collect_visibles stmt in
                let (variadic_sym_opt, last_arg_sym_opt) =
                  if is_variadic then
                    match List.reverse param_syms with
                      | [] -> error "variadic functions need to have at least one parameter"
                      | sym::_ -> (Just (Symbol.fresh ()), Just sym)
                    end
                  else
                    (Nothing, Nothing)
                in
                let (mk_body_wrapper, label_visibles) =
                  if is_using_inner_arg_temps then
                    let xs = List.map (fun (sym, (_, ty, _)) -> (sym, ty)) (List.zip param_syms params) in
                    ( (fun z -> E.with_block_objects (List.map (fun (sym, ty) -> (sym, (Ctype.no_qualifiers, ty))) xs) z >>= fun (_, _, ret) -> E.return ret)
                    , Map.map (fun z -> z ++ xs) visibles.label_visibles_ )
                  else
                    ((fun z -> z), visibles.label_visibles_) in
                mk_body_wrapper
                  (translate_stmt stdlib core_tagDefs sym <|
                    return_ty= return_ty;
                    return_lab= ret_label;
                    variadic_sym_opt= variadic_sym_opt;
                    last_arg_sym_opt= last_arg_sym_opt;
                    is_Noreturn= is_Noreturn;
                    default_lab= Nothing;
                    case_labs= [];
                    loop= Nothing;
                    break= Nothing;
                    label_visibles= label_visibles;
                  |> stmt) >>= fun core_body ->
                let add_prelude_and_epilogue z =
                  if is_using_inner_arg_temps then
                    Caux.mk_sseqs
                      begin
                        List.concat begin
                          List.mapi (fun i ((_, ty, _), (ptr_sym, (_, value_sym_pe))) ->
                            let ty_pe = Caux.mk_ctype_pe ty in
                            [ ( Caux.mk_sym_pat ptr_sym (C.BTy_object C.OTy_pointer)
                              , Caux.pcreate loc (Caux.mk_alignof_pe ty_pe) ty_pe (Symbol.PrefFunArg loc (Symbol.digest ()) (intFromNat i)) )
                            ; ( Caux.mk_empty_pat C.BTy_unit
                              , Caux.pstore loc ty_pe (Caux.mk_sym_pe ptr_sym) value_sym_pe Cmm.NA ) ]
                          ) (List.zip params (List.zip param_syms arg_value_decls))
                        end
                      end
                      begin
                        Caux.mk_unit_sseq
                          begin
                            z ::
                            List.map (fun (ptr_sym, (_, ty, _)) ->
                              Caux.pkill loc (C.Static ty) (Caux.mk_sym_pe ptr_sym)
                            ) (List.zip param_syms params)
                          end
                          (Caux.mk_pure_e Caux.mk_unit_pe)
                      end
                  else
                    z in
                (* let is_used_sym = Symbol.fresh () in
                let is_used_arg_type = (is_used_sym, C.BTy_boolean) in *)
                let ret_sym = Symbol.fresh () in
                let core_return =
                  let ret_pe =
                    if startup_sym_opt = Just sym then
                      (* STD §5.1.2.2.3#1 sentence 1*)
                      Caux.mk_specified_pe (Caux.mk_integer_pe 0)
                    else if AilTypesAux.is_void return_ty && is_Noreturn then
                      Caux.mk_std_undef_pe loc "§6.7.4#8" Undefined.UB071_noreturn
                    else if AilTypesAux.is_void return_ty then
                      Caux.mk_unit_pe
                    else
                      (* Caux.mk_if_pe (Caux.mk_sym_pe is_used_sym)
                        (Caux.mk_std_undef_pe loc "§6.9.1#12" Undefined.UB088_reached_end_of_function)
                        (Caux.mk_unspecified_pe return_ty) in *)
                      Caux.mk_std_undef_pe loc "§6.9.1#12" Undefined.UB088_reached_end_of_function in
                  Caux.mk_save_e_ [Annot.Alabel Annot.LAreturn; Annot.Aloc loc]
                                  (ret_label, ret_bTy)
                                  [(ret_sym, ((ret_bTy, Just (return_ty, C.By_value)), ret_pe))]
                    (Caux.mk_pure_e (Caux.mk_sym_pe ret_sym))
                in
                let variadic_arg_type =
                  match variadic_sym_opt with
                    | Just sym -> [(sym, C.BTy_list (C.BTy_tuple [C.BTy_ctype; C.BTy_object C.OTy_pointer]))]
                    | Nothing -> []
                  end
                in
                let param_syms =
                  if is_using_inner_arg_temps then
                    List.map fst arg_value_decls
                  else
                    param_syms in
                E.return
                  ( gacc
                  , Map.insert sym
                     (C.Proc loc (Just mrk) ret_bTy
                             ((*is_used_arg_type :: *)List.zip param_syms param_bTys ++ variadic_arg_type)
                             (Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit) (add_prelude_and_epilogue core_body) core_return)
                     ) facc
                  , Map.insert sym finfo finfoacc )
          end
    end
  ) ([], Map.empty, Map.empty) (List.reverse sigm.A.declarations) >>= fun (globs, cfuns, funinfo) ->
  
  (* adding string literals as Core globals *)
  E.get_string_literals >>= fun xs ->
  E.foldlM begin if Global.is_CHERI () then
    (* For CHERI we do not use create_readonly() *)
    fun acc (loc, sym, ty, e_init) ->
       let ptr_ty = AilTypesAux.array_coercion ty in
        E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun ptr_wrp ->
        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun tmp_wrp ->
        (*
          lets ptr = create(Ivalignof([| ty |]), [| ty |]) in
          lets _   = store_lock(TY, ptr, [| e_init |]) in
          LET mask = [| ~(CAP_PERM_STORE || CAP_PERM_STORE_CAP || CAP_PERM_STORE_LOCAL_CAP) |] IN
          lets tmp = memop(cheri_perms_and, ptr, mask) in
          case tmp of
            | Specifed(ptr) => pure(ptr)
            | Unspecified(_) => pure(undef("Unspecified cheri_perms_and()"))
          end
        *)
        let expr =
          let ty_pe = Caux.mk_ctype_pe ty in
          Caux.mk_sseqs [
            ( ptr_wrp.E.sym_pat
            , Caux.pcreate loc (Caux.mk_alignof_pe ty_pe) ty_pe
                (Symbol.PrefStringLiteral loc (Symbol.digest_of_sym sym)) )
          ; ( Caux.mk_empty_pat C.BTy_unit
            , Caux.pstore_lock loc ty_pe ptr_wrp.E.sym_pe e_init Cmm.NA )
          ] begin
            Caux.mk_sseq_e tmp_wrp.E.sym_pat (cheri_readonly_perms ptr_ty ptr_wrp.E.sym_pe)
              (Caux.mk_case_e tmp_wrp.E.sym_pe
                [ ( Caux.mk_specified_pat ptr_wrp.E.sym_pat
                  , Caux.mk_pure_e ptr_wrp.E.sym_pe )
                ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                  , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY "Unspecified cheri_perms_and()")) ) ] )
          end in
        E.return ((sym, C.GlobalDef (C.BTy_object C.OTy_pointer, ty) expr) :: acc)
  else
    fun acc (loc, sym, ty, e_init) ->
      let expr =
        Caux.pcreate_readonly loc
          (Caux.mk_alignof_pe (Caux.mk_ctype_pe ty))
          (Caux.mk_ctype_pe ty)
          e_init
          (Symbol.PrefStringLiteral loc (Symbol.digest_of_sym sym)) in
      E.return ((sym, C.GlobalDef (C.BTy_object C.OTy_pointer, ty) expr) :: acc)
  end globs (List.reverse xs) >>= fun globs' ->
  E.return (core_tagDefs, globs', cfuns, funinfo)


let translate_extern_map (_, sigm) =
  Map.map (fun (sym, kind) ->
    match kind with
      | A.IK_declaration -> ([sym], C.LK_none)
      | A.IK_tentative   -> ([sym], C.LK_tentative sym)
      | A.IK_definition  -> ([sym], C.LK_normal sym)
    end) sigm.A.extern_idmap


(* This is the entry function (called from main.ml) *)
val translate:
    (map string Symbol.sym) * C.fun_map unit ->
    C.calling_convention ->
    C.impl -> 
    A.ail_program GenTypes.genTypeCategory ->
    C.file unit
let translate (ailnames, stdlib_fun_map) callconv impl prog =
  let translation_stdlib = mk_translation_stdlib (ailnames, stdlib_fun_map) in
  let ((core_tagDefs, cglobs, (*cdecls, *) cfuns, funinfo), st) =
    E.runStateM_errors (translate_program translation_stdlib prog) (E.elab_init callconv)
  in
  <| C.main= fst prog;
     C.calling_convention= callconv;
     C.tagDefs= core_tagDefs;
     C.stdlib= stdlib_fun_map;
     C.impl= impl;
     C.globs= Core_linking.merge_globs cglobs [] []; (* topological sort *)
     C.funs= cfuns;
     C.extern = translate_extern_map prog;
     C.funinfo= funinfo;
     C.loop_attributes= (snd prog).A.loop_attributes; 
     C.visible_objects_env= st.E.visible_objects_types_markers_env;
  |>
