open Global

type constant = num
type apply = constant * constant
type term =
  | Constant of constant
  | Apply of apply

type t = <|
  delta : Union_find.t;
  use : (apply * constant) list Braun.t;
  congr : (constant * constant, constant) map;
  pending : (constant * constant) list;
  length : num
|>

let create s = <|
  delta = Union_find.create s;
  use = Braun.create s [];
  congr = Pmap.empty;
  pending = [];
  length = s
|>

let find cc c =
  let (r, d) = Union_find.find cc.delta c in
  (r, <|cc with delta = d|>)

let combine cc c1 c2 =
  let (hint, d) = Union_find.combine_hint cc.delta c1 c2 in
  (hint, <|cc with delta = d|>)

let find_congr cc r1 r2 = Map.find (r1, r2) cc.congr

let add_pending cc eq = <|cc with pending = eq :: cc.pending|>

let rec fold f cc =
  match cc.pending with
    | []         -> cc
    | eq :: rest -> fold f (f <|cc with pending = rest|> eq)
  end

let propagate cc =
  let process cc (c1, c2) =
    let (hint, cc) = combine cc c1 c2 in
    match hint with
      | Union_find.Equal      -> cc
      | Union_find.Less r1 r2 ->
          List.fold_left 
            (fun cc ((c1, c2) as f, c) ->
              let (c1', cc) = find cc c1 in
              let (c2', cc) = find cc c2 in
              match find_congr cc c1' c2' with
                | Some congr ->
                    add_pending cc (c, congr)
                | None ->
                    <|cc with
                      use   = Braun.update cc.use r2 ((::) (f, c));
                      congr = Pmap.add (c1', c2') c cc.congr
                    |>
              end)
            <|cc with use = Braun.set cc.use r1 []|>
            (Braun.get cc.use r1)
    end in
  fold process cc

let merge cc t c =
  match t with
    | Constant c' -> propagate (add_pending cc (c', c))
    | Apply ((c1, c2) as f)->
        let (r1, cc) = find cc c1 in
        let (r2, cc) = find cc c2 in
        match find_congr cc r1 r2 with
          | Some congr ->
              propagate (add_pending cc (c, congr))
          | None ->
              let add r a = Braun.update a r ((::) (f, c)) in
              <|cc with
                use = add r2 (add r1 cc.use);
                congr = Pmap.add (r1, r2) c cc.congr
              |>
        end
  end

let merge_constants cc c c' = propagate (add_pending cc (c', c))

let rec normalise cc t =
  match t with
    | Constant c ->
        let (r, cc) = find cc c in
        (Constant r, cc)
    | Apply (c1, c2) ->
        let (u1, cc) = normalise cc (Constant c1) in
        let (u2, cc) = normalise cc (Constant c2) in
        match (u1, u2) with
          | (Constant r1, Constant r2) ->
              match find_congr cc r1 r2 with
                | Some congr ->
                    let (r, cc) = find cc congr in
                    (Constant r, cc)
                | None ->
                    (Apply (r1, r2), cc)
              end
          (* Should be unreachable *)
          | _ -> (t, cc)
       end
  end

let normalise_constant cc c = find cc c

let congruent cc t1 t2 =
  let (r1, cc) = normalise cc t1 in
  let (r2, cc) = normalise cc t2 in
  (r1 = r2, cc)

let congruent_constants cc c1 c2 =
  let (r1, cc) = normalise_constant cc c1 in
  let (r2, cc) = normalise_constant cc c2 in
  (r1 = r2, cc)

(*
let grow cc n = <|cc with
  delta = Union_find.grow cc.delta n;
  use = Braun.grow cc.use n (fun _ -> []);
  length = cc.length + n
|>
*)

let size cc = cc.length