% Categories
% X - hide from Tex
% O - hide from OCaml

embed {{ tex-preamble
\geometry{landscape}
\renewcommand{\[[TEX_NAME_PREFIX]]kw}[1]{ \texttt{#1} }
\renewcommand{\[[TEX_NAME_PREFIX]]drule}[4][]{ {\displaystyle\frac{\begin{array}{l}#2\end{array} }{#3}\quad\[[TEX_NAME_PREFIX]]drulename{#4} }\\[\baselineskip] }
}}


metavar ident , x , y , yp {{ tex { y_p } }} , yf {{ tex { y_f } }} , _ , abbrev , r ::= {{ phantom }}
  {{ com subscripts: p for pointers, f for functions }}


indexvar n , i , j ::= {{ phantom }} {{ com index variables }}


grammar

  Sctypes_t , ct {{ tex \tau }} :: '' ::= {{ ocaml Sctypes.t }} {{ phantom }} {{ com C type }}
    | ct *s :: :: Pointer {{ com pointer to type $[[ct]]$ }}


grammar

  ty_tag {{ tex tag }} :: 'Ty_tag' ::= {{ ocaml tag }} {{ phantom }} {{ com OCaml type for struct/union tag }}
    | ident :: :: ident


  base_type {{ tex \beta }} , _bt {{ tex \_ }} :: '' ::= {{ com base types }}
    | unit                                       ::   :: Unit     {{ com unit              }}
    | bool                                       ::   :: Bool     {{ com boolean           }}
    | integer                                    ::   :: Integer  {{ com integer           }}
    | real                                       ::   :: Read     {{ com rational numbers? }}
    | loc                                        ::   :: Loc      {{ com location          }}
    | array base_type                            ::   :: ArrayTy  {{ com array             }}
    | list base_type                             ::   :: ListTy   {{ com list              }}
    | </ base_typei // * // i />                 ::   :: TupleTy  {{ com tuple             }}
    | struct ty_tag                              ::   :: Struct   {{ com struct            }}
    | set base_type                              ::   :: Set      {{ com set               }}
    | opt ( base_type )                          ::   :: Option   {{ com option            }}
    | base_type -> base_type'                    ::   :: ParamTy  {{ com parameter types   }}
    | to_base ( ct )                             :: M :: Of_Ctype {{ com of a C type       }}
                                                                  {{ tex \beta_{ [[ct]] }  }}
                                                                  {{ ocaml (BT.of_sct ( [[ct]] ) ) }}


grammar

  % Binary operators
  binop {{ tex \mathbin{ binop } }}:: 'Op' ::= {{ ocaml Core.binop }} {{ phantom }} {{ com binary operators }}
    % arithmetic operators (integer -> integer -> integer)
    | +     :: :: Add   {{ tex \mathbin{ \texttt{+} } }} {{ com addition       }}
    | -     :: :: Sub   {{ tex \mathbin{ \texttt{-} } }} {{ com subtraction    }}
    | *     :: :: Mul   {{ tex \mathbin{ \texttt{*} } }} {{ com multiplication }}
    | /     :: :: Div   {{ tex \mathbin{ \texttt{/} } }} {{ com division       }}
    | rem_t :: :: Rem_t {{ tex \mathbin{ [[rem_t]] }  }} {{ com modulus        }}
    | rem_f :: :: Rem_f {{ tex \mathbin{ [[rem_f]] }  }} {{ com remainder      }}
    | ^     :: :: Exp                                    {{ com exponentiation }}
    % relational operators ( ptr/int -> ptr/int -> bool)
    | =     :: :: Eq    {{ tex \mathbin{ \texttt{=}  } }} {{ com equality, defined both for integer and C types }}
    | <>    :: :: Ne    {{ tex \mathbin{ \texttt{!=} } }} {{ com inequality, similiarly defined                 }}
    | >     :: :: Gt    {{ tex \mathbin{ \texttt{>}  } }} {{ com greater than, similarly defined                }}
    | <     :: :: Lt    {{ tex \mathbin{ \texttt{<}  } }} {{ com less than, similarly defined                   }}
    | >=    :: :: Ge    {{ tex \mathbin{ \texttt{>=} } }} {{ com greater than or equal to, similarly defined    }}
    | <=    :: :: Le    {{ tex \mathbin{ \texttt{<=} } }} {{ com less than or equal to, similarly defined       }}
    % logical connectives ( bool -> bool -> bool)
    | /\    :: :: And   {{ tex \mathbin{ \texttt{/\char`\\} } }} {{ com conjucntion }}
    | \/    :: :: Or    {{ tex \mathbin{ \texttt{\char`\\/} } }} {{ com disjunction }}


  arith_binop {{ tex \mathbin{ binop_{arith} } }} :: 'Arith_Op' ::= {{ phantom }} {{ com arithmentic binary operators }}
    | +     :: :: Add
    | -     :: :: Sub
    | *     :: :: Mul
    | /     :: :: Div
    | rem_t :: :: Rem_t
    | rem_f :: :: Rem_f
    | ^     :: :: Exp


  rel_binop {{ tex \mathbin{ binop_{rel} } }} :: 'Rel_Op' ::= {{ phantom }} {{ com relational binary operators }}
    | =     :: :: Eq
    | <>    :: :: Ne
    | >     :: :: Gt
    | <     :: :: Lt
    | >=    :: :: Ge
    | <=    :: :: Le


  bool_binop {{ tex \mathbin{ binop_{bool} } }} :: 'Bool_Op' ::= {{ phantom }} {{ com boolean binary operators }}
    | /\    :: :: And
    | \/    :: :: Or


  subrules
    arith_binop <:: binop
    rel_binop   <:: binop
    bool_binop  <:: binop


metavar impl_const ::= {{ ocaml Implementation.implementation_constant }} {{ phantom }}
  {{ com implementation-defined constant }}


grammar

  tyvar_sym {{ tex ident }} :: 'Tyvar_sym_' ::= {{ ocaml 'sym }} {{ phantom }} {{ com Ott-hack, ignore }}
    | ident :: :: ident


grammar

  ty_mem_int {{ tex mem\_int }} :: 'Ty_mem_int' ::= {{ ocaml Impl_mem.integer_value }} {{ phantom }} {{ com memory integer value }}
    | mem_one  :: M :: One  {{ ocaml Memory.integer_ival Z.one  }} {{ tex 1 }}
    | mem_zero :: M :: Zero {{ ocaml Memory.integer_ival Z.zero }} {{ tex 0 }}


metavar Symbol_identifier {{ tex member }} ::= {{ ocaml Symbol.identifier }} {{ phantom }}
  {{ com C struct/union member name }}

metavar annots {{ tex }} ::= {{ ocaml annot list }} {{ phantom }}
  {{ com Ott-hack, ignore (annotations) }}

metavar ty_nat {{ tex nat }} ::= {{ ocaml Nat_big_num.num }} {{ phantom }}
  {{ com OCaml arbitrary-width natural number }}

metavar ty_mem_ptr {{ tex mem\_ptr }} ::= {{ ocaml Impl_mem.pointer_value }} {{ phantom }}
    {{ com abstract pointer value }}

%   ty_mem_ptr {{ tex mem\_ptr }} :: 'PV' ::= {{ ocaml Impl_mem.pointer_value }} {{ phantom }} {{ com pointer values }}
%     | nullptr            :: :: null       {{ com null pointer }}
%     | funcptr Symbol_sym :: :: function   {{ com function pointer }}
%     | concptr ty_nat     :: :: concrete   {{ com concrete pointer }}

metavar ty_mem_value {{ tex mem\_val }} ::= {{ phantom }} {{ ocaml Impl_mem.mem_value }}
    {{ com abstract memory value }}

% ty_mem_value {{ tex mem\_val }} :: 'MV' ::= {{ phantom }} {{ ocaml Impl_mem.mem_value }} {{ com memory value }}
%     | int ty_mem_int                                                                 :: :: integer
%     | ty_mem_ptr                                                                     :: :: pointer
%     | array ( </ ty_mem_valuei // i /> )                                             :: :: array
%     | ( struct Symbol_sym ) { </ . Symbol_identifieri = ty_mem_valuei // , // i /> } :: :: struct
%     | union Symbol_sym Symbol_identifier                                             :: :: union


grammar

  T_ct {{ tex \tau }} :: 'T_ct_of_' ::= {{ ocaml T.ct }} {{ phantom }} {{ com Ott-hack, ignore }}
    | ct :: :: ct


grammar

  Symbol_sym {{ tex ident }}:: '' ::= {{ ocaml Symbol.sym }} {{ phantom }} {{ com Ott-hack, ignore }}
    | ident  :: :: ident
    | ty_tag :: :: ty_tag {{ com hack for struct typing rules }}


grammar

  mu_object_value {{ tex object\_value }} :: 'M_OV' ::=  {{ auxparam 'TY }} {{ com C object values (inhabitants of object types), which can be read/stored }}
    | ty_mem_int                                                                                :: :: integer {{ com integer value  }}
    | ty_mem_ptr                                                                                :: :: pointer {{ com pointer value  }}
    | array ( </ mu_loaded_valuei // , // i /> )                                                :: :: array   {{ com C array value  }}
    | ( struct Symbol_sym ) { </ dot Symbol_identifieri : T_cti = ty_mem_valuei // , // i /> }  :: :: struct  {{ com C struct value }}
    | ( union Symbol_sym ) { dot Symbol_identifier = ty_mem_value }                             :: :: union   {{ com C union value  }}


  mu_loaded_value {{ tex loaded\_value }} :: 'M_LV' ::= {{ auxparam 'TY }} {{ com potentially unspecified C object values }}
    | specified mu_object_value :: :: specified {{ com specified loaded value }}


grammar

  T_bt {{ tex \beta }} :: 'T_bt_' ::= {{ ocaml T.bt }} {{ phantom }} {{ com Ott-hack, ignore }}
    | base_type :: :: BaseType


grammar

  mu_value {{ tex value }} :: 'M_V' ::= {{ auxparam 'TY }} {{ com Core values }}
    | mu_object_value                    :: :: object {{ com C object value        }}
    | mu_loaded_value                    :: :: loaded {{ com loaded C object value }}
    | Unit                               :: :: unit   {{ com unit                  }}
    | True                               :: :: true   {{ com boolean true          }}
    | False                              :: :: false  {{ com boolean false         }}
    | T_bt [ </ mu_valuei // , // i /> ] :: :: list   {{ com list                  }}
    | ( </ mu_valuei // , // i /> )      :: :: tuple  {{ com tuple                 }}


  mu_bool_value {{ tex bool\_value }} :: 'M_VB' ::= {{ auxparam 'TY }} {{ com Core booleans }}
    | True                               :: :: true   {{ com boolean true          }}
    | False                              :: :: false  {{ com boolean false         }}


 subrules
   mu_bool_value <:: mu_value


grammar

  mu_ctor_val {{ tex ctor\_val }} :: 'M_C' ::= {{ com data constructors }}
    | Nil T_bt    :: :: nil         {{ com empty list                     }} % : [bTy]
    | Cons        :: :: cons        {{ com list cons                      }} % : bTy -> [bTy] -> [bTy]
    | Tuple       :: :: tuple       {{ com tuple                          }} % : bTy1 -> ... -> bTyN -> (bTy1, ..., bTyN)
    | Array       :: :: array       {{ com C array                        }} % : bTy -> ... -> bTy -> array bTy
    | Specified   :: :: specified   {{ com non-unspecified loaded value   }} % : objTy -> loaded objTy


  mu_ctor_expr {{ tex ctor\_expr }} :: 'M_C' ::= {{ com data constructors }}
    | Ivmax       :: :: ivmax       {{ com max integer value              }} % : ctype -> integer
    | Ivmin       :: :: ivmin       {{ com min integer value              }} % : ctype -> integer
    | Ivsizeof    :: :: ivsizeof    {{ com sizeof value                   }} % : ctype -> integer
    | Ivalignof   :: :: ivalignof   {{ com alignof value                  }} % : ctype -> integer
    | IvCOMPL     :: :: ivCOMPL     {{ com bitwise complement             }} % : ctype -> integer -> integer
    | IvAND       :: :: ivAND       {{ com bitwise AND                    }} % : ctype -> integer -> integer -> integer
    | IvOR        :: :: ivOR        {{ com bitwise OR                     }} % : ctype -> integer -> integer -> integer
    | IvXOR       :: :: ivXOR       {{ com bitwise XOR                    }} % : ctype -> integer -> integer -> integer
    | Fvfromint   :: :: fvfromint   {{ com cast integer to floating value }} % : integer -> floating
    | Ivfromfloat :: :: ivfromfloat {{ com cast floating to integer value }} % : ctype -> floating -> integer


metavar ty_loc {{ tex }} ::= {{ ocaml Location_ocaml.t }} {{ phantom }}
  {{ com Ott-hack, ignore (locations) }}

metavar Mem_mem_iv_constraint {{ tex mem\_iv\_c }} ::= {{ ocaml Mem.mem_iv_constraint }} {{ phantom }}
  {{ com OCaml type for memory constraints on integer values }}

metavar UB_name ::= {{ ocaml Undefined.undefined_behaviour }} {{ phantom }}
 {{ com undefined behaviour }}

metavar ty_string {{ tex string }} ::= {{ ocaml string }} {{ phantom }}
  {{ com OCaml string }}

metavar tyvar_TY {{ tex }} ::= {{ ocaml 'TY }} {{ phantom }}
  {{ com Ott-hack, ignore (OCaml type variable TY) }}


grammar

  ty_act {{ tex \tau }} :: 'Ty_act_of' ::= {{ ocaml 'TY act }} {{ phantom }} {{ com Ott-hack, ignore }}
    | ct :: :: ct


grammar

  mu_name {{ tex name }} :: '' ::= {{ ocaml Symbol.sym Core.generic_name }} {{ phantom }}
    | Symbol_sym :: :: Sym   {{ com Core identifier                 }}
    | impl_const :: :: ImplC {{ com implementation-defined constant }}


grammar

  mu_pval {{ tex pval }} :: 'M_PV' ::= {{ auxparam 'TY }} {{ com pure values }}
    | Symbol_sym                                                                      :: :: sym          {{ com Core identifier                           }}
    | impl_const                                                                      :: :: impl         {{ com implementation-defined constant           }}
    | mu_value                                                                        :: :: mu_val       {{ com Core values                               }}
    | constrained ( </ Mem_mem_iv_constrainti , mu_pval_auxi // , // i /> )           :: :: constrained  {{ com constrained value                         }}
    | error ( ty_string , mu_pval_aux )                                               :: :: error        {{ com impl-defined static error                 }}
    | mu_ctor_val ( </ mu_pval_auxi // , // i /> )                                    :: :: ctor         {{ com data constructor application              }}
    | ( struct Symbol_sym ) { </ dot Symbol_identifieri = mu_pval_auxi // , // i /> } :: :: struct       {{ com C struct expression                       }}
    | ( union Symbol_sym ) { dot Symbol_identifier = mu_pval_aux }                    :: :: union        {{ com C union expression                        }}


  mu_pval_aux {{ tex pval }} :: 'M_P' ::= {{ auxparam 'TY }} {{ com pure values with auxiliary info }}
    | ty_loc annots tyvar_TY mu_pval :: X :: val
    |                        mu_pval :: O :: val_no_aux {{ com Ott-hack for simpler typing rules }}
    |               [ subs ] mu_pval :: M :: val_subs   {{ com substitution for pure values }}
                                                        {{ ocaml MU_PVAL_SUBS [[subs]] [[mu_pval]] }}
                                                        {{ tex [[subs]] ( [[mu_pval]] ) }}


  subrules
    mu_name <:: mu_pval


grammar

  mu_tpval {{ tex tpval }} :: 'M_TPV' ::= {{ auxparam 'TY }} {{ com top-level pure values }}
    | undef ty_loc UB_name :: :: undef {{ com undefined behaviour }}
    | done mu_pval_aux     :: :: done  {{ com pure done           }}


  mu_tpval_aux {{ tex tpval }} :: 'M_TP' ::= {{ auxparam 'TY }} {{ com top-level pure values with location and annotations }}
    | ty_loc annots tyvar_TY mu_tpval :: X :: val
    |                        mu_tpval :: O :: val_no_aux   {{ com Ott-hack for simpler typing rules }}


grammar

  ty_sym_opt_T_bt {{ tex ident\_opt\_\beta }} :: '' ::= {{ ocaml ( Symbol.sym option * T.bt ) }} {{ com type annotated optional identifier }}
    | _ : T_bt          :: :: No_sym (+ binders = {}         +) {{ ocaml ( None , [[T_bt]] ) }}
    | Symbol_sym : T_bt :: :: Just   (+ binders = Symbol_sym +) {{ ocaml ( Some [[Symbol_sym]] , [[T_bt]] ) }}


grammar

  mu_pattern {{ tex pattern }} :: 'M_Case' ::=
    | ty_sym_opt_T_bt                                 :: :: Base (+ binders = binders( ty_sym_opt_T_bt ) +)
    | mu_ctor_val ( </ mu_pattern_auxi // , // i /> ) :: :: Ctor (+ binders = binders( </ mu_pattern_auxi // i /> ) +)


  mu_pattern_aux {{ tex pattern }} :: 'M_' ::=
    | ty_loc annots mu_pattern :: X :: Pattern     (+ binders = binders(mu_pattern) +)
    |               mu_pattern :: O :: Pat_no_aux  (+ binders = binders(mu_pattern) +) {{ com Ott-hack for simpler typing rules }}


grammar

  Z_t {{ tex z }} :: 'Z_' ::= {{ ocaml Z.t }} {{ phantom }} {{ com OCaml arbitrary-width integer }}
    | z_one                       :: X M :: One        {{ ocaml Z.one  }} {{ tex 1                     }}
    | z_zero                      :: X M :: Zero       {{ ocaml Z.zero }} {{ tex 0                     }}
    | i                           :: M :: of_index   {{ ocaml OF_INDEX [[i]]                         }}
                                                     {{ com literal integer                          }}
    | to_int ty_mem_int           :: M :: of_mem_ptr {{ ocaml Memory.integer_value_to_num            }}
                                                     {{ tex [[ty_mem_int]]                           }}
    | size_of ct                  :: M :: of_Ctype   {{ ocaml z_ ( Memory.size_of_ctype ( [[ct]] ) ) }}
                                                     {{ tex \mathrm{size\_of}( [[ct]] )              }}
                                                     {{ com size of a C type                         }}
    | offset_of ty_tag Symbol_identifier :: M :: of_Member
      {{ ocaml z_ ( Memory.member_offset ( (??) [[ty_tag]] ) ( [[Symbol_identifier]] ) ) }}
      {{ tex \mathrm{offset\_of}_{ [[ty_tag]] }( [[Symbol_identifier]] )               }}
      {{ com offset of a struct member                                                 }}
    | ptr_size                    :: M :: Ptr_size   {{ ocaml Memory.size_of_pointer                 }}
                                                     {{ com size of a pointer                        }}
    | max_int ct                  :: M :: of_Max_Int {{ ocaml z_ ( Memory.max_integer_type ( [[ct]] ) ) }}
                                                     {{ tex \mathrm{max\_int}_{ [[ct]] }                }}
                                                     {{ com maximum value of int of type $[[ct]]$       }}
    | min_int ct                  :: M :: of_Min_Int {{ ocaml z_ ( Memory.min_integer_type ( [[ct]] ) ) }}
                                                     {{ tex \mathrm{min\_int}_{ [[ct]] }                }}
                                                     {{ com minimum value of int of type $[[ct]]$       }}


grammar

  rational {{ tex \mathbb{Q} }} , q , _q {{ tex \_ }} :: 'Q_' ::= {{ ocaml ( int * int ) }} {{ phantom }} {{ com OCaml type for rational numbers }}
    | q_one             :: X :: One  {{ ocaml (1, 1) }} {{ tex 1 }}
    | ty_int1 / ty_int2 ::   :: Frac {{ ocaml ( [[ty_int1]], [[ty_int2]] ) }} {{ tex \frac{[[ty_int1]]}{[[ty_int2]]} }}


grammar

  lit :: 'Lit_' ::=
    | Symbol_sym ::   :: Sym
    | unit       ::   :: Unit
    | ty_bool    ::   :: Bool
    | Z_t        ::   :: Z
    | rational   ::   :: Q


grammar

  mu_sym_or_pattern {{ tex ident\_or\_pattern }} :: 'M_' ::= {{ auxparam 'TY }}
    | Symbol_sym     :: :: Symbol (+ binders = Symbol_sym +)
    | mu_pattern_aux :: :: Pat    (+ binders = binders(mu_pattern_aux) +)


grammar

  bool_op :: '' ::= {{ auxparam 'bt }}
    | neg term_aux                         ::     :: Not
    | term_aux1 = term_aux2                ::     :: Eq
    | term_aux1 -> term_aux2               ::     :: Impl
    | /\\ ( </ term_auxi // , // i />    ) ::     :: And
    | \// ( </ term_auxi // , // i />    ) ::     :: Or
    | term_aux1 /\ term_aux2               :: X M :: And_Binary {{ ocaml And ( [ [[term_aux1]] , [[term_aux2]] ] ) }}
    | term_aux1 \/ term_aux2               :: X M :: Or_Binary {{ ocaml Or ( [ [[term_aux1]] , [[term_aux2]] ] ) }}
    | term_aux1 ' bool_binop ' term_aux2   ::   M :: Bool_binop
      {{ tex [[term_aux1]] [[bool_binop]] [[term_aux2]] }}
      {{ ocaml BOOL_BINOP_TO_BOOL_OP [[term_aux1]] [[bool_binop]] [[term_aux2]] }}
    | if term_aux1 then term_aux2 else term_aux3  :: :: ITE


  arith_op :: '' ::= {{ auxparam 'bt }}
    | term_aux1 +     term_aux2            ::   :: Add
    | term_aux1 -     term_aux2            ::   :: Sub
    | term_aux1 *     term_aux2            ::   :: Mul
    | term_aux1 /     term_aux2            ::   :: Div
    | term_aux1 rem_t term_aux2            ::   :: Rem_t
    | term_aux1 rem_f term_aux2            ::   :: Rem_f
    | term_aux1 ^     term_aux2            ::   :: Exp
    | term_aux1 ' arith_binop ' term_aux2  :: M :: Arith_binop
      {{ tex [[term_aux1]] [[arith_binop]] [[term_aux2]] }}
      {{ ocaml ARITH_BINOP_TO_ARITH_OP [[term_aux1]] [[arith_binop]] [[term_aux2]] }}


  cmp_op :: '' ::= {{ auxparam 'bt }}
    | term_aux1 <  term_aux2            ::   :: LT {{ com less than          }}
    | term_aux1 =< term_aux2            ::   :: LE {{ com less than or equal }}
    | term_aux1 ' rel_binop ' term_aux2 :: M :: Rel_binop
      {{ tex [[term_aux1]] [[rel_binop]] [[term_aux2]] }}
      {{ ocaml REL_BINOP_TO_CMP_OP [[term_aux1]] [[rel_binop]] [[term_aux2]] }}


  list_op :: '' ::= {{ auxparam 'bt }}
    | nil                      :: :: Nil
    | term_aux1 cons term_aux2 :: :: Cons    {{ tex [[term_aux1]] :: [[term_aux2]] }}
    | tl term_aux              :: :: Tail
    | ty_int th_l term_aux     :: :: NthList {{ order [[ty_int]] [[term_aux]]   }}
                                             {{ tex [[term_aux]]^{([[ty_int]])} }}

  tuple_op :: '' ::= {{ auxparam 'bt }}
    | ( </ term_auxi // , // i /> ) :: :: Tuple
    | ty_int th_t term_aux          :: :: NthTuple {{ tex [[term_aux]]^{([[ty_int]])} }}


  pointer_op :: '' ::= {{ auxparam 'bt }}
    | ty_mem_ptr               :: :: Null
    | term_aux1 +ptr term_aux2 :: :: AddPointer
    | cast_int_to_ptr term_aux :: :: IntegerToPointerCast
    | cast_ptr_to_int term_aux :: :: PointerToIntegerCast


  BT_t {{ tex \beta }} :: '' ::= {{ ocaml BT.t }} {{ phantom }} {{ com Ott-hack, ignore }}
    | base_type :: :: Base_type


  array_op :: '' ::= {{ auxparam 'bt }}
    | [ | </ term_auxi // , // i /> |] :: :: Array
    | term_aux1 [ term_aux2 ]          :: :: ArrayGet


  param_op :: '' ::= {{ auxparam 'bt }}
    | Symbol_sym : base_type . term_aux       :: :: Param
    | term_aux ( term_aux1 , .. , term_auxn ) :: :: App


  struct_op :: '' ::= {{ auxparam 'bt }}
    | ty_tag term_aux dot Symbol_identifier :: :: StructMember {{ tex [[term_aux]] [[dot]] [[Symbol_identifier]] }}


  ct_pred :: '' ::= {{ auxparam 'bt }}
    | representable ( ct , term_aux )    :: :: Representable
    | aligned ( ct , term_aux )          :: :: Aligned
    | alignedI ( term_aux1 , term_aux2 ) :: :: AlignedI


  term , _t {{ tex \_ }} :: '' ::= {{ auxparam 'bt }}
    | lit        :: :: Lit
    | arith_op   :: :: Arith_op
    | bool_op    :: :: Bool_op
    | cmp_op     :: :: Cmp_op
    | tuple_op   :: :: Tuple_op
    | struct_op  :: :: Struct_op
    | pointer_op :: :: Pointer_op
    | list_op    :: :: List_op
    | array_op   :: :: Array_op
    | ct_pred    :: :: CT_pred
    | param_op   :: :: Param_op

    | ( term )         :: S :: Paren   {{ ocaml [[term]] }} {{ com parentheses }}
    | [ subs ] term    :: M :: Subs    {{ ocaml INDEX_TERM_SUBS [[subs]] [[term]] }} {{ tex [[subs]] ( [[term]] ) }}
                                       {{ com simul-sub $[[subs]]$ in $[[term]]$ }}
    | inj mu_pval_aux  :: M :: Of_pval {{ tex [[mu_pval_aux]] }} {{ ocaml TERM_OF_PVAL_AUX [[mu_pval_aux]] }}


  term_aux {{ tex term }} :: '' ::= {{ auxparam 'bt }} {{ com terms with auxiliary info }}
    | term ty_bt :: X :: IT
    | term       :: O :: IT_no_aux {{ com Ott-hack for simpler typing rules }}


grammar

  mu_pexpr {{ tex pexpr }} :: 'M_PE' ::= {{ auxparam 'TY }} {{ com pure expressions }}
    | mu_pval_aux                                                   :: :: pval         {{ com pure values                               }}
    | mu_ctor_expr ( </ mu_pval_auxi // , // i /> )                 :: :: ctor         {{ com data constructor application              }}
    | array_shift ( mu_pval_aux1 , T_ct , mu_pval_aux2 )            :: :: array_shift  {{ com pointer array shift                       }}
    | member_shift ( mu_pval_aux , Symbol_sym , Symbol_identifier ) :: :: member_shift {{ com pointer struct/union member shift         }}
    | not ( mu_pval_aux )                                           :: :: not          {{ com boolean not                               }}
    | mu_pval_aux1 binop mu_pval_aux2                               :: :: op           {{ order [[binop]] [[mu_pval_aux1]] [[mu_pval_aux2]] }} {{ com binary operations }}
    | memberof  ( Symbol_sym , Symbol_identifier , mu_pval_aux )    :: :: memberof     {{ com C struct/union member access              }}
    | mu_name ( </ mu_pval_auxi // , // i /> )                      :: :: call         {{ com pure function call                        }}

    | assert_undef ( mu_pval_aux , ty_loc UB_name )                 :: :: assert_undef
    | bool_to_integer ( mu_pval_aux )                               :: :: bool_to_integer
    | conv_int ( ty_act , mu_pval_aux )                             :: :: conv_int
    | wrapI ( ty_act , mu_pval_aux )                                :: :: wrapI


  mu_pexpr_aux {{ tex pexpr }} :: 'M_P' ::= {{ auxparam 'TY }} {{ com pure expressions with location and annotations }}
    | ty_loc annots tyvar_TY mu_pexpr :: X :: expr
    |                        mu_pexpr :: O :: expr_no_aux {{ com Ott-hack for simpler typing rules }}
    |               [ subs ] mu_pexpr :: M :: expr_subs   {{ com substitution for pure expressions }}
                                                          {{ ocaml MU_PEXPR_SUBS [[subs]] [[mu_pexpr]] }}
                                                          {{ tex [[subs]] ( [[mu_pexpr]] ) }}


  mu_tpexpr {{ tex tpexpr }} :: 'M_TPE' ::= {{ auxparam 'TY }} {{ com top-level pure expressions }}
    | mu_tpval_aux                                                ::   :: tpval  {{ com top-level pure values }}
    | case mu_pval_aux of </ | mu_tpexpr_case_branchi // i /> end ::   :: case   {{ com pattern matching      }}
    | let mu_sym_or_pattern = mu_pexpr_aux in mu_tpexpr_aux       ::   :: let    (+ bind binders( mu_sym_or_pattern ) in mu_tpexpr_aux  +)
                                                                                 {{ com pure let              }}
    | let mu_sym_or_pattern : ( y1 : base_type1 . term1 ) = mu_tpexpr_aux1 in mu_tpexpr_aux2
                                                                  ::   :: letT   (+ bind binders( mu_sym_or_pattern ) in mu_tpexpr_aux2 +)
                                                                                 (+ bind y1 in term1 +)
                                                                                 {{ com pure let              }}
    | if mu_pval_aux then mu_tpexpr_aux1 else mu_tpexpr_aux2      ::   :: if     {{ com pure if               }}
    | [ subs ] mu_tpexpr                                          :: M :: subs   {{ ocaml MU_TPEXPR_SUBS [[subs]] [[mu_tpexpr]] }} {{ tex [[subs]] ( [[mu_tpexpr]] ) }}
                                                                                 {{ com simul-sub $[[subs]]$ in $[[mu_tpexpr]]$ }}


  mu_tpexpr_case_branch {{ tex tpexpr\_case\_branch }} :: 'M_TPE_Case_' ::= {{ auxparam 'TY }} {{ com pure top-level case expression branch }}
                                                                            {{ ocaml ( mu_pattern_aux * 'TY mu_tpexpr_aux ) }}
    | mu_pattern_aux => mu_tpexpr_aux :: :: branch (+ bind binders( mu_pattern_aux ) in mu_tpexpr_aux  +)
                                                   {{ com top-level case expression branch             }}
                                                   {{ ocaml ( [[mu_pattern_aux]] , [[mu_tpexpr_aux]] ) }}


  mu_tpexpr_aux {{ tex tpexpr }} :: 'M_TP' ::= {{ auxparam 'TY }} {{ com pure top-level pure expressions with auxiliary info }}
    | ty_loc annots tyvar_TY mu_tpexpr :: X :: expr
    |                        mu_tpexpr :: O :: expr_no_aux   {{ com Ott-hack for simpler typing rules }}


grammar

  m_kill_kind :: 'M_' ::=
    | dynamic     :: :: Dynamic
    | static T_ct :: :: Static


grammar

  ty_bool {{ tex bool }} , _b {{ tex \_ }} :: '' ::= {{ ocaml bool  }} {{ phantom }} {{ com OCaml booleans }}
    | true                  ::   :: True  {{ ocaml true  }}
    | false                 ::   :: False {{ ocaml false }}


  ty_int {{ tex int }} , _int {{ tex \_ }} :: 'Int_' ::=   {{ ocaml int  }} {{ phantom }} {{ com OCaml fixed-width integer }}
    | i     ::   :: IndexVar {{ com literal integer }}
    | i_one :: X :: One      {{ tex 1               }}


metavar Symbol_prefix {{ tex }} ::= {{ ocaml Symbol.prefix }} {{ phantom }}
  {{ com Ott-hack, ignore (OCaml Symbol.prefix) }}

metavar Cmm_memory_order {{ tex mem\_order }} , _mem_order {{ tex \_ }} ::= {{ ocaml Cmm_csem.memory_order }} {{ phantom }}
  {{ com OCaml type for memory order }}

metavar Linux_linux_memory_order {{ tex linux\_mem\_order }} ::= {{ ocaml Linux.linux_memory_order }} {{ phantom }}
  {{ com OCaml type for Linux memory order }}


grammar

  res_term :: 'ResT_' ::= {{ com resource terms }}
    | emp                             ::   :: Empty    {{ com empty heap }}
    | points_to                       ::   :: PointsTo {{ com single-cell heap }}
    | Symbol_sym                      ::   :: Var      {{ com variable }}
    | <( res_term1 , res_term2 )>     ::   :: SepPair  {{ com seperating-conjunction pair }}
    | pack ( mu_pval_aux , res_term ) ::   :: Pack     {{ com packing for existentials }}
    |               [ subs ] res_term :: M :: Subs     {{ com substitution for resource terms }}
                                                       {{ tex [[subs]] ( [[res_term]] ) }}
                                                       {{ ocaml RES_TERM_SUBS [[subs]] [[res_term]] }}


grammar

  mu_action {{ tex mem\_action }} :: 'M_' ::= {{ auxparam 'TY }} {{ com memory actions }}
    | create ( mu_pval_aux , ty_act ) Symbol_prefix                                                                   :: :: Create
    | create_readonly ( mu_pval_aux1 , ty_act , mu_pval_aux2 ) Symbol_prefix                                          :: :: CreateReadOnly
    | alloc ( mu_pval_aux1 , mu_pval_aux2 ) Symbol_prefix                                                             :: :: Alloc
    | kill ( m_kill_kind , mu_pval_aux , pt )                                                                         :: :: Kill
    | store ( ty_bool , ty_act , mu_pval_aux1 , mu_pval_aux2 , Cmm_memory_order , pt )                                :: :: Store {{ com true means store is locking }}
    | load ( ty_act , mu_pval_aux , Cmm_memory_order , pt )                                                           :: :: Load
    | rmw ( ty_act ,  mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 , Cmm_memory_order1 , Cmm_memory_order2 )            :: :: RMW
    | fence ( Cmm_memory_order )                                                                                      :: :: Fence
    | cmp_exch_strong ( ty_act , mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 , Cmm_memory_order1 , Cmm_memory_order2 ) :: :: CompareExchangeStrong
    | cmp_exch_weak ( ty_act , mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 , Cmm_memory_order1 , Cmm_memory_order2 )   :: :: CompareExchangeWeak
    | linux_fence ( Linux_linux_memory_order )                                                                        :: :: LinuxFence
    | linux_load ( ty_act , mu_pval_aux , Linux_linux_memory_order )                                                  :: :: LinuxLoad
    | linux_store ( ty_act , mu_pval_aux1 , mu_pval_aux2 , Linux_linux_memory_order )                                 :: :: LinuxStore
    | linux_rmw ( ty_act , mu_pval_aux1 , mu_pval_aux2 , Linux_linux_memory_order )                                   :: :: LinuxRMW


  mu_action_aux {{ tex mem\_action }} :: 'M_' ::= {{ auxparam 'TY }} {{ com memory actions with auxiliary info }}
    | ty_loc mu_action :: X :: Action
    |        mu_action :: O :: no_aux {{ com Ott-hack for simpler typing rules }}


grammar

  polarity :: '' ::= {{ ocaml Core.polarity }} {{ phantom }} {{ com polarities for memory actions }}
    | Pos :: :: Pos {{ com (pos) sequenced by \ottkw{let\ weak} and \ottkw{let\ strong} }} {{ tex              }}
    | Neg :: :: Neg {{ com only sequenced by \ottkw{let\ strong}                        }} {{ tex \texttt{neg} }}


  mu_paction {{ tex pol\_mem\_action }} :: 'M_' ::= {{ auxparam 'TY }} {{ com memory actions with polarity }}
    | polarity mu_action_aux :: :: Paction


grammar

  mu_memop {{ tex mem\_op }} :: 'M_' ::=  {{ auxparam 'TY }} {{ com operations involving the memory state}}
    | mu_pval_aux1 rel_binop mu_pval_aux2                     :: :: PtrRelBinop      {{ com pointer relational binary operations }}
    | mu_pval_aux1 - ty_act - mu_pval_aux2                    :: :: Ptrdiff          {{ order [[ty_act]] [[mu_pval_aux1]] [[mu_pval_aux2]] }} {{ com pointer subtraction }}
                                                                                     {{ tex [[mu_pval_aux1]] -_{ [[ty_act]] } [[mu_pval_aux2]] }}
    | intFromPtr ( ty_act1 , ty_act2 , mu_pval_aux )          :: :: IntFromPtr       {{ com cast of pointer value to integer value }}
    | ptrFromInt ( ty_act1 , ty_act2 , mu_pval_aux )          :: :: PtrFromInt       {{ com cast of integer value to pointer value }}
    | ptrValidForDeref ( ty_act , mu_pval_aux , pt )          :: :: PtrValidForDeref {{ com dereferencing validity predicate }}
    | ptrWellAligned ( ty_act , mu_pval_aux )                 :: :: PtrWellAligned
    | ptrArrayShift ( mu_pval_aux1 ,  ty_act , mu_pval_aux2 ) :: :: PtrArrayShift
    | memcpy ( mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 )   :: :: Memcpy
    | memcmp ( mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 )   :: :: Memcmp
    | realloc ( mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 )  :: :: Realloc
    | va_start ( mu_pval_aux1 , mu_pval_aux2 )                :: :: Va_start
    | va_copy ( mu_pval_aux )                                 :: :: Va_copy
    | va_arg ( mu_pval_aux , ty_act )                         :: :: Va_arg
    | va_end ( mu_pval_aux )                                  :: :: Va_end



grammar

  spine_elem :: Spine_Elem_ ::= {{ auxparam 'TY }} {{ com spine element }}
    | mu_pval_aux         ::   :: val     {{ com pure or logical value      }}
    | res_term            ::   :: res_val {{ com resource value             }}
    | [ subs ] spine_elem :: M :: subs    {{ com substitution for spine elements / return values }}
                                          {{ ocaml SPINE_ELEM_SUBS [[subs]] [[spine_elem]] }}
                                          {{ tex [[subs]] ( [[spine_elem]] ) }}
  

  spine :: Spine_ ::= {{ ocaml 'TY spine_elem list }} {{ phantom }} {{ com spine }}
    | </ spine_elemi // , // i /> ::   :: elems


grammar

   mu_tval {{ tex tval }} :: 'M_TV' ::= {{ auxparam 'TY }} {{ com (effectful) top-level values }}
    | done spine            :: :: done  {{ com end of top-level expression }}
    | undef ty_loc UB_name  :: :: undef {{ com undefined behaviour         }}


   mu_tval_aux {{ tex tval }} :: 'M_T' ::= {{ auxparam 'TY }} {{ com (effectful) top-level values with auxiliary info }}
     | ty_loc annots mu_tval :: X :: val
     |               mu_tval :: O :: no_aux   {{ com Ott-hack for simpler typing rules }}
     |      [ subs ] mu_tval :: M :: val_subs {{ com substitution for top-level values }}
                                              {{ ocaml MU_TVAL_SUBS [[subs]] [[mu_tval]] }}
                                              {{ tex [[subs]] ( [[mu_tval]] ) }}


grammar

  res_pattern :: 'ResP_' ::= {{ com resource terms }}
    | emp                               :: :: Empty    (+ binders = {}         +) {{ com empty heap }}
    | pt                                :: :: PointsTo (+ binders = {}         +) {{ com single-cell heap }}
    | Symbol_sym                        :: :: Var      (+ binders = Symbol_sym +) {{ com variable }}
    | <( res_pattern1 , res_pattern2 )> :: :: SepPair  (+ binders = binders( res_pattern1 ) union binders( res_pattern2 ) +)
                                                       {{ com seperating-conjunction pair }}
    | pack ( Symbol_sym , res_pattern ) :: :: Pack     (+ binders = Symbol_sym union binders( res_pattern ) +)
                                                       {{ com packing for existentials }}


grammar

  ret_pattern :: RetP_ ::= {{ com return pattern }}
    | comp mu_sym_or_pattern :: :: comp (+ binders = binders( mu_sym_or_pattern ) +) {{ com computational variable }}
    | log  Symbol_sym        :: :: log  (+ binders = Symbol_sym                   +) {{ com logical variable       }}
    | reso res_pattern       :: :: res  (+ binders = binders( res_pattern )       +) {{ com resource variable      }}


grammar

  init_t {{ tex init }} , _i {{ tex }} :: '' ::= {{ ocaml bool }} {{ phantom }} {{ com initialisation status }}
    | tick :: :: init   {{ ocaml true  }}                     {{ com initialised  }}
    |  *   :: :: uninit {{ ocaml false }} {{ tex { [[*]] } }} {{ com uninitalised }}


grammar

  points_to , pt :: '' ::= {{ ocaml type points_to = { pointer: 'bt term; perm : int * int; init: bool; ct = Sctypes.t; pointee : 'bt term; } }}
                      {{ phantom }} {{ com points-to separation logic predicate }}
    | term_aux1 ( rational )|- init_t - ct -> term_aux2 :: :: Points_to
      % Omitting [[rational]] until fractional permissions are used (2021-06)
      {{ tex [[term_aux1]] \mathbin{ { \overset{ [[init_t]] }{ \mapsto } }_{ [[ct]] } } [[term_aux2]] }}
      {{ ocaml { pointer = [[term_aux1]] ; perm = [[rational]] ; init = [[init_t]] ; ct = [[ct]] ; pointee = [[term_aux2]] ; } }}


grammar

  res :: 'Res_' ::= {{ com resources }}
    | emp                                 ::   :: Empty     {{ com empty heap             }}
    | points_to                           ::   :: Points_to {{ com points-top heap pred.  }}
    | res1 *s res2                        ::   :: SepConj   {{ com seperating conjunction }}
    | exists Symbol_sym : base_type . res ::   :: Exists    {{ com existential            }}
    | term_aux /\ res                     ::   :: Term      {{ com logical conjuction     }}
    | ( res )                             :: X S :: Paren   {{ com parentheses            }} {{ ocaml [[res]] }} {{ tex [[res]] }}
    | [ subs ] res                        :: M :: Subs      {{ ocaml RES_SUBS [[subs]] [[res]]         }}
                                                            {{ com simul-sub $[[subs]]$ in $[[res]]$   }}
                                                            {{ tex [[subs]] ( [[res]] )   }}


grammar

   ret , _r {{ tex \_ }} :: RetTy_ ::= {{ com return types }}
    | sigma tyvar_sym : base_type . ret  :: :: Comp   {{ com return a computational value          }}
    | exists tyvar_sym : base_type . ret :: :: Log    {{ com return a logical value                }}
    | res *o ret                         :: :: Res    {{ com return a resource value               }}
    | term_aux /\ ret                    :: :: Phi    {{ com return a predicate (post-condition)   }}
    | I                                  :: :: I      {{ com end return list                       }}
    | [ subs ] ret                       :: M :: Subs {{ ocaml RET_SPINE_ELEM_SUBS [[subs]] [[ret]] }}
                                                      {{ tex [[subs]] ( [[ret]] )                   }}
                                                      {{ com simul-sub $[[subs]]$ in $[[ret]]$      }}
  % | concat rets                        :: M :: Concat {{ tex [[rets]] }} {{ ocaml [[rets]] }} {{ com concatenation of return types }}


  % rets :: RetTys_ ::= {{ com concatenation of return types }}
  %   | </ reti // i /> :: :: Concat


grammar

  % There used to be an effectful value (mu_val) `skip' - I (dcm41) removed it because it seemed redundant.
  mu_seq_expr {{ tex seq\_expr }} :: 'M_Seq_E' ::= {{ auxparam 'TY }} {{ com sequential (effectful) expressions }}
    | ccall ( ty_act , Symbol_sym , spine ) :: :: ccall  {{ com C function call  }}
    | pcall ( mu_name , spine )             :: :: proc  {{ com procedure call   }}


  mu_seq_expr_aux {{ tex seq\_expr }} :: 'M_Seq_' ::= {{ auxparam 'TY }} {{ com sequential (effectful) expressions with auxiliary info }}
    | ty_loc annots mu_seq_expr :: X :: expr
    |               mu_seq_expr :: O :: no_aux   {{ com Ott-hack for simpler typing rules }}
    |      [ subs ] mu_seq_expr :: M :: Subs     {{ ocaml MU_SEQ_EXPR_SUBS [[subs]] [[mu_seq_expr]] }} {{ tex [[subs]] ( [[mu_seq_expr]] ) }}


  % nd() is only used in the elab of if/loops for the case where the condiditional expression evaluates to unspecified()
  % We don't have unspecified() so we won't have nd()
  mu_seq_texpr {{ tex seq\_texpr }} :: 'M_Seq_TE' ::= {{ auxparam 'TY }} {{ com sequential top-level (effectful) expressions }}
    | mu_tval                                                           :: :: tval  {{ com (effectful) top-level values   }}
    | run Symbol_sym </ mu_pval_auxi // , // i />                       :: :: run   {{ com run from label                 }}
    | let mu_sym_or_pattern = mu_pexpr_aux in mu_texpr                  :: :: letP  (+ bind binders( mu_sym_or_pattern ) in mu_texpr  +)
                                                                                    {{ com pure let              }}
    | let mu_sym_or_pattern : ( y1 : base_type1 . term1 ) = mu_tpexpr_aux in mu_texpr
                                                                        :: :: letTP (+ bind binders( mu_sym_or_pattern ) in mu_texpr +)
                                                                                    (+ bind y1 in term1 +)
                                                                                    {{ com pure let              }}
    | let </ ret_patterni // , // i /> = mu_seq_expr_aux in mu_texpr    :: :: let   (+ bind binders( </ ret_patterni // i /> ) in mu_texpr  +)
                                                                                    {{ com bind return patterns           }}
    | let </ ret_patterni // , // i /> : ret = mu_texpr1 in mu_texpr2   :: :: letT  (+ bind binders( </ ret_patterni // i /> ) in mu_texpr2 +)
                                                                                    {{ com annotated bind return patterns }}
    | case mu_pval_aux of </ | mu_texpr_case_branchi // i /> end        :: :: case  {{ com pattern matching               }}
    | if mu_pval_aux then mu_texpr1 else mu_texpr2                      :: :: if    {{ com conditional                    }}
    | bound [ ty_int ] ( mu_is_texpr_aux )                              :: :: bound {{ com limit scope of indet seq behaviour, absent at runtime }}


  mu_texpr_case_branch {{ tex texpr\_case\_branch }} :: 'M_Seq_TE_Case_' ::= {{ auxparam 'TY }} {{ com top-level case expression branch }}
                                                                             {{ ocaml ( mu_pattern_aux * 'TY mu_texpr ) }}
    | mu_pattern_aux => mu_texpr :: :: branch (+ bind binders( mu_pattern_aux ) in mu_texpr +)
                                              {{ com top-level case expression branch        }}
                                              {{ ocaml ( [[mu_pattern_aux]] , [[mu_texpr]] ) }}


  mu_seq_texpr_aux {{ tex seq\_texpr }} :: 'M_Seq_T' ::= {{ auxparam 'TY }} {{ com sequential top-level (effectful) expressions with auxiliary info }}
    | ty_loc annots mu_seq_texpr :: X :: expr
    |               mu_seq_texpr :: O :: seq_no_aux   {{ com Ott-hack for simpler typing rules }}


  mu_is_expr {{ tex is\_expr }} :: 'M_Is_E' ::= {{ auxparam 'TY }} {{ com indet seq (effectful) expressions }}
    | mu_tval                               :: :: tval  {{ com (effectful) top-level values   }}
    | memop ( mu_memop )                    :: :: memop  {{ com pointer op involving memory }}
    | mu_paction                            :: :: action {{ com memory action               }}
    % unseq ( </ mu_texpri : reti // i /> ) :: :: unseq  {{ com unsequenced expressions     }}


  mu_is_expr_aux {{ tex is\_expr }} :: 'M_Is_' ::= {{ auxparam 'TY }} {{ com indet seq (effectful) expressions with auxiliary info }}
    | ty_loc annots mu_is_expr :: X :: expr
    |               mu_is_expr :: O :: no_aux   {{ com Ott-hack for simpler typing rules }}


  mu_is_texpr {{ tex is\_texpr }} :: 'M_Is_TE' ::= {{ auxparam 'TY }} {{ com indet seq top-level (effectful) expressions }}
    | let weak   </ ret_patterni // , // i /> = mu_is_expr_aux in mu_texpr  :: :: wseq (+ bind binders( </ ret_patterni // i /> ) in mu_texpr +)
                                                                                       {{ com weak sequencing   }}
    | let strong </ ret_patterni // , // i /> = mu_is_expr_aux in mu_texpr  :: :: sseq (+ bind binders( </ ret_patterni // i /> ) in mu_texpr +)
                                                                                       {{ com strong sequencing }}


  mu_is_texpr_aux {{ tex is\_texpr }} :: 'M_Is_T' ::= {{ auxparam 'TY }} {{ com indet seq top-level (effectful) expressions with auxiliary info }}
    | ty_loc annots mu_is_texpr :: X :: expr
    |               mu_is_texpr :: O :: no_aux   {{ com Ott-hack for simpler typing rules }}


  mu_texpr {{ tex texpr }} :: 'M_TE' ::= {{ auxparam 'TY }} {{ com top-level (effectful) expressions }}
    | mu_seq_texpr_aux  ::   :: Seq   {{ com sequential (effectful) expressions                }}
    | mu_is_texpr_aux   ::   :: Is    {{ com indet seq (effectful) expressions                 }}
    | [ subs ] mu_texpr :: M :: Subs  {{ ocaml MU_TEXPR_SUBS [[subs]] [[mu_texpr]] }} {{ tex [[subs]] ( [[mu_texpr]] ) }}
                                      {{ com simul-sub $[[subs]]$ in $[[mu_texpr]]$   }}

% TODO substitutions

grammar

  terminals :: 'terminals_' ::=
    | \      :: :: lambda    {{ tex \lambda                          }}
    | -->    :: :: red       {{ tex \longrightarrow                  }}
    |  ->    :: :: arrow     {{ tex \rightarrow                      }}
    |  ~>    :: :: leadsto   {{ tex \leadsto                         }}
    |  =>    :: :: synths    {{ tex \Rightarrow                      }}
    |  <=    :: :: checks    {{ tex \Leftarrow                       }}
    | |-     :: :: turnstile {{ tex \vdash                           }}
    | inEnv  :: :: inEnv     {{ tex \in                              }}
    | pi     :: :: pi        {{ tex \Pi                              }}
    | forall :: :: forall    {{ tex \forall                          }}
    | --o    :: :: lollipop  {{ tex \multimap                        }}
    | --*    :: :: magicwand {{ tex \mathrel{-\mkern-6mu*}           }}
    | -)     :: :: implies   {{ tex \supset                          }}
    | sigma  :: :: sigma     {{ tex \Sigma                           }}
    | exists :: :: exists    {{ tex \exists                          }}
    | *s     :: :: ast       {{ tex *                                }}
    | *o     :: :: otimes    {{ tex \otimes                          }}
    | *      :: :: times     {{ tex \times                           }}
    | /\     :: :: and       {{ tex \wedge                           }}
    | /\\    :: :: big_and   {{ tex \bigwedge                        }}
    | neg    :: :: neg       {{ tex \neg                             }}
    | =      :: :: eq        {{ tex =                                }}
    | <>     :: :: neq       {{ tex \neq                             }}
    | =<     :: :: lte       {{ tex \leq                             }}
    | >=     :: :: gte       {{ tex \geq                             }}
    | &      :: :: ampersand {{ tex \ \&                             }}
    | cdot   :: :: cdot      {{ tex \cdot                            }}
    | |      :: :: bar       {{ tex \mid                             }}
    | +ptr   :: :: addptr    {{ tex \mathbin{ {+}_{ \mathrm{ptr} } } }}
    | |->    :: :: mapsto    {{ tex \mapsto                          }}
    | cons   :: :: cons      {{ tex ::                               }}
    | tick   :: :: tick      {{ tex \checkmark                       }}
    | :      :: :: of_type   {{ tex {:}                              }}
    | .      :: :: such_that {{ tex . \:                             }}
    | dot    :: :: dot       {{ tex .                                }}
    | >>     :: :: chevron   {{ tex \gg                              }}
    | :;     :: :: doublecol {{ tex \mathbin{ {:} {:} }              }}
    | ^      :: :: caret     {{ tex \mathbin { \texttt{\char`\^} }   }}
    | \//    :: :: big_or    {{ tex \bigvee                          }}
    | eq     :: :: equiv     {{ tex \equiv                           }}
    | <(     :: :: langle    {{ tex \langle                          }}
    | )>     :: :: rangle    {{ tex \rangle                          }}
    | reso   :: :: reso      {{ tex \texttt{res}                     }}
    | [=     :: :: sqlte     {{ tex \sqsubseteq                      }}


metavar ty_bt {{ tex }} ::= {{ ocaml 'bt }} {{ phantom }}
  {{ com Ott-hack, ignore (OCaml type variable bt) }}


grammar

  arg :: ArgTy_ ::= {{ com argument/function types }}
    | pi tyvar_sym : base_type . arg     ::   :: Comp
    | forall tyvar_sym : base_type . arg ::   :: Log
    | res --o arg                        ::   :: Res
    | term_aux -) arg                    ::   :: Phi
    | ret                                ::   :: Ret
    | ( arg  )                           :: X S :: Paren {{ tex [[arg]] }} {{ ocaml [[arg]] }}
    | [ subs ] arg                       :: M :: Subs  {{ ocaml ARG_SPINE_ELEM_SUB [[subs]] [[arg]] }} {{ tex [[subs]] ( [[arg]] ) }}
                                                       {{ com simul-sub $[[subs]]$ in $[[arg]]$     }}


  pure_arg :: Pure_ArgTy_ ::= {{ com pure argument/function types }}
    | pi tyvar_sym : base_type . pure_arg  :: :: Comp
    | term_aux -) pure_arg                 :: :: Phi
    | pure_ret                             :: :: Ret


  pure_ret :: Pure_RetTy_ ::= {{ com pure return types }}
    | sigma tyvar_sym : base_type . pure_ret :: :: Comp
    | term_aux /\ pure_ret                   :: :: Phi
    | I                                      :: :: I


  subrules
    pure_arg <:: arg
    pure_ret <:: ret


grammar

  C {{ tex \mathcal{C} }} :: Comp_ ::= {{ phantom }} {{ com computational var env }}
    | cdot                  ::   :: empty
    | C , Symbol_sym : BT_t ::   :: cons
    | </ Ci // , // i />    ::   :: concat


grammar

  L {{ tex \mathcal{L} }} :: Log_ ::= {{ phantom }} {{ com logical var env }}
    | cdot                  ::   :: empty
    | </ Li // , // i />    ::   :: concat
    | L , Symbol_sym : BT_t ::   :: cons


grammar

  N {{ tex \Phi }} :: Con_ ::= {{ phantom }} {{ com constraints env }}
    | cdot                 ::   :: empty
    | N , term_aux         ::   :: cons
    | </ Ni // , // i />   ::   :: concat


grammar

  R {{ tex \mathcal{R} }} :: Res_ ::= {{ phantom }} {{ com resources env }}
    | cdot                 ::   :: empty
    | R , res              ::   :: anon_cons
    | R , Symbol_sym : res ::   :: bound_cons
    | </ Ri // , // i />   ::   :: concat

grammar

  subs {{ tex \sigma }} , psi {{ tex \psi }} :: Subs_ ::= {{ phantom }} {{ com substitutions }}
    | cdot                            ::   :: empty
    | id                              :: X M :: id {{ com identity substitution }} {{ tex \mathrm{id} }} {{ ocaml SUBS_ID }}
    | spine_elem  / Symbol_sym , subs ::   :: cons_spine_elem
    | term_aux / Symbol_sym , subs    ::   :: cons_term
    | </ subsi // , // i />           ::   :: concat
    | ( subs )                        :: X S :: paren {{ com parentheses }} {{ tex [[subs]] }} {{ ocaml [[subs]] }}
    | [ subs ] psi                    :: M :: subs {{ com apply $[[subs]]$ to all elements in $[[psi]]$ }}
                                                   {{ ocaml SUBS_SUBS [[subs]] [[psi]] }}
                                                   {{ tex [[subs]] ( [[psi]] ) }}

grammar

  typing :: 'typing_' ::=
    | smt ( N => term_aux )                                               ::   :: smt
    | Symbol_sym : base_type inEnv C                                      ::   :: x_in_C
    | Symbol_sym : base_type inEnv L                                      ::   :: x_in_L
    | struct ty_tag & </ Symbol_identifieri : T_cti // i /> inEnv Globals ::   :: struct_in_globals
    | </ Ci ; Li ; Ni |- ty_mem_valuei => mem base_typei // i />          ::   :: indexed_infer_mem_value       {{ com dependent on memory object model }}
    | </ Ci ; Li ; Ni |- mu_pval_auxi => base_typei // i />               :: X :: index_infer_mu_pval
    | </ mu_pattern_auxi : base_typei ~> Ci with term_auxi // i />        :: X :: indexed_pattern
    | </ Ci ; Li ; Ni |- mu_tpexpri <= yi : base_typei . termi // i />    :: X :: indexed_check_mu_tpexpr
    | </ Ci ; Li ; Ni ; Ri |- mu_texpri <= reti // i />                   :: X :: indexed_check_mu_texpr


grammar

  opsem :: 'opsem_' ::=
    | </ mu_pattern_auxi = mu_pval_auxi ~> subsi // i />              :: X :: indexed_decons_value
    | forall i <  j . not ( mu_pattern_auxi = mu_pval_aux ~> subsi )  ::   :: forall_i_lt_j_not_decons_jtype
    | fresh ( ty_mem_ptr )                                            ::   :: fresh_loc
    | term_aux                                                        ::   :: constraints
    | mu_pval_aux : base_type                                         ::   :: arb_pval_of_base_type


grammar

  formula :: 'formula_' ::=
    | judgement                                                       ::   :: judgement
    | typing                                                          ::   :: typing
    | opsem                                                           ::   :: opsem
    % both
    | term_aux eq term_aux'                                           ::   :: abbreviations
    | mu_name : pure_arg eq </ xi // i /> |-> mu_tpexpr inEnv Globals ::   :: pure_func_body_in_globals
    | mu_name : arg      eq </ xi // i /> |-> mu_texpr  inEnv Globals ::   :: func_body_in_globals

defns
  lemma_jtype :: '' ::=

  defn
    </ xi // , // i /> :; arg ~> C ; L ; N ; R | ret :: :: Arg_Env :: Arg_Env_ by

    -------------------------------------- :: Ret
    :; ret ~> cdot ; cdot ; cdot ; cdot | ret


    </ xi // i /> :; arg ~> C ; L ; N ; R | ret
    ---------------------------------------------------------------------------------- :: Comp
    x , </ xi // i /> :; pi x : base_type . arg ~> C , x : base_type ; L ; N ; R | ret


    </ xi // i /> :; arg ~> C ; L ; N ; R | ret
    --------------------------------------------------------------------------------------- :: Log
    x , </ xi // i /> :; forall x : base_type . arg ~> C ; L , x : base_type ; N ; R | ret


    </ xi // i /> :; arg ~> C ; L ; N ; R | ret
    -------------------------------------------------------------------- :: Phi
    </ xi // i /> :; term_aux -) arg ~> C ; L ; N , term_aux ; R | ret


    </ xi // i /> :; arg ~> C ; L ; N ; R | ret
    ----------------------------------------------------------------- :: Res
    x , </ xi // i /> :; res --o arg ~> C ; L ; N ; R , x : res | ret


  defn
    C ; L ; N ; R [= C' ; L' ; N' ; R' :: :: Weak :: Weak_ by


    ------------------------------------------------------ :: Empty
    cdot ; cdot ; cdot ; cdot [= cdot ; cdot ; cdot ; cdot


    C ; L ; N ; R [= C' ; L' ; N' ; R'
    ------------------------------------------------------------------ :: Cons_Comp
    C , x : base_type ; L ; N ; R [= C' , x : base_type ; L' ; N' ; R'


    C ; L ; N ; R [= C' ; L' ; N' ; R'
    ----------------------------------------------------------------- :: Cons_Log
    C ; L , x : base_type ; N ; R [= C' ; L' , x : base_type ; N' ; R'


    C ; L ; N ; R [= C' ; L' ; N' ; R'
    -------------------------------------------------------- :: Cons_Phi
    C ; L ; N , term_aux ; R [= C' ; L' ; N' , term_aux ; R'


    C ; L ; N ; R [= C' ; L' ; N' ; R'
    ---------------------------------------------- :: Cons_Res_Anon
    C ; L ; N ; R , res [= C' ; L' ; N' ; R' , res


    C ; L ; N ; R [= C' ; L' ; N' ; R'
    ------------------------------------------------------- :: Cons_Res_Named
    C ; L ; N ; R , x : res [= C' ; L' ; N' ; R' , x : res


    C ; L ; N ; R [= C' ; L' ; N' ; R'
    -------------------------------------------------- :: Skip_Comp
    C ; L ; N ; R [= C' , x : base_type ; L' ; N' ; R'


    C ; L ; N ; R [= C' ; L' ; N' ; R'
    -------------------------------------------------- :: Skip_Log
    C ; L ; N ; R [= C' ; L' , x : base_type ; N' ; R'


    C ; L ; N ; R [= C' ; L' ; N' ; R'
    --------------------------------------------- :: Skip_Phi
    C ; L ; N ; R [= C' ; L' ; N' , term_aux ; R'


    % Remember R is a linear environment, so no weakening


  defn
    C ; L ; N ; R |- ( subs ) : ( C' ; L' ; N' ; R' ) :: :: Ty_Subs :: Ty_Subs_ by


    ---------------------------------------------------------- :: Empty
    C ; L ; N ; cdot |- ( cdot ) : ( cdot ; cdot ; cdot ; cdot )


    C ; L ; N ; R |- ( subs ) : ( C' ; L' ; N' ; R' )
    C ; L ; N |- mu_pval_aux => base_type
    ------------------------------------------------------------------------------------ :: Cons_Comp
    C ; L ; N ; R |- ( mu_pval_aux / x , subs ) : ( C' , x : base_type ; L' ; N' ; R' )


    C ; L ; N ; R |- ( subs ) : ( C' ; L' ; N' ; R' )
    C ; L ; N |- mu_pval_aux => base_type
    ----------------------------------------------------------------------------------- :: Cons_Log
    C ; L ; N ; R |- ( mu_pval_aux / x , subs ) : ( C' ; L' , x : base_type ; N' ; R' )


    C ; L ; N ; R |- ( subs ) : ( C' ; L' ; N' ; R' )
    smt ( N => term_aux )
    ------------------------------------------------------------- :: Cons_Phi
    C ; L ; N ; R |- ( subs ) : ( C' ; L' ; N' , term_aux ; R' )


    C ; L ; N ; R  |- ( subs ) : ( C' ; L' ; N' ; R' )
    C ; L ; N ; R1 |- res_term <= [ subs ] res
    -------------------------------------------------------------------------------- :: Cons_Res_Named
    C ; L ; N ; R , R1 |- ( res_term / x , subs ) :  ( C' ; L' ; N' ; R' , x : res )


    % ASK: not so sure about this rule - it is necessary but how?
    C ; L ; N ; R  |- ( subs ) : ( C' ; L' ; N' ; R' )
    C ; L ; N ; R1 |- res_term <= [ subs ] res
    ------------------------------------------------------------- :: Cons_Res_Anon
    C ; L ; N ; R , R1 |- ( subs ) :  ( C' ; L' ; N' ; R' , res )


grammar

  heap , h :: 'Heap_' ::= {{ phantom }} {{ com heaps }}
    | cdot              :: :: empty
    | h + { points_to } :: :: points_to


defns
  res_jtype :: 'Ty_' ::=

  defn
    N |- res eq res' :: :: Res_Eq :: Res_Eq_ by

    -------------------- :: Emp
    N |- emp eq emp


    smt ( N => ( term_aux1 = term_aux'1 ) /\ ( term_aux2 = term_aux'2 ) )
    ----------------------------------------------------------------------------------------------- :: PointsTo
    N |- term_aux1 ( q )|- init_t - ct -> term_aux2 eq term_aux'1 ( q )|- init_t - ct -> term_aux'2


    N |- res1 eq res'1
    N |- res2 eq res'2
    ------------------------------------ :: SepConj
    N |- res1 *s res2 eq res'1 *s res'2


    N |- res eq res'
    -------------------------------------------------------------------------------- :: Exists
    N |- exists Symbol_sym : base_type . res eq exists Symbol_sym : base_type . res'


    smt ( N =>  ( term_aux -> term_aux' ) /\ ( term_aux' -> term_aux ) )
    N |- res eq res'
    -------------------------------------------------------------------- :: Term
    N |- term_aux /\ res eq term_aux' /\ res'


  defn
    C ; L ; N ; R |- res_term <= res :: :: Res :: Res_ by


    ------------------------------ :: Emp
    C ; L ; N ; cdot |- emp <= emp


    N |- points_to  eq points_to'
    N |- points_to' eq points_to''
    --------------------------------------------------------- :: PointsTo
    C ; L ; N ; cdot , points_to |- points_to' <= points_to''


    N |- res eq res'
    --------------------------------------- :: Var
    C ; L ; N ; cdot , r : res |- r <= res'


    C ; L ; N ; R1 |- res_term1 <= res1
    C ; L ; N ; R2 |- res_term2 <= res2
    ------------------------------------------------------------------ :: SepConj
    C ; L ; N ; R1 , R2 |- <( res_term1 , res_term2 )> <= res1 *s res2


    smt ( N => term_aux )
    C ; L ; N ; R |- res_term <= res
    ----------------------------------------------------------------- :: Conj
    C ; L ; N ; R |- res_term <= term_aux /\ res


    % Has to be checking. Consider type of pack (1 , l |-> 1 , 1)
    % exists y : integer . l |-> (y,y or y,1 or 1,y or 1,1)
    C ; L ; N |- mu_pval_aux => base_type
    C ; L ; N ; R |- res_term <= [ mu_pval_aux / y , cdot ] res
    ------------------------------------------------------------------------------- :: Pack
    C ; L ; N ; R |- pack ( mu_pval_aux , res_term ) <= exists y : base_type . res

  defn
    h : R :: :: Heap :: Heap_ by

    ----------- :: Emp
    cdot : cdot


    h : R
    cdot ; cdot ; cdot ; R' |- pt <= pt
    ----------------------------------- :: PointsTo
    h + { pt } : R , R'


defns
  object_value_jtype :: 'Ty_' ::=

  defn
    C ; L ; N |- mu_object_value => obj base_type :: :: Pval_Obj_ :: Pval_Obj_ by


    -------------------------------------- :: Int
    C ; L ; N |- ty_mem_int => obj integer


    ---------------------------------- :: Ptr
    C ; L ; N |- ty_mem_ptr => obj loc


    % only instance of mutually recursive call to mu_value_judgement, can be inlined away
    </ C ; L ; N |- mu_loaded_valuei => base_type // i />
    --------------------------------------------------------------------------- :: Arr
    C ; L ; N |- array ( </ mu_loaded_valuei // i /> ) => obj array base_type


    struct ty_tag & </ Symbol_identifieri : cti // i /> inEnv Globals
    </ C ; L ; N |- ty_mem_valuei => mem to_base ( cti ) // i />
    -------------------------------------------------------------------------------- :: Struct
    C ; L ; N |- ( struct ty_tag ) { </ dot Symbol_identifieri : T_cti = ty_mem_valuei //  i /> } => obj struct ty_tag


    % NOT IMPLEMENTED: union
    % UNSUPPORTED: floats

defns
  pval_jtype :: 'Ty_' ::=

  defn
    C ; L ; N |- mu_pval_aux => base_type :: :: Pval :: Pval_ by


    x : base_type inEnv C
    --------------------------- :: Var_Comp
    C ; L ; N |- x => base_type


    x : base_type inEnv L
    --------------------------- :: Var_Log
    C ; L ; N |- x => base_type


    % DEFER impl_const (aka globals) needs resources


    C ; L ; N |- mu_object_value => obj base_type
    --------------------------------------------- :: Obj
    C ; L ; N |- mu_object_value => base_type


    C ; L ; N |- mu_object_value => obj base_type
    --------------------------------------------------- :: Loaded
    C ; L ; N |- specified mu_object_value => base_type


    ------------------------- :: Unit
    C ; L ; N |- Unit => unit


    ------------------------- :: True
    C ; L ; N |- True => bool


    -------------------------- :: False
    C ; L ; N |- False => bool


    </ C ; L ; N |- mu_valuei => base_type // i />
    ----------------------------------------------------------------- :: List
    C ; L ; N |- base_type [ </ mu_valuei // i /> ] => list base_type


    </ C ; L ; N |- mu_valuei =>  base_typei // i />
    -------------------------------------------------------------- :: Tuple
    C ; L ; N |- ( </ mu_valuei // i /> ) => </ base_typei // i />


    % NOT IMPLEMENTED - constrained


    smt ( N => false )
    ----------------------------------------------------------- :: Error
    C ; L ; N |- error ( ty_string , mu_pval_aux ) => base_type


    ------------------------------------------------ :: Ctor_Nil
    C ; L ; N |- Nil base_type ( ) => list base_type


    C ; L ; N |- mu_pval1 => base_type
    C ; L ; N |- mu_pval2 => list base_type
    ---------------------------------------------------------- :: Ctor_Cons
    C ; L ; N |- Cons ( mu_pval1, mu_pval2 ) => list base_type


    </ C ; L ; N |- mu_pvali => base_typei // i />
    ------------------------------------------------------------------- :: Ctor_Tuple
    C ; L ; N |- Tuple ( </ mu_pvali // i /> ) => </ base_typei // i />


    % NOT IMPLEMENTED - empty arrays


    </ C ; L ; N |- mu_pvali => base_type // i />
    ------------------------------------------------------------- :: Ctor_Array
    C ; L ; N |- Array ( </ mu_pvali // i /> ) => array base_type


    C ; L ; N |- mu_pval => base_type
    ----------------------------------------------- :: Ctor_Specified
    C ; L ; N |- Specified ( mu_pval ) => base_type


    struct ty_tag & </ Symbol_identifieri : cti // i /> inEnv Globals
    </ C ; L ; N |- mu_pvali => to_base ( cti ) // i />
    ------------------------------------------------------------------------------------------------ :: Struct
    C ; L ; N |- ( struct ty_tag ) { </ dot Symbol_identifieri = mu_pvali // i /> } => struct ty_tag


   % NOT IMPLEMENTED - union

defns
  spine_jtype :: 'Ty_' ::=

  defn
    C ; L ; N ; R |- </ xi = spine_elemi // , // i /> :; arg >> subs ; ret :: :: Spine :: Spine_ by

    ------------------------------------------ :: Empty
    C ; L ; N ; cdot |- :; ret >> cdot ; ret


    C ; L ; N |- mu_pval_aux => base_type
    C ; L ; N ; R |- </ xi = spine_elemi // i /> :; arg >> subs ; ret
    ----------------------------------------------------------------- :: Comp
    C ; L ; N ; R |- x  = mu_pval_aux , </ xi = spine_elemi // i /> :; pi x : base_type . arg >> mu_pval_aux / x , subs ; ret


    C ; L ; N |- mu_pval_aux => base_type
    C ; L ; N ; R |- </ xi = spine_elemi  // i /> :; arg >> subs ; ret
    ------------------------------------------------------------------ :: Log
    C ; L ; N ; R |- x = mu_pval_aux , </ xi = spine_elemi // i /> :;  forall x : base_type . arg >> mu_pval_aux / x , subs ; ret


    C ; L ; N ; R1 |- res_term <= res
    C ; L ; N ; R2 |- </ xi = spine_elemi // i /> :; arg >> subs ; ret
    ------------------------------------------------------------------ :: Res
    C ; L ; N ; R1 , R2 |- x = res_term , </ xi = spine_elemi // i /> :;  res --o arg >> res_term / x , subs ; ret


    smt ( N => term_aux )
    C ; L ; N ; R |- </ xi = spine_elemi // i /> :; arg >> subs ; ret
    ----------------------------------------------------------------------------- :: Phi
    C ; L ; N ; R |- </ xi = spine_elemi // i /> :;  term_aux -) arg >> subs ; ret


defns
  pexpr_jtype :: 'Ty_' ::=

  defn
    C ; L ; N |- mu_pexpr_aux => ident : base_type . term_aux :: :: PE :: PE_ by


    C ; L ; N |- mu_pval_aux => base_type
    ----------------------------------------------------------------- :: Val
    C ; L ; N |- mu_pval_aux => y : base_type . y = inj mu_pval_aux


   % NOT IMPLEMENTED - mu_ctor_expr
   % Ivmax       :: :: ivmax       {{ com max integer value              }} % : ctype -> integer
   % Ivmin       :: :: ivmin       {{ com min integer value              }} % : ctype -> integer
   % Ivsizeof    :: :: ivsizeof    {{ com sizeof value                   }} % : ctype -> integer
   % Ivalignof   :: :: ivalignof   {{ com alignof value                  }} % : ctype -> integer
   % IvCOMPL     :: :: ivCOMPL     {{ com bitwise complement             }} % : ctype -> integer -> integer
   % IvAND       :: :: ivAND       {{ com bitwise AND                    }} % : ctype -> integer -> integer -> integer
   % IvOR        :: :: ivOR        {{ com bitwise OR                     }} % : ctype -> integer -> integer -> integer
   % IvXOR       :: :: ivXOR       {{ com bitwise XOR                    }} % : ctype -> integer -> integer -> integer

   % Unsupported
   % Fvfromint   :: :: fvfromint   {{ com cast integer to floating value }} % : integer -> floating
   % Ivfromfloat :: :: ivfromfloat {{ com cast floating to integer value }} % : ctype -> floating -> integer


    C ; L ; N |- mu_pval_aux1 => loc
    C ; L ; N |- mu_pval_aux2 => integer
    ------------------------------------ :: Array_Shift
    C ; L ; N |- array_shift ( mu_pval_aux1 , ct , mu_pval_aux2 ) => y : loc . y = inj mu_pval_aux1 +ptr ( inj mu_pval_aux2 * size_of ct )


    C ; L ; N |- mu_pval_aux => loc
    struct ty_tag & </ Symbol_identifieri : T_cti // i /> inEnv Globals
    ------------------------------------------------------------------------ :: Member_Shift
    C ; L ; N |- member_shift ( mu_pval_aux , ty_tag , Symbol_identifierj ) => y : loc . y = inj mu_pval_aux +ptr offset_of ty_tag Symbol_identifierj


    C ; L ; N |- mu_pval_aux => bool
    ------------------------------------------------------------------------ :: Not
    C ; L ; N |- not ( mu_pval_aux ) => y : bool . y = neg inj mu_pval_aux


    C ; L ; N |- mu_pval_aux1 => integer
    C ; L ; N |- mu_pval_aux2 => integer
    --------------------------------------------------------------------------------------------------------------------------------- :: Arith_Binop
    C ; L ; N |- mu_pval_aux1 arith_binop mu_pval_aux2 => y : integer . y = ( inj mu_pval_aux1 ' arith_binop ' inj mu_pval_aux2 )


    C ; L ; N |- mu_pval_aux1 => integer
    C ; L ; N |- mu_pval_aux2 => integer
    -------------------------------------------------------------------------------------------------------------------------- :: Rel_Binop
    C ; L ; N |- mu_pval_aux1 rel_binop mu_pval_aux2 => y : bool . y = ( inj mu_pval_aux1 ' rel_binop ' inj mu_pval_aux2 )


    C ; L ; N |- mu_pval_aux1 => bool
    C ; L ; N |- mu_pval_aux2 => bool
    ---------------------------------------------------------------------------------------------------------------------------- :: Bool_Binop
    C ; L ; N |- mu_pval_aux1 bool_binop mu_pval_aux2 => y : bool . y = ( inj mu_pval_aux1 ' bool_binop ' inj mu_pval_aux2 )


    mu_name : pure_arg eq </ xi // i /> |-> mu_tpexpr inEnv Globals
    C ; L ; N ; cdot |- </ xi = mu_pval_auxi // i /> :; pure_arg >> subs ; sigma y : base_type . term /\ I
    ------------------------------------------------------------------------------------------------------ :: Call
    C ; L ; N |- mu_name ( </ mu_pval_auxi // i /> ) => y : base_type . [ subs ] term


    % NOT IMPLEMENTED: memberof ( Symbol_sym , Symbol_identifier , mu_pval_aux )


    % DEFER conv_int
    % conv_int ( ty_act , mu_pval_aux )


    C ; L ; N |- mu_pval_aux => bool
    smt ( N => inj mu_pval_aux )
    --------------------------------------------------------------------------------- :: Assert_Undef
    C ; L ; N |- assert_undef ( mu_pval_aux , ty_loc UB_name ) => y : unit . y = unit


    C ; L ; N |- mu_pval_aux => bool
    ------------------------------------------------------------------------------------------------------------- :: Bool_To_Integer
    C ; L ; N |- bool_to_integer ( mu_pval_aux ) => y : integer . y = if inj mu_pval_aux then z_one else z_zero


    C ; L ; N |- mu_pval_aux => integer
    abbrev1 eq max_int ct - min_int ct + z_one
    abbrev2 eq inj mu_pval_aux rem_f abbrev1
    ---------------------------------------------------------------------------------------------------------------------------- :: WrapI
    C ; L ; N |- wrapI ( ct , mu_pval_aux ) => y : base_type . y = if abbrev2 =< max_int ct then abbrev2 else abbrev2 - abbrev1


defns
  comp_pattern_jtype :: 'Ty_Pat_' ::=

  defn
    mu_pattern_aux : base_type ~> C with term_aux :: :: Comp_ :: Comp_ by


    ---------------------------------------- :: No_Sym_Annot
    _ : base_type : base_type ~> cdot with _


    -------------------------------------------------------- :: Sym_Annot
    x : base_type : base_type ~> cdot , x : base_type with x


    --------------------------------------------------- :: Nil
    Nil base_type ( ) : list base_type ~> cdot with nil


    mu_pattern_aux1 : base_type ~> C1 with term_aux1
    mu_pattern_aux2 : list base_type ~> C2 with term_aux2
    ---------------------------------------------------------------------------------------------------- :: Cons
    Cons ( mu_pattern_aux1 , mu_pattern_aux2 ) : list base_type ~> C1 , C2 with term_aux1 cons term_aux2


    </ mu_pattern_auxi : base_typei ~> Ci with term_auxi // i />
    ----------------------------------------------------------------------------------------------------------- :: Tuple
    Tuple ( </ mu_pattern_auxi // i /> ) : </ base_typei // i /> ~> </ Ci // i /> with ( </ term_auxi // i /> )


    </ mu_pattern_auxi : base_type ~> Ci with term_auxi // i />
    ------------------------------------------------------------------------------------------------------- :: Array
    Array ( </ mu_pattern_auxi // i /> ) : array base_type ~> </ Ci // i /> with [| </ term_auxi // i /> |]


    mu_pattern_aux : base_type ~> C with term_aux
    ----------------------------------------------------------- :: Specified
    Specified ( mu_pattern_aux ) : base_type ~> C with term_aux


  defn
    mu_sym_or_pattern : base_type ~> C with term_aux :: :: Sym_Or_Pattern :: Sym_Or_Pattern_ by


    -------------------------------------------- :: Sym
    x : base_type ~> cdot , x : base_type with x


    mu_pattern_aux : base_type ~> C with term_aux
    ----------------------------------------------- :: Pattern
    mu_pattern_aux : base_type ~> C with term_aux

defns
  res_pattern_jtype :: 'Ty_Pat_' ::=

  defn
    res_pattern : res ~> L ; N ;  R :: :: Res_ :: Res_ by


    -------------------------------- :: Empty
    emp : emp ~> cdot ; cdot ; cdot


    ----------------------------------------------------------- :: PointsTo
    points_to : points_to ~> cdot ; cdot ; cdot , points_to


    ------------------------------------------------- :: Var
    r : res ~> cdot ; cdot ; cdot , r : res


    res_pattern1 : res1 ~> L1 ; N1 ; R1
    res_pattern2 : res2 ~> L2 ; N2 ; R2
    ------------------------------------------------------------------------------- :: SepConj
    <( res_pattern1 , res_pattern2 )> : res1 *s res2 ~> L1 , L2 ; N1 , N2 ; R1 , R2


    res_pattern : res ~> L ; N ; R
    ------------------------------------------------------ :: Conj
    res_pattern : term_aux /\ res ~> L ; N , term_aux ; R


    res_pattern : [ x / y , cdot ] res ~> L ; N ; R
    ---------------------------------------------------------------------------------- :: Pack
    pack ( x , res_pattern ) : exists y : base_type . res ~> L , x : base_type ; N ; R


defns
  ret_pattern_jtype :: 'Ty_Pat_' ::=

  defn
    </ ret_patterni // , // i /> : ret ~> C ; L ; N ; R :: :: Ret_ :: Ret_ by


    ------------------------------------------------- :: Empty
     : I ~> cdot ; cdot ; cdot ; cdot


    mu_sym_or_pattern : base_type ~> C1 with term_aux1
    </ ret_patterni // i /> : [ term_aux1 / y , cdot ] ret ~> C2 ; L2 ; N2 ; R2
    --------------------------------------------------------------------------- :: Comp
    comp mu_sym_or_pattern , </ ret_patterni // i /> : sigma y : base_type . ret ~> C1, C2 ; L2 ; N2 ; R2


    </ ret_patterni // i /> : ret ~> C ; L ; N ; R
    ---------------------------------------------------------------------------------------------- :: Log
    log y , </ ret_patterni // i /> : exists y : base_type . ret ~> C ; L , y : base_type ; N ; R


    res_pattern : res ~> L1 ; N1 ; R1
    </ ret_patterni // i /> : ret ~> C2 ; L2 ; N2 ; R2
    ---------------------------------------------------------------------------------------- :: Res
    reso res_pattern , </ ret_patterni // i /> : res *o ret ~> C2 ; L1, L2 ; N1, N2 ; R1, R2


    </ ret_patterni // i /> : ret ~> C ; L ; N ; R
    --------------------------------------------------------------------- :: Phi
    </ ret_patterni // i /> : term_aux /\ ret ~> C ; L ; N , term_aux ; R


defns
  tpval_jtype :: 'Ty_' ::=

  defn
    C ; L ; N |- mu_tpval_aux <= ident : base_type . term_aux :: :: TPVal :: TPVal_ by


    smt ( N => false )
    ------------------------------------------------------------- :: Undef
    C ; L ; N |- undef ty_loc UB_name <= y : base_type . term_aux


    C ; L ; N |- mu_pval_aux => base_type
    smt ( N => [ mu_pval_aux / y , cdot ] term )
    ----------------------------------------------------- :: Done
    C ; L ; N |- done mu_pval_aux <= y : base_type . term


defns
  tpexpr_jtype :: 'Ty_' ::=

  defn
    C ; L ; N |- mu_tpexpr_aux <= ident : base_type . term_aux :: :: TPE :: TPE_ by


    % No need for propogating constraints
    C ; L ; N |- mu_pval_aux => bool
    C ; L ; N , inj mu_pval_aux = true  |- mu_tpexpr_aux1 <= y : base_type . term
    C ; L ; N , inj mu_pval_aux = false |- mu_tpexpr_aux2 <= y : base_type . term
    -------------------------------------------------------------------------------------------- :: If
    C ; L ; N |- if mu_pval_aux then mu_tpexpr_aux1 else mu_tpexpr_aux2 <= y : base_type . term


    C ; L ; N |- mu_pexpr_aux => y1 : base_type1 . term1
    mu_sym_or_pattern : base_type1 ~> C1 with term_aux
    C , C1 ; L ; N , [ term_aux / y1 , cdot ] term1 |- mu_tpexpr <= y2 : base_type2 . term2
    -------------------------------------------------------------------------------------------- :: Let
    C ; L ; N |- let mu_sym_or_pattern = mu_pexpr_aux in mu_tpexpr <= y2 : base_type2 . term2


    C ; L ; N |- mu_tpexpr_aux1 <= y1 : base_type1 . term1
    mu_sym_or_pattern : base_type1 ~> C1 with term_aux
    C , C1 ; L ; N , [ term_aux / y1 , cdot ] term1 |- mu_tpexpr <= y2 : base_type2 . term2
    ------------------------------------------------------------------------------------------------------------------------------ :: LetT
    C ; L ; N |- let mu_sym_or_pattern : ( y1 : base_type1 . term1 ) = mu_tpexpr_aux1 in mu_tpexpr_aux2 <= y2 : base_type2 . term2


    C ; L ; N |- mu_pval_aux => base_type1
    </ mu_patterni : base_type1 ~> Ci with term_auxi // i />
    </ C , Ci ; L ; N , term_auxi = inj mu_pval_aux |- mu_tpexpri <= y2 : base_type2 . term2 // i />
    ---------------------------------------------------------------------------------------------------------------- :: Case
    C ; L ; N |- case mu_pval_aux of </ | mu_patterni => mu_tpexpri // i /> end <= y2 : base_type2 . term2


defns
  action_jtype :: 'Ty_' ::=

  defn
    C ; L ; N ; R |- mu_action_aux => ret :: :: Action :: Action_ by


    C ; L ; N |- mu_pval_aux => integer
    ----------------------------------- :: Create
    C ; L ; N ; cdot |- create ( mu_pval_aux , ct ) Symbol_prefix => sigma yp : loc . representable ( ct *s , yp ) /\ alignedI ( inj mu_pval_aux , yp ) /\ exists y : to_base ( ct ) . ( yp ( q_one )|- * - ct -> y ) *o I


    % NOT IMPLEMENTED
    % C ; L ; N ; cdot |-> create_readonly ( vp , ct , v ) Symbol_prefix => ??


    % NOT IMPLEMENTED - memory order
    C ; L ; N |- mu_pval_aux0 => loc
    smt ( N => inj mu_pval_aux0 = inj mu_pval_aux1 )
    C ; L ; N ; R |- inj mu_pval_aux1 ( q_one )|- tick - ct -> inj mu_pval_aux2 <= inj mu_pval_aux1 ( q_one )|- tick - ct -> inj mu_pval_aux2
    ----------------------------------------------------------------------------------------------------------------------------------------- :: Load
    C ; L ; N ; R |- load ( ct , mu_pval_aux0 , _mem_order , inj mu_pval_aux1 ( q_one )|- tick - ct -> inj mu_pval_aux2 ) => sigma y : to_base ( ct ) . y = inj mu_pval_aux2 /\ ( inj mu_pval_aux1 ( q_one )|- tick - ct -> inj mu_pval_aux2 ) *o I


    C ; L ; N |- mu_pval_aux0 => loc
    C ; L ; N |- mu_pval_aux1 => to_base ( ct )
    % NOT IMPLEMENTED - locking boolean
    smt ( N => representable ( ct , inj mu_pval_aux1 ) )
    smt ( N => inj mu_pval_aux2 = inj mu_pval_aux0 )
    C ; L ; N ; R |- inj mu_pval_aux2 ( q_one )|- _i - ct -> _t <= inj mu_pval_aux2 ( q_one )|- _i - ct -> _t
    --------------------------------------------------------------------------------------------------------- :: Store
    C ; L ; N ; R |- store ( _b , ct , mu_pval_aux0 , mu_pval_aux1 , _mem_order , inj mu_pval_aux2 ( q_one )|- _i - ct -> _t ) => sigma _ : unit . ( inj mu_pval_aux2 ( q_one )|- tick - ct -> inj mu_pval_aux1 ) *o I


    C ; L ; N |- mu_pval_aux0 => loc
    smt ( N => inj mu_pval_aux0 = inj mu_pval_aux1 )
    C ; L ; N ; R |- inj mu_pval_aux1 ( q_one )|- _i - ct -> _t <= inj mu_pval_aux1 ( q_one )|- _i - ct -> _t
    --------------------------------------------------------------------------------------------------------------- :: Kill_Static
    C ; L ; N ; R |-  kill ( static ct , mu_pval_aux0 , inj mu_pval_aux1 ( q_one )|- _i - ct -> _t ) => sigma _ : unit . I


    % NOT IMPLEMENTED
    % C ; L ; N ; ?? |- kill ( dynamic , v ) => ??


    % mu_action_aux {{ tex action\_aux }} :: 'M_' ::= {{ auxparam 'TY }} {{ com memory actions }}
    %   | alloc ( ty_asym1 , ty_asym2 ) Symbol_prefix                                                         :: :: Alloc
    %   | load ( ty_act , ty_asym , Cmm_memory_order )                                                        :: :: Load
    %   | rmw ( ty_act ,  ty_asym1 , ty_asym2 , ty_asym3 , Cmm_memory_order1 , Cmm_memory_order2 )            :: :: RMW
    %   | fence ( Cmm_memory_order )                                                                          :: :: Fence
    %   | cmp_exch_strong ( ty_act , ty_asym1 , ty_asym2 , ty_asym3 , Cmm_memory_order1 , Cmm_memory_order2 ) :: :: CompareExchangeStrong
    %   | cmp_exch_weak ( ty_act , ty_asym1 , ty_asym2 , ty_asym3 , Cmm_memory_order1 , Cmm_memory_order2 )   :: :: CompareExchangeWeak
    %   | linux_fence ( Linux_linux_memory_order )                                                            :: :: LinuxFence
    %   | linux_load ( ty_act , ty_asym , Linux_linux_memory_order )                                          :: :: LinuxLoad
    %   | linux_store ( ty_act , ty_asym1 , ty_asym2 , Linux_linux_memory_order )                             :: :: LinuxStore
    %   | linux_rmw ( ty_act , ty_asym1 , ty_asym2 , Linux_linux_memory_order )                               :: :: LinuxRMW

defns
  memop_jtype :: 'Ty_' ::=

  defn
    C ; L ; N ; R |- mu_memop => ret :: :: Memop :: Memop_ by


    C ; L ; N |- mu_pval_aux1 => loc
    C ; L ; N |- mu_pval_aux2 => loc
    ----------------------------------------------------------------------------------------------------------------------------------------- :: Rel_Binop
    C ; L ; N ; cdot |- mu_pval_aux1 rel_binop mu_pval_aux2 => sigma y : bool . y = ( inj mu_pval_aux1 ' rel_binop ' inj mu_pval_aux2 ) /\ I


    % NOT IMPLEMENTED
    % mu_pval_aux1 - ty_act - mu_pval_aux2


    C ; L ; N |- mu_pval_aux => loc
    ------------------------------- :: IntFromPtr
    C ; L ; N ; cdot |- intFromPtr ( ct1 , ct2 , mu_pval_aux ) => sigma y : integer . y = cast_ptr_to_int inj mu_pval_aux /\ I


    C ; L ; N |- mu_pval_aux => integer
    ----------------------------------- :: PtrFromInt
    C ; L ; N ; cdot |- ptrFromInt ( ct1 , ct2 , mu_pval_aux ) => sigma y : loc . y = cast_int_to_ptr inj mu_pval_aux /\ I


    C ; L ; N |- mu_pval_aux0 => loc
    smt ( N => inj mu_pval_aux1 = inj mu_pval_aux0 )
    C ; L ; N ; R |- inj mu_pval_aux1 ( _q )|- tick - ct -> _t <= inj mu_pval_aux1 ( _q )|- tick - ct -> _t
    ------------------------------------------------------------------------------------------------------- :: PtrValidForDeref
    C ; L ; N ; R |- ptrValidForDeref ( ct , mu_pval_aux0 , inj mu_pval_aux1 ( _q )|- tick - ct -> _t ) => sigma y : bool . y = aligned ( ct , inj mu_pval_aux1 ) /\ ( inj mu_pval_aux1 ( _q )|- tick - ct -> _t ) *o I


    C ; L ; N |- mu_pval_aux1 => loc
    -------------------------------- :: PtrWellAligned
    C ; L ; N ; cdot |- ptrWellAligned ( ct , mu_pval_aux ) => sigma y : bool . y = aligned ( ct , inj mu_pval_aux ) /\ I


    C ; L ; N |- mu_pval_aux1 => loc
    C ; L ; N |- mu_pval_aux2 => integer
    ------------------------------------ :: PtrArrayShift
    C ; L ; N ; cdot |- ptrArrayShift ( mu_pval_aux1 ,  ct , mu_pval_aux2 ) => sigma y : loc . y = inj mu_pval_aux1 +ptr ( inj mu_pval_aux2 * size_of ct ) /\ I



defns
  tval_jtype :: 'Ty_' ::=

  defn
    C ; L ; N ; R |- mu_tval_aux <= ret :: :: TVal :: TVal_ by

    ------------------------------ :: I
    C ; L ; N ; cdot |- done <= I


    C ; L ; N |- mu_pval_aux => base_type
    C ; L ; N ; R |- done </ spine_elemi // i /> <= [ mu_pval_aux / y , cdot ] ret
    --------------------------------------------------------------------------------------- :: Comp
    C ; L ; N ; R |- done mu_pval_aux , </ spine_elemi // i /> <= sigma y : base_type . ret


    C ; L ; N |- mu_pval_aux => base_type
    C ; L ; N ; R |- done </ spine_elemi // i /> <= [ mu_pval_aux / y , cdot ] ret
    ----------------------------------------------------------------------------------------- :: Log
    C ; L ; N ; R |- done mu_pval_aux , </ spine_elemi // i /> <= exists y : base_type . ret


    smt ( N => term_aux )
    C ; L ; N ; R |- done spine <= ret
    ---------------------------------------------- :: Phi
    C ; L ; N ; R |- done spine <= term_aux /\ ret


    C ; L ; N ; R1 |- res_term <= res
    C ; L ; N ; R2 |- done </ spine_elemi // i /> <= ret
    ---------------------------------------------------------------------------- :: Res
    C ; L ; N ; R1 , R2 |- done res_term , </ spine_elem // i /> <= res *o ret


    smt ( N => false )
    ----------------------------------------------- :: Undef
    C ; L ; N ; cdot |- undef ty_loc UB_name <= ret


defns
  seq_expr_jtype :: 'Ty_' ::=

  defn
    C ; L ; N ; R |- mu_seq_expr_aux => ret :: :: Seq_E :: Seq_E_ by


    Symbol_sym :  arg eq </ xi // i /> |-> mu_texpr  inEnv Globals
    C ; L ; N ; R |- </ xi = spine_elemi // i /> :; arg >> subs ; ret
    ----------------------------------------------------------------------------------------- :: CCall
    C ; L ; N ; R |- ccall ( ty_act , Symbol_sym , </ spine_elemi // i /> ) => [ subs ] ret


    mu_name :  arg eq </ xi // i /> |-> mu_texpr  inEnv Globals
    C ; L ; N ; R |- </ xi = spine_elemi // i /> :; arg >> subs ; ret
    ----------------------------------------------------------------------------- :: Proc
    C ; L ; N ; R |- pcall ( mu_name , </ spine_elemi // i /> ) => [ subs ] ret


defns
  is_expr_jtype :: 'Ty_' ::=

  defn
    C ; L ; N ; R |- mu_is_expr_aux => ret :: :: Is_E :: Is_E_ by


    % NOT IMPLEMENTED
    % memcpy ( mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 )
    % memcmp ( mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 )
    % realloc ( mu_pval_aux1 , mu_pval_aux2 , mu_pval_aux3 )
    % va_start ( mu_pval_aux1 , mu_pval_aux2 )
    % va_copy ( mu_pval_aux )
    % va_arg ( mu_pval_aux , ty_act )
    % va_end ( mu_pval_aux )


    C ; L ; N ; R |- mu_memop => ret
    ------------------------------------------ :: Memop
    C ; L ; N ; R |- memop ( mu_memop ) => ret


    C ; L ; N ; R |- mu_action => ret
    ------------------------------------- :: Action
    C ; L ; N ; R |- Pos mu_action => ret


    C ; L ; N ; R |- mu_action => ret
    ------------------------------------- :: Neg_Action
    C ; L ; N ; R |- Neg mu_action => ret


    % </ C ; L ; N ; Ri |- mu_texpri <= reti // i />
    % -------------------------------------------------------------------------------------------- :: Unseq
    % C ; L ; N ; </ Ri // i /> |- unseq ( </ mu_texpri : reti // i /> ) => concat </ reti // i />

defns
  texpr_jtype :: 'Ty_' ::=

  defn
    C ; L ; N ; R |- mu_seq_texpr_aux <= ret :: :: Seq_TE :: Seq_TE_ by


    C ; L ; N ; R |- mu_tval <= ret
    -------------------------------- :: TVal
    C ; L ; N ; R |- mu_tval <= ret


    C ; L ; N |- mu_pexpr_aux => y : base_type . term
    mu_sym_or_pattern : base_type ~> C1 with term_aux1
    C , C1 ; L ; N , [ term_aux1 / y , cdot ] term ; R |- mu_texpr <= ret
    ------------------------------------------------------------------------- :: LetP
    C ; L ; N ; R |- let mu_sym_or_pattern = mu_pexpr_aux in mu_texpr <= ret


    C ; L ; N |- mu_tpexpr_aux <= y : base_type . term
    mu_sym_or_pattern : base_type ~> C1 with term_aux1
    C , C1 ; L ; N , [ term_aux1 / y , cdot ] term ; R |- mu_texpr <= ret
    ---------------------------------------------------------------------------------------------------- :: LetPT
    C ; L ; N ; R |- let mu_sym_or_pattern : ( y : base_type . term ) = mu_tpexpr_aux in mu_texpr <= ret


    C ; L ; N ; R' |- mu_seq_expr => ret1
    </ ret_patterni // i /> : ret1 ~> C1 ; L1 ; N1 ; R1
    C , C1 ; L , L1 ; N , N1 ; R , R1 |- mu_texpr <= ret2
    ----------------------------------------------------------------------------------- :: Let
    C ; L ; N ; R' , R |- let </ ret_patterni // i /> = mu_seq_expr in mu_texpr <= ret2


    C ; L ; N ; R' |- mu_texpr1 <= ret1
    </ ret_patterni // i /> : ret1 ~> C1 ; L1 ; N1 ; R1
    C , C1 ; L , L1 ; N , N1 ; R , R1 |- mu_texpr2 <= ret2
    ----------------------------------------------------------------------------------------- :: LetT
    C ; L ; N ; R' , R |- let </ ret_patterni // i /> : ret1 = mu_texpr1 in mu_texpr2 <= ret2


    C ; L ; N |- mu_pval_aux => base_type1
    </ mu_patterni : base_type1 ~> Ci with term_auxi // i />
    </ C , Ci ; L ; N , term_auxi = inj mu_pval_aux ; R |- mu_texpri <= ret // i />
    ------------------------------------------------------------------------------------------------ :: Case
    C ; L ; N ; R |- case mu_pval_aux of </ | mu_patterni => mu_texpri // i /> end <= ret


    C ; L ; N |- mu_pval_aux => bool
    C ; L ; N , inj mu_pval_aux = true  ; R |- mu_texpr1 <= ret
    C ; L ; N , inj mu_pval_aux = false ; R |- mu_texpr2 <= ret
    --------------------------------------------------------------------- :: If
    C ; L ; N ; R |- if mu_pval_aux then mu_texpr1 else mu_texpr2 <= ret


    Symbol_sym :  arg eq </ xi // i /> |-> mu_texpr  inEnv Globals
    C ; L ; N ; cdot |- </ xi = mu_pval_auxi // i /> :; arg >> subs ; false /\ I
    ----------------------------------------------------------------------------- :: Run
    C ; L ; N ; cdot |- run Symbol_sym </ mu_pval_auxi // i /> <= false /\ I


    C ; L ; N ; R |- mu_is_texpr_aux <= ret
    ------------------------------------------------------------ :: Bound
    C ; L ; N ; R |- bound [ ty_int ] ( mu_is_texpr_aux ) <= ret


  defn
    C ; L ; N ; R |- mu_is_texpr_aux <= ret :: :: Is_TE :: Is_TE_  by


    % % NOT IMPLEMENTED - memory events
    % C ; L ; N ; R |- mu_is_expr_aux => ret1
    % </ ret_patterni // i /> : ret1 ~> C1 ; L1 ; N1 ; R1
    % C , C1 ; L , L1 ; N , N1 ; R , R1 |- mu_texpr <= ret2
    % --------------------------------------------------------------------------------------- :: LetW
    % C ; L ; N ; R |- let weak </ ret_patterni // i /> = mu_is_expr_aux in mu_texpr <= ret2


    % NOT IMPLEMENTED - memory events
    C ; L ; N ; R' |- mu_is_expr_aux => ret1
    </ ret_patterni // i /> : ret1 ~> C1 ; L1 ; N1 ; R1
    C , C1 ; L , L1 ; N , N1 ; R , R1 |- mu_texpr <= ret2
    --------------------------------------------------------------------------------------------- :: LetS
    C ; L ; N ; R' , R |- let strong </ ret_patterni // i /> = mu_is_expr_aux in mu_texpr <= ret2


    % impl does Ret orFalse, for checking the body of a label (to ensure it doesn't return)
  defn
    C ; L ; N ; R |- mu_texpr <= ret :: :: TE :: TE_ by


    C ; L ; N ; R |- mu_is_texpr_aux <= ret
    --------------------------------------- :: Is
    C ; L ; N ; R |- mu_is_texpr_aux <= ret


    C ; L ; N ; R |- mu_seq_texpr_aux <= ret
    ---------------------------------------- :: Seq
    C ; L ; N ; R |- mu_seq_texpr_aux <= ret


defns
  subs_jtype :: 'Subs_' ::=

  defn
    mu_pattern_aux = mu_pval_aux ~> subs :: :: Decons_Value_ :: Decons_Value_ by


    ----------------------------- :: No_Sym_Annot
    _ : _bt = mu_pval_aux ~> cdot


    -------------------------------------------------- :: Sym_Annot
    x : _bt = mu_pval_aux ~> mu_pval_aux / x , cdot


    mu_pattern_aux1 = mu_pval_aux1 ~> subs1
    mu_pattern_aux2 = mu_pval_aux2 ~> subs2
    --------------------------------------------------------------------------------------------------- :: Cons
    Cons ( mu_pattern_aux1 , mu_pattern_aux2 ) = Cons ( mu_pval_aux1 , mu_pval_aux2 ) ~> subs1 , subs2


    </ mu_pattern_auxi = mu_pval_auxi ~> subsi // i />
    ------------------------------------------------------------------------------------------- :: Tuple
    Tuple ( </ mu_pattern_auxi // i /> ) = Tuple ( </ mu_pval_auxi // i /> ) ~> </ subsi // i />


    </ mu_pattern_auxi = mu_pval_auxi ~> subsi // i />
    -------------------------------------------------------------------------------------------- :: Array
    Array ( </ mu_pattern_auxi // i /> ) = Array ( </ mu_pval_auxi // i /> ) ~> </ subsi // i />


    mu_pattern_aux = mu_pval_aux ~> subs
    -------------------------------------------------- :: Specified
    Specified ( mu_pattern_aux ) = mu_pval_aux ~> subs


  defn
    mu_sym_or_pattern = mu_pval_aux ~> subs :: :: Decons_Value'_ :: Decons_Value'_ by


    ------------------------------------------- :: Sym
    x = mu_pval_aux ~> mu_pval_aux / x , cdot


    mu_pattern_aux = mu_pval_aux ~> subs
    ------------------------------------ :: Pattern
    mu_pattern_aux = mu_pval_aux ~> subs


  defn
    res_pattern = res_term ~> subs :: :: Decons_Res :: Decons_Res_ by


    ----------------- :: Emp
    emp = emp ~> cdot


    --------------- :: Points_to
    pt = pt ~> cdot


    --------------------------------------------------------- :: Var
    Symbol_sym = res_term ~> res_term / Symbol_sym , cdot


    res_pattern1 = res_term1 ~> subs1
    res_pattern2 = res_term2 ~> subs2
    -------------------------------------------------------------------------------- :: Pair
    <( res_pattern1 , res_pattern2 )> = <( res_term1 , res_term2 )> ~> subs1 , subs2


    res_pattern = res_term ~> subs
    ------------------------------------------------------------------------------------------------------ :: Pack
    pack ( Symbol_sym , res_pattern ) = pack ( mu_pval_aux , res_term ) ~> mu_pval_aux / Symbol_sym , subs


  defn
    </ ret_patterni = spine_elemi // , // i /> ~> subs :: :: Decons_Ret :: Decons_Ret_ by


    ------- :: Empty
    ~> cdot

    mu_sym_or_pattern = mu_pval_aux ~> subs
    </ ret_patterni = spine_elemi // i /> ~> psi
    -------------------------------------------- :: Comp
    comp mu_sym_or_pattern = mu_pval_aux , </ ret_patterni = spine_elemi // i /> ~> subs , psi


    </ ret_patterni = spine_elemi // i /> ~> psi
    -------------------------------------------- :: Log
    log Symbol_sym = mu_pval_aux , </ ret_patterni = spine_elemi // i /> ~> mu_pval_aux / Symbol_sym , psi


    res_pattern = res_term ~> subs
    </ ret_patterni = spine_elemi // i /> ~> psi
    --------------------------------------------- :: Res
    reso res_pattern = res_term , </ ret_patterni = spine_elemi // i /> ~> subs , psi


  defn
    </ xi = spine_elemi // , // i /> :; arg >> subs ; ret :: :: Decons_Arg :: Decons_Arg_ by

    ------------------------------------------ :: Empty
    :; ret >> cdot ; ret


    </ xi = spine_elemi // i /> :; arg >> subs ; ret
    ------------------------------------------------ :: Comp
    x = mu_pval_aux , </ xi = spine_elemi // i /> :; pi x : base_type . arg >> mu_pval_aux / x , subs ; ret


    </ xi = spine_elemi  // i /> :; arg >> subs ; ret
    ------------------------------------------------- :: Log
    x = mu_pval_aux , </ xi = spine_elemi // i /> :;  forall x : base_type . arg >> mu_pval_aux / x , subs ; ret


    </ xi = spine_elemi // i /> :; arg >> subs ; ret
    ------------------------------------------------ :: Res
    x = res_term , </ xi = spine_elemi // i /> :;  res --o arg >> res_term / x , subs ; ret


    </ xi = spine_elemi // i /> :; arg >> subs ; ret
    --------------------------------------------------------------- :: Phi
    </ xi = spine_elemi // i /> :;  term_aux -) arg >> subs ; ret


defns
  pure_opsem_jtype :: 'Op_' ::=

  defn
    <( mu_pexpr_aux )> --> <( mu_pexpr_aux' )> :: :: PE_PE :: PE_PE_ by


    % NOT IMPLEMENTED
    % mu_ctor_expr ( </ mu_pval_auxi // , // i /> )


    ty_mem_ptr' eq ty_mem_ptr +ptr to_int ty_mem_int * size_of ct
    --------------------------------------------------------------------------- :: ArrayShift
    <( array_shift ( ty_mem_ptr , T_ct , ty_mem_int ) )> --> <( ty_mem_ptr' )>


    ty_mem_ptr' eq ty_mem_ptr +ptr offset_of ty_tag Symbol_identifier
    ------------------------------------------------------------------------------------- :: MemberShift
    <( member_shift ( ty_mem_ptr , ty_tag , Symbol_identifier ) )> --> <( ty_mem_ptr' )>


    ------------------------------------ :: Not_True
    <( not ( True ) )> --> <( False )>


    ------------------------------------ :: Not_False
    <( not ( False ) )> --> <( True )>


    inj ty_mem_int eq inj ty_mem_int1 ' arith_binop ' inj ty_mem_int2
    ----------------------------------------------------------------- :: Arith_Binop
    <( ty_mem_int1 arith_binop ty_mem_int2 )> --> <( ty_mem_int )>


    inj mu_bool_value eq inj ty_mem_int1 ' rel_binop ' inj ty_mem_int2
    ------------------------------------------------------------------ :: Rel_Binop
    <( ty_mem_int1 rel_binop ty_mem_int2 )> --> <( mu_bool_value )>


    inj mu_bool_value eq inj mu_bool_value1 ' bool_binop ' inj mu_bool_value2
    --------------------------------------------------------------------------- :: Bool_Binop
    <( mu_bool_value1 bool_binop mu_bool_value2 )> --> <( mu_bool_value )>


    % NOT IMPLEMENTED memberof ( Symbol_sym , Symbol_identifier , mu_pval_aux )


    ------------------------------------------------------------------- :: Assert_Undef
    <( assert_undef ( True , ty_loc UB_name ) )> --> <( Unit )>


    ---------------------------------------------------- :: Bool_To_Integer_True
    <( bool_to_integer ( True ) )> --> <( mem_one )>


    ---------------------------------------------------- :: Bool_To_Integer_False
    <( bool_to_integer ( False ) )> --> <( mem_zero )>


    % DEFER conv_int ( ty_act , mu_pval_aux )


    abbrev1 eq max_int ct - min_int ct + z_one
    abbrev2 eq inj mu_pval_aux rem_f abbrev1
    inj ty_mem_int' eq if abbrev2 =< max_int ct then abbrev2 else abbrev2 - abbrev1
    ------------------------------------------------------------------------------- :: WrapI
    <( wrapI ( ty_act , ty_mem_int ) )> --> <( ty_mem_int' )>

  defn
    <( mu_pexpr_aux )> --> <( mu_tpexpr_aux : ( y : base_type . term_aux ) )> :: :: PE_TPE :: PE_TPE_ by


    mu_name : pure_arg eq </ xi // i /> |-> mu_tpexpr inEnv Globals
    </ xi = mu_pval_auxi // i /> :; pure_arg >> subs ; sigma y : base_type . term /\ I
    -------------------------------------------------------------------------------------- :: Call
    <( mu_name ( </ mu_pval_auxi // i /> ) )> --> <( [ subs ] mu_tpexpr : ( y : base_type . [ subs ] term ) )>


  defn
    <( mu_tpexpr_aux )> --> <( mu_tpexpr_aux' )> :: :: TPE_TPE :: TPE_TPE_ by


    mu_pattern_auxj = mu_pval_aux ~> subsj
    forall i < j . not ( mu_pattern_auxi = mu_pval_aux ~> subsi )
    ------------------------------------------------------------------------------------------------------- :: Case
    <( case mu_pval_aux of </ | mu_pattern_auxi => mu_tpexpri // i /> end )> --> <( [ subsj ]  mu_tpexprj )>


    mu_sym_or_pattern = mu_pval_aux ~> subs
    -------------------------------------------------------------------------------- :: Let_Sub
    <( let mu_sym_or_pattern = mu_pval_aux in mu_tpexpr )> --> <( [ subs ] mu_tpexpr )>


    <( mu_pexpr_aux )> --> <( mu_pexpr_aux' )>
    ------------------------------------------- :: Let_Let
    <( let mu_sym_or_pattern = mu_pexpr_aux in mu_tpexpr_aux )> --> <( let mu_sym_or_pattern = mu_pexpr_aux' in mu_tpexpr_aux )>


    <( mu_pexpr_aux )> --> <( mu_tpexpr_aux1 : ( y : base_type . term ) )>
    ---------------------------------------------------------------------- :: Let_LetT
    <( let mu_sym_or_pattern = mu_pexpr_aux in mu_tpexpr_aux2 )> --> <( let mu_sym_or_pattern : ( y : base_type . term ) = mu_tpexpr_aux1 in mu_tpexpr_aux2 )>


    mu_sym_or_pattern = mu_pval_aux ~> subs
    ------------------------------------------- :: LetT_Sub
    <( let mu_sym_or_pattern : ( y : base_type . term ) = done mu_pval_aux in mu_tpexpr )> --> <( [ subs ] mu_tpexpr )>


    <( mu_tpexpr_aux1 )> --> <( mu_tpexpr_aux1' )>
    ------------------------------------------- :: LetT_LetT
    <( let mu_sym_or_pattern : ( y : base_type . term ) = mu_tpexpr_aux1 in mu_tpexpr_aux2 )> --> <( let mu_sym_or_pattern : ( y : base_type . term ) = mu_tpexpr_aux1' in mu_tpexpr_aux2 )>


    ------------------------------------------------------------------------------- :: If_True
    <( if True then mu_tpexpr_aux1 else mu_tpexpr_aux2 )> --> <( mu_tpexpr_aux1 )>


    -------------------------------------------------------------------------------- :: If_False
    <( if False then mu_tpexpr_aux1 else mu_tpexpr_aux2 )> --> <( mu_tpexpr_aux2 )>


defns
  opsem_jtype :: 'Op_' ::=

  defn
    <( h ; mu_seq_expr_aux )> --> <( h' ; mu_texpr : ret )> :: :: SE_TE :: SE_TE_ by


    Symbol_sym : arg eq </ xi // i /> |-> mu_texpr inEnv Globals
    </ xi = spine_elemi // i /> :; arg >> subs ; ret
    ------------------------------------------------------------- :: CCall
    <( h ; ccall ( ty_act , Symbol_sym , </ spine_elemi // i /> ) )> --> <( h ; [ subs ] mu_texpr : [ subs ] ret )>


    mu_name : arg eq </ xi // i /> |-> mu_texpr inEnv Globals
    </ xi = spine_elemi // i /> :; arg >> subs ; ret
    --------------------------------------------------------- :: PCall
    <( h ; pcall ( mu_name , </ spine_elemi // i /> ) )> --> <( h ; [ subs ] mu_texpr : [ subs ] ret )>


  defn
    <( h ; mu_seq_texpr_aux )> --> <( h' ; mu_texpr )> :: :: STE_TE :: STE_TE_ by


    Symbol_sym : arg eq </ xi // i /> |-> mu_texpr inEnv Globals
    </ xi = mu_pval_auxi // i /> :; arg >> subs ; false /\ I
    ------------------------------------------------------------ :: Run
    <( h ; run Symbol_sym </ mu_pval_auxi // i /> )> --> <( h ; [ subs ] mu_texpr )>


    mu_pattern_auxj = mu_pval_aux ~> subsj
    forall i < j . not ( mu_pattern_auxi = mu_pval_aux ~> subsi )
    ------------------------------------------------------------ :: Case
    <( h ; case mu_pval_aux of </ | mu_pattern_auxi => mu_texpri // i /> end )> --> <( h ; [ subsj ] mu_texprj )>


    mu_sym_or_pattern = mu_pval_aux ~> subs
    --------------------------------------- :: LetP_Sub
    <( h ; let mu_sym_or_pattern = mu_pval_aux in mu_texpr )> --> <( h ; [ subs ] mu_texpr )>


    <( mu_pexpr_aux )> --> <( mu_pexpr_aux' )>
    ------------------------------------------- :: LetP_LetP
    <( h ; let mu_sym_or_pattern = mu_pexpr_aux in mu_texpr )> --> <( h ; let mu_sym_or_pattern = mu_pexpr_aux' in mu_texpr )>


    <( mu_pexpr_aux )> --> <( mu_tpexpr_aux : ( y : base_type . term ) )>
    ---------------------------------------------------------------------- :: LetP_LetTP
    <( h ; let mu_sym_or_pattern = mu_pexpr_aux in mu_texpr )> --> <( h ; let mu_sym_or_pattern : ( y : base_type . term ) = mu_tpexpr_aux in mu_texpr )>


    mu_sym_or_pattern = mu_pval_aux ~> subs
    ------------------------------------------- :: LetTP_Sub
    <( h ; let mu_sym_or_pattern : ( y : base_type . term ) = done mu_pval_aux in mu_texpr )> --> <( h ; [ subs ] mu_texpr )>


    <( mu_tpexpr_aux )> --> <( mu_tpexpr_aux' )>
    ------------------------------------------- :: LetTP_LetTP
    <( h ; let mu_sym_or_pattern : ( y : base_type . term ) = mu_tpexpr_aux in mu_texpr )> --> <( h ; let mu_sym_or_pattern : ( y : base_type . term ) = mu_tpexpr_aux' in mu_texpr )>


    </ ret_patterni = spine_elemi // i /> ~> subs
    --------------------------------------------- :: LetT_Sub
    <( h ; let </ ret_patterni // i /> : ret = done </ spine_elemi // i /> in mu_texpr )> --> <( h ; [ subs ] mu_texpr )>


    <( h ; mu_seq_expr_aux )> --> <( h ; mu_texpr1 : ret )>
    -------------------------------------------------------- :: Let_LetT
    <( h ; let </ ret_patterni // i /> = mu_seq_expr_aux in mu_texpr2 )> --> <( h ; let </ ret_patterni // i /> : ret = mu_texpr1 in mu_texpr2 )>


    <( h ; mu_texpr1 )> --> <( h' ; mu_texpr1' )>
    -------------------------------------------- :: LetT_LetT
    <( h ; let </ ret_patterni // i /> : ret = mu_texpr1 in mu_texpr2 )> --> <( h' ; let </ ret_patterni // i /> : ret = mu_texpr1' in mu_texpr2 )>


    ----------------------------------------------------------------------- :: If_True
    <( h ; if True then mu_texpr1 else mu_texpr2 )> --> <( h ; mu_texpr1 )>


    ------------------------------------------------------------------------ :: If_False
    <( h ; if False then mu_texpr1 else mu_texpr2 )> --> <( h ; mu_texpr2 )>


    ----------------------------------------------------------------------------- :: Bound
    <( h ; bound [ ty_int ] ( mu_is_texpr_aux ) )> --> <( h ; mu_is_texpr_aux )>


  defn
    <( h ; mu_memop  )> --> <( h' ; mu_tval )> :: :: Memop_Tval :: Memop_TVal_ by


    inj mu_bool_value eq inj ty_mem_int1 ' rel_binop ' inj ty_mem_int2
    ---------------------------------------------------------------------------- :: Rel_Binop
    <( h ; ty_mem_int1 rel_binop ty_mem_int2 )> --> <( h ; done mu_bool_value )>


    inj ty_mem_int eq cast_ptr_to_int inj ty_mem_ptr
    ---------------------------------------------------------------------- :: IntFromPtr
    <( h ; intFromPtr ( ct1 , ct2 , ty_mem_ptr ) )> --> <( h ; done ty_mem_int )>


    inj ty_mem_ptr eq cast_ptr_to_int inj ty_mem_int
    ------------------------------------------------------------------------------ :: PtrFromInt
    <( h ; ptrFromInt ( ct1 , ct2 , ty_mem_int ) )> --> <( h ; done ty_mem_ptr )>


    inj mu_bool_value eq aligned ( ct , inj ty_mem_ptr )
    ---------------------------------------------------- :: PtrValidForDeref
    <( h + { inj ty_mem_ptr ( _q )|- tick - ct -> _t } ; ptrValidForDeref ( ct , ty_mem_ptr , inj ty_mem_ptr ( _q )|- tick - ct -> _t ) )> --> <( h + { inj ty_mem_ptr ( _q )|- tick - ct -> _t } ; done mu_bool_value , inj ty_mem_ptr ( _q )|- tick - ct -> _t )>


    inj mu_bool_value eq aligned ( ct , inj ty_mem_ptr )
    ---------------------------------------------------- :: PtrWellAligned
    <( h ; ptrWellAligned ( ct , ty_mem_ptr ) )> --> <( h ; done mu_bool_value )>


    inj ty_mem_ptr' eq inj ty_mem_ptr +ptr ( inj ty_mem_int * size_of ct )
    -------------------------------------------------------------------------------- :: PtrArrayShift
    <( h ; ptrArrayShift ( ty_mem_ptr ,  ct , ty_mem_int ) )> --> <( h ; done ty_mem_ptr' )>


  defn
    <( h ; mu_action_aux  )> --> <( h' ; mu_tval )> :: :: Action_Tval :: Action_Tval_ by


    fresh ( ty_mem_ptr )
    representable ( ct *s , inj ty_mem_ptr )
    alignedI ( inj ty_mem_int , inj ty_mem_ptr )
    mu_pval_aux : to_base ( ct )
    -------------------------------------------- :: Create
    <( h ; create ( ty_mem_int , ct ) Symbol_prefix )> --> <( h + { inj ty_mem_ptr ( q_one )|- * - ct -> inj mu_pval_aux } ; done ty_mem_ptr , mu_pval_aux , inj ty_mem_ptr ( q_one )|- * - ct -> inj mu_pval_aux )>


    --------------------------------------------------------------------------------------------------------------------------------------------------------- :: Load
    <( h + { inj ty_mem_ptr ( q_one )|- tick - ct -> inj mu_pval_aux } ; load ( ct , ty_mem_ptr , _mem_order , inj ty_mem_ptr ( q_one )|- tick - ct -> inj mu_pval_aux ) )> --> <( h + { inj ty_mem_ptr ( q_one )|- tick - ct -> inj mu_pval_aux } ; done mu_pval_aux , inj ty_mem_ptr ( q_one )|- tick - ct -> inj mu_pval_aux )>


    --------------------------------------------------------------------------------------------------------------------------------------------------------- :: Store
    <( h + { inj ty_mem_ptr ( _q )|- tick - ct -> _t } ; store ( _b , ct , ty_mem_ptr , mu_pval_aux , _mem_order , inj ty_mem_ptr ( _q )|- tick - ct -> _t ) )> --> <( h + { inj ty_mem_ptr ( _q )|- tick - ct -> inj mu_pval_aux } ; done Unit , inj ty_mem_ptr ( _q )|- tick - ct -> inj mu_pval_aux )>


    --------------------------------------------------------------------------------------------------------------------------------------------------- :: Kill_Static
    <( h + { inj ty_mem_ptr ( _q )|- _i - ct -> _t } ; kill ( static ct , ty_mem_ptr , inj ty_mem_ptr ( _q )|- _i - ct -> _t ) )> --> <( h ; done Unit )>


  defn
    <( h ; mu_is_expr_aux  )> --> <( h' ; mu_is_expr_aux' )> :: :: IsE_IsE :: IsE_IsE_ by


    <( h ; mu_memop )> --> <( h ; mu_tval )>
    --------------------------------------------------- :: Memop
    <( h ; memop ( mu_memop )  )> --> <( h ; mu_tval )>


    <( h ; mu_action_aux )> --> <( h' ; mu_tval )>
    ------------------------------------------------- :: Action
    <( h ; Pos mu_action_aux )> --> <( h' ; mu_tval )>


    <( h ; mu_action_aux )> --> <( h' ; mu_tval )>
    ---------------------------------------------------- :: Neg_Action
    <( h ; Neg mu_action_aux )> --> <( h' ; mu_tval )>


    % -------------------------------------------------------------------------------------- :: Unseq_Done
    % <( h ; unseq ( </ done spinei : reti // i /> ) )> --> <( h ; done </ spinei // i /> )>


    % <( mu_texprj )> --> <( mu_texprj' )>
    % ------------------------------------ :: Unseq
    % <( h ; unseq ( </ mu_texpri : reti // i /> ) )> --> <( h ; unseq ( </ mu_texpr'i : reti // i /> ) )>


  defn
    <( h ; mu_is_texpr  )> --> <( h' ; mu_texpr )> :: :: IsTE_TE :: IsTE_IsTE_ by

    % let weak   </ ret_patterni // i /> = mu_is_expr_aux in mu_texpr

    </ ret_patterni = spine_elemi // i /> ~> subs
    --------------------------------------------- :: LetS_Sub
    <( h ; let strong </ ret_patterni // i /> = done </ spine_elemi // i /> in mu_texpr )> --> <( h ; [ subs ] mu_texpr )>


    <( h ; mu_is_expr_aux  )> --> <( h' ; mu_is_expr_aux' )>
    ----------------------------------------------------------------- :: LetS_LetS
    <( h ; let strong </ ret_patterni // i /> = mu_is_expr_aux in mu_texpr )> --> <( h' ; let strong </ ret_patterni // i /> = mu_is_expr_aux' in mu_texpr )>


  defn
    <( h ; mu_texpr )> --> <( h' ; mu_texpr' )> :: :: TE_TE :: TE_TE_ by


    <( h ; mu_seq_texpr_aux )> --> <( h ; mu_texpr )>
    ------------------------------------------------- :: Seq
    <( h ; mu_seq_texpr_aux )> --> <( h ; mu_texpr )>


    <( h ; mu_is_texpr_aux )> --> <( h' ; mu_texpr )>
    ------------------------------------------------ :: Is
    <( h ; mu_is_texpr_aux )> --> <( h' ; mu_texpr )>


