% generated by Ott 0.31 from: mucore.ott
\newcommand{\cndrule}[4][]{{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}\quad\cndrulename{#4}}}
\newcommand{\cnusedrule}[1]{\[#1\]}
\newcommand{\cnpremise}[1]{ #1 \\}
\newenvironment{cndefnblock}[3][]{ \framebox{\mbox{#2}} \quad #3 \\[0pt]}{}
\newenvironment{cnfundefnblock}[3][]{ \framebox{\mbox{#2}} \quad #3 \\[0pt]\begin{displaymath}\begin{array}{l}}{\end{array}\end{displaymath}}
\newcommand{\cnfunclause}[2]{ #1 \equiv #2 \\}
\newcommand{\cnnt}[1]{\mathit{#1}}
\newcommand{\cnmv}[1]{\mathit{#1}}
\newcommand{\cnkw}[1]{\mathbf{#1}}
\newcommand{\cnsym}[1]{#1}
\newcommand{\cncom}[1]{\text{#1}}
\newcommand{\cndrulename}[1]{\textsc{#1}}
\newcommand{\cncomplu}[5]{\overline{#1}^{\,#2\in #3 #4 #5}}
\newcommand{\cncompu}[3]{\overline{#1}^{\,#2<#3}}
\newcommand{\cncomp}[2]{\overline{#1}^{\,#2}}
\newcommand{\cngrammartabular}[1]{\begin{supertabular}{llcllllll}#1\end{supertabular}}
\newcommand{\cnmetavartabular}[1]{\begin{supertabular}{ll}#1\end{supertabular}}
\newcommand{\cnrulehead}[3]{$#1$ & & $#2$ & & & \multicolumn{2}{l}{#3}}
\newcommand{\cnprodline}[6]{& & $#1$ & $#2$ & $#3 #4$ & $#5$ & $#6$}
\newcommand{\cnfirstprodline}[6]{\cnprodline{#1}{#2}{#3}{#4}{#5}{#6}}
\newcommand{\cnlongprodline}[2]{& & $#1$ & \multicolumn{4}{l}{$#2$}}
\newcommand{\cnfirstlongprodline}[2]{\cnlongprodline{#1}{#2}}
\newcommand{\cnbindspecprodline}[6]{\cnprodline{#1}{#2}{#3}{#4}{#5}{#6}}
\newcommand{\cnprodnewline}{\\}
\newcommand{\cninterrule}{\\[5.0mm]}
\newcommand{\cnafterlastrule}{\\}
\geometry{landscape}
\renewcommand{\cnkw}[1]{ \texttt{#1} }
\renewcommand{\cndrule}[4][]{ {\displaystyle\frac{\begin{array}{l}#2\end{array} }{#3}\quad\cndrulename{#4} }\\[\baselineskip] }

\newcommand{\cnmetavars}{
\cnmetavartabular{
 $ \cnmv{ident} ,\, \cnmv{x} ,\, \cnmv{y} ,\, { y_p } ,\, { y_f } ,\, \cnmv{\_} ,\, \cnmv{abbrev} ,\, \cnmv{r} ,\, { \alpha } $ & \cncom{subscripts: p for pointers, f for functions} \\
 $ \cnmv{n} ,\, \cnmv{i} ,\, \cnmv{j} $ & \cncom{index variables} \\
 $ \cnmv{impl\_const} $ & \cncom{implementation-defined constant} \\
 $ member $ & \cncom{C struct/union member name} \\
 $  $ & \cncom{Ott-hack, ignore (annotations)} \\
 $ nat $ & \cncom{OCaml arbitrary-width natural number} \\
 $ mem\_ptr $ & \cncom{abstract pointer value} \\
 $ mem\_val $ & \cncom{abstract memory value} \\
 $  $ & \cncom{Ott-hack, ignore (locations)} \\
 $ mem\_iv\_c $ & \cncom{OCaml type for memory constraints on integer values} \\
 $ \cnmv{UB\_name} $ & \cncom{undefined behaviour} \\
 $ string $ & \cncom{OCaml string} \\
 $  $ & \cncom{Ott-hack, ignore (OCaml type variable TY)} \\
 $  $ & \cncom{Ott-hack, ignore (OCaml Symbol.prefix)} \\
 $ mem\_order ,\, \_ $ & \cncom{OCaml type for memory order} \\
 $ linux\_mem\_order $ & \cncom{OCaml type for Linux memory order} \\
 $  $ & \cncom{Ott-hack, ignore (OCaml type variable bt)} \\
}}

\newcommand{\cnSctypesXXt}{
\cnrulehead{\cnnt{Sctypes\_t}  ,\ \tau}{::=}{\cncom{C type}}\cnprodnewline
\cnfirstprodline{|}{\tau  *}{}{}{}{\cncom{pointer to type $\tau$}}}

\newcommand{\cntyXXtag}{
\cnrulehead{tag}{::=}{\cncom{OCaml type for struct/union tag}}\cnprodnewline
\cnfirstprodline{|}{\cnmv{ident}}{}{}{}{}}

\newcommand{\cnbaseXXtype}{
\cnrulehead{\beta  ,\ \_}{::=}{\cncom{base types}}\cnprodnewline
\cnfirstprodline{|}{\cnkw{unit}}{}{}{}{\cncom{unit}}\cnprodnewline
\cnprodline{|}{\cnkw{bool}}{}{}{}{\cncom{boolean}}\cnprodnewline
\cnprodline{|}{\cnkw{integer}}{}{}{}{\cncom{integer}}\cnprodnewline
\cnprodline{|}{\cnkw{real}}{}{}{}{\cncom{rational numbers?}}\cnprodnewline
\cnprodline{|}{\cnkw{loc}}{}{}{}{\cncom{location}}\cnprodnewline
\cnprodline{|}{\cnkw{array} \, \beta}{}{}{}{\cncom{array}}\cnprodnewline
\cnprodline{|}{\cnkw{list} \, \beta}{}{}{}{\cncom{list}}\cnprodnewline
\cnprodline{|}{\cncomp{\beta_{\cnmv{i}}}{\cnmv{i}}}{}{}{}{\cncom{tuple}}\cnprodnewline
\cnprodline{|}{\cnkw{struct} \, tag}{}{}{}{\cncom{struct}}\cnprodnewline
\cnprodline{|}{\cnkw{set} \, \beta}{}{}{}{\cncom{set}}\cnprodnewline
\cnprodline{|}{\cnkw{opt} \, \cnsym{(}  \beta  \cnsym{)}}{}{}{}{\cncom{option}}\cnprodnewline
\cnprodline{|}{\beta  \rightarrow  \beta'}{}{}{}{\cncom{parameter types}}\cnprodnewline
\cnprodline{|}{ \beta_{  \tau  } } {\textsf{M}}{}{}{\cncom{of a C type}}}

\newcommand{\cnbinop}{
\cnrulehead{\mathbin{ binop }}{::=}{\cncom{binary operators}}\cnprodnewline
\cnfirstprodline{|}{ \mathbin{ \texttt{+} } }{}{}{}{\cncom{addition}}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{-} } }{}{}{}{\cncom{subtraction}}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{*} } }{}{}{}{\cncom{multiplication}}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{/} } }{}{}{}{\cncom{division}}\cnprodnewline
\cnprodline{|}{ \mathbin{  \cnkw{rem\_t}  } }{}{}{}{\cncom{modulus}}\cnprodnewline
\cnprodline{|}{ \mathbin{  \cnkw{rem\_f}  } }{}{}{}{\cncom{remainder}}\cnprodnewline
\cnprodline{|}{\mathbin { \texttt{\char`\^} }}{}{}{}{\cncom{exponentiation}}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{=}  } }{}{}{}{\cncom{equality, defined both for integer and C types}}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{!=} } }{}{}{}{\cncom{inequality, similiarly defined}}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{>}  } }{}{}{}{\cncom{greater than, similarly defined}}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{<}  } }{}{}{}{\cncom{less than, similarly defined}}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{>=} } }{}{}{}{\cncom{greater than or equal to, similarly defined}}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{<=} } }{}{}{}{\cncom{less than or equal to, similarly defined}}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{/\char`\\} } }{}{}{}{\cncom{conjucntion}}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{\char`\\/} } }{}{}{}{\cncom{disjunction}}}

\newcommand{\cnarithXXbinop}{
\cnrulehead{\mathbin{ binop_{arith} }}{::=}{\cncom{arithmentic binary operators}}\cnprodnewline
\cnfirstprodline{|}{ \mathbin{ \texttt{+} } }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{-} } }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{*} } }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{/} } }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \mathbin{  \cnkw{rem\_t}  } }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \mathbin{  \cnkw{rem\_f}  } }{}{}{}{}\cnprodnewline
\cnprodline{|}{\mathbin { \texttt{\char`\^} }}{}{}{}{}}

\newcommand{\cnrelXXbinop}{
\cnrulehead{\mathbin{ binop_{rel} }}{::=}{\cncom{relational binary operators}}\cnprodnewline
\cnfirstprodline{|}{ \mathbin{ \texttt{=}  } }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{!=} } }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{>}  } }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{<}  } }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{>=} } }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{<=} } }{}{}{}{}}

\newcommand{\cnboolXXbinop}{
\cnrulehead{\mathbin{ binop_{bool} }}{::=}{\cncom{boolean binary operators}}\cnprodnewline
\cnfirstprodline{|}{ \mathbin{ \texttt{/\char`\\} } }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \mathbin{ \texttt{\char`\\/} } }{}{}{}{}}

\newcommand{\cntyvarXXsym}{
\cnrulehead{ident}{::=}{\cncom{Ott-hack, ignore}}\cnprodnewline
\cnfirstprodline{|}{\cnmv{ident}}{}{}{}{}}

\newcommand{\cntyXXmemXXint}{
\cnrulehead{mem\_int}{::=}{\cncom{memory integer value}}\cnprodnewline
\cnfirstprodline{|}{ 1 } {\textsf{M}}{}{}{}\cnprodnewline
\cnprodline{|}{ 0 } {\textsf{M}}{}{}{}}

\newcommand{\cnTXXct}{
\cnrulehead{\tau}{::=}{\cncom{Ott-hack, ignore}}\cnprodnewline
\cnfirstprodline{|}{\tau}{}{}{}{}}

\newcommand{\cnSymbolXXsym}{
\cnrulehead{ident}{::=}{\cncom{Ott-hack, ignore}}\cnprodnewline
\cnfirstprodline{|}{\cnmv{ident}}{}{}{}{}\cnprodnewline
\cnprodline{|}{tag}{}{}{}{\cncom{hack for struct typing rules}}}

\newcommand{\cnmuXXobjectXXvalue}{
\cnrulehead{object\_value}{::=}{\cncom{C object values (inhabitants of object types), which can be read/stored}}\cnprodnewline
\cnfirstprodline{|}{mem\_int}{}{}{}{\cncom{integer value}}\cnprodnewline
\cnprodline{|}{mem\_ptr}{}{}{}{\cncom{pointer value}}\cnprodnewline
\cnprodline{|}{\cnkw{array} \, \cnsym{(} \, \cncomp{loaded\_value_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}}{}{}{}{\cncom{C array value}}\cnprodnewline
\cnprodline{|}{\cnsym{(} \, \cnkw{struct} \, ident  \cnsym{)}  \cnsym{\{} \, \cncomp{. \, member_{\cnmv{i}}  {:}  \tau_{\cnmv{i}}  =  mem\_val_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{\}}}{}{}{}{\cncom{C struct value}}\cnprodnewline
\cnprodline{|}{\cnsym{(} \, \cnkw{union} \, ident  \cnsym{)}  \cnsym{\{} \, . \, member  =  mem\_val  \cnsym{\}}}{}{}{}{\cncom{C union value}}}

\newcommand{\cnmuXXloadedXXvalue}{
\cnrulehead{loaded\_value}{::=}{\cncom{potentially unspecified C object values}}\cnprodnewline
\cnfirstprodline{|}{\cnkw{specified} \, object\_value}{}{}{}{\cncom{specified loaded value}}}

\newcommand{\cnTXXbt}{
\cnrulehead{\beta}{::=}{\cncom{Ott-hack, ignore}}\cnprodnewline
\cnfirstprodline{|}{\beta}{}{}{}{}}

\newcommand{\cnmuXXvalue}{
\cnrulehead{value}{::=}{\cncom{Core values}}\cnprodnewline
\cnfirstprodline{|}{object\_value}{}{}{}{\cncom{C object value}}\cnprodnewline
\cnprodline{|}{loaded\_value}{}{}{}{\cncom{loaded C object value}}\cnprodnewline
\cnprodline{|}{\cnkw{Unit}}{}{}{}{\cncom{unit}}\cnprodnewline
\cnprodline{|}{\cnkw{True}}{}{}{}{\cncom{boolean true}}\cnprodnewline
\cnprodline{|}{\cnkw{False}}{}{}{}{\cncom{boolean false}}\cnprodnewline
\cnprodline{|}{\beta  \cnsym{[} \, \cncomp{value_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{]}}{}{}{}{\cncom{list}}\cnprodnewline
\cnprodline{|}{\cnsym{(} \, \cncomp{value_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}}{}{}{}{\cncom{tuple}}}

\newcommand{\cnmuXXboolXXvalue}{
\cnrulehead{bool\_value}{::=}{\cncom{Core booleans}}\cnprodnewline
\cnfirstprodline{|}{\cnkw{True}}{}{}{}{\cncom{boolean true}}\cnprodnewline
\cnprodline{|}{\cnkw{False}}{}{}{}{\cncom{boolean false}}}

\newcommand{\cnmuXXctorXXval}{
\cnrulehead{ctor\_val}{::=}{\cncom{data constructors}}\cnprodnewline
\cnfirstprodline{|}{\cnkw{Nil} \, \beta}{}{}{}{\cncom{empty list}}\cnprodnewline
\cnprodline{|}{\cnkw{Cons}}{}{}{}{\cncom{list cons}}\cnprodnewline
\cnprodline{|}{\cnkw{Tuple}}{}{}{}{\cncom{tuple}}\cnprodnewline
\cnprodline{|}{\cnkw{Array}}{}{}{}{\cncom{C array}}\cnprodnewline
\cnprodline{|}{\cnkw{Specified}}{}{}{}{\cncom{non-unspecified loaded value}}}

\newcommand{\cnmuXXctorXXexpr}{
\cnrulehead{ctor\_expr}{::=}{\cncom{data constructors}}\cnprodnewline
\cnfirstprodline{|}{\cnkw{Ivmax}}{}{}{}{\cncom{max integer value}}\cnprodnewline
\cnprodline{|}{\cnkw{Ivmin}}{}{}{}{\cncom{min integer value}}\cnprodnewline
\cnprodline{|}{\cnkw{Ivsizeof}}{}{}{}{\cncom{sizeof value}}\cnprodnewline
\cnprodline{|}{\cnkw{Ivalignof}}{}{}{}{\cncom{alignof value}}\cnprodnewline
\cnprodline{|}{\cnkw{IvCOMPL}}{}{}{}{\cncom{bitwise complement}}\cnprodnewline
\cnprodline{|}{\cnkw{IvAND}}{}{}{}{\cncom{bitwise AND}}\cnprodnewline
\cnprodline{|}{\cnkw{IvOR}}{}{}{}{\cncom{bitwise OR}}\cnprodnewline
\cnprodline{|}{\cnkw{IvXOR}}{}{}{}{\cncom{bitwise XOR}}\cnprodnewline
\cnprodline{|}{\cnkw{Fvfromint}}{}{}{}{\cncom{cast integer to floating value}}\cnprodnewline
\cnprodline{|}{\cnkw{Ivfromfloat}}{}{}{}{\cncom{cast floating to integer value}}}

\newcommand{\cntyXXact}{
\cnrulehead{\tau}{::=}{\cncom{Ott-hack, ignore}}\cnprodnewline
\cnfirstprodline{|}{\tau}{}{}{}{}}

\newcommand{\cnmuXXname}{
\cnrulehead{name}{::=}{}\cnprodnewline
\cnfirstprodline{|}{ident}{}{}{}{\cncom{Core identifier}}\cnprodnewline
\cnprodline{|}{\cnmv{impl\_const}}{}{}{}{\cncom{implementation-defined constant}}}

\newcommand{\cnmuXXpval}{
\cnrulehead{pval}{::=}{\cncom{pure values}}\cnprodnewline
\cnfirstprodline{|}{ident}{}{}{}{\cncom{Core identifier}}\cnprodnewline
\cnprodline{|}{\cnmv{impl\_const}}{}{}{}{\cncom{implementation-defined constant}}\cnprodnewline
\cnprodline{|}{value}{}{}{}{\cncom{Core values}}\cnprodnewline
\cnprodline{|}{\cnkw{constrained} \, \cnsym{(} \, \cncomp{mem\_iv\_c_{\cnmv{i}}  \cnsym{,}  pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}}{}{}{}{\cncom{constrained value}}\cnprodnewline
\cnprodline{|}{\cnkw{error} \, \cnsym{(}  string  \cnsym{,}  pval  \cnsym{)}}{}{}{}{\cncom{impl-defined static error}}\cnprodnewline
\cnprodline{|}{ctor\_val  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}}{}{}{}{\cncom{data constructor application}}\cnprodnewline
\cnprodline{|}{\cnsym{(} \, \cnkw{struct} \, ident  \cnsym{)}  \cnsym{\{} \, \cncomp{. \, member_{\cnmv{i}}  =  pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{\}}}{}{}{}{\cncom{C struct expression}}\cnprodnewline
\cnprodline{|}{\cnsym{(} \, \cnkw{union} \, ident  \cnsym{)}  \cnsym{\{} \, . \, member  =  pval  \cnsym{\}}}{}{}{}{\cncom{C union expression}}}

\newcommand{\cnmuXXpvalXXaux}{
\cnrulehead{pval}{::=}{\cncom{pure values with auxiliary info}}\cnprodnewline
\cnfirstprodline{|}{ \,  \,  \, pval}{}{}{}{}\cnprodnewline
\cnprodline{|}{pval}{}{}{}{\cncom{Ott-hack for simpler typing rules}}\cnprodnewline
\cnprodline{|}{ \sigma  (  pval  ) } {\textsf{M}}{}{}{\cncom{substitution for pure values}}}

\newcommand{\cnmuXXtpval}{
\cnrulehead{tpval}{::=}{\cncom{top-level pure values}}\cnprodnewline
\cnfirstprodline{|}{\cnkw{undef} \,  \, \cnmv{UB\_name}}{}{}{}{\cncom{undefined behaviour}}\cnprodnewline
\cnprodline{|}{\cnkw{done} \, pval}{}{}{}{\cncom{pure done}}}

\newcommand{\cnmuXXtpvalXXaux}{
\cnrulehead{tpval}{::=}{\cncom{top-level pure values with location and annotations}}\cnprodnewline
\cnfirstprodline{|}{ \,  \,  \, tpval}{}{}{}{}\cnprodnewline
\cnprodline{|}{tpval}{}{}{}{\cncom{Ott-hack for simpler typing rules}}}

\newcommand{\cntyXXsymXXoptXXTXXbt}{
\cnrulehead{ident\_opt\_\beta}{::=}{\cncom{type annotated optional identifier}}\cnprodnewline
\cnfirstprodline{|}{\cnmv{\_}  {:}  \beta}{}{\textrm{binders}=\{\}}{}{}\cnprodnewline
\cnprodline{|}{ident  {:}  \beta}{}{\textrm{binders}=ident}{}{}}

\newcommand{\cnmuXXpattern}{
\cnrulehead{pattern}{::=}{}\cnprodnewline
\cnfirstprodline{|}{ident\_opt\_\beta}{}{\textrm{binders}=\textrm{binders}(ident\_opt\_\beta)}{}{}\cnprodnewline
\cnprodline{|}{ctor\_val  \cnsym{(} \, \cncomp{pattern_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}}{}{\textrm{binders}=\textrm{binders}(\cncomp{pattern_{\cnmv{i}}}{\cnmv{i}})}{}{}}

\newcommand{\cnmuXXpatternXXaux}{
\cnrulehead{pattern}{::=}{}\cnprodnewline
\cnfirstprodline{|}{ \,  \, pattern}{}{\textrm{binders}=\textrm{binders}(pattern)}{}{}\cnprodnewline
\cnprodline{|}{pattern}{}{\textrm{binders}=\textrm{binders}(pattern)}{}{\cncom{Ott-hack for simpler typing rules}}}

\newcommand{\cnZXXt}{
\cnrulehead{z}{::=}{\cncom{OCaml arbitrary-width integer}}\cnprodnewline
\cnfirstprodline{|}{ 1 } {\textsf{M}}{}{}{}\cnprodnewline
\cnprodline{|}{ 0 } {\textsf{M}}{}{}{}\cnprodnewline
\cnprodline{|}{\cnmv{i}} {\textsf{M}}{}{}{\cncom{literal integer}}\cnprodnewline
\cnprodline{|}{ mem\_int } {\textsf{M}}{}{}{}\cnprodnewline
\cnprodline{|}{ \mathrm{size\_of}(  \tau  ) } {\textsf{M}}{}{}{\cncom{size of a C type}}\cnprodnewline
\cnprodline{|}{ \mathrm{offset\_of}_{  tag  }(  member  ) } {\textsf{M}}{}{}{\cncom{offset of a struct member}}\cnprodnewline
\cnprodline{|}{\cnkw{ptr\_size}} {\textsf{M}}{}{}{\cncom{size of a pointer}}\cnprodnewline
\cnprodline{|}{ \mathrm{max\_int}_{  \tau  } } {\textsf{M}}{}{}{\cncom{maximum value of int of type $\tau$}}\cnprodnewline
\cnprodline{|}{ \mathrm{min\_int}_{  \tau  } } {\textsf{M}}{}{}{\cncom{minimum value of int of type $\tau$}}}

\newcommand{\cnrational}{
\cnrulehead{\mathbb{Q}  ,\ \cnnt{q}  ,\ \_}{::=}{\cncom{OCaml type for rational numbers}}\cnprodnewline
\cnfirstprodline{|}{ 1 }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \frac{ int_{{\mathrm{1}}} }{ int_{{\mathrm{2}}} } }{}{}{}{}}

\newcommand{\cnlit}{
\cnrulehead{\cnnt{lit}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{ident}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{unit}}{}{}{}{}\cnprodnewline
\cnprodline{|}{bool}{}{}{}{}\cnprodnewline
\cnprodline{|}{z}{}{}{}{}\cnprodnewline
\cnprodline{|}{\mathbb{Q}}{}{}{}{}}

\newcommand{\cnmuXXsymXXorXXpattern}{
\cnrulehead{ident\_or\_pattern}{::=}{}\cnprodnewline
\cnfirstprodline{|}{ident}{}{\textrm{binders}=ident}{}{}\cnprodnewline
\cnprodline{|}{pattern}{}{\textrm{binders}=\textrm{binders}(pattern)}{}{}}

\newcommand{\cnboolXXop}{
\cnrulehead{\cnnt{bool\_op}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\neg \, term}{}{}{}{}\cnprodnewline
\cnprodline{|}{term_{{\mathrm{1}}}  =  term_{{\mathrm{2}}}}{}{}{}{}\cnprodnewline
\cnprodline{|}{term_{{\mathrm{1}}}  \rightarrow  term_{{\mathrm{2}}}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\bigwedge  \cnsym{(} \, \cncomp{term_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\bigvee  \cnsym{(} \, \cncomp{term_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{term_{{\mathrm{1}}}  \wedge  term_{{\mathrm{2}}}} {\textsf{M}}{}{}{}\cnprodnewline
\cnprodline{|}{term_{{\mathrm{1}}}  \vee  term_{{\mathrm{2}}}} {\textsf{M}}{}{}{}\cnprodnewline
\cnprodline{|}{ term_{{\mathrm{1}}}   \mathbin{ binop_{bool} }   term_{{\mathrm{2}}} } {\textsf{M}}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{if} \, term_{{\mathrm{1}}} \, \cnkw{then} \, term_{{\mathrm{2}}} \, \cnkw{else} \, term_{{\mathrm{3}}}}{}{}{}{}}

\newcommand{\cnarithXXop}{
\cnrulehead{\cnnt{arith\_op}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{term_{{\mathrm{1}}}  \cnsym{+}  term_{{\mathrm{2}}}}{}{}{}{}\cnprodnewline
\cnprodline{|}{term_{{\mathrm{1}}}  \cnsym{-}  term_{{\mathrm{2}}}}{}{}{}{}\cnprodnewline
\cnprodline{|}{term_{{\mathrm{1}}}  \times  term_{{\mathrm{2}}}}{}{}{}{}\cnprodnewline
\cnprodline{|}{term_{{\mathrm{1}}}  \cnsym{/}  term_{{\mathrm{2}}}}{}{}{}{}\cnprodnewline
\cnprodline{|}{term_{{\mathrm{1}}} \, \cnkw{rem\_t} \, term_{{\mathrm{2}}}}{}{}{}{}\cnprodnewline
\cnprodline{|}{term_{{\mathrm{1}}} \, \cnkw{rem\_f} \, term_{{\mathrm{2}}}}{}{}{}{}\cnprodnewline
\cnprodline{|}{term_{{\mathrm{1}}}  \mathbin { \texttt{\char`\^} }  term_{{\mathrm{2}}}}{}{}{}{}\cnprodnewline
\cnprodline{|}{ term_{{\mathrm{1}}}   \mathbin{ binop_{arith} }   term_{{\mathrm{2}}} } {\textsf{M}}{}{}{}}

\newcommand{\cncmpXXop}{
\cnrulehead{\cnnt{cmp\_op}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{term_{{\mathrm{1}}}  \cnsym{<}  term_{{\mathrm{2}}}}{}{}{}{\cncom{less than}}\cnprodnewline
\cnprodline{|}{term_{{\mathrm{1}}}  \leq  term_{{\mathrm{2}}}}{}{}{}{\cncom{less than or equal}}\cnprodnewline
\cnprodline{|}{ term_{{\mathrm{1}}}   \mathbin{ binop_{rel} }   term_{{\mathrm{2}}} } {\textsf{M}}{}{}{}}

\newcommand{\cnlistXXop}{
\cnrulehead{\cnnt{list\_op}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\cnkw{nil}}{}{}{}{}\cnprodnewline
\cnprodline{|}{ term_{{\mathrm{1}}}  ::  term_{{\mathrm{2}}} }{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{tl} \, term}{}{}{}{}\cnprodnewline
\cnprodline{|}{ term ^{( int )} }{}{}{}{}}

\newcommand{\cntupleXXop}{
\cnrulehead{\cnnt{tuple\_op}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\cnsym{(} \, \cncomp{term_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{ term ^{( int )} }{}{}{}{}}

\newcommand{\cnpointerXXop}{
\cnrulehead{\cnnt{pointer\_op}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{mem\_ptr}{}{}{}{}\cnprodnewline
\cnprodline{|}{term_{{\mathrm{1}}}  \mathbin{ {+}_{ \mathrm{ptr} } }  term_{{\mathrm{2}}}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{cast\_int\_to\_ptr} \, term}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{cast\_ptr\_to\_int} \, term}{}{}{}{}}

\newcommand{\cnBTXXt}{
\cnrulehead{\beta}{::=}{\cncom{Ott-hack, ignore}}\cnprodnewline
\cnfirstprodline{|}{\beta}{}{}{}{}}

\newcommand{\cnarrayXXop}{
\cnrulehead{\cnnt{array\_op}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\cnsym{[}  \mid \, \cncomp{term_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{\mbox{$\mid$}]}}{}{}{}{}\cnprodnewline
\cnprodline{|}{term_{{\mathrm{1}}}  \cnsym{[}  term_{{\mathrm{2}}}  \cnsym{]}}{}{}{}{}}

\newcommand{\cnparamXXop}{
\cnrulehead{\cnnt{param\_op}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{ident  {:}  \beta  . \:  term}{}{}{}{}\cnprodnewline
\cnprodline{|}{term  \cnsym{(}  term_{{\mathrm{1}}}  \cnsym{,} \, .. \, \cnsym{,}  term_{\cnmv{n}}  \cnsym{)}}{}{}{}{}}

\newcommand{\cnstructXXop}{
\cnrulehead{\cnnt{struct\_op}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{ term   .   member }{}{}{}{}}

\newcommand{\cnctXXpred}{
\cnrulehead{\cnnt{ct\_pred}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\cnkw{representable} \, \cnsym{(}  \tau  \cnsym{,}  term  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{aligned} \, \cnsym{(}  \tau  \cnsym{,}  term  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{alignedI} \, \cnsym{(}  term_{{\mathrm{1}}}  \cnsym{,}  term_{{\mathrm{2}}}  \cnsym{)}}{}{}{}{}}

\newcommand{\cnterm}{
\cnrulehead{\cnnt{term}  ,\ \_}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\cnnt{lit}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{arith\_op}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{bool\_op}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{cmp\_op}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{tuple\_op}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{struct\_op}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{pointer\_op}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{list\_op}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{array\_op}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{ct\_pred}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{param\_op}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnsym{(}  \cnnt{term}  \cnsym{)}} {\textsf{S}}{}{}{\cncom{parentheses}}\cnprodnewline
\cnprodline{|}{ \sigma  (  \cnnt{term}  ) } {\textsf{M}}{}{}{\cncom{simul-sub $\sigma$ in $\cnnt{term}$}}\cnprodnewline
\cnprodline{|}{ pval } {\textsf{M}}{}{}{}}

\newcommand{\cntermXXaux}{
\cnrulehead{term}{::=}{\cncom{terms with auxiliary info}}\cnprodnewline
\cnfirstprodline{|}{\cnnt{term} \, }{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{term}}{}{}{}{\cncom{Ott-hack for simpler typing rules}}}

\newcommand{\cnmuXXpexpr}{
\cnrulehead{pexpr}{::=}{\cncom{pure expressions}}\cnprodnewline
\cnfirstprodline{|}{pval}{}{}{}{\cncom{pure values}}\cnprodnewline
\cnprodline{|}{ctor\_expr  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}}{}{}{}{\cncom{data constructor application}}\cnprodnewline
\cnprodline{|}{\cnkw{array\_shift} \, \cnsym{(}  pval_{{\mathrm{1}}}  \cnsym{,}  \tau  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{)}}{}{}{}{\cncom{pointer array shift}}\cnprodnewline
\cnprodline{|}{\cnkw{member\_shift} \, \cnsym{(}  pval  \cnsym{,}  ident  \cnsym{,}  member  \cnsym{)}}{}{}{}{\cncom{pointer struct/union member shift}}\cnprodnewline
\cnprodline{|}{\cnkw{not} \, \cnsym{(}  pval  \cnsym{)}}{}{}{}{\cncom{boolean not}}\cnprodnewline
\cnprodline{|}{pval_{{\mathrm{1}}} \, \mathbin{ binop } \, pval_{{\mathrm{2}}}}{}{}{}{\cncom{binary operations}}\cnprodnewline
\cnprodline{|}{\cnkw{memberof} \, \cnsym{(}  ident  \cnsym{,}  member  \cnsym{,}  pval  \cnsym{)}}{}{}{}{\cncom{C struct/union member access}}\cnprodnewline
\cnprodline{|}{name  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}}{}{}{}{\cncom{pure function call}}\cnprodnewline
\cnprodline{|}{\cnkw{assert\_undef} \, \cnsym{(}  pval  \cnsym{,}   \, \cnmv{UB\_name}  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{bool\_to\_integer} \, \cnsym{(}  pval  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{conv\_int} \, \cnsym{(}  \tau  \cnsym{,}  pval  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{wrapI} \, \cnsym{(}  \tau  \cnsym{,}  pval  \cnsym{)}}{}{}{}{}}

\newcommand{\cnmuXXpexprXXaux}{
\cnrulehead{pexpr}{::=}{\cncom{pure expressions with location and annotations}}\cnprodnewline
\cnfirstprodline{|}{ \,  \,  \, pexpr}{}{}{}{}\cnprodnewline
\cnprodline{|}{pexpr}{}{}{}{\cncom{Ott-hack for simpler typing rules}}\cnprodnewline
\cnprodline{|}{ \sigma  (  pexpr  ) } {\textsf{M}}{}{}{\cncom{substitution for pure expressions}}}

\newcommand{\cnmuXXtpexpr}{
\cnrulehead{tpexpr}{::=}{\cncom{top-level pure expressions}}\cnprodnewline
\cnfirstprodline{|}{tpval}{}{}{}{\cncom{top-level pure values}}\cnprodnewline
\cnprodline{|}{\cnkw{case} \, pval \, \cnkw{of} \, \cncomp{\mid  tpexpr\_case\_branch_{\cnmv{i}}}{\cnmv{i}} \, \cnkw{end}}{}{}{}{\cncom{pattern matching}}\cnprodnewline
\cnprodline{|}{\cnkw{let} \, ident\_or\_pattern  =  pexpr \, \cnkw{in} \, tpexpr}{}{\textsf{bind}\; \textrm{binders}(ident\_or\_pattern)\; \textsf{in}\; tpexpr}{}{\cncom{pure let}}\cnprodnewline
\cnprodline{|}{\cnkw{let} \, ident\_or\_pattern  {:}  \cnsym{(}  \cnmv{y_{{\mathrm{1}}}}  {:}  \beta_{{\mathrm{1}}}  . \:  \cnnt{term_{{\mathrm{1}}}}  \cnsym{)}  =  tpexpr_{{\mathrm{1}}} \, \cnkw{in} \, tpexpr_{{\mathrm{2}}}}{}{\textsf{bind}\; \textrm{binders}(ident\_or\_pattern)\; \textsf{in}\; tpexpr_{{\mathrm{2}}}}{}{\cncom{annoted pure let}}\cnprodnewline
\cnbindspecprodline{}{}{}{\textsf{bind}\; \cnmv{y_{{\mathrm{1}}}}\; \textsf{in}\; \cnnt{term_{{\mathrm{1}}}}}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{if} \, pval \, \cnkw{then} \, tpexpr_{{\mathrm{1}}} \, \cnkw{else} \, tpexpr_{{\mathrm{2}}}}{}{}{}{\cncom{pure if}}\cnprodnewline
\cnprodline{|}{ \sigma  (  tpexpr  ) } {\textsf{M}}{}{}{\cncom{simul-sub $\sigma$ in $tpexpr$}}}

\newcommand{\cnmuXXtpexprXXcaseXXbranch}{
\cnrulehead{tpexpr\_case\_branch}{::=}{\cncom{pure top-level case expression branch}}\cnprodnewline
\cnfirstprodline{|}{pattern  \Rightarrow  tpexpr}{}{\textsf{bind}\; \textrm{binders}(pattern)\; \textsf{in}\; tpexpr}{}{\cncom{top-level case expression branch}}}

\newcommand{\cnmuXXtpexprXXaux}{
\cnrulehead{tpexpr}{::=}{\cncom{pure top-level pure expressions with auxiliary info}}\cnprodnewline
\cnfirstprodline{|}{ \,  \,  \, tpexpr}{}{}{}{}\cnprodnewline
\cnprodline{|}{tpexpr}{}{}{}{\cncom{Ott-hack for simpler typing rules}}}

\newcommand{\cnmXXkillXXkind}{
\cnrulehead{\cnnt{m\_kill\_kind}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\cnkw{dynamic}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{static} \, \tau}{}{}{}{}}

\newcommand{\cntyXXbool}{
\cnrulehead{bool  ,\ \_}{::=}{\cncom{OCaml booleans}}\cnprodnewline
\cnfirstprodline{|}{\cnkw{true}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{false}}{}{}{}{}}

\newcommand{\cntyXXint}{
\cnrulehead{int  ,\ \_}{::=}{\cncom{OCaml fixed-width integer}}\cnprodnewline
\cnfirstprodline{|}{\cnmv{i}}{}{}{}{\cncom{literal integer}}\cnprodnewline
\cnprodline{|}{ 1 }{}{}{}{}}

\newcommand{\cnresXXterm}{
\cnrulehead{\cnnt{res\_term}}{::=}{\cncom{resource terms}}\cnprodnewline
\cnfirstprodline{|}{\cnkw{emp}}{}{}{}{\cncom{empty heap}}\cnprodnewline
\cnprodline{|}{\cnnt{points\_to}}{}{}{}{\cncom{single-cell heap}}\cnprodnewline
\cnprodline{|}{ident}{}{}{}{\cncom{variable}}\cnprodnewline
\cnprodline{|}{\langle  \cnnt{res\_term_{{\mathrm{1}}}}  \cnsym{,}  \cnnt{res\_term_{{\mathrm{2}}}}  \rangle}{}{}{}{\cncom{seperating-conjunction pair}}\cnprodnewline
\cnprodline{|}{\cnkw{pack} \, \cnsym{(}  pval  \cnsym{,}  \cnnt{res\_term}  \cnsym{)}}{}{}{}{\cncom{packing for existentials}}\cnprodnewline
\cnprodline{|}{\cnkw{fold} \, \cnsym{(}  \cnnt{res\_term}  \cnsym{)}}{}{}{}{\cncom{fold into recursive res. pred.}}\cnprodnewline
\cnprodline{|}{ \sigma  (  \cnnt{res\_term}  ) } {\textsf{M}}{}{}{\cncom{substitution for resource terms}}}

\newcommand{\cnmuXXaction}{
\cnrulehead{mem\_action}{::=}{\cncom{memory actions}}\cnprodnewline
\cnfirstprodline{|}{\cnkw{create} \, \cnsym{(}  pval  \cnsym{,}  \tau  \cnsym{)}  }{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{create\_readonly} \, \cnsym{(}  pval_{{\mathrm{1}}}  \cnsym{,}  \tau  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{)}  }{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{alloc} \, \cnsym{(}  pval_{{\mathrm{1}}}  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{)}  }{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{kill} \, \cnsym{(}  \cnnt{m\_kill\_kind}  \cnsym{,}  pval  \cnsym{,}  \cnnt{pt}  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{store} \, \cnsym{(}  bool  \cnsym{,}  \tau  \cnsym{,}  pval_{{\mathrm{1}}}  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{,}  mem\_order  \cnsym{,}  \cnnt{pt}  \cnsym{)}}{}{}{}{\cncom{true means store is locking}}\cnprodnewline
\cnprodline{|}{\cnkw{load} \, \cnsym{(}  \tau  \cnsym{,}  pval  \cnsym{,}  mem\_order  \cnsym{,}  \cnnt{pt}  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{rmw} \, \cnsym{(}  \tau  \cnsym{,}  pval_{{\mathrm{1}}}  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{,}  pval_{{\mathrm{3}}}  \cnsym{,}  mem\_order_{{\mathrm{1}}}  \cnsym{,}  mem\_order_{{\mathrm{2}}}  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{fence} \, \cnsym{(}  mem\_order  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{cmp\_exch\_strong} \, \cnsym{(}  \tau  \cnsym{,}  pval_{{\mathrm{1}}}  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{,}  pval_{{\mathrm{3}}}  \cnsym{,}  mem\_order_{{\mathrm{1}}}  \cnsym{,}  mem\_order_{{\mathrm{2}}}  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{cmp\_exch\_weak} \, \cnsym{(}  \tau  \cnsym{,}  pval_{{\mathrm{1}}}  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{,}  pval_{{\mathrm{3}}}  \cnsym{,}  mem\_order_{{\mathrm{1}}}  \cnsym{,}  mem\_order_{{\mathrm{2}}}  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{linux\_fence} \, \cnsym{(}  linux\_mem\_order  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{linux\_load} \, \cnsym{(}  \tau  \cnsym{,}  pval  \cnsym{,}  linux\_mem\_order  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{linux\_store} \, \cnsym{(}  \tau  \cnsym{,}  pval_{{\mathrm{1}}}  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{,}  linux\_mem\_order  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{linux\_rmw} \, \cnsym{(}  \tau  \cnsym{,}  pval_{{\mathrm{1}}}  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{,}  linux\_mem\_order  \cnsym{)}}{}{}{}{}}

\newcommand{\cnmuXXactionXXaux}{
\cnrulehead{mem\_action}{::=}{\cncom{memory actions with auxiliary info}}\cnprodnewline
\cnfirstprodline{|}{ \, mem\_action}{}{}{}{}\cnprodnewline
\cnprodline{|}{mem\_action}{}{}{}{\cncom{Ott-hack for simpler typing rules}}}

\newcommand{\cnpolarity}{
\cnrulehead{\cnnt{polarity}}{::=}{\cncom{polarities for memory actions}}\cnprodnewline
\cnfirstprodline{|}{  }{}{}{}{\cncom{(pos) sequenced by \ottkw{let\ weak} and \ottkw{let\ strong}}}\cnprodnewline
\cnprodline{|}{ \texttt{neg} }{}{}{}{\cncom{only sequenced by \ottkw{let\ strong}}}}

\newcommand{\cnmuXXpaction}{
\cnrulehead{pol\_mem\_action}{::=}{\cncom{memory actions with polarity}}\cnprodnewline
\cnfirstprodline{|}{\cnnt{polarity} \, mem\_action}{}{}{}{}}

\newcommand{\cnmuXXmemop}{
\cnrulehead{mem\_op}{::=}{\cncom{operations involving the memory state}}\cnprodnewline
\cnfirstprodline{|}{pval_{{\mathrm{1}}} \, \mathbin{ binop_{rel} } \, pval_{{\mathrm{2}}}}{}{}{}{\cncom{pointer relational binary operations}}\cnprodnewline
\cnprodline{|}{ pval_{{\mathrm{1}}}  -_{  \tau  }  pval_{{\mathrm{2}}} }{}{}{}{\cncom{pointer subtraction}}\cnprodnewline
\cnprodline{|}{\cnkw{intFromPtr} \, \cnsym{(}  \tau_{{\mathrm{1}}}  \cnsym{,}  \tau_{{\mathrm{2}}}  \cnsym{,}  pval  \cnsym{)}}{}{}{}{\cncom{cast of pointer value to integer value}}\cnprodnewline
\cnprodline{|}{\cnkw{ptrFromInt} \, \cnsym{(}  \tau_{{\mathrm{1}}}  \cnsym{,}  \tau_{{\mathrm{2}}}  \cnsym{,}  pval  \cnsym{)}}{}{}{}{\cncom{cast of integer value to pointer value}}\cnprodnewline
\cnprodline{|}{\cnkw{ptrValidForDeref} \, \cnsym{(}  \tau  \cnsym{,}  pval  \cnsym{,}  \cnnt{pt}  \cnsym{)}}{}{}{}{\cncom{dereferencing validity predicate}}\cnprodnewline
\cnprodline{|}{\cnkw{ptrWellAligned} \, \cnsym{(}  \tau  \cnsym{,}  pval  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{ptrArrayShift} \, \cnsym{(}  pval_{{\mathrm{1}}}  \cnsym{,}  \tau  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{memcpy} \, \cnsym{(}  pval_{{\mathrm{1}}}  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{,}  pval_{{\mathrm{3}}}  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{memcmp} \, \cnsym{(}  pval_{{\mathrm{1}}}  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{,}  pval_{{\mathrm{3}}}  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{realloc} \, \cnsym{(}  pval_{{\mathrm{1}}}  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{,}  pval_{{\mathrm{3}}}  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{va\_start} \, \cnsym{(}  pval_{{\mathrm{1}}}  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{va\_copy} \, \cnsym{(}  pval  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{va\_arg} \, \cnsym{(}  pval  \cnsym{,}  \tau  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{va\_end} \, \cnsym{(}  pval  \cnsym{)}}{}{}{}{}}

\newcommand{\cnspineXXelem}{
\cnrulehead{\cnnt{spine\_elem}}{::=}{\cncom{spine element}}\cnprodnewline
\cnfirstprodline{|}{pval}{}{}{}{\cncom{pure or logical value}}\cnprodnewline
\cnprodline{|}{\cnnt{res\_term}}{}{}{}{\cncom{resource value}}\cnprodnewline
\cnprodline{|}{ \sigma  (  \cnnt{spine\_elem}  ) } {\textsf{M}}{}{}{\cncom{substitution for spine elements / return values}}}

\newcommand{\cnspine}{
\cnrulehead{\cnnt{spine}}{::=}{\cncom{spine}}\cnprodnewline
\cnfirstprodline{|}{\cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}}}{}{}{}{}}

\newcommand{\cnmuXXtval}{
\cnrulehead{tval}{::=}{\cncom{(effectful) top-level values}}\cnprodnewline
\cnfirstprodline{|}{\cnkw{done} \, \cnnt{spine}}{}{}{}{\cncom{end of top-level expression}}\cnprodnewline
\cnprodline{|}{\cnkw{undef} \,  \, \cnmv{UB\_name}}{}{}{}{\cncom{undefined behaviour}}}

\newcommand{\cnmuXXtvalXXaux}{
\cnrulehead{tval}{::=}{\cncom{(effectful) top-level values with auxiliary info}}\cnprodnewline
\cnfirstprodline{|}{ \,  \, tval}{}{}{}{}\cnprodnewline
\cnprodline{|}{tval}{}{}{}{\cncom{Ott-hack for simpler typing rules}}\cnprodnewline
\cnprodline{|}{ \sigma  (  tval  ) } {\textsf{M}}{}{}{\cncom{substitution for top-level values}}}

\newcommand{\cnresXXpattern}{
\cnrulehead{\cnnt{res\_pattern}}{::=}{\cncom{resource terms}}\cnprodnewline
\cnfirstprodline{|}{\cnkw{emp}}{}{\textrm{binders}=\{\}}{}{\cncom{empty heap}}\cnprodnewline
\cnprodline{|}{ident}{}{\textrm{binders}=ident}{}{\cncom{variable}}\cnprodnewline
\cnprodline{|}{\cnkw{fold} \, \cnsym{(}  \cnnt{res\_pattern}  \cnsym{)}}{}{\textrm{binders}=\{\}}{}{\cncom{unfold (recursive) predicate}}\cnprodnewline
\cnprodline{|}{\langle  \cnnt{res\_pattern_{{\mathrm{1}}}}  \cnsym{,}  \cnnt{res\_pattern_{{\mathrm{2}}}}  \rangle}{}{\textrm{binders}=\textrm{binders}(\cnnt{res\_pattern_{{\mathrm{1}}}}) \cup  \textrm{binders}(\cnnt{res\_pattern_{{\mathrm{2}}}})}{}{\cncom{seperating-conjunction pair}}\cnprodnewline
\cnprodline{|}{\cnkw{pack} \, \cnsym{(}  ident  \cnsym{,}  \cnnt{res\_pattern}  \cnsym{)}}{}{\textrm{binders}=ident \cup  \textrm{binders}(\cnnt{res\_pattern})}{}{\cncom{packing for existentials}}}

\newcommand{\cnretXXpattern}{
\cnrulehead{\cnnt{ret\_pattern}}{::=}{\cncom{return pattern}}\cnprodnewline
\cnfirstprodline{|}{\cnkw{comp} \, ident\_or\_pattern}{}{\textrm{binders}=\textrm{binders}(ident\_or\_pattern)}{}{\cncom{computational variable}}\cnprodnewline
\cnprodline{|}{\cnkw{log} \, ident}{}{\textrm{binders}=ident}{}{\cncom{logical variable}}\cnprodnewline
\cnprodline{|}{\texttt{res} \, \cnnt{res\_pattern}}{}{\textrm{binders}=\textrm{binders}(\cnnt{res\_pattern})}{}{\cncom{resource variable}}}

\newcommand{\cninitXXt}{
\cnrulehead{init  ,\ }{::=}{\cncom{initialisation status}}\cnprodnewline
\cnfirstprodline{|}{\checkmark}{}{}{}{\cncom{initialised}}\cnprodnewline
\cnprodline{|}{ {  \times  } }{}{}{}{\cncom{uninitalised}}}

\newcommand{\cnpointsXXto}{
\cnrulehead{\cnnt{points\_to}  ,\ \cnnt{pt}}{::=}{\cncom{points-to separation logic predicate}}\cnprodnewline
\cnfirstprodline{|}{ term_{{\mathrm{1}}}  \mathbin{ { \overset{  init  }{ \mapsto } }_{  \tau  } }  term_{{\mathrm{2}}} }{}{}{}{}}

\newcommand{\cnres}{
\cnrulehead{\cnnt{res}}{::=}{\cncom{resources}}\cnprodnewline
\cnfirstprodline{|}{\cnkw{emp}}{}{}{}{\cncom{empty heap}}\cnprodnewline
\cnprodline{|}{\cnnt{points\_to}}{}{}{}{\cncom{points-top heap pred.}}\cnprodnewline
\cnprodline{|}{\cnnt{res_{{\mathrm{1}}}}  *  \cnnt{res_{{\mathrm{2}}}}}{}{}{}{\cncom{seperating conjunction}}\cnprodnewline
\cnprodline{|}{\exists \, ident  {:}  \beta  . \:  \cnnt{res}}{}{}{}{\cncom{existential}}\cnprodnewline
\cnprodline{|}{term  \wedge  \cnnt{res}}{}{}{}{\cncom{logical conjuction}}\cnprodnewline
\cnprodline{|}{\cnkw{if} \, term \, \cnkw{then} \, \cnnt{res_{{\mathrm{1}}}} \, \cnkw{else} \, \cnnt{res_{{\mathrm{2}}}}}{}{}{}{\cncom{ordered disjuction}}\cnprodnewline
\cnprodline{|}{{ \alpha }  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}}{}{}{}{\cncom{predicate}}\cnprodnewline
\cnprodline{|}{ \cnnt{res} } {\textsf{S}}{}{}{\cncom{parentheses}}\cnprodnewline
\cnprodline{|}{ \sigma  (  \cnnt{res}  ) } {\textsf{M}}{}{}{\cncom{simul-sub $\sigma$ in $\cnnt{res}$}}}

\newcommand{\cnret}{
\cnrulehead{\cnnt{ret}  ,\ \_}{::=}{\cncom{return types}}\cnprodnewline
\cnfirstprodline{|}{\Sigma \, ident  {:}  \beta  . \:  \cnnt{ret}}{}{}{}{\cncom{return a computational value}}\cnprodnewline
\cnprodline{|}{\exists \, ident  {:}  \beta  . \:  \cnnt{ret}}{}{}{}{\cncom{return a logical value}}\cnprodnewline
\cnprodline{|}{\cnnt{res}  \otimes  \cnnt{ret}}{}{}{}{\cncom{return a resource value}}\cnprodnewline
\cnprodline{|}{term  \wedge  \cnnt{ret}}{}{}{}{\cncom{return a predicate (post-condition)}}\cnprodnewline
\cnprodline{|}{\cnkw{I}}{}{}{}{\cncom{end return list}}\cnprodnewline
\cnprodline{|}{ \sigma  (  \cnnt{ret}  ) } {\textsf{M}}{}{}{\cncom{simul-sub $\sigma$ in $\cnnt{ret}$}}}

\newcommand{\cnmuXXseqXXexpr}{
\cnrulehead{seq\_expr}{::=}{\cncom{sequential (effectful) expressions}}\cnprodnewline
\cnfirstprodline{|}{\cnkw{ccall} \, \cnsym{(}  \tau  \cnsym{,}  ident  \cnsym{,}  \cnnt{spine}  \cnsym{)}}{}{}{}{\cncom{C function call}}\cnprodnewline
\cnprodline{|}{\cnkw{pcall} \, \cnsym{(}  name  \cnsym{,}  \cnnt{spine}  \cnsym{)}}{}{}{}{\cncom{procedure call}}}

\newcommand{\cnmuXXseqXXexprXXaux}{
\cnrulehead{seq\_expr}{::=}{\cncom{sequential (effectful) expressions with auxiliary info}}\cnprodnewline
\cnfirstprodline{|}{ \,  \, seq\_expr}{}{}{}{}\cnprodnewline
\cnprodline{|}{seq\_expr}{}{}{}{\cncom{Ott-hack for simpler typing rules}}\cnprodnewline
\cnprodline{|}{ \sigma  (  seq\_expr  ) } {\textsf{M}}{}{}{}}

\newcommand{\cnmuXXseqXXtexpr}{
\cnrulehead{seq\_texpr}{::=}{\cncom{sequential top-level (effectful) expressions}}\cnprodnewline
\cnfirstprodline{|}{tval}{}{}{}{\cncom{(effectful) top-level values}}\cnprodnewline
\cnprodline{|}{\cnkw{run} \, ident \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}}}{}{}{}{\cncom{run from label}}\cnprodnewline
\cnprodline{|}{\cnkw{let} \, ident\_or\_pattern  =  pexpr \, \cnkw{in} \, texpr}{}{\textsf{bind}\; \textrm{binders}(ident\_or\_pattern)\; \textsf{in}\; texpr}{}{\cncom{pure let}}\cnprodnewline
\cnprodline{|}{\cnkw{let} \, ident\_or\_pattern  {:}  \cnsym{(}  \cnmv{y_{{\mathrm{1}}}}  {:}  \beta_{{\mathrm{1}}}  . \:  \cnnt{term_{{\mathrm{1}}}}  \cnsym{)}  =  tpexpr \, \cnkw{in} \, texpr}{}{\textsf{bind}\; \textrm{binders}(ident\_or\_pattern)\; \textsf{in}\; texpr}{}{\cncom{annotated pure let}}\cnprodnewline
\cnbindspecprodline{}{}{}{\textsf{bind}\; \cnmv{y_{{\mathrm{1}}}}\; \textsf{in}\; \cnnt{term_{{\mathrm{1}}}}}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, =  seq\_expr \, \cnkw{in} \, texpr}{}{\textsf{bind}\; \textrm{binders}(\cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}})\; \textsf{in}\; texpr}{}{\cncom{bind return patterns}}\cnprodnewline
\cnprodline{|}{\cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret}  =  texpr_{{\mathrm{1}}} \, \cnkw{in} \, texpr_{{\mathrm{2}}}}{}{\textsf{bind}\; \textrm{binders}(\cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}})\; \textsf{in}\; texpr_{{\mathrm{2}}}}{}{\cncom{annotated bind return patterns}}\cnprodnewline
\cnprodline{|}{\cnkw{case} \, pval \, \cnkw{of} \, \cncomp{\mid  texpr\_case\_branch_{\cnmv{i}}}{\cnmv{i}} \, \cnkw{end}}{}{}{}{\cncom{pattern matching}}\cnprodnewline
\cnprodline{|}{\cnkw{if} \, pval \, \cnkw{then} \, texpr_{{\mathrm{1}}} \, \cnkw{else} \, texpr_{{\mathrm{2}}}}{}{}{}{\cncom{conditional}}\cnprodnewline
\cnprodline{|}{\cnkw{bound} \, \cnsym{[}  int  \cnsym{]}  \cnsym{(}  is\_texpr  \cnsym{)}}{}{}{}{\cncom{limit scope of indet seq behaviour, absent at runtime}}}

\newcommand{\cnmuXXtexprXXcaseXXbranch}{
\cnrulehead{texpr\_case\_branch}{::=}{\cncom{top-level case expression branch}}\cnprodnewline
\cnfirstprodline{|}{pattern  \Rightarrow  texpr}{}{\textsf{bind}\; \textrm{binders}(pattern)\; \textsf{in}\; texpr}{}{\cncom{top-level case expression branch}}}

\newcommand{\cnmuXXseqXXtexprXXaux}{
\cnrulehead{seq\_texpr}{::=}{\cncom{sequential top-level (effectful) expressions with auxiliary info}}\cnprodnewline
\cnfirstprodline{|}{ \,  \, seq\_texpr}{}{}{}{}\cnprodnewline
\cnprodline{|}{seq\_texpr}{}{}{}{\cncom{Ott-hack for simpler typing rules}}}

\newcommand{\cnmuXXisXXexpr}{
\cnrulehead{is\_expr}{::=}{\cncom{indet seq (effectful) expressions}}\cnprodnewline
\cnfirstprodline{|}{tval}{}{}{}{\cncom{(effectful) top-level values}}\cnprodnewline
\cnprodline{|}{\cnkw{memop} \, \cnsym{(}  mem\_op  \cnsym{)}}{}{}{}{\cncom{pointer op involving memory}}\cnprodnewline
\cnprodline{|}{pol\_mem\_action}{}{}{}{\cncom{memory action}}}

\newcommand{\cnmuXXisXXexprXXaux}{
\cnrulehead{is\_expr}{::=}{\cncom{indet seq (effectful) expressions with auxiliary info}}\cnprodnewline
\cnfirstprodline{|}{ \,  \, is\_expr}{}{}{}{}\cnprodnewline
\cnprodline{|}{is\_expr}{}{}{}{\cncom{Ott-hack for simpler typing rules}}}

\newcommand{\cnmuXXisXXtexpr}{
\cnrulehead{is\_texpr}{::=}{\cncom{indet seq top-level (effectful) expressions}}\cnprodnewline
\cnfirstprodline{|}{\cnkw{let} \, \cnkw{weak} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, =  is\_expr \, \cnkw{in} \, texpr}{}{\textsf{bind}\; \textrm{binders}(\cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}})\; \textsf{in}\; texpr}{}{\cncom{weak sequencing}}\cnprodnewline
\cnprodline{|}{\cnkw{let} \, \cnkw{strong} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, =  is\_expr \, \cnkw{in} \, texpr}{}{\textsf{bind}\; \textrm{binders}(\cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}})\; \textsf{in}\; texpr}{}{\cncom{strong sequencing}}}

\newcommand{\cnmuXXisXXtexprXXaux}{
\cnrulehead{is\_texpr}{::=}{\cncom{indet seq top-level (effectful) expressions with auxiliary info}}\cnprodnewline
\cnfirstprodline{|}{ \,  \, is\_texpr}{}{}{}{}\cnprodnewline
\cnprodline{|}{is\_texpr}{}{}{}{\cncom{Ott-hack for simpler typing rules}}}

\newcommand{\cnmuXXtexpr}{
\cnrulehead{texpr}{::=}{\cncom{top-level (effectful) expressions}}\cnprodnewline
\cnfirstprodline{|}{seq\_texpr}{}{}{}{\cncom{sequential (effectful) expressions}}\cnprodnewline
\cnprodline{|}{is\_texpr}{}{}{}{\cncom{indet seq (effectful) expressions}}\cnprodnewline
\cnprodline{|}{ \sigma  (  texpr  ) } {\textsf{M}}{}{}{\cncom{simul-sub $\sigma$ in $texpr$}}}

\newcommand{\cnterminals}{
\cnrulehead{\cnnt{terminals}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{ \lambda }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \longrightarrow }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \rightarrow }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \leadsto }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \Rightarrow }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \Leftarrow }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \vdash }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \in }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \Pi }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \forall }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \multimap }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \mathrel{-\mkern-6mu*} }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \supset }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \Sigma }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \exists }{}{}{}{}\cnprodnewline
\cnprodline{|}{ * }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \otimes }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \times }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \wedge }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \bigwedge }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \neg }{}{}{}{}\cnprodnewline
\cnprodline{|}{ = }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \neq }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \leq }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \geq }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \ \& }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \cdot }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \mid }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \mathbin{ {+}_{ \mathrm{ptr} } } }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \mapsto }{}{}{}{}\cnprodnewline
\cnprodline{|}{ :: }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \checkmark }{}{}{}{}\cnprodnewline
\cnprodline{|}{ {:} }{}{}{}{}\cnprodnewline
\cnprodline{|}{ . \: }{}{}{}{}\cnprodnewline
\cnprodline{|}{ . }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \gg }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \mathbin{ {:} {:} } }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \mathbin { \texttt{\char`\^} } }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \vee }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \bigvee }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \equiv }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \langle }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \rangle }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \texttt{res} }{}{}{}{}\cnprodnewline
\cnprodline{|}{ \sqsubseteq }{}{}{}{}}

\newcommand{\cnarg}{
\cnrulehead{\cnnt{arg}}{::=}{\cncom{argument/function types}}\cnprodnewline
\cnfirstprodline{|}{\Pi \, ident  {:}  \beta  . \:  \cnnt{arg}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\forall \, ident  {:}  \beta  . \:  \cnnt{arg}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{res}  \multimap  \cnnt{arg}}{}{}{}{}\cnprodnewline
\cnprodline{|}{term  \supset  \cnnt{arg}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{ret}}{}{}{}{}\cnprodnewline
\cnprodline{|}{ \cnnt{arg} } {\textsf{S}}{}{}{}\cnprodnewline
\cnprodline{|}{ \sigma  (  \cnnt{arg}  ) } {\textsf{M}}{}{}{\cncom{simul-sub $\sigma$ in $\cnnt{arg}$}}}

\newcommand{\cnpureXXarg}{
\cnrulehead{\cnnt{pure\_arg}}{::=}{\cncom{pure argument/function types}}\cnprodnewline
\cnfirstprodline{|}{\Pi \, ident  {:}  \beta  . \:  \cnnt{pure\_arg}}{}{}{}{}\cnprodnewline
\cnprodline{|}{term  \supset  \cnnt{pure\_arg}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{pure\_ret}}{}{}{}{}}

\newcommand{\cnpureXXret}{
\cnrulehead{\cnnt{pure\_ret}}{::=}{\cncom{pure return types}}\cnprodnewline
\cnfirstprodline{|}{\Sigma \, ident  {:}  \beta  . \:  \cnnt{pure\_ret}}{}{}{}{}\cnprodnewline
\cnprodline{|}{term  \wedge  \cnnt{pure\_ret}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{I}}{}{}{}{}}

\newcommand{\cnC}{
\cnrulehead{\mathcal{C}}{::=}{\cncom{computational var env}}\cnprodnewline
\cnfirstprodline{|}{\cdot}{}{}{}{}\cnprodnewline
\cnprodline{|}{\mathcal{C}  \cnsym{,}  ident  {:}  \beta}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cncomp{\mathcal{C}_{\cnmv{i}}}{\cnmv{i}}}{}{}{}{}}

\newcommand{\cnL}{
\cnrulehead{\mathcal{L}}{::=}{\cncom{logical var env}}\cnprodnewline
\cnfirstprodline{|}{\cdot}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cncomp{\mathcal{L}_{\cnmv{i}}}{\cnmv{i}}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\mathcal{L}  \cnsym{,}  ident  {:}  \beta}{}{}{}{}}

\newcommand{\cnN}{
\cnrulehead{\Phi}{::=}{\cncom{constraints env}}\cnprodnewline
\cnfirstprodline{|}{\cdot}{}{}{}{}\cnprodnewline
\cnprodline{|}{\Phi  \cnsym{,}  term}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cncomp{\Phi_{\cnmv{i}}}{\cnmv{i}}}{}{}{}{}}

\newcommand{\cnR}{
\cnrulehead{\mathcal{R}}{::=}{\cncom{resources env}}\cnprodnewline
\cnfirstprodline{|}{\cdot}{}{}{}{}\cnprodnewline
\cnprodline{|}{\mathcal{R}  \cnsym{,}  ident  {:}  \cnnt{res}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cncomp{\mathcal{R}_{\cnmv{i}}}{\cnmv{i}}}{}{}{}{}}

\newcommand{\cnsubs}{
\cnrulehead{\sigma  ,\ \psi}{::=}{\cncom{substitutions}}\cnprodnewline
\cnfirstprodline{|}{\cdot}{}{}{}{}\cnprodnewline
\cnprodline{|}{ \mathrm{id} } {\textsf{M}}{}{}{\cncom{identity substitution}}\cnprodnewline
\cnprodline{|}{\cnnt{spine\_elem}  \cnsym{/}  ident  \cnsym{,}  \sigma}{}{}{}{}\cnprodnewline
\cnprodline{|}{term  \cnsym{/}  ident  \cnsym{,}  \sigma}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cncomp{\sigma_{\cnmv{i}}}{\cnmv{i}}}{}{}{}{}\cnprodnewline
\cnprodline{|}{ \sigma } {\textsf{S}}{}{}{\cncom{parentheses}}\cnprodnewline
\cnprodline{|}{ \sigma  (  \psi  ) } {\textsf{M}}{}{}{\cncom{apply $\sigma$ to all elements in $\psi$}}}

\newcommand{\cntyping}{
\cnrulehead{\cnnt{typing}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  term  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{ident  {:}  \beta \, \in \, \mathcal{C}}{}{}{}{}\cnprodnewline
\cnprodline{|}{ident  {:}  \beta \, \in \, \mathcal{L}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{struct} \, tag  \ \& \, \cncomp{member_{\cnmv{i}}  {:}  \tau_{\cnmv{i}}}{\cnmv{i}} \, \in \, \cnkw{Globals}}{}{}{}{}\cnprodnewline
\cnprodline{|}{{ \alpha } \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}  {:}  \beta_{\cnmv{i}}}{\cnmv{i}} \, \mapsto  \cnnt{res} \, \in \, \cnkw{Globals}}{}{}{}{\cncom{recursive resource predicate}}\cnprodnewline
\cnprodline{|}{\cncomp{\mathcal{C}_{\cnmv{i}}  \cnsym{;}  \mathcal{L}_{\cnmv{i}}  \cnsym{;}  \Phi_{\cnmv{i}}  \vdash  mem\_val_{\cnmv{i}}  \Rightarrow \, \cnkw{mem} \, \beta_{\cnmv{i}}}{\cnmv{i}}}{}{}{}{\cncom{dependent on memory object model}}\cnprodnewline
\cnprodline{|}{\cncomp{\mathcal{C}_{\cnmv{i}}  \cnsym{;}  \mathcal{L}_{\cnmv{i}}  \cnsym{;}  \Phi_{\cnmv{i}}  \vdash  pval_{\cnmv{i}}  \Rightarrow  \beta_{\cnmv{i}}}{\cnmv{i}}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cncomp{pattern_{\cnmv{i}}  {:}  \beta_{\cnmv{i}}  \leadsto  \mathcal{C}_{\cnmv{i}} \, \cnkw{with} \, term_{\cnmv{i}}}{\cnmv{i}}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cncomp{\mathcal{C}_{\cnmv{i}}  \cnsym{;}  \mathcal{L}_{\cnmv{i}}  \cnsym{;}  \Phi_{\cnmv{i}}  \vdash  tpexpr_{\cnmv{i}}  \Leftarrow  \cnmv{y_{\cnmv{i}}}  {:}  \beta_{\cnmv{i}}  . \:  \cnnt{term_{\cnmv{i}}}}{\cnmv{i}}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cncomp{\mathcal{C}_{\cnmv{i}}  \cnsym{;}  \mathcal{L}_{\cnmv{i}}  \cnsym{;}  \Phi_{\cnmv{i}}  \cnsym{;}  \mathcal{R}_{\cnmv{i}}  \vdash  texpr_{\cnmv{i}}  \Leftarrow  \cnnt{ret_{\cnmv{i}}}}{\cnmv{i}}}{}{}{}{}}

\newcommand{\cnopsem}{
\cnrulehead{\cnnt{opsem}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\cncomp{pattern_{\cnmv{i}}  =  pval_{\cnmv{i}}  \leadsto  \sigma_{\cnmv{i}}}{\cnmv{i}}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\forall \, \cnmv{i}  \cnsym{<}  \cnmv{j}  . \: \, \cnkw{not} \, \cnsym{(}  pattern_{\cnmv{i}}  =  pval  \leadsto  \sigma_{\cnmv{i}}  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnkw{fresh} \, \cnsym{(}  mem\_ptr  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{term}{}{}{}{}\cnprodnewline
\cnprodline{|}{pval  {:}  \beta}{}{}{}{}}

\newcommand{\cnformula}{
\cnrulehead{\cnnt{formula}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\cnnt{judgement}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{typing}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{opsem}}{}{}{}{}\cnprodnewline
\cnprodline{|}{term \, \equiv \, term'}{}{}{}{}\cnprodnewline
\cnprodline{|}{name  {:}  \cnnt{pure\_arg} \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mapsto  tpexpr \, \in \, \cnkw{Globals}}{}{}{}{}\cnprodnewline
\cnprodline{|}{name  {:}  \cnnt{arg} \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mapsto  texpr \, \in \, \cnkw{Globals}}{}{}{}{}}

\newcommand{\cnheap}{
\cnrulehead{\cnnt{heap}  ,\ \cnnt{h}  ,\ \cnnt{f}}{::=}{\cncom{heaps}}\cnprodnewline
\cnfirstprodline{|}{\cdot}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{h}  \cnsym{+}  \cnsym{\{}  \cnnt{points\_to}  \cnsym{\}}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{h}  \cnsym{+}  \cnnt{f}}{}{}{}{\cncom{convenient for the soundness proof}}}

\newcommand{\cnlemmaXXjtype}{
\cnrulehead{\cnnt{lemma\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \leadsto  \mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \mid  \cnnt{ret}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \sqsubseteq  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}{}{}{}{}\cnprodnewline
\cnprodline{|}{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \cnsym{)}}{}{}{}{}}

\newcommand{\cnresXXjtype}{
\cnrulehead{\cnnt{res\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\Phi  \vdash  \cnnt{res} \, \equiv \, \cnnt{res'}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnnt{res\_term}  \Leftarrow  \cnnt{res}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{h}  {:}  \mathcal{R}}{}{}{}{}}

\newcommand{\cnobjectXXvalueXXjtype}{
\cnrulehead{\cnnt{object\_value\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  object\_value  \Rightarrow \, \cnkw{obj} \, \beta}{}{}{}{}}

\newcommand{\cnpvalXXjtype}{
\cnrulehead{\cnnt{pval\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \beta}{}{}{}{}}

\newcommand{\cnspineXXjtype}{
\cnrulehead{\cnnt{spine\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}}{}{}{}{}}

\newcommand{\cnpexprXXjtype}{
\cnrulehead{\cnnt{pexpr\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pexpr  \Rightarrow  \cnmv{ident}  {:}  \beta  . \:  term}{}{}{}{}}

\newcommand{\cncompXXpatternXXjtype}{
\cnrulehead{\cnnt{comp\_pattern\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{pattern  {:}  \beta  \leadsto  \mathcal{C} \, \cnkw{with} \, term}{}{}{}{}\cnprodnewline
\cnprodline{|}{ident\_or\_pattern  {:}  \beta  \leadsto  \mathcal{C} \, \cnkw{with} \, term}{}{}{}{}}

\newcommand{\cnresXXpatternXXjtype}{
\cnrulehead{\cnnt{res\_pattern\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\Phi  \vdash  \cnnt{res'}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  \cnnt{res}  \cnsym{)}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\Phi  \vdash  \cnnt{res} \, \cnkw{as} \, \cnnt{res\_pattern}  \leadsto  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}{}{}{}{}\cnprodnewline
\cnprodline{|}{\Phi  \vdash  \cnnt{res\_pattern}  {:}  \cnnt{res}  \leadsto  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}{}{}{}{}}

\newcommand{\cnretXXpatternXXjtype}{
\cnrulehead{\cnnt{ret\_pattern\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\Phi  \vdash \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret}  \leadsto  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}{}{}{}{}}

\newcommand{\cntpvalXXjtype}{
\cnrulehead{\cnnt{tpval\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  tpval  \Leftarrow  \cnmv{ident}  {:}  \beta  . \:  term}{}{}{}{}}

\newcommand{\cntpexprXXjtype}{
\cnrulehead{\cnnt{tpexpr\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  tpexpr  \Leftarrow  \cnmv{ident}  {:}  \beta  . \:  term}{}{}{}{}}

\newcommand{\cnactionXXjtype}{
\cnrulehead{\cnnt{action\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  mem\_action  \Rightarrow  \cnnt{ret}}{}{}{}{}}

\newcommand{\cnmemopXXjtype}{
\cnrulehead{\cnnt{memop\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  mem\_op  \Rightarrow  \cnnt{ret}}{}{}{}{}}

\newcommand{\cntvalXXjtype}{
\cnrulehead{\cnnt{tval\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  tval  \Leftarrow  \cnnt{ret}}{}{}{}{}}

\newcommand{\cnseqXXexprXXjtype}{
\cnrulehead{\cnnt{seq\_expr\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  seq\_expr  \Rightarrow  \cnnt{ret}}{}{}{}{}}

\newcommand{\cnisXXexprXXjtype}{
\cnrulehead{\cnnt{is\_expr\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  is\_expr  \Rightarrow  \cnnt{ret}}{}{}{}{}}

\newcommand{\cntexprXXjtype}{
\cnrulehead{\cnnt{texpr\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  seq\_texpr  \Leftarrow  \cnnt{ret}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  is\_texpr  \Leftarrow  \cnnt{ret}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  texpr  \Leftarrow  \cnnt{ret}}{}{}{}{}}

\newcommand{\cnsubsXXjtype}{
\cnrulehead{\cnnt{subs\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{pattern  =  pval  \leadsto  \sigma}{}{}{}{}\cnprodnewline
\cnprodline{|}{ident\_or\_pattern  =  pval  \leadsto  \sigma}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{res\_pattern}  =  \cnnt{res\_term}  \leadsto  \sigma}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \leadsto  \sigma}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}}{}{}{}{}}

\newcommand{\cnpureXXopsemXXjtype}{
\cnrulehead{\cnnt{pure\_opsem\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\langle  pexpr  \rangle  \longrightarrow  \langle  pexpr'  \rangle}{}{}{}{}\cnprodnewline
\cnprodline{|}{\langle  pexpr  \rangle  \longrightarrow  \langle  tpexpr  {:}  \cnsym{(}  \cnmv{y}  {:}  \beta  . \:  term  \cnsym{)}  \rangle}{}{}{}{}\cnprodnewline
\cnprodline{|}{\langle  tpexpr  \rangle  \longrightarrow  \langle  tpexpr'  \rangle}{}{}{}{}}

\newcommand{\cnopsemXXjtype}{
\cnrulehead{\cnnt{opsem\_jtype}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\langle  \cnnt{h}  \cnsym{;}  seq\_expr  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  texpr  {:}  \cnnt{ret}  \rangle}{}{}{}{}\cnprodnewline
\cnprodline{|}{\langle  \cnnt{h}  \cnsym{;}  seq\_texpr  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  texpr  \rangle}{}{}{}{}\cnprodnewline
\cnprodline{|}{\langle  \cnnt{h}  \cnsym{;}  mem\_op  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  tval  \rangle}{}{}{}{}\cnprodnewline
\cnprodline{|}{\langle  \cnnt{h}  \cnsym{;}  mem\_action  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  tval  \rangle}{}{}{}{}\cnprodnewline
\cnprodline{|}{\langle  \cnnt{h}  \cnsym{;}  is\_expr  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  is\_expr'  \rangle}{}{}{}{}\cnprodnewline
\cnprodline{|}{\langle  \cnnt{h}  \cnsym{;}  is\_texpr  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  texpr  \rangle}{}{}{}{}\cnprodnewline
\cnprodline{|}{\langle  \cnnt{h}  \cnsym{;}  texpr  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  texpr'  \rangle}{}{}{}{}}

\newcommand{\cnjudgement}{
\cnrulehead{\cnnt{judgement}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\cnnt{lemma\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{res\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{object\_value\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{pval\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{spine\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{pexpr\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{comp\_pattern\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{res\_pattern\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{ret\_pattern\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{tpval\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{tpexpr\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{action\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{memop\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{tval\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{seq\_expr\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{is\_expr\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{texpr\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{subs\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{pure\_opsem\_jtype}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{opsem\_jtype}}{}{}{}{}}

\newcommand{\cnuserXXsyntax}{
\cnrulehead{\cnnt{user\_syntax}}{::=}{}\cnprodnewline
\cnfirstprodline{|}{\cnmv{ident}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnmv{n}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnmv{impl\_const}}{}{}{}{}\cnprodnewline
\cnprodline{|}{member}{}{}{}{}\cnprodnewline
\cnprodline{|}{}{}{}{}{}\cnprodnewline
\cnprodline{|}{nat}{}{}{}{}\cnprodnewline
\cnprodline{|}{mem\_ptr}{}{}{}{}\cnprodnewline
\cnprodline{|}{mem\_val}{}{}{}{}\cnprodnewline
\cnprodline{|}{}{}{}{}{}\cnprodnewline
\cnprodline{|}{mem\_iv\_c}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnmv{UB\_name}}{}{}{}{}\cnprodnewline
\cnprodline{|}{string}{}{}{}{}\cnprodnewline
\cnprodline{|}{}{}{}{}{}\cnprodnewline
\cnprodline{|}{}{}{}{}{}\cnprodnewline
\cnprodline{|}{mem\_order}{}{}{}{}\cnprodnewline
\cnprodline{|}{linux\_mem\_order}{}{}{}{}\cnprodnewline
\cnprodline{|}{}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{Sctypes\_t}}{}{}{}{}\cnprodnewline
\cnprodline{|}{tag}{}{}{}{}\cnprodnewline
\cnprodline{|}{\beta}{}{}{}{}\cnprodnewline
\cnprodline{|}{\mathbin{ binop }}{}{}{}{}\cnprodnewline
\cnprodline{|}{\mathbin{ binop_{arith} }}{}{}{}{}\cnprodnewline
\cnprodline{|}{\mathbin{ binop_{rel} }}{}{}{}{}\cnprodnewline
\cnprodline{|}{\mathbin{ binop_{bool} }}{}{}{}{}\cnprodnewline
\cnprodline{|}{ident}{}{}{}{}\cnprodnewline
\cnprodline{|}{mem\_int}{}{}{}{}\cnprodnewline
\cnprodline{|}{\tau}{}{}{}{}\cnprodnewline
\cnprodline{|}{ident}{}{}{}{}\cnprodnewline
\cnprodline{|}{object\_value}{}{}{}{}\cnprodnewline
\cnprodline{|}{loaded\_value}{}{}{}{}\cnprodnewline
\cnprodline{|}{\beta}{}{}{}{}\cnprodnewline
\cnprodline{|}{value}{}{}{}{}\cnprodnewline
\cnprodline{|}{bool\_value}{}{}{}{}\cnprodnewline
\cnprodline{|}{ctor\_val}{}{}{}{}\cnprodnewline
\cnprodline{|}{ctor\_expr}{}{}{}{}\cnprodnewline
\cnprodline{|}{\tau}{}{}{}{}\cnprodnewline
\cnprodline{|}{name}{}{}{}{}\cnprodnewline
\cnprodline{|}{pval}{}{}{}{}\cnprodnewline
\cnprodline{|}{pval}{}{}{}{}\cnprodnewline
\cnprodline{|}{tpval}{}{}{}{}\cnprodnewline
\cnprodline{|}{tpval}{}{}{}{}\cnprodnewline
\cnprodline{|}{ident\_opt\_\beta}{}{}{}{}\cnprodnewline
\cnprodline{|}{pattern}{}{}{}{}\cnprodnewline
\cnprodline{|}{pattern}{}{}{}{}\cnprodnewline
\cnprodline{|}{z}{}{}{}{}\cnprodnewline
\cnprodline{|}{\mathbb{Q}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{lit}}{}{}{}{}\cnprodnewline
\cnprodline{|}{ident\_or\_pattern}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{bool\_op}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{arith\_op}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{cmp\_op}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{list\_op}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{tuple\_op}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{pointer\_op}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\beta}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{array\_op}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{param\_op}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{struct\_op}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{ct\_pred}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{term}}{}{}{}{}\cnprodnewline
\cnprodline{|}{term}{}{}{}{}\cnprodnewline
\cnprodline{|}{pexpr}{}{}{}{}\cnprodnewline
\cnprodline{|}{pexpr}{}{}{}{}\cnprodnewline
\cnprodline{|}{tpexpr}{}{}{}{}\cnprodnewline
\cnprodline{|}{tpexpr\_case\_branch}{}{}{}{}\cnprodnewline
\cnprodline{|}{tpexpr}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{m\_kill\_kind}}{}{}{}{}\cnprodnewline
\cnprodline{|}{bool}{}{}{}{}\cnprodnewline
\cnprodline{|}{int}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{res\_term}}{}{}{}{}\cnprodnewline
\cnprodline{|}{mem\_action}{}{}{}{}\cnprodnewline
\cnprodline{|}{mem\_action}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{polarity}}{}{}{}{}\cnprodnewline
\cnprodline{|}{pol\_mem\_action}{}{}{}{}\cnprodnewline
\cnprodline{|}{mem\_op}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{spine\_elem}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{spine}}{}{}{}{}\cnprodnewline
\cnprodline{|}{tval}{}{}{}{}\cnprodnewline
\cnprodline{|}{tval}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{res\_pattern}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{ret\_pattern}}{}{}{}{}\cnprodnewline
\cnprodline{|}{init}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{points\_to}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{res}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{ret}}{}{}{}{}\cnprodnewline
\cnprodline{|}{seq\_expr}{}{}{}{}\cnprodnewline
\cnprodline{|}{seq\_expr}{}{}{}{}\cnprodnewline
\cnprodline{|}{seq\_texpr}{}{}{}{}\cnprodnewline
\cnprodline{|}{texpr\_case\_branch}{}{}{}{}\cnprodnewline
\cnprodline{|}{seq\_texpr}{}{}{}{}\cnprodnewline
\cnprodline{|}{is\_expr}{}{}{}{}\cnprodnewline
\cnprodline{|}{is\_expr}{}{}{}{}\cnprodnewline
\cnprodline{|}{is\_texpr}{}{}{}{}\cnprodnewline
\cnprodline{|}{is\_texpr}{}{}{}{}\cnprodnewline
\cnprodline{|}{texpr}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{terminals}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{arg}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{pure\_arg}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{pure\_ret}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\mathcal{C}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\mathcal{L}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\Phi}{}{}{}{}\cnprodnewline
\cnprodline{|}{\mathcal{R}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\sigma}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{typing}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{opsem}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{formula}}{}{}{}{}\cnprodnewline
\cnprodline{|}{\cnnt{heap}}{}{}{}{}}

\newcommand{\cngrammar}{\cngrammartabular{
\cnSctypesXXt\cninterrule
\cntyXXtag\cninterrule
\cnbaseXXtype\cninterrule
\cnbinop\cninterrule
\cnarithXXbinop\cninterrule
\cnrelXXbinop\cninterrule
\cnboolXXbinop\cninterrule
\cntyvarXXsym\cninterrule
\cntyXXmemXXint\cninterrule
\cnTXXct\cninterrule
\cnSymbolXXsym\cninterrule
\cnmuXXobjectXXvalue\cninterrule
\cnmuXXloadedXXvalue\cninterrule
\cnTXXbt\cninterrule
\cnmuXXvalue\cninterrule
\cnmuXXboolXXvalue\cninterrule
\cnmuXXctorXXval\cninterrule
\cnmuXXctorXXexpr\cninterrule
\cntyXXact\cninterrule
\cnmuXXname\cninterrule
\cnmuXXpval\cninterrule
\cnmuXXpvalXXaux\cninterrule
\cnmuXXtpval\cninterrule
\cnmuXXtpvalXXaux\cninterrule
\cntyXXsymXXoptXXTXXbt\cninterrule
\cnmuXXpattern\cninterrule
\cnmuXXpatternXXaux\cninterrule
\cnZXXt\cninterrule
\cnrational\cninterrule
\cnlit\cninterrule
\cnmuXXsymXXorXXpattern\cninterrule
\cnboolXXop\cninterrule
\cnarithXXop\cninterrule
\cncmpXXop\cninterrule
\cnlistXXop\cninterrule
\cntupleXXop\cninterrule
\cnpointerXXop\cninterrule
\cnBTXXt\cninterrule
\cnarrayXXop\cninterrule
\cnparamXXop\cninterrule
\cnstructXXop\cninterrule
\cnctXXpred\cninterrule
\cnterm\cninterrule
\cntermXXaux\cninterrule
\cnmuXXpexpr\cninterrule
\cnmuXXpexprXXaux\cninterrule
\cnmuXXtpexpr\cninterrule
\cnmuXXtpexprXXcaseXXbranch\cninterrule
\cnmuXXtpexprXXaux\cninterrule
\cnmXXkillXXkind\cninterrule
\cntyXXbool\cninterrule
\cntyXXint\cninterrule
\cnresXXterm\cninterrule
\cnmuXXaction\cninterrule
\cnmuXXactionXXaux\cninterrule
\cnpolarity\cninterrule
\cnmuXXpaction\cninterrule
\cnmuXXmemop\cninterrule
\cnspineXXelem\cninterrule
\cnspine\cninterrule
\cnmuXXtval\cninterrule
\cnmuXXtvalXXaux\cninterrule
\cnresXXpattern\cninterrule
\cnretXXpattern\cninterrule
\cninitXXt\cninterrule
\cnpointsXXto\cninterrule
\cnres\cninterrule
\cnret\cninterrule
\cnmuXXseqXXexpr\cninterrule
\cnmuXXseqXXexprXXaux\cninterrule
\cnmuXXseqXXtexpr\cninterrule
\cnmuXXtexprXXcaseXXbranch\cninterrule
\cnmuXXseqXXtexprXXaux\cninterrule
\cnmuXXisXXexpr\cninterrule
\cnmuXXisXXexprXXaux\cninterrule
\cnmuXXisXXtexpr\cninterrule
\cnmuXXisXXtexprXXaux\cninterrule
\cnmuXXtexpr\cninterrule
\cnterminals\cninterrule
\cnarg\cninterrule
\cnpureXXarg\cninterrule
\cnpureXXret\cninterrule
\cnC\cninterrule
\cnL\cninterrule
\cnN\cninterrule
\cnR\cninterrule
\cnsubs\cninterrule
\cntyping\cninterrule
\cnopsem\cninterrule
\cnformula\cninterrule
\cnheap\cninterrule
\cnlemmaXXjtype\cninterrule
\cnresXXjtype\cninterrule
\cnobjectXXvalueXXjtype\cninterrule
\cnpvalXXjtype\cninterrule
\cnspineXXjtype\cninterrule
\cnpexprXXjtype\cninterrule
\cncompXXpatternXXjtype\cninterrule
\cnresXXpatternXXjtype\cninterrule
\cnretXXpatternXXjtype\cninterrule
\cntpvalXXjtype\cninterrule
\cntpexprXXjtype\cninterrule
\cnactionXXjtype\cninterrule
\cnmemopXXjtype\cninterrule
\cntvalXXjtype\cninterrule
\cnseqXXexprXXjtype\cninterrule
\cnisXXexprXXjtype\cninterrule
\cntexprXXjtype\cninterrule
\cnsubsXXjtype\cninterrule
\cnpureXXopsemXXjtype\cninterrule
\cnopsemXXjtype\cninterrule
\cnjudgement\cninterrule
\cnuserXXsyntax\cnafterlastrule
}}

% defnss
% defns lemma_jtype
%% defn Arg_Env
\newcommand{\cndruleArgXXEnvXXRet}[1]{\cndrule[#1]{%
}{
\,  \mathbin{ {:} {:} }  \cnnt{ret}  \leadsto  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \mid  \cnnt{ret}}{%
{\cndrulename{Arg\_Env\_Ret}}{}%
}}


\newcommand{\cndruleArgXXEnvXXComp}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \leadsto  \mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \mid  \cnnt{ret}}%
}{
\cnmv{x}  \cnsym{,} \, \cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \Pi \, \cnmv{x}  {:}  \beta  . \:  \cnnt{arg}  \leadsto  \mathcal{C}  \cnsym{,}  \cnmv{x}  {:}  \beta  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \mid  \cnnt{ret}}{%
{\cndrulename{Arg\_Env\_Comp}}{}%
}}


\newcommand{\cndruleArgXXEnvXXLog}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \leadsto  \mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \mid  \cnnt{ret}}%
}{
\cnmv{x}  \cnsym{,} \, \cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \forall \, \cnmv{x}  {:}  \beta  . \:  \cnnt{arg}  \leadsto  \mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{,}  \cnmv{x}  {:}  \beta  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \mid  \cnnt{ret}}{%
{\cndrulename{Arg\_Env\_Log}}{}%
}}


\newcommand{\cndruleArgXXEnvXXPhi}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \leadsto  \mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \mid  \cnnt{ret}}%
}{
\cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  term  \supset  \cnnt{arg}  \leadsto  \mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{,}  term  \cnsym{;}  \mathcal{R}  \mid  \cnnt{ret}}{%
{\cndrulename{Arg\_Env\_Phi}}{}%
}}


\newcommand{\cndruleArgXXEnvXXRes}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \leadsto  \mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \mid  \cnnt{ret}}%
}{
\cnmv{x}  \cnsym{,} \, \cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{res}  \multimap  \cnnt{arg}  \leadsto  \mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \cnsym{,}  \cnmv{x}  {:}  \cnnt{res}  \mid  \cnnt{ret}}{%
{\cndrulename{Arg\_Env\_Res}}{}%
}}

\newcommand{\cndefnArgXXEnv}[1]{\begin{cndefnblock}[#1]{$\cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \leadsto  \mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \mid  \cnnt{ret}$}{}
\cnusedrule{\cndruleArgXXEnvXXRet{}}
\cnusedrule{\cndruleArgXXEnvXXComp{}}
\cnusedrule{\cndruleArgXXEnvXXLog{}}
\cnusedrule{\cndruleArgXXEnvXXPhi{}}
\cnusedrule{\cndruleArgXXEnvXXRes{}}
\end{cndefnblock}}

%% defn Weak
\newcommand{\cndruleWeakXXEmpty}[1]{\cndrule[#1]{%
}{
\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \sqsubseteq  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot}{%
{\cndrulename{Weak\_Empty}}{}%
}}


\newcommand{\cndruleWeakXXConsXXComp}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \sqsubseteq  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}%
}{
\mathcal{C}  \cnsym{,}  \cnmv{x}  {:}  \beta  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \sqsubseteq  \mathcal{C}'  \cnsym{,}  \cnmv{x}  {:}  \beta  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}{%
{\cndrulename{Weak\_Cons\_Comp}}{}%
}}


\newcommand{\cndruleWeakXXConsXXLog}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \sqsubseteq  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{,}  \cnmv{x}  {:}  \beta  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \sqsubseteq  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{,}  \cnmv{x}  {:}  \beta  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}{%
{\cndrulename{Weak\_Cons\_Log}}{}%
}}


\newcommand{\cndruleWeakXXConsXXPhi}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \sqsubseteq  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{,}  term  \cnsym{;}  \mathcal{R}  \sqsubseteq  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{,}  term  \cnsym{;}  \mathcal{R}'}{%
{\cndrulename{Weak\_Cons\_Phi}}{}%
}}


\newcommand{\cndruleWeakXXConsXXRes}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \sqsubseteq  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \cnsym{,}  \cnmv{x}  {:}  \cnnt{res}  \sqsubseteq  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \cnsym{,}  \cnmv{x}  {:}  \cnnt{res}}{%
{\cndrulename{Weak\_Cons\_Res}}{}%
}}


\newcommand{\cndruleWeakXXSkipXXComp}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \sqsubseteq  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \sqsubseteq  \mathcal{C}'  \cnsym{,}  \cnmv{x}  {:}  \beta  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}{%
{\cndrulename{Weak\_Skip\_Comp}}{}%
}}


\newcommand{\cndruleWeakXXSkipXXLog}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \sqsubseteq  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \sqsubseteq  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{,}  \cnmv{x}  {:}  \beta  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}{%
{\cndrulename{Weak\_Skip\_Log}}{}%
}}


\newcommand{\cndruleWeakXXSkipXXPhi}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \sqsubseteq  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \sqsubseteq  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{,}  term  \cnsym{;}  \mathcal{R}'}{%
{\cndrulename{Weak\_Skip\_Phi}}{}%
}}

\newcommand{\cndefnWeak}[1]{\begin{cndefnblock}[#1]{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \sqsubseteq  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'$}{}
\cnusedrule{\cndruleWeakXXEmpty{}}
\cnusedrule{\cndruleWeakXXConsXXComp{}}
\cnusedrule{\cndruleWeakXXConsXXLog{}}
\cnusedrule{\cndruleWeakXXConsXXPhi{}}
\cnusedrule{\cndruleWeakXXConsXXRes{}}
\cnusedrule{\cndruleWeakXXSkipXXComp{}}
\cnusedrule{\cndruleWeakXXSkipXXLog{}}
\cnusedrule{\cndruleWeakXXSkipXXPhi{}}
\end{cndefnblock}}

%% defn Ty_Subs
\newcommand{\cndruleTyXXSubsXXEmpty}[1]{\cndrule[#1]{%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \cdot  \vdash  \cnsym{(}  \cdot  \cnsym{)}  {:}  \cnsym{(}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{)}}{%
{\cndrulename{Ty\_Subs\_Empty}}{}%
}}


\newcommand{\cndruleTyXXSubsXXConsXXComp}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \cnsym{)}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \beta}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  pval  \cnsym{/}  \cnmv{x}  \cnsym{,}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}'  \cnsym{,}  \cnmv{x}  {:}  \beta  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \cnsym{)}}{%
{\cndrulename{Ty\_Subs\_Cons\_Comp}}{}%
}}


\newcommand{\cndruleTyXXSubsXXConsXXLog}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \cnsym{)}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \beta}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  pval  \cnsym{/}  \cnmv{x}  \cnsym{,}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{,}  \cnmv{x}  {:}  \beta  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \cnsym{)}}{%
{\cndrulename{Ty\_Subs\_Cons\_Log}}{}%
}}


\newcommand{\cndruleTyXXSubsXXConsXXPhi}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \cnsym{)}}%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  term  \cnsym{)}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{,}  term  \cnsym{;}  \mathcal{R}'  \cnsym{)}}{%
{\cndrulename{Ty\_Subs\_Cons\_Phi}}{}%
}}


\newcommand{\cndruleTyXXSubsXXConsXXRes}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \cnsym{)}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \vdash  \cnnt{res\_term}  \Leftarrow   \sigma  (  \cnnt{res}  ) }%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \cnsym{,}  \mathcal{R}_{{\mathrm{1}}}  \vdash  \cnsym{(}  \cnnt{res\_term}  \cnsym{/}  \cnmv{x}  \cnsym{,}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \cnsym{,}  \cnmv{x}  {:}  \cnnt{res}  \cnsym{)}}{%
{\cndrulename{Ty\_Subs\_Cons\_Res}}{}%
}}

\newcommand{\cndefnTyXXSubs}[1]{\begin{cndefnblock}[#1]{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \cnsym{)}$}{}
\cnusedrule{\cndruleTyXXSubsXXEmpty{}}
\cnusedrule{\cndruleTyXXSubsXXConsXXComp{}}
\cnusedrule{\cndruleTyXXSubsXXConsXXLog{}}
\cnusedrule{\cndruleTyXXSubsXXConsXXPhi{}}
\cnusedrule{\cndruleTyXXSubsXXConsXXRes{}}
\end{cndefnblock}}


\newcommand{\cndefnslemmaXXjtype}{
\cndefnArgXXEnv{}\cndefnWeak{}\cndefnTyXXSubs{}}

% defns res_jtype
%% defn Res_Eq
\newcommand{\cndruleTyXXResXXEqXXEmp}[1]{\cndrule[#1]{%
}{
\Phi  \vdash  \cnkw{emp} \, \equiv \, \cnkw{emp}}{%
{\cndrulename{Ty\_Res\_Eq\_Emp}}{}%
}}


\newcommand{\cndruleTyXXResXXEqXXPointsTo}[1]{\cndrule[#1]{%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  \cnsym{(}  term_{{\mathrm{1}}}  =  term'_{{\mathrm{1}}}  \cnsym{)}  \wedge  \cnsym{(}  term_{{\mathrm{2}}}  =  term'_{{\mathrm{2}}}  \cnsym{)}  \cnsym{)}}%
}{
\Phi  \vdash   term_{{\mathrm{1}}}  \mathbin{ { \overset{  init  }{ \mapsto } }_{  \tau  } }  term_{{\mathrm{2}}}  \, \equiv \,  term'_{{\mathrm{1}}}  \mathbin{ { \overset{  init  }{ \mapsto } }_{  \tau  } }  term'_{{\mathrm{2}}} }{%
{\cndrulename{Ty\_Res\_Eq\_PointsTo}}{}%
}}


\newcommand{\cndruleTyXXResXXEqXXSepConj}[1]{\cndrule[#1]{%
\cnpremise{\Phi  \vdash  \cnnt{res_{{\mathrm{1}}}} \, \equiv \, \cnnt{res'_{{\mathrm{1}}}}}%
\cnpremise{\Phi  \vdash  \cnnt{res_{{\mathrm{2}}}} \, \equiv \, \cnnt{res'_{{\mathrm{2}}}}}%
}{
\Phi  \vdash  \cnnt{res_{{\mathrm{1}}}}  *  \cnnt{res_{{\mathrm{2}}}} \, \equiv \, \cnnt{res'_{{\mathrm{1}}}}  *  \cnnt{res'_{{\mathrm{2}}}}}{%
{\cndrulename{Ty\_Res\_Eq\_SepConj}}{}%
}}


\newcommand{\cndruleTyXXResXXEqXXExists}[1]{\cndrule[#1]{%
\cnpremise{\Phi  \vdash  \cnnt{res} \, \equiv \, \cnnt{res'}}%
}{
\Phi  \vdash  \exists \, ident  {:}  \beta  . \:  \cnnt{res} \, \equiv \, \exists \, ident  {:}  \beta  . \:  \cnnt{res'}}{%
{\cndrulename{Ty\_Res\_Eq\_Exists}}{}%
}}


\newcommand{\cndruleTyXXResXXEqXXTerm}[1]{\cndrule[#1]{%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  \cnsym{(}  term  \rightarrow  term'  \cnsym{)}  \wedge  \cnsym{(}  term'  \rightarrow  term  \cnsym{)}  \cnsym{)}}%
\cnpremise{\Phi  \vdash  \cnnt{res} \, \equiv \, \cnnt{res'}}%
}{
\Phi  \vdash  term  \wedge  \cnnt{res} \, \equiv \, term'  \wedge  \cnnt{res'}}{%
{\cndrulename{Ty\_Res\_Eq\_Term}}{}%
}}


\newcommand{\cndruleTyXXResXXEqXXOrdDisj}[1]{\cndrule[#1]{%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  \cnsym{(}  term_{{\mathrm{1}}}  \rightarrow  term_{{\mathrm{2}}}  \cnsym{)}  \wedge  \cnsym{(}  term_{{\mathrm{2}}}  \rightarrow  term_{{\mathrm{1}}}  \cnsym{)}  \cnsym{)}}%
\cnpremise{\Phi  \vdash  \cnnt{res_{{\mathrm{11}}}} \, \equiv \, \cnnt{res_{{\mathrm{21}}}}}%
\cnpremise{\Phi  \vdash  \cnnt{res_{{\mathrm{21}}}} \, \equiv \, \cnnt{res_{{\mathrm{22}}}}}%
}{
\Phi  \vdash  \cnkw{if} \, term_{{\mathrm{1}}} \, \cnkw{then} \, \cnnt{res_{{\mathrm{11}}}} \, \cnkw{else} \, \cnnt{res_{{\mathrm{12}}}} \, \equiv \, \cnkw{if} \, term_{{\mathrm{2}}} \, \cnkw{then} \, \cnnt{res_{{\mathrm{21}}}} \, \cnkw{else} \, \cnnt{res_{{\mathrm{22}}}}}{%
{\cndrulename{Ty\_Res\_Eq\_OrdDisj}}{}%
}}


\newcommand{\cndruleTyXXResXXEqXXPred}[1]{\cndrule[#1]{%
}{
\Phi  \vdash  { \alpha }  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)} \, \equiv \, { \alpha }  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}}{%
{\cndrulename{Ty\_Res\_Eq\_Pred}}{}%
}}

\newcommand{\cndefnTyXXResXXEq}[1]{\begin{cndefnblock}[#1]{$\Phi  \vdash  \cnnt{res} \, \equiv \, \cnnt{res'}$}{}
\cnusedrule{\cndruleTyXXResXXEqXXEmp{}}
\cnusedrule{\cndruleTyXXResXXEqXXPointsTo{}}
\cnusedrule{\cndruleTyXXResXXEqXXSepConj{}}
\cnusedrule{\cndruleTyXXResXXEqXXExists{}}
\cnusedrule{\cndruleTyXXResXXEqXXTerm{}}
\cnusedrule{\cndruleTyXXResXXEqXXOrdDisj{}}
\cnusedrule{\cndruleTyXXResXXEqXXPred{}}
\end{cndefnblock}}

%% defn Res
\newcommand{\cndruleTyXXResXXEmp}[1]{\cndrule[#1]{%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \cdot  \vdash  \cnkw{emp}  \Leftarrow  \cnkw{emp}}{%
{\cndrulename{Ty\_Res\_Emp}}{}%
}}


\newcommand{\cndruleTyXXResXXPointsTo}[1]{\cndrule[#1]{%
\cnpremise{\Phi  \vdash  \cnnt{points\_to} \, \equiv \, \cnnt{points\_to'}}%
\cnpremise{\Phi  \vdash  \cnnt{points\_to'} \, \equiv \, \cnnt{points\_to''}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \cdot  \cnsym{,}  \cnmv{\_}  {:}  \cnnt{points\_to}  \vdash  \cnnt{points\_to'}  \Leftarrow  \cnnt{points\_to''}}{%
{\cndrulename{Ty\_Res\_PointsTo}}{}%
}}


\newcommand{\cndruleTyXXResXXVar}[1]{\cndrule[#1]{%
\cnpremise{\Phi  \vdash  \cnnt{res'_{{\mathrm{1}}}}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  \cnnt{res_{{\mathrm{1}}}}  \cnsym{)}}%
\cnpremise{\Phi  \vdash  \cnnt{res'_{{\mathrm{2}}}}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  \cnnt{res_{{\mathrm{2}}}}  \cnsym{)}}%
\cnpremise{\Phi  \vdash  \cnnt{res'_{{\mathrm{1}}}} \, \equiv \, \cnnt{res'_{{\mathrm{2}}}}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \cdot  \cnsym{,}  \cnmv{r}  {:}  \cnnt{res_{{\mathrm{1}}}}  \vdash  \cnmv{r}  \Leftarrow  \cnnt{res_{{\mathrm{2}}}}}{%
{\cndrulename{Ty\_Res\_Var}}{}%
}}


\newcommand{\cndruleTyXXResXXSepConj}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \vdash  \cnnt{res\_term_{{\mathrm{1}}}}  \Leftarrow  \cnnt{res_{{\mathrm{1}}}}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}_{{\mathrm{2}}}  \vdash  \cnnt{res\_term_{{\mathrm{2}}}}  \Leftarrow  \cnnt{res_{{\mathrm{2}}}}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{R}_{{\mathrm{2}}}  \vdash  \langle  \cnnt{res\_term_{{\mathrm{1}}}}  \cnsym{,}  \cnnt{res\_term_{{\mathrm{2}}}}  \rangle  \Leftarrow  \cnnt{res_{{\mathrm{1}}}}  *  \cnnt{res_{{\mathrm{2}}}}}{%
{\cndrulename{Ty\_Res\_SepConj}}{}%
}}


\newcommand{\cndruleTyXXResXXConj}[1]{\cndrule[#1]{%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  term  \cnsym{)}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnnt{res\_term}  \Leftarrow  \cnnt{res}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnnt{res\_term}  \Leftarrow  term  \wedge  \cnnt{res}}{%
{\cndrulename{Ty\_Res\_Conj}}{}%
}}


\newcommand{\cndruleTyXXResXXPack}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \beta}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnnt{res\_term}  \Leftarrow   pval  \cnsym{/}  \cnmv{y}  \cnsym{,}  \cdot  (  \cnnt{res}  ) }%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{pack} \, \cnsym{(}  pval  \cnsym{,}  \cnnt{res\_term}  \cnsym{)}  \Leftarrow  \exists \, \cnmv{y}  {:}  \beta  . \:  \cnnt{res}}{%
{\cndrulename{Ty\_Res\_Pack}}{}%
}}


\newcommand{\cndruleTyXXResXXFold}[1]{\cndrule[#1]{%
\cnpremise{{ \alpha } \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}  {:}  \beta_{\cnmv{i}}}{\cnmv{i}} \, \mapsto  \cnnt{res} \, \in \, \cnkw{Globals}}%
\cnpremise{\cncomp{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{\cnmv{i}}  \Rightarrow  \beta_{\cnmv{i}}}{\cnmv{i}}}%
\cnpremise{\Phi  \vdash  \cnnt{res'}  = \, \cnkw{strip\_ifs} \, \cnsym{(}   \cncomp{pval_{\cnmv{i}}  \cnsym{/}  \cnmv{x_{\cnmv{i}}}  \cnsym{,}  \cdot}{\cnmv{i}}  (  \cnnt{res}  )   \cnsym{)}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnnt{res\_term}  \Leftarrow  \cnnt{res'}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{fold} \, \cnsym{(}  \cnnt{res\_term}  \cnsym{)}  \Leftarrow  { \alpha }  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}}{%
{\cndrulename{Ty\_Res\_Fold}}{}%
}}

\newcommand{\cndefnTyXXRes}[1]{\begin{cndefnblock}[#1]{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnnt{res\_term}  \Leftarrow  \cnnt{res}$}{}
\cnusedrule{\cndruleTyXXResXXEmp{}}
\cnusedrule{\cndruleTyXXResXXPointsTo{}}
\cnusedrule{\cndruleTyXXResXXVar{}}
\cnusedrule{\cndruleTyXXResXXSepConj{}}
\cnusedrule{\cndruleTyXXResXXConj{}}
\cnusedrule{\cndruleTyXXResXXPack{}}
\cnusedrule{\cndruleTyXXResXXFold{}}
\end{cndefnblock}}

%% defn Heap
\newcommand{\cndruleTyXXHeapXXEmp}[1]{\cndrule[#1]{%
}{
\cdot  {:}  \cdot}{%
{\cndrulename{Ty\_Heap\_Emp}}{}%
}}


\newcommand{\cndruleTyXXHeapXXPointsTo}[1]{\cndrule[#1]{%
\cnpremise{\cnnt{h}  {:}  \mathcal{R}}%
\cnpremise{\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}'  \vdash  \cnnt{pt}  \Leftarrow  \cnnt{pt}}%
}{
\cnnt{h}  \cnsym{+}  \cnsym{\{}  \cnnt{pt}  \cnsym{\}}  {:}  \mathcal{R}  \cnsym{,}  \mathcal{R}'}{%
{\cndrulename{Ty\_Heap\_PointsTo}}{}%
}}

\newcommand{\cndefnTyXXHeap}[1]{\begin{cndefnblock}[#1]{$\cnnt{h}  {:}  \mathcal{R}$}{}
\cnusedrule{\cndruleTyXXHeapXXEmp{}}
\cnusedrule{\cndruleTyXXHeapXXPointsTo{}}
\end{cndefnblock}}


\newcommand{\cndefnsresXXjtype}{
\cndefnTyXXResXXEq{}\cndefnTyXXRes{}\cndefnTyXXHeap{}}

% defns object_value_jtype
%% defn Pval_Obj_
\newcommand{\cndruleTyXXPvalXXObjXXInt}[1]{\cndrule[#1]{%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  mem\_int  \Rightarrow \, \cnkw{obj} \, \cnkw{integer}}{%
{\cndrulename{Ty\_Pval\_Obj\_Int}}{}%
}}


\newcommand{\cndruleTyXXPvalXXObjXXPtr}[1]{\cndrule[#1]{%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  mem\_ptr  \Rightarrow \, \cnkw{obj} \, \cnkw{loc}}{%
{\cndrulename{Ty\_Pval\_Obj\_Ptr}}{}%
}}


\newcommand{\cndruleTyXXPvalXXObjXXArr}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  loaded\_value_{\cnmv{i}}  \Rightarrow  \beta}{\cnmv{i}}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{array} \, \cnsym{(} \, \cncomp{loaded\_value_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}  \Rightarrow \, \cnkw{obj} \, \cnkw{array} \, \beta}{%
{\cndrulename{Ty\_Pval\_Obj\_Arr}}{}%
}}


\newcommand{\cndruleTyXXPvalXXObjXXStruct}[1]{\cndrule[#1]{%
\cnpremise{\cnkw{struct} \, tag  \ \& \, \cncomp{member_{\cnmv{i}}  {:}  \tau_{\cnmv{i}}}{\cnmv{i}} \, \in \, \cnkw{Globals}}%
\cnpremise{\cncomp{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  mem\_val_{\cnmv{i}}  \Rightarrow \, \cnkw{mem} \,  \beta_{  \tau_{\cnmv{i}}  } }{\cnmv{i}}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnsym{(} \, \cnkw{struct} \, tag  \cnsym{)}  \cnsym{\{} \, \cncomp{. \, member_{\cnmv{i}}  {:}  \tau_{\cnmv{i}}  =  mem\_val_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{\}}  \Rightarrow \, \cnkw{obj} \, \cnkw{struct} \, tag}{%
{\cndrulename{Ty\_Pval\_Obj\_Struct}}{}%
}}

\newcommand{\cndefnTyXXPvalXXObjXX}[1]{\begin{cndefnblock}[#1]{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  object\_value  \Rightarrow \, \cnkw{obj} \, \beta$}{}
\cnusedrule{\cndruleTyXXPvalXXObjXXInt{}}
\cnusedrule{\cndruleTyXXPvalXXObjXXPtr{}}
\cnusedrule{\cndruleTyXXPvalXXObjXXArr{}}
\cnusedrule{\cndruleTyXXPvalXXObjXXStruct{}}
\end{cndefnblock}}


\newcommand{\cndefnsobjectXXvalueXXjtype}{
\cndefnTyXXPvalXXObjXX{}}

% defns pval_jtype
%% defn Pval
\newcommand{\cndruleTyXXPvalXXVarXXComp}[1]{\cndrule[#1]{%
\cnpremise{\cnmv{x}  {:}  \beta \, \in \, \mathcal{C}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnmv{x}  \Rightarrow  \beta}{%
{\cndrulename{Ty\_Pval\_Var\_Comp}}{}%
}}


\newcommand{\cndruleTyXXPvalXXVarXXLog}[1]{\cndrule[#1]{%
\cnpremise{\cnmv{x}  {:}  \beta \, \in \, \mathcal{L}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnmv{x}  \Rightarrow  \beta}{%
{\cndrulename{Ty\_Pval\_Var\_Log}}{}%
}}


\newcommand{\cndruleTyXXPvalXXObj}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  object\_value  \Rightarrow \, \cnkw{obj} \, \beta}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  object\_value  \Rightarrow  \beta}{%
{\cndrulename{Ty\_Pval\_Obj}}{}%
}}


\newcommand{\cndruleTyXXPvalXXLoaded}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  object\_value  \Rightarrow \, \cnkw{obj} \, \beta}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{specified} \, object\_value  \Rightarrow  \beta}{%
{\cndrulename{Ty\_Pval\_Loaded}}{}%
}}


\newcommand{\cndruleTyXXPvalXXUnit}[1]{\cndrule[#1]{%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{Unit}  \Rightarrow  \cnkw{unit}}{%
{\cndrulename{Ty\_Pval\_Unit}}{}%
}}


\newcommand{\cndruleTyXXPvalXXTrue}[1]{\cndrule[#1]{%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{True}  \Rightarrow  \cnkw{bool}}{%
{\cndrulename{Ty\_Pval\_True}}{}%
}}


\newcommand{\cndruleTyXXPvalXXFalse}[1]{\cndrule[#1]{%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{False}  \Rightarrow  \cnkw{bool}}{%
{\cndrulename{Ty\_Pval\_False}}{}%
}}


\newcommand{\cndruleTyXXPvalXXList}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  value_{\cnmv{i}}  \Rightarrow  \beta}{\cnmv{i}}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \beta  \cnsym{[} \, \cncomp{value_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{]}  \Rightarrow  \cnkw{list} \, \beta}{%
{\cndrulename{Ty\_Pval\_List}}{}%
}}


\newcommand{\cndruleTyXXPvalXXTuple}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  value_{\cnmv{i}}  \Rightarrow  \beta_{\cnmv{i}}}{\cnmv{i}}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnsym{(} \, \cncomp{value_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}  \Rightarrow  \cncomp{\beta_{\cnmv{i}}}{\cnmv{i}}}{%
{\cndrulename{Ty\_Pval\_Tuple}}{}%
}}


\newcommand{\cndruleTyXXPvalXXError}[1]{\cndrule[#1]{%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  \cnkw{false}  \cnsym{)}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{error} \, \cnsym{(}  string  \cnsym{,}  pval  \cnsym{)}  \Rightarrow  \beta}{%
{\cndrulename{Ty\_Pval\_Error}}{}%
}}


\newcommand{\cndruleTyXXPvalXXCtorXXNil}[1]{\cndrule[#1]{%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{Nil} \, \beta  \cnsym{(}  \,  \cnsym{)}  \Rightarrow  \cnkw{list} \, \beta}{%
{\cndrulename{Ty\_Pval\_Ctor\_Nil}}{}%
}}


\newcommand{\cndruleTyXXPvalXXCtorXXCons}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{1}}}  \Rightarrow  \beta}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{2}}}  \Rightarrow  \cnkw{list} \, \beta}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{Cons}  \cnsym{(}  pval_{{\mathrm{1}}}  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{)}  \Rightarrow  \cnkw{list} \, \beta}{%
{\cndrulename{Ty\_Pval\_Ctor\_Cons}}{}%
}}


\newcommand{\cndruleTyXXPvalXXCtorXXTuple}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{\cnmv{i}}  \Rightarrow  \beta_{\cnmv{i}}}{\cnmv{i}}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{Tuple}  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}  \Rightarrow  \cncomp{\beta_{\cnmv{i}}}{\cnmv{i}}}{%
{\cndrulename{Ty\_Pval\_Ctor\_Tuple}}{}%
}}


\newcommand{\cndruleTyXXPvalXXCtorXXArray}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{\cnmv{i}}  \Rightarrow  \beta}{\cnmv{i}}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{Array}  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}  \Rightarrow  \cnkw{array} \, \beta}{%
{\cndrulename{Ty\_Pval\_Ctor\_Array}}{}%
}}


\newcommand{\cndruleTyXXPvalXXCtorXXSpecified}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \beta}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{Specified}  \cnsym{(}  pval  \cnsym{)}  \Rightarrow  \beta}{%
{\cndrulename{Ty\_Pval\_Ctor\_Specified}}{}%
}}


\newcommand{\cndruleTyXXPvalXXStruct}[1]{\cndrule[#1]{%
\cnpremise{\cnkw{struct} \, tag  \ \& \, \cncomp{member_{\cnmv{i}}  {:}  \tau_{\cnmv{i}}}{\cnmv{i}} \, \in \, \cnkw{Globals}}%
\cnpremise{\cncomp{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{\cnmv{i}}  \Rightarrow   \beta_{  \tau_{\cnmv{i}}  } }{\cnmv{i}}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnsym{(} \, \cnkw{struct} \, tag  \cnsym{)}  \cnsym{\{} \, \cncomp{. \, member_{\cnmv{i}}  =  pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{\}}  \Rightarrow  \cnkw{struct} \, tag}{%
{\cndrulename{Ty\_Pval\_Struct}}{}%
}}

\newcommand{\cndefnTyXXPval}[1]{\begin{cndefnblock}[#1]{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \beta$}{}
\cnusedrule{\cndruleTyXXPvalXXVarXXComp{}}
\cnusedrule{\cndruleTyXXPvalXXVarXXLog{}}
\cnusedrule{\cndruleTyXXPvalXXObj{}}
\cnusedrule{\cndruleTyXXPvalXXLoaded{}}
\cnusedrule{\cndruleTyXXPvalXXUnit{}}
\cnusedrule{\cndruleTyXXPvalXXTrue{}}
\cnusedrule{\cndruleTyXXPvalXXFalse{}}
\cnusedrule{\cndruleTyXXPvalXXList{}}
\cnusedrule{\cndruleTyXXPvalXXTuple{}}
\cnusedrule{\cndruleTyXXPvalXXError{}}
\cnusedrule{\cndruleTyXXPvalXXCtorXXNil{}}
\cnusedrule{\cndruleTyXXPvalXXCtorXXCons{}}
\cnusedrule{\cndruleTyXXPvalXXCtorXXTuple{}}
\cnusedrule{\cndruleTyXXPvalXXCtorXXArray{}}
\cnusedrule{\cndruleTyXXPvalXXCtorXXSpecified{}}
\cnusedrule{\cndruleTyXXPvalXXStruct{}}
\end{cndefnblock}}


\newcommand{\cndefnspvalXXjtype}{
\cndefnTyXXPval{}}

% defns spine_jtype
%% defn Spine
\newcommand{\cndruleTyXXSpineXXEmpty}[1]{\cndrule[#1]{%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \cdot  \vdash  \,  \mathbin{ {:} {:} }  \cnnt{ret}  \gg  \cdot  \cnsym{;}  \cnnt{ret}}{%
{\cndrulename{Ty\_Spine\_Empty}}{}%
}}


\newcommand{\cndruleTyXXSpineXXComp}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \beta}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnmv{x}  =  pval  \cnsym{,} \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \Pi \, \cnmv{x}  {:}  \beta  . \:  \cnnt{arg}  \gg  pval  \cnsym{/}  \cnmv{x}  \cnsym{,}  \sigma  \cnsym{;}  \cnnt{ret}}{%
{\cndrulename{Ty\_Spine\_Comp}}{}%
}}


\newcommand{\cndruleTyXXSpineXXLog}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \beta}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnmv{x}  =  pval  \cnsym{,} \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \forall \, \cnmv{x}  {:}  \beta  . \:  \cnnt{arg}  \gg  pval  \cnsym{/}  \cnmv{x}  \cnsym{,}  \sigma  \cnsym{;}  \cnnt{ret}}{%
{\cndrulename{Ty\_Spine\_Log}}{}%
}}


\newcommand{\cndruleTyXXSpineXXRes}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \vdash  \cnnt{res\_term}  \Leftarrow  \cnnt{res}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}_{{\mathrm{2}}}  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{R}_{{\mathrm{2}}}  \vdash  \cnmv{x}  =  \cnnt{res\_term}  \cnsym{,} \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{res}  \multimap  \cnnt{arg}  \gg  \cnnt{res\_term}  \cnsym{/}  \cnmv{x}  \cnsym{,}  \sigma  \cnsym{;}  \cnnt{ret}}{%
{\cndrulename{Ty\_Spine\_Res}}{}%
}}


\newcommand{\cndruleTyXXSpineXXPhi}[1]{\cndrule[#1]{%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  term  \cnsym{)}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  term  \supset  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}}{%
{\cndrulename{Ty\_Spine\_Phi}}{}%
}}

\newcommand{\cndefnTyXXSpine}[1]{\begin{cndefnblock}[#1]{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}$}{}
\cnusedrule{\cndruleTyXXSpineXXEmpty{}}
\cnusedrule{\cndruleTyXXSpineXXComp{}}
\cnusedrule{\cndruleTyXXSpineXXLog{}}
\cnusedrule{\cndruleTyXXSpineXXRes{}}
\cnusedrule{\cndruleTyXXSpineXXPhi{}}
\end{cndefnblock}}


\newcommand{\cndefnsspineXXjtype}{
\cndefnTyXXSpine{}}

% defns pexpr_jtype
%% defn PE
\newcommand{\cndruleTyXXPEXXVal}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \beta}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \cnmv{y}  {:}  \beta  . \:  \cnmv{y}  =   pval }{%
{\cndrulename{Ty\_PE\_Val}}{}%
}}


\newcommand{\cndruleTyXXPEXXArrayXXShift}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{1}}}  \Rightarrow  \cnkw{loc}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{2}}}  \Rightarrow  \cnkw{integer}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{array\_shift} \, \cnsym{(}  pval_{{\mathrm{1}}}  \cnsym{,}  \tau  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{)}  \Rightarrow  \cnmv{y}  {:}  \cnkw{loc}  . \:  \cnmv{y}  =   pval_{{\mathrm{1}}}   \mathbin{ {+}_{ \mathrm{ptr} } }  \cnsym{(}   pval_{{\mathrm{2}}}   \times   \mathrm{size\_of}(  \tau  )   \cnsym{)}}{%
{\cndrulename{Ty\_PE\_Array\_Shift}}{}%
}}


\newcommand{\cndruleTyXXPEXXMemberXXShift}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \cnkw{loc}}%
\cnpremise{\cnkw{struct} \, tag  \ \& \, \cncomp{member_{\cnmv{i}}  {:}  \tau_{\cnmv{i}}}{\cnmv{i}} \, \in \, \cnkw{Globals}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{member\_shift} \, \cnsym{(}  pval  \cnsym{,}  tag  \cnsym{,}  member_{\cnmv{j}}  \cnsym{)}  \Rightarrow  \cnmv{y}  {:}  \cnkw{loc}  . \:  \cnmv{y}  =   pval   \mathbin{ {+}_{ \mathrm{ptr} } }   \mathrm{offset\_of}_{  tag  }(  member_{\cnmv{j}}  ) }{%
{\cndrulename{Ty\_PE\_Member\_Shift}}{}%
}}


\newcommand{\cndruleTyXXPEXXNot}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \cnkw{bool}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{not} \, \cnsym{(}  pval  \cnsym{)}  \Rightarrow  \cnmv{y}  {:}  \cnkw{bool}  . \:  \cnmv{y}  =  \neg \,  pval }{%
{\cndrulename{Ty\_PE\_Not}}{}%
}}


\newcommand{\cndruleTyXXPEXXArithXXBinop}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{1}}}  \Rightarrow  \cnkw{integer}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{2}}}  \Rightarrow  \cnkw{integer}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{1}}} \, \mathbin{ binop_{arith} } \, pval_{{\mathrm{2}}}  \Rightarrow  \cnmv{y}  {:}  \cnkw{integer}  . \:  \cnmv{y}  =  \cnsym{(}    pval_{{\mathrm{1}}}    \mathbin{ binop_{arith} }    pval_{{\mathrm{2}}}    \cnsym{)}}{%
{\cndrulename{Ty\_PE\_Arith\_Binop}}{}%
}}


\newcommand{\cndruleTyXXPEXXRelXXBinop}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{1}}}  \Rightarrow  \cnkw{integer}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{2}}}  \Rightarrow  \cnkw{integer}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{1}}} \, \mathbin{ binop_{rel} } \, pval_{{\mathrm{2}}}  \Rightarrow  \cnmv{y}  {:}  \cnkw{bool}  . \:  \cnmv{y}  =  \cnsym{(}    pval_{{\mathrm{1}}}    \mathbin{ binop_{rel} }    pval_{{\mathrm{2}}}    \cnsym{)}}{%
{\cndrulename{Ty\_PE\_Rel\_Binop}}{}%
}}


\newcommand{\cndruleTyXXPEXXBoolXXBinop}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{1}}}  \Rightarrow  \cnkw{bool}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{2}}}  \Rightarrow  \cnkw{bool}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{1}}} \, \mathbin{ binop_{bool} } \, pval_{{\mathrm{2}}}  \Rightarrow  \cnmv{y}  {:}  \cnkw{bool}  . \:  \cnmv{y}  =  \cnsym{(}    pval_{{\mathrm{1}}}    \mathbin{ binop_{bool} }    pval_{{\mathrm{2}}}    \cnsym{)}}{%
{\cndrulename{Ty\_PE\_Bool\_Binop}}{}%
}}


\newcommand{\cndruleTyXXPEXXCall}[1]{\cndrule[#1]{%
\cnpremise{name  {:}  \cnnt{pure\_arg} \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mapsto  tpexpr \, \in \, \cnkw{Globals}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \cdot  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  pval_{\cnmv{i}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{pure\_arg}  \gg  \sigma  \cnsym{;}  \Sigma \, \cnmv{y}  {:}  \beta  . \:  \cnnt{term}  \wedge  \cnkw{I}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  name  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}  \Rightarrow  \cnmv{y}  {:}  \beta  . \:   \sigma  (  \cnnt{term}  ) }{%
{\cndrulename{Ty\_PE\_Call}}{}%
}}


\newcommand{\cndruleTyXXPEXXAssertXXUndef}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \cnkw{bool}}%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow   pval   \cnsym{)}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{assert\_undef} \, \cnsym{(}  pval  \cnsym{,}   \, \cnmv{UB\_name}  \cnsym{)}  \Rightarrow  \cnmv{y}  {:}  \cnkw{unit}  . \:  \cnmv{y}  =  \cnkw{unit}}{%
{\cndrulename{Ty\_PE\_Assert\_Undef}}{}%
}}


\newcommand{\cndruleTyXXPEXXBoolXXToXXInteger}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \cnkw{bool}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{bool\_to\_integer} \, \cnsym{(}  pval  \cnsym{)}  \Rightarrow  \cnmv{y}  {:}  \cnkw{integer}  . \:  \cnmv{y}  =  \cnkw{if} \,  pval  \, \cnkw{then} \,  1  \, \cnkw{else} \,  0 }{%
{\cndrulename{Ty\_PE\_Bool\_To\_Integer}}{}%
}}


\newcommand{\cndruleTyXXPEXXWrapI}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \cnkw{integer}}%
\cnpremise{\cnmv{abbrev_{{\mathrm{1}}}} \, \equiv \,  \mathrm{max\_int}_{  \tau  }   \cnsym{-}   \mathrm{min\_int}_{  \tau  }   \cnsym{+}   1 }%
\cnpremise{\cnmv{abbrev_{{\mathrm{2}}}} \, \equiv \,  pval  \, \cnkw{rem\_f} \, \cnmv{abbrev_{{\mathrm{1}}}}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{wrapI} \, \cnsym{(}  \tau  \cnsym{,}  pval  \cnsym{)}  \Rightarrow  \cnmv{y}  {:}  \beta  . \:  \cnmv{y}  =  \cnkw{if} \, \cnmv{abbrev_{{\mathrm{2}}}}  \leq   \mathrm{max\_int}_{  \tau  }  \, \cnkw{then} \, \cnmv{abbrev_{{\mathrm{2}}}} \, \cnkw{else} \, \cnmv{abbrev_{{\mathrm{2}}}}  \cnsym{-}  \cnmv{abbrev_{{\mathrm{1}}}}}{%
{\cndrulename{Ty\_PE\_WrapI}}{}%
}}

\newcommand{\cndefnTyXXPE}[1]{\begin{cndefnblock}[#1]{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pexpr  \Rightarrow  \cnmv{ident}  {:}  \beta  . \:  term$}{}
\cnusedrule{\cndruleTyXXPEXXVal{}}
\cnusedrule{\cndruleTyXXPEXXArrayXXShift{}}
\cnusedrule{\cndruleTyXXPEXXMemberXXShift{}}
\cnusedrule{\cndruleTyXXPEXXNot{}}
\cnusedrule{\cndruleTyXXPEXXArithXXBinop{}}
\cnusedrule{\cndruleTyXXPEXXRelXXBinop{}}
\cnusedrule{\cndruleTyXXPEXXBoolXXBinop{}}
\cnusedrule{\cndruleTyXXPEXXCall{}}
\cnusedrule{\cndruleTyXXPEXXAssertXXUndef{}}
\cnusedrule{\cndruleTyXXPEXXBoolXXToXXInteger{}}
\cnusedrule{\cndruleTyXXPEXXWrapI{}}
\end{cndefnblock}}


\newcommand{\cndefnspexprXXjtype}{
\cndefnTyXXPE{}}

% defns comp_pattern_jtype
%% defn Comp_
\newcommand{\cndruleTyXXPatXXCompXXNoXXSymXXAnnot}[1]{\cndrule[#1]{%
}{
\cnmv{\_}  {:}  \beta  {:}  \beta  \leadsto  \cdot \, \cnkw{with} \, \cnmv{\_}}{%
{\cndrulename{Ty\_Pat\_Comp\_No\_Sym\_Annot}}{}%
}}


\newcommand{\cndruleTyXXPatXXCompXXSymXXAnnot}[1]{\cndrule[#1]{%
}{
\cnmv{x}  {:}  \beta  {:}  \beta  \leadsto  \cdot  \cnsym{,}  \cnmv{x}  {:}  \beta \, \cnkw{with} \, \cnmv{x}}{%
{\cndrulename{Ty\_Pat\_Comp\_Sym\_Annot}}{}%
}}


\newcommand{\cndruleTyXXPatXXCompXXNil}[1]{\cndrule[#1]{%
}{
\cnkw{Nil} \, \beta  \cnsym{(}  \,  \cnsym{)}  {:}  \cnkw{list} \, \beta  \leadsto  \cdot \, \cnkw{with} \, \cnkw{nil}}{%
{\cndrulename{Ty\_Pat\_Comp\_Nil}}{}%
}}


\newcommand{\cndruleTyXXPatXXCompXXCons}[1]{\cndrule[#1]{%
\cnpremise{pattern_{{\mathrm{1}}}  {:}  \beta  \leadsto  \mathcal{C}_{{\mathrm{1}}} \, \cnkw{with} \, term_{{\mathrm{1}}}}%
\cnpremise{pattern_{{\mathrm{2}}}  {:}  \cnkw{list} \, \beta  \leadsto  \mathcal{C}_{{\mathrm{2}}} \, \cnkw{with} \, term_{{\mathrm{2}}}}%
}{
\cnkw{Cons}  \cnsym{(}  pattern_{{\mathrm{1}}}  \cnsym{,}  pattern_{{\mathrm{2}}}  \cnsym{)}  {:}  \cnkw{list} \, \beta  \leadsto  \mathcal{C}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{C}_{{\mathrm{2}}} \, \cnkw{with} \,  term_{{\mathrm{1}}}  ::  term_{{\mathrm{2}}} }{%
{\cndrulename{Ty\_Pat\_Comp\_Cons}}{}%
}}


\newcommand{\cndruleTyXXPatXXCompXXTuple}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{pattern_{\cnmv{i}}  {:}  \beta_{\cnmv{i}}  \leadsto  \mathcal{C}_{\cnmv{i}} \, \cnkw{with} \, term_{\cnmv{i}}}{\cnmv{i}}}%
}{
\cnkw{Tuple}  \cnsym{(} \, \cncomp{pattern_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}  {:}  \cncomp{\beta_{\cnmv{i}}}{\cnmv{i}}  \leadsto  \cncomp{\mathcal{C}_{\cnmv{i}}}{\cnmv{i}} \, \cnkw{with} \, \cnsym{(} \, \cncomp{term_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}}{%
{\cndrulename{Ty\_Pat\_Comp\_Tuple}}{}%
}}


\newcommand{\cndruleTyXXPatXXCompXXArray}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{pattern_{\cnmv{i}}  {:}  \beta  \leadsto  \mathcal{C}_{\cnmv{i}} \, \cnkw{with} \, term_{\cnmv{i}}}{\cnmv{i}}}%
}{
\cnkw{Array}  \cnsym{(} \, \cncomp{pattern_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}  {:}  \cnkw{array} \, \beta  \leadsto  \cncomp{\mathcal{C}_{\cnmv{i}}}{\cnmv{i}} \, \cnkw{with} \, \cnsym{[}  \mid \, \cncomp{term_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{\mbox{$\mid$}]}}{%
{\cndrulename{Ty\_Pat\_Comp\_Array}}{}%
}}


\newcommand{\cndruleTyXXPatXXCompXXSpecified}[1]{\cndrule[#1]{%
\cnpremise{pattern  {:}  \beta  \leadsto  \mathcal{C} \, \cnkw{with} \, term}%
}{
\cnkw{Specified}  \cnsym{(}  pattern  \cnsym{)}  {:}  \beta  \leadsto  \mathcal{C} \, \cnkw{with} \, term}{%
{\cndrulename{Ty\_Pat\_Comp\_Specified}}{}%
}}

\newcommand{\cndefnTyXXPatXXCompXX}[1]{\begin{cndefnblock}[#1]{$pattern  {:}  \beta  \leadsto  \mathcal{C} \, \cnkw{with} \, term$}{}
\cnusedrule{\cndruleTyXXPatXXCompXXNoXXSymXXAnnot{}}
\cnusedrule{\cndruleTyXXPatXXCompXXSymXXAnnot{}}
\cnusedrule{\cndruleTyXXPatXXCompXXNil{}}
\cnusedrule{\cndruleTyXXPatXXCompXXCons{}}
\cnusedrule{\cndruleTyXXPatXXCompXXTuple{}}
\cnusedrule{\cndruleTyXXPatXXCompXXArray{}}
\cnusedrule{\cndruleTyXXPatXXCompXXSpecified{}}
\end{cndefnblock}}

%% defn Sym_Or_Pattern
\newcommand{\cndruleTyXXPatXXSymXXOrXXPatternXXSym}[1]{\cndrule[#1]{%
}{
\cnmv{x}  {:}  \beta  \leadsto  \cdot  \cnsym{,}  \cnmv{x}  {:}  \beta \, \cnkw{with} \, \cnmv{x}}{%
{\cndrulename{Ty\_Pat\_Sym\_Or\_Pattern\_Sym}}{}%
}}


\newcommand{\cndruleTyXXPatXXSymXXOrXXPatternXXPattern}[1]{\cndrule[#1]{%
\cnpremise{pattern  {:}  \beta  \leadsto  \mathcal{C} \, \cnkw{with} \, term}%
}{
pattern  {:}  \beta  \leadsto  \mathcal{C} \, \cnkw{with} \, term}{%
{\cndrulename{Ty\_Pat\_Sym\_Or\_Pattern\_Pattern}}{}%
}}

\newcommand{\cndefnTyXXPatXXSymXXOrXXPattern}[1]{\begin{cndefnblock}[#1]{$ident\_or\_pattern  {:}  \beta  \leadsto  \mathcal{C} \, \cnkw{with} \, term$}{}
\cnusedrule{\cndruleTyXXPatXXSymXXOrXXPatternXXSym{}}
\cnusedrule{\cndruleTyXXPatXXSymXXOrXXPatternXXPattern{}}
\end{cndefnblock}}


\newcommand{\cndefnscompXXpatternXXjtype}{
\cndefnTyXXPatXXCompXX{}\cndefnTyXXPatXXSymXXOrXXPattern{}}

% defns res_pattern_jtype
%% defn Res_StripIfs_
\newcommand{\cndruleTyXXPatXXResXXStripIfsXXEmpty}[1]{\cndrule[#1]{%
}{
\Phi  \vdash  \cnkw{emp}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  \cnkw{emp}  \cnsym{)}}{%
{\cndrulename{Ty\_Pat\_Res\_StripIfs\_Empty}}{}%
}}


\newcommand{\cndruleTyXXPatXXResXXStripIfsXXPointsTo}[1]{\cndrule[#1]{%
}{
\Phi  \vdash  \cnnt{pt}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  \cnnt{pt}  \cnsym{)}}{%
{\cndrulename{Ty\_Pat\_Res\_StripIfs\_PointsTo}}{}%
}}


\newcommand{\cndruleTyXXPatXXResXXStripIfsXXSepConj}[1]{\cndrule[#1]{%
}{
\Phi  \vdash  \cnnt{res_{{\mathrm{1}}}}  *  \cnnt{res_{{\mathrm{2}}}}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  \cnnt{res_{{\mathrm{1}}}}  *  \cnnt{res_{{\mathrm{2}}}}  \cnsym{)}}{%
{\cndrulename{Ty\_Pat\_Res\_StripIfs\_SepConj}}{}%
}}


\newcommand{\cndruleTyXXPatXXResXXStripIfsXXExists}[1]{\cndrule[#1]{%
}{
\Phi  \vdash  \exists \, \cnmv{x}  {:}  \beta  . \:  \cnnt{res}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  \exists \, \cnmv{x}  {:}  \beta  . \:  \cnnt{res}  \cnsym{)}}{%
{\cndrulename{Ty\_Pat\_Res\_StripIfs\_Exists}}{}%
}}


\newcommand{\cndruleTyXXPatXXResXXStripIfsXXTermConj}[1]{\cndrule[#1]{%
}{
\Phi  \vdash  term  \wedge  \cnnt{res}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  term  \wedge  \cnnt{res}  \cnsym{)}}{%
{\cndrulename{Ty\_Pat\_Res\_StripIfs\_TermConj}}{}%
}}


\newcommand{\cndruleTyXXPatXXResXXStripIfsXXTrue}[1]{\cndrule[#1]{%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  term  \cnsym{)}}%
\cnpremise{\Phi  \vdash  \cnnt{res'_{{\mathrm{1}}}}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  \cnnt{res'_{{\mathrm{1}}}}  \cnsym{)}}%
}{
\Phi  \vdash  \cnnt{res'_{{\mathrm{1}}}}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  \cnkw{if} \, term \, \cnkw{then} \, \cnnt{res_{{\mathrm{1}}}} \, \cnkw{else} \, \cnnt{res_{{\mathrm{2}}}}  \cnsym{)}}{%
{\cndrulename{Ty\_Pat\_Res\_StripIfs\_True}}{}%
}}


\newcommand{\cndruleTyXXPatXXResXXStripIfsXXFalse}[1]{\cndrule[#1]{%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  \neg \, term  \cnsym{)}}%
\cnpremise{\Phi  \vdash  \cnnt{res'_{{\mathrm{2}}}}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  \cnnt{res_{{\mathrm{2}}}}  \cnsym{)}}%
}{
\Phi  \vdash  \cnnt{res'_{{\mathrm{2}}}}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  \cnkw{if} \, term \, \cnkw{then} \, \cnnt{res_{{\mathrm{1}}}} \, \cnkw{else} \, \cnnt{res_{{\mathrm{2}}}}  \cnsym{)}}{%
{\cndrulename{Ty\_Pat\_Res\_StripIfs\_False}}{}%
}}


\newcommand{\cndruleTyXXPatXXResXXStripIfsXXUnderDet}[1]{\cndrule[#1]{%
}{
\Phi  \vdash  \cnkw{if} \, term \, \cnkw{then} \, \cnnt{res_{{\mathrm{1}}}} \, \cnkw{else} \, \cnnt{res_{{\mathrm{2}}}}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  \cnkw{if} \, term \, \cnkw{then} \, \cnnt{res_{{\mathrm{1}}}} \, \cnkw{else} \, \cnnt{res_{{\mathrm{2}}}}  \cnsym{)}}{%
{\cndrulename{Ty\_Pat\_Res\_StripIfs\_UnderDet}}{}%
}}


\newcommand{\cndruleTyXXPatXXResXXStripIfsXXPred}[1]{\cndrule[#1]{%
}{
\Phi  \vdash  { \alpha }  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  { \alpha }  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}  \cnsym{)}}{%
{\cndrulename{Ty\_Pat\_Res\_StripIfs\_Pred}}{}%
}}

\newcommand{\cndefnTyXXPatXXResXXStripIfsXX}[1]{\begin{cndefnblock}[#1]{$\Phi  \vdash  \cnnt{res'}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  \cnnt{res}  \cnsym{)}$}{}
\cnusedrule{\cndruleTyXXPatXXResXXStripIfsXXEmpty{}}
\cnusedrule{\cndruleTyXXPatXXResXXStripIfsXXPointsTo{}}
\cnusedrule{\cndruleTyXXPatXXResXXStripIfsXXSepConj{}}
\cnusedrule{\cndruleTyXXPatXXResXXStripIfsXXExists{}}
\cnusedrule{\cndruleTyXXPatXXResXXStripIfsXXTermConj{}}
\cnusedrule{\cndruleTyXXPatXXResXXStripIfsXXTrue{}}
\cnusedrule{\cndruleTyXXPatXXResXXStripIfsXXFalse{}}
\cnusedrule{\cndruleTyXXPatXXResXXStripIfsXXUnderDet{}}
\cnusedrule{\cndruleTyXXPatXXResXXStripIfsXXPred{}}
\end{cndefnblock}}

%% defn Res_Match_
\newcommand{\cndruleTyXXPatXXResXXMatchXXEmpty}[1]{\cndrule[#1]{%
}{
\Phi  \vdash  \cnkw{emp} \, \cnkw{as} \, \cnkw{emp}  \leadsto  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot}{%
{\cndrulename{Ty\_Pat\_Res\_Match\_Empty}}{}%
}}


\newcommand{\cndruleTyXXPatXXResXXMatchXXVar}[1]{\cndrule[#1]{%
}{
\Phi  \vdash  \cnnt{res} \, \cnkw{as} \, \cnmv{r}  \leadsto  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{,}  \cnmv{r}  {:}  \cnnt{res}}{%
{\cndrulename{Ty\_Pat\_Res\_Match\_Var}}{}%
}}


\newcommand{\cndruleTyXXPatXXResXXMatchXXSepConj}[1]{\cndrule[#1]{%
\cnpremise{\Phi  \vdash  \cnnt{res\_pattern_{{\mathrm{1}}}}  {:}  \cnnt{res_{{\mathrm{1}}}}  \leadsto  \mathcal{L}_{{\mathrm{1}}}  \cnsym{;}  \Phi_{{\mathrm{1}}}  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}}%
\cnpremise{\Phi  \vdash  \cnnt{res\_pattern_{{\mathrm{2}}}}  {:}  \cnnt{res_{{\mathrm{2}}}}  \leadsto  \mathcal{L}_{{\mathrm{2}}}  \cnsym{;}  \Phi_{{\mathrm{2}}}  \cnsym{;}  \mathcal{R}_{{\mathrm{2}}}}%
}{
\Phi  \vdash  \cnnt{res_{{\mathrm{1}}}}  *  \cnnt{res_{{\mathrm{2}}}} \, \cnkw{as} \, \langle  \cnnt{res\_pattern_{{\mathrm{1}}}}  \cnsym{,}  \cnnt{res\_pattern_{{\mathrm{2}}}}  \rangle  \leadsto  \mathcal{L}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{L}_{{\mathrm{2}}}  \cnsym{;}  \Phi_{{\mathrm{1}}}  \cnsym{,}  \Phi_{{\mathrm{2}}}  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{R}_{{\mathrm{2}}}}{%
{\cndrulename{Ty\_Pat\_Res\_Match\_SepConj}}{}%
}}


\newcommand{\cndruleTyXXPatXXResXXMatchXXConj}[1]{\cndrule[#1]{%
\cnpremise{\Phi  \vdash  \cnnt{res\_pattern}  {:}  \cnnt{res}  \leadsto  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}%
}{
\Phi  \vdash  term  \wedge  \cnnt{res} \, \cnkw{as} \, \cnnt{res\_pattern}  \leadsto  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{,}  term  \cnsym{;}  \mathcal{R}'}{%
{\cndrulename{Ty\_Pat\_Res\_Match\_Conj}}{}%
}}


\newcommand{\cndruleTyXXPatXXResXXMatchXXPack}[1]{\cndrule[#1]{%
\cnpremise{\Phi  \vdash  \cnnt{res\_pattern}  {:}   \cnmv{x}  \cnsym{/}  \cnmv{y}  \cnsym{,}  \cdot  (  \cnnt{res}  )   \leadsto  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}%
}{
\Phi  \vdash  \exists \, \cnmv{y}  {:}  \beta  . \:  \cnnt{res} \, \cnkw{as} \, \cnkw{pack} \, \cnsym{(}  \cnmv{x}  \cnsym{,}  \cnnt{res\_pattern}  \cnsym{)}  \leadsto  \mathcal{L}'  \cnsym{,}  \cnmv{x}  {:}  \beta  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}{%
{\cndrulename{Ty\_Pat\_Res\_Match\_Pack}}{}%
}}


\newcommand{\cndruleTyXXPatXXResXXMatchXXFold}[1]{\cndrule[#1]{%
\cnpremise{{ \alpha } \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}  {:}  \beta_{\cnmv{i}}}{\cnmv{i}} \, \mapsto  \cnnt{res} \, \in \, \cnkw{Globals}}%
\cnpremise{\Phi  \vdash  \cnnt{res\_pattern}  {:}   \cncomp{pval_{\cnmv{i}}  \cnsym{/}  \cnmv{x_{\cnmv{i}}}  \cnsym{,}  \cdot}{\cnmv{i}}  (  \cnnt{res}  )   \leadsto  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}%
}{
\Phi  \vdash  { \alpha }  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)} \, \cnkw{as} \, \cnkw{fold} \, \cnsym{(}  \cnnt{res\_pattern}  \cnsym{)}  \leadsto  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}{%
{\cndrulename{Ty\_Pat\_Res\_Match\_Fold}}{}%
}}

\newcommand{\cndefnTyXXPatXXResXXMatchXX}[1]{\begin{cndefnblock}[#1]{$\Phi  \vdash  \cnnt{res} \, \cnkw{as} \, \cnnt{res\_pattern}  \leadsto  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'$}{}
\cnusedrule{\cndruleTyXXPatXXResXXMatchXXEmpty{}}
\cnusedrule{\cndruleTyXXPatXXResXXMatchXXVar{}}
\cnusedrule{\cndruleTyXXPatXXResXXMatchXXSepConj{}}
\cnusedrule{\cndruleTyXXPatXXResXXMatchXXConj{}}
\cnusedrule{\cndruleTyXXPatXXResXXMatchXXPack{}}
\cnusedrule{\cndruleTyXXPatXXResXXMatchXXFold{}}
\end{cndefnblock}}

%% defn Res_
\newcommand{\cndruleTyXXPatXXResXXStripXXIfs}[1]{\cndrule[#1]{%
\cnpremise{\Phi  \vdash  \cnnt{res'}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  \cnnt{res}  \cnsym{)}}%
\cnpremise{\Phi  \vdash  \cnnt{res'} \, \cnkw{as} \, \cnnt{res\_pattern}  \leadsto  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}%
}{
\Phi  \vdash  \cnnt{res\_pattern}  {:}  \cnnt{res}  \leadsto  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}{%
{\cndrulename{Ty\_Pat\_Res\_Strip\_Ifs}}{}%
}}

\newcommand{\cndefnTyXXPatXXResXX}[1]{\begin{cndefnblock}[#1]{$\Phi  \vdash  \cnnt{res\_pattern}  {:}  \cnnt{res}  \leadsto  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'$}{}
\cnusedrule{\cndruleTyXXPatXXResXXStripXXIfs{}}
\end{cndefnblock}}


\newcommand{\cndefnsresXXpatternXXjtype}{
\cndefnTyXXPatXXResXXStripIfsXX{}\cndefnTyXXPatXXResXXMatchXX{}\cndefnTyXXPatXXResXX{}}

% defns ret_pattern_jtype
%% defn Ret_
\newcommand{\cndruleTyXXPatXXRetXXEmpty}[1]{\cndrule[#1]{%
}{
\Phi  \vdash  \,  {:}  \cnkw{I}  \leadsto  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot}{%
{\cndrulename{Ty\_Pat\_Ret\_Empty}}{}%
}}


\newcommand{\cndruleTyXXPatXXRetXXComp}[1]{\cndrule[#1]{%
\cnpremise{ident\_or\_pattern  {:}  \beta  \leadsto  \mathcal{C}_{{\mathrm{1}}} \, \cnkw{with} \, term_{{\mathrm{1}}}}%
\cnpremise{\Phi  \vdash \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}   term_{{\mathrm{1}}}  \cnsym{/}  \cnmv{y}  \cnsym{,}  \cdot  (  \cnnt{ret}  )   \leadsto  \mathcal{C}_{{\mathrm{2}}}  \cnsym{;}  \mathcal{L}_{{\mathrm{2}}}  \cnsym{;}  \Phi_{{\mathrm{2}}}  \cnsym{;}  \mathcal{R}_{{\mathrm{2}}}}%
}{
\Phi  \vdash  \cnkw{comp} \, ident\_or\_pattern  \cnsym{,} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \Sigma \, \cnmv{y}  {:}  \beta  . \:  \cnnt{ret}  \leadsto  \mathcal{C}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{C}_{{\mathrm{2}}}  \cnsym{;}  \mathcal{L}_{{\mathrm{2}}}  \cnsym{;}  \Phi_{{\mathrm{2}}}  \cnsym{;}  \mathcal{R}_{{\mathrm{2}}}}{%
{\cndrulename{Ty\_Pat\_Ret\_Comp}}{}%
}}


\newcommand{\cndruleTyXXPatXXRetXXLog}[1]{\cndrule[#1]{%
\cnpremise{\Phi  \vdash \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret}  \leadsto  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}%
}{
\Phi  \vdash  \cnkw{log} \, \cnmv{y}  \cnsym{,} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \exists \, \cnmv{y}  {:}  \beta  . \:  \cnnt{ret}  \leadsto  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{,}  \cnmv{y}  {:}  \beta  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}{%
{\cndrulename{Ty\_Pat\_Ret\_Log}}{}%
}}


\newcommand{\cndruleTyXXPatXXRetXXRes}[1]{\cndrule[#1]{%
\cnpremise{\Phi  \vdash  \cnnt{res\_pattern}  {:}  \cnnt{res}  \leadsto  \mathcal{L}_{{\mathrm{1}}}  \cnsym{;}  \Phi_{{\mathrm{1}}}  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}}%
\cnpremise{\Phi  \vdash \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret}  \leadsto  \mathcal{C}_{{\mathrm{2}}}  \cnsym{;}  \mathcal{L}_{{\mathrm{2}}}  \cnsym{;}  \Phi_{{\mathrm{2}}}  \cnsym{;}  \mathcal{R}_{{\mathrm{2}}}}%
}{
\Phi  \vdash  \texttt{res} \, \cnnt{res\_pattern}  \cnsym{,} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{res}  \otimes  \cnnt{ret}  \leadsto  \mathcal{C}_{{\mathrm{2}}}  \cnsym{;}  \mathcal{L}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{L}_{{\mathrm{2}}}  \cnsym{;}  \Phi_{{\mathrm{1}}}  \cnsym{,}  \Phi_{{\mathrm{2}}}  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{R}_{{\mathrm{2}}}}{%
{\cndrulename{Ty\_Pat\_Ret\_Res}}{}%
}}


\newcommand{\cndruleTyXXPatXXRetXXPhi}[1]{\cndrule[#1]{%
\cnpremise{\Phi  \vdash \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret}  \leadsto  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'}%
}{
\Phi  \vdash \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  term  \wedge  \cnnt{ret}  \leadsto  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{,}  term  \cnsym{;}  \mathcal{R}'}{%
{\cndrulename{Ty\_Pat\_Ret\_Phi}}{}%
}}

\newcommand{\cndefnTyXXPatXXRetXX}[1]{\begin{cndefnblock}[#1]{$\Phi  \vdash \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret}  \leadsto  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'$}{}
\cnusedrule{\cndruleTyXXPatXXRetXXEmpty{}}
\cnusedrule{\cndruleTyXXPatXXRetXXComp{}}
\cnusedrule{\cndruleTyXXPatXXRetXXLog{}}
\cnusedrule{\cndruleTyXXPatXXRetXXRes{}}
\cnusedrule{\cndruleTyXXPatXXRetXXPhi{}}
\end{cndefnblock}}


\newcommand{\cndefnsretXXpatternXXjtype}{
\cndefnTyXXPatXXRetXX{}}

% defns tpval_jtype
%% defn TPVal
\newcommand{\cndruleTyXXTPValXXUndef}[1]{\cndrule[#1]{%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  \cnkw{false}  \cnsym{)}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{undef} \,  \, \cnmv{UB\_name}  \Leftarrow  \cnmv{y}  {:}  \beta  . \:  term}{%
{\cndrulename{Ty\_TPVal\_Undef}}{}%
}}


\newcommand{\cndruleTyXXTPValXXDone}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \beta}%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow   pval  \cnsym{/}  \cnmv{y}  \cnsym{,}  \cdot  (  \cnnt{term}  )   \cnsym{)}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{done} \, pval  \Leftarrow  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}}{%
{\cndrulename{Ty\_TPVal\_Done}}{}%
}}

\newcommand{\cndefnTyXXTPVal}[1]{\begin{cndefnblock}[#1]{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  tpval  \Leftarrow  \cnmv{ident}  {:}  \beta  . \:  term$}{}
\cnusedrule{\cndruleTyXXTPValXXUndef{}}
\cnusedrule{\cndruleTyXXTPValXXDone{}}
\end{cndefnblock}}


\newcommand{\cndefnstpvalXXjtype}{
\cndefnTyXXTPVal{}}

% defns tpexpr_jtype
%% defn TPE
\newcommand{\cndruleTyXXTPEXXIf}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \cnkw{bool}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{,}   pval   =  \cnkw{true}  \vdash  tpexpr_{{\mathrm{1}}}  \Leftarrow  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{,}   pval   =  \cnkw{false}  \vdash  tpexpr_{{\mathrm{2}}}  \Leftarrow  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{if} \, pval \, \cnkw{then} \, tpexpr_{{\mathrm{1}}} \, \cnkw{else} \, tpexpr_{{\mathrm{2}}}  \Leftarrow  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}}{%
{\cndrulename{Ty\_TPE\_If}}{}%
}}


\newcommand{\cndruleTyXXTPEXXLet}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pexpr  \Rightarrow  \cnmv{y_{{\mathrm{1}}}}  {:}  \beta_{{\mathrm{1}}}  . \:  \cnnt{term_{{\mathrm{1}}}}}%
\cnpremise{ident\_or\_pattern  {:}  \beta_{{\mathrm{1}}}  \leadsto  \mathcal{C}_{{\mathrm{1}}} \, \cnkw{with} \, term}%
\cnpremise{\mathcal{C}  \cnsym{,}  \mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{,}   term  \cnsym{/}  \cnmv{y_{{\mathrm{1}}}}  \cnsym{,}  \cdot  (  \cnnt{term_{{\mathrm{1}}}}  )   \vdash  tpexpr  \Leftarrow  \cnmv{y_{{\mathrm{2}}}}  {:}  \beta_{{\mathrm{2}}}  . \:  \cnnt{term_{{\mathrm{2}}}}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{let} \, ident\_or\_pattern  =  pexpr \, \cnkw{in} \, tpexpr  \Leftarrow  \cnmv{y_{{\mathrm{2}}}}  {:}  \beta_{{\mathrm{2}}}  . \:  \cnnt{term_{{\mathrm{2}}}}}{%
{\cndrulename{Ty\_TPE\_Let}}{}%
}}


\newcommand{\cndruleTyXXTPEXXLetT}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  tpexpr_{{\mathrm{1}}}  \Leftarrow  \cnmv{y_{{\mathrm{1}}}}  {:}  \beta_{{\mathrm{1}}}  . \:  \cnnt{term_{{\mathrm{1}}}}}%
\cnpremise{ident\_or\_pattern  {:}  \beta_{{\mathrm{1}}}  \leadsto  \mathcal{C}_{{\mathrm{1}}} \, \cnkw{with} \, term}%
\cnpremise{\mathcal{C}  \cnsym{,}  \mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{,}   term  \cnsym{/}  \cnmv{y_{{\mathrm{1}}}}  \cnsym{,}  \cdot  (  \cnnt{term_{{\mathrm{1}}}}  )   \vdash  tpexpr  \Leftarrow  \cnmv{y_{{\mathrm{2}}}}  {:}  \beta_{{\mathrm{2}}}  . \:  \cnnt{term_{{\mathrm{2}}}}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{let} \, ident\_or\_pattern  {:}  \cnsym{(}  \cnmv{y_{{\mathrm{1}}}}  {:}  \beta_{{\mathrm{1}}}  . \:  \cnnt{term_{{\mathrm{1}}}}  \cnsym{)}  =  tpexpr_{{\mathrm{1}}} \, \cnkw{in} \, tpexpr_{{\mathrm{2}}}  \Leftarrow  \cnmv{y_{{\mathrm{2}}}}  {:}  \beta_{{\mathrm{2}}}  . \:  \cnnt{term_{{\mathrm{2}}}}}{%
{\cndrulename{Ty\_TPE\_LetT}}{}%
}}


\newcommand{\cndruleTyXXTPEXXCase}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \beta_{{\mathrm{1}}}}%
\cnpremise{\cncomp{pattern_{\cnmv{i}}  {:}  \beta_{{\mathrm{1}}}  \leadsto  \mathcal{C}_{\cnmv{i}} \, \cnkw{with} \, term_{\cnmv{i}}}{\cnmv{i}}}%
\cnpremise{\cncomp{\mathcal{C}  \cnsym{,}  \mathcal{C}_{\cnmv{i}}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{,}  term_{\cnmv{i}}  =   pval   \vdash  tpexpr_{\cnmv{i}}  \Leftarrow  \cnmv{y_{{\mathrm{2}}}}  {:}  \beta_{{\mathrm{2}}}  . \:  \cnnt{term_{{\mathrm{2}}}}}{\cnmv{i}}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnkw{case} \, pval \, \cnkw{of} \, \cncomp{\mid  pattern_{\cnmv{i}}  \Rightarrow  tpexpr_{\cnmv{i}}}{\cnmv{i}} \, \cnkw{end}  \Leftarrow  \cnmv{y_{{\mathrm{2}}}}  {:}  \beta_{{\mathrm{2}}}  . \:  \cnnt{term_{{\mathrm{2}}}}}{%
{\cndrulename{Ty\_TPE\_Case}}{}%
}}

\newcommand{\cndefnTyXXTPE}[1]{\begin{cndefnblock}[#1]{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  tpexpr  \Leftarrow  \cnmv{ident}  {:}  \beta  . \:  term$}{}
\cnusedrule{\cndruleTyXXTPEXXIf{}}
\cnusedrule{\cndruleTyXXTPEXXLet{}}
\cnusedrule{\cndruleTyXXTPEXXLetT{}}
\cnusedrule{\cndruleTyXXTPEXXCase{}}
\end{cndefnblock}}


\newcommand{\cndefnstpexprXXjtype}{
\cndefnTyXXTPE{}}

% defns action_jtype
%% defn Action
\newcommand{\cndruleTyXXActionXXCreate}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \cnkw{integer}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \cdot  \vdash  \cnkw{create} \, \cnsym{(}  pval  \cnsym{,}  \tau  \cnsym{)}    \Rightarrow  \Sigma \, { y_p }  {:}  \cnkw{loc}  . \:  \cnkw{representable} \, \cnsym{(}  \tau  *  \cnsym{,}  { y_p }  \cnsym{)}  \wedge  \cnkw{alignedI} \, \cnsym{(}   pval   \cnsym{,}  { y_p }  \cnsym{)}  \wedge  \exists \, \cnmv{y}  {:}   \beta_{  \tau  }   . \:    { y_p }  \mathbin{ { \overset{   {  \times  }   }{ \mapsto } }_{  \tau  } }  \cnmv{y}    \otimes  \cnkw{I}}{%
{\cndrulename{Ty\_Action\_Create}}{}%
}}


\newcommand{\cndruleTyXXActionXXLoad}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{0}}}  \Rightarrow  \cnkw{loc}}%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow   pval_{{\mathrm{0}}}   =   pval_{{\mathrm{1}}}   \cnsym{)}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash    pval_{{\mathrm{1}}}   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }   pval_{{\mathrm{2}}}    \Leftarrow    pval_{{\mathrm{1}}}   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }   pval_{{\mathrm{2}}}  }%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{load} \, \cnsym{(}  \tau  \cnsym{,}  pval_{{\mathrm{0}}}  \cnsym{,}  \_  \cnsym{,}    pval_{{\mathrm{1}}}   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }   pval_{{\mathrm{2}}}    \cnsym{)}  \Rightarrow  \Sigma \, \cnmv{y}  {:}   \beta_{  \tau  }   . \:  \cnmv{y}  =   pval_{{\mathrm{2}}}   \wedge     pval_{{\mathrm{1}}}   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }   pval_{{\mathrm{2}}}     \otimes  \cnkw{I}}{%
{\cndrulename{Ty\_Action\_Load}}{}%
}}


\newcommand{\cndruleTyXXActionXXStore}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{0}}}  \Rightarrow  \cnkw{loc}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{1}}}  \Rightarrow   \beta_{  \tau  } }%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  \cnkw{representable} \, \cnsym{(}  \tau  \cnsym{,}   pval_{{\mathrm{1}}}   \cnsym{)}  \cnsym{)}}%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow   pval_{{\mathrm{2}}}   =   pval_{{\mathrm{0}}}   \cnsym{)}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash    pval_{{\mathrm{2}}}   \mathbin{ { \overset{    }{ \mapsto } }_{  \tau  } }  \_   \Leftarrow    pval_{{\mathrm{2}}}   \mathbin{ { \overset{    }{ \mapsto } }_{  \tau  } }  \_ }%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{store} \, \cnsym{(}  \_  \cnsym{,}  \tau  \cnsym{,}  pval_{{\mathrm{0}}}  \cnsym{,}  pval_{{\mathrm{1}}}  \cnsym{,}  \_  \cnsym{,}    pval_{{\mathrm{2}}}   \mathbin{ { \overset{    }{ \mapsto } }_{  \tau  } }  \_   \cnsym{)}  \Rightarrow  \Sigma \, \cnmv{\_}  {:}  \cnkw{unit}  . \:     pval_{{\mathrm{2}}}   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }   pval_{{\mathrm{1}}}     \otimes  \cnkw{I}}{%
{\cndrulename{Ty\_Action\_Store}}{}%
}}


\newcommand{\cndruleTyXXActionXXKillXXStatic}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{0}}}  \Rightarrow  \cnkw{loc}}%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow   pval_{{\mathrm{0}}}   =   pval_{{\mathrm{1}}}   \cnsym{)}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash    pval_{{\mathrm{1}}}   \mathbin{ { \overset{    }{ \mapsto } }_{  \tau  } }  \_   \Leftarrow    pval_{{\mathrm{1}}}   \mathbin{ { \overset{    }{ \mapsto } }_{  \tau  } }  \_ }%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{kill} \, \cnsym{(}  \cnkw{static} \, \tau  \cnsym{,}  pval_{{\mathrm{0}}}  \cnsym{,}    pval_{{\mathrm{1}}}   \mathbin{ { \overset{    }{ \mapsto } }_{  \tau  } }  \_   \cnsym{)}  \Rightarrow  \Sigma \, \cnmv{\_}  {:}  \cnkw{unit}  . \:  \cnkw{I}}{%
{\cndrulename{Ty\_Action\_Kill\_Static}}{}%
}}

\newcommand{\cndefnTyXXAction}[1]{\begin{cndefnblock}[#1]{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  mem\_action  \Rightarrow  \cnnt{ret}$}{}
\cnusedrule{\cndruleTyXXActionXXCreate{}}
\cnusedrule{\cndruleTyXXActionXXLoad{}}
\cnusedrule{\cndruleTyXXActionXXStore{}}
\cnusedrule{\cndruleTyXXActionXXKillXXStatic{}}
\end{cndefnblock}}


\newcommand{\cndefnsactionXXjtype}{
\cndefnTyXXAction{}}

% defns memop_jtype
%% defn Memop
\newcommand{\cndruleTyXXMemopXXRelXXBinop}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{1}}}  \Rightarrow  \cnkw{loc}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{2}}}  \Rightarrow  \cnkw{loc}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \cdot  \vdash  pval_{{\mathrm{1}}} \, \mathbin{ binop_{rel} } \, pval_{{\mathrm{2}}}  \Rightarrow  \Sigma \, \cnmv{y}  {:}  \cnkw{bool}  . \:  \cnmv{y}  =  \cnsym{(}    pval_{{\mathrm{1}}}    \mathbin{ binop_{rel} }    pval_{{\mathrm{2}}}    \cnsym{)}  \wedge  \cnkw{I}}{%
{\cndrulename{Ty\_Memop\_Rel\_Binop}}{}%
}}


\newcommand{\cndruleTyXXMemopXXIntFromPtr}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \cnkw{loc}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \cdot  \vdash  \cnkw{intFromPtr} \, \cnsym{(}  \tau_{{\mathrm{1}}}  \cnsym{,}  \tau_{{\mathrm{2}}}  \cnsym{,}  pval  \cnsym{)}  \Rightarrow  \Sigma \, \cnmv{y}  {:}  \cnkw{integer}  . \:  \cnmv{y}  =  \cnkw{cast\_ptr\_to\_int} \,  pval   \wedge  \cnkw{I}}{%
{\cndrulename{Ty\_Memop\_IntFromPtr}}{}%
}}


\newcommand{\cndruleTyXXMemopXXPtrFromInt}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \cnkw{integer}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \cdot  \vdash  \cnkw{ptrFromInt} \, \cnsym{(}  \tau_{{\mathrm{1}}}  \cnsym{,}  \tau_{{\mathrm{2}}}  \cnsym{,}  pval  \cnsym{)}  \Rightarrow  \Sigma \, \cnmv{y}  {:}  \cnkw{loc}  . \:  \cnmv{y}  =  \cnkw{cast\_int\_to\_ptr} \,  pval   \wedge  \cnkw{I}}{%
{\cndrulename{Ty\_Memop\_PtrFromInt}}{}%
}}


\newcommand{\cndruleTyXXMemopXXPtrValidForDeref}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{0}}}  \Rightarrow  \cnkw{loc}}%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow   pval_{{\mathrm{1}}}   =   pval_{{\mathrm{0}}}   \cnsym{)}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash    pval_{{\mathrm{1}}}   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }  \_   \Leftarrow    pval_{{\mathrm{1}}}   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }  \_ }%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{ptrValidForDeref} \, \cnsym{(}  \tau  \cnsym{,}  pval_{{\mathrm{0}}}  \cnsym{,}    pval_{{\mathrm{1}}}   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }  \_   \cnsym{)}  \Rightarrow  \Sigma \, \cnmv{y}  {:}  \cnkw{bool}  . \:  \cnmv{y}  =  \cnkw{aligned} \, \cnsym{(}  \tau  \cnsym{,}   pval_{{\mathrm{1}}}   \cnsym{)}  \wedge     pval_{{\mathrm{1}}}   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }  \_    \otimes  \cnkw{I}}{%
{\cndrulename{Ty\_Memop\_PtrValidForDeref}}{}%
}}


\newcommand{\cndruleTyXXMemopXXPtrWellAligned}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{1}}}  \Rightarrow  \cnkw{loc}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \cdot  \vdash  \cnkw{ptrWellAligned} \, \cnsym{(}  \tau  \cnsym{,}  pval  \cnsym{)}  \Rightarrow  \Sigma \, \cnmv{y}  {:}  \cnkw{bool}  . \:  \cnmv{y}  =  \cnkw{aligned} \, \cnsym{(}  \tau  \cnsym{,}   pval   \cnsym{)}  \wedge  \cnkw{I}}{%
{\cndrulename{Ty\_Memop\_PtrWellAligned}}{}%
}}


\newcommand{\cndruleTyXXMemopXXPtrArrayShift}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{1}}}  \Rightarrow  \cnkw{loc}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{2}}}  \Rightarrow  \cnkw{integer}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \cdot  \vdash  \cnkw{ptrArrayShift} \, \cnsym{(}  pval_{{\mathrm{1}}}  \cnsym{,}  \tau  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{)}  \Rightarrow  \Sigma \, \cnmv{y}  {:}  \cnkw{loc}  . \:  \cnmv{y}  =   pval_{{\mathrm{1}}}   \mathbin{ {+}_{ \mathrm{ptr} } }  \cnsym{(}   pval_{{\mathrm{2}}}   \times   \mathrm{size\_of}(  \tau  )   \cnsym{)}  \wedge  \cnkw{I}}{%
{\cndrulename{Ty\_Memop\_PtrArrayShift}}{}%
}}

\newcommand{\cndefnTyXXMemop}[1]{\begin{cndefnblock}[#1]{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  mem\_op  \Rightarrow  \cnnt{ret}$}{}
\cnusedrule{\cndruleTyXXMemopXXRelXXBinop{}}
\cnusedrule{\cndruleTyXXMemopXXIntFromPtr{}}
\cnusedrule{\cndruleTyXXMemopXXPtrFromInt{}}
\cnusedrule{\cndruleTyXXMemopXXPtrValidForDeref{}}
\cnusedrule{\cndruleTyXXMemopXXPtrWellAligned{}}
\cnusedrule{\cndruleTyXXMemopXXPtrArrayShift{}}
\end{cndefnblock}}


\newcommand{\cndefnsmemopXXjtype}{
\cndefnTyXXMemop{}}

% defns tval_jtype
%% defn TVal
\newcommand{\cndruleTyXXTValXXI}[1]{\cndrule[#1]{%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \cdot  \vdash  \cnkw{done} \, \,  \Leftarrow  \cnkw{I}}{%
{\cndrulename{Ty\_TVal\_I}}{}%
}}


\newcommand{\cndruleTyXXTValXXComp}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \beta}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{done} \, \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}}  \Leftarrow   pval  \cnsym{/}  \cnmv{y}  \cnsym{,}  \cdot  (  \cnnt{ret}  ) }%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{done} \, pval  \cnsym{,} \, \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}}  \Leftarrow  \Sigma \, \cnmv{y}  {:}  \beta  . \:  \cnnt{ret}}{%
{\cndrulename{Ty\_TVal\_Comp}}{}%
}}


\newcommand{\cndruleTyXXTValXXLog}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \beta}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{done} \, \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}}  \Leftarrow   pval  \cnsym{/}  \cnmv{y}  \cnsym{,}  \cdot  (  \cnnt{ret}  ) }%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{done} \, pval  \cnsym{,} \, \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}}  \Leftarrow  \exists \, \cnmv{y}  {:}  \beta  . \:  \cnnt{ret}}{%
{\cndrulename{Ty\_TVal\_Log}}{}%
}}


\newcommand{\cndruleTyXXTValXXPhi}[1]{\cndrule[#1]{%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  term  \cnsym{)}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{done} \, \cnnt{spine}  \Leftarrow  \cnnt{ret}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{done} \, \cnnt{spine}  \Leftarrow  term  \wedge  \cnnt{ret}}{%
{\cndrulename{Ty\_TVal\_Phi}}{}%
}}


\newcommand{\cndruleTyXXTValXXRes}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \vdash  \cnnt{res\_term}  \Leftarrow  \cnnt{res}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}_{{\mathrm{2}}}  \vdash  \cnkw{done} \, \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}}  \Leftarrow  \cnnt{ret}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{R}_{{\mathrm{2}}}  \vdash  \cnkw{done} \, \cnnt{res\_term}  \cnsym{,} \, \cncomp{\cnnt{spine\_elem}}{\cnmv{i}}  \Leftarrow  \cnnt{res}  \otimes  \cnnt{ret}}{%
{\cndrulename{Ty\_TVal\_Res}}{}%
}}


\newcommand{\cndruleTyXXTValXXUndef}[1]{\cndrule[#1]{%
\cnpremise{\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  \cnkw{false}  \cnsym{)}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \cdot  \vdash  \cnkw{undef} \,  \, \cnmv{UB\_name}  \Leftarrow  \cnnt{ret}}{%
{\cndrulename{Ty\_TVal\_Undef}}{}%
}}

\newcommand{\cndefnTyXXTVal}[1]{\begin{cndefnblock}[#1]{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  tval  \Leftarrow  \cnnt{ret}$}{}
\cnusedrule{\cndruleTyXXTValXXI{}}
\cnusedrule{\cndruleTyXXTValXXComp{}}
\cnusedrule{\cndruleTyXXTValXXLog{}}
\cnusedrule{\cndruleTyXXTValXXPhi{}}
\cnusedrule{\cndruleTyXXTValXXRes{}}
\cnusedrule{\cndruleTyXXTValXXUndef{}}
\end{cndefnblock}}


\newcommand{\cndefnstvalXXjtype}{
\cndefnTyXXTVal{}}

% defns seq_expr_jtype
%% defn Seq_E
\newcommand{\cndruleTyXXSeqXXEXXCCall}[1]{\cndrule[#1]{%
\cnpremise{ident  {:}  \cnnt{arg} \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mapsto  texpr \, \in \, \cnkw{Globals}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{ccall} \, \cnsym{(}  \tau  \cnsym{,}  ident  \cnsym{,}  \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}}  \cnsym{)}  \Rightarrow   \sigma  (  \cnnt{ret}  ) }{%
{\cndrulename{Ty\_Seq\_E\_CCall}}{}%
}}


\newcommand{\cndruleTyXXSeqXXEXXProc}[1]{\cndrule[#1]{%
\cnpremise{name  {:}  \cnnt{arg} \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mapsto  texpr \, \in \, \cnkw{Globals}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{pcall} \, \cnsym{(}  name  \cnsym{,}  \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}}  \cnsym{)}  \Rightarrow   \sigma  (  \cnnt{ret}  ) }{%
{\cndrulename{Ty\_Seq\_E\_Proc}}{}%
}}

\newcommand{\cndefnTyXXSeqXXE}[1]{\begin{cndefnblock}[#1]{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  seq\_expr  \Rightarrow  \cnnt{ret}$}{}
\cnusedrule{\cndruleTyXXSeqXXEXXCCall{}}
\cnusedrule{\cndruleTyXXSeqXXEXXProc{}}
\end{cndefnblock}}


\newcommand{\cndefnsseqXXexprXXjtype}{
\cndefnTyXXSeqXXE{}}

% defns is_expr_jtype
%% defn Is_E
\newcommand{\cndruleTyXXIsXXEXXMemop}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  mem\_op  \Rightarrow  \cnnt{ret}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{memop} \, \cnsym{(}  mem\_op  \cnsym{)}  \Rightarrow  \cnnt{ret}}{%
{\cndrulename{Ty\_Is\_E\_Memop}}{}%
}}


\newcommand{\cndruleTyXXIsXXEXXAction}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  mem\_action  \Rightarrow  \cnnt{ret}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash     \, mem\_action  \Rightarrow  \cnnt{ret}}{%
{\cndrulename{Ty\_Is\_E\_Action}}{}%
}}


\newcommand{\cndruleTyXXIsXXEXXNegXXAction}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  mem\_action  \Rightarrow  \cnnt{ret}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash   \texttt{neg}  \, mem\_action  \Rightarrow  \cnnt{ret}}{%
{\cndrulename{Ty\_Is\_E\_Neg\_Action}}{}%
}}

\newcommand{\cndefnTyXXIsXXE}[1]{\begin{cndefnblock}[#1]{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  is\_expr  \Rightarrow  \cnnt{ret}$}{}
\cnusedrule{\cndruleTyXXIsXXEXXMemop{}}
\cnusedrule{\cndruleTyXXIsXXEXXAction{}}
\cnusedrule{\cndruleTyXXIsXXEXXNegXXAction{}}
\end{cndefnblock}}


\newcommand{\cndefnsisXXexprXXjtype}{
\cndefnTyXXIsXXE{}}

% defns texpr_jtype
%% defn Seq_TE
\newcommand{\cndruleTyXXSeqXXTEXXTVal}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  tval  \Leftarrow  \cnnt{ret}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  tval  \Leftarrow  \cnnt{ret}}{%
{\cndrulename{Ty\_Seq\_TE\_TVal}}{}%
}}


\newcommand{\cndruleTyXXSeqXXTEXXLetP}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pexpr  \Rightarrow  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}}%
\cnpremise{ident\_or\_pattern  {:}  \beta  \leadsto  \mathcal{C}_{{\mathrm{1}}} \, \cnkw{with} \, term_{{\mathrm{1}}}}%
\cnpremise{\mathcal{C}  \cnsym{,}  \mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{,}   term_{{\mathrm{1}}}  \cnsym{/}  \cnmv{y}  \cnsym{,}  \cdot  (  \cnnt{term}  )   \cnsym{;}  \mathcal{R}  \vdash  texpr  \Leftarrow  \cnnt{ret}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{let} \, ident\_or\_pattern  =  pexpr \, \cnkw{in} \, texpr  \Leftarrow  \cnnt{ret}}{%
{\cndrulename{Ty\_Seq\_TE\_LetP}}{}%
}}


\newcommand{\cndruleTyXXSeqXXTEXXLetPT}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  tpexpr  \Leftarrow  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}}%
\cnpremise{ident\_or\_pattern  {:}  \beta  \leadsto  \mathcal{C}_{{\mathrm{1}}} \, \cnkw{with} \, term_{{\mathrm{1}}}}%
\cnpremise{\mathcal{C}  \cnsym{,}  \mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{,}   term_{{\mathrm{1}}}  \cnsym{/}  \cnmv{y}  \cnsym{,}  \cdot  (  \cnnt{term}  )   \cnsym{;}  \mathcal{R}  \vdash  texpr  \Leftarrow  \cnnt{ret}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{let} \, ident\_or\_pattern  {:}  \cnsym{(}  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}  \cnsym{)}  =  tpexpr \, \cnkw{in} \, texpr  \Leftarrow  \cnnt{ret}}{%
{\cndrulename{Ty\_Seq\_TE\_LetPT}}{}%
}}


\newcommand{\cndruleTyXXSeqXXTEXXLet}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}'  \vdash  seq\_expr  \Rightarrow  \cnnt{ret_{{\mathrm{1}}}}}%
\cnpremise{\Phi  \vdash \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret_{{\mathrm{1}}}}  \leadsto  \mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \mathcal{L}_{{\mathrm{1}}}  \cnsym{;}  \Phi_{{\mathrm{1}}}  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}}%
\cnpremise{\mathcal{C}  \cnsym{,}  \mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \mathcal{L}  \cnsym{,}  \mathcal{L}_{{\mathrm{1}}}  \cnsym{;}  \Phi  \cnsym{,}  \Phi_{{\mathrm{1}}}  \cnsym{;}  \mathcal{R}  \cnsym{,}  \mathcal{R}_{{\mathrm{1}}}  \vdash  texpr  \Leftarrow  \cnnt{ret_{{\mathrm{2}}}}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}'  \cnsym{,}  \mathcal{R}  \vdash  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, =  seq\_expr \, \cnkw{in} \, texpr  \Leftarrow  \cnnt{ret_{{\mathrm{2}}}}}{%
{\cndrulename{Ty\_Seq\_TE\_Let}}{}%
}}


\newcommand{\cndruleTyXXSeqXXTEXXLetT}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}'  \vdash  texpr_{{\mathrm{1}}}  \Leftarrow  \cnnt{ret_{{\mathrm{1}}}}}%
\cnpremise{\Phi  \vdash \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret_{{\mathrm{1}}}}  \leadsto  \mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \mathcal{L}_{{\mathrm{1}}}  \cnsym{;}  \Phi_{{\mathrm{1}}}  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}}%
\cnpremise{\mathcal{C}  \cnsym{,}  \mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \mathcal{L}  \cnsym{,}  \mathcal{L}_{{\mathrm{1}}}  \cnsym{;}  \Phi  \cnsym{,}  \Phi_{{\mathrm{1}}}  \cnsym{;}  \mathcal{R}  \cnsym{,}  \mathcal{R}_{{\mathrm{1}}}  \vdash  texpr_{{\mathrm{2}}}  \Leftarrow  \cnnt{ret_{{\mathrm{2}}}}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}'  \cnsym{,}  \mathcal{R}  \vdash  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret_{{\mathrm{1}}}}  =  texpr_{{\mathrm{1}}} \, \cnkw{in} \, texpr_{{\mathrm{2}}}  \Leftarrow  \cnnt{ret_{{\mathrm{2}}}}}{%
{\cndrulename{Ty\_Seq\_TE\_LetT}}{}%
}}


\newcommand{\cndruleTyXXSeqXXTEXXCase}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \beta_{{\mathrm{1}}}}%
\cnpremise{\cncomp{pattern_{\cnmv{i}}  {:}  \beta_{{\mathrm{1}}}  \leadsto  \mathcal{C}_{\cnmv{i}} \, \cnkw{with} \, term_{\cnmv{i}}}{\cnmv{i}}}%
\cnpremise{\cncomp{\mathcal{C}  \cnsym{,}  \mathcal{C}_{\cnmv{i}}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{,}  term_{\cnmv{i}}  =   pval   \cnsym{;}  \mathcal{R}  \vdash  texpr_{\cnmv{i}}  \Leftarrow  \cnnt{ret}}{\cnmv{i}}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{case} \, pval \, \cnkw{of} \, \cncomp{\mid  pattern_{\cnmv{i}}  \Rightarrow  texpr_{\cnmv{i}}}{\cnmv{i}} \, \cnkw{end}  \Leftarrow  \cnnt{ret}}{%
{\cndrulename{Ty\_Seq\_TE\_Case}}{}%
}}


\newcommand{\cndruleTyXXSeqXXTEXXIf}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \cnkw{bool}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{,}   pval   =  \cnkw{true}  \cnsym{;}  \mathcal{R}  \vdash  texpr_{{\mathrm{1}}}  \Leftarrow  \cnnt{ret}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{,}   pval   =  \cnkw{false}  \cnsym{;}  \mathcal{R}  \vdash  texpr_{{\mathrm{2}}}  \Leftarrow  \cnnt{ret}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{if} \, pval \, \cnkw{then} \, texpr_{{\mathrm{1}}} \, \cnkw{else} \, texpr_{{\mathrm{2}}}  \Leftarrow  \cnnt{ret}}{%
{\cndrulename{Ty\_Seq\_TE\_If}}{}%
}}


\newcommand{\cndruleTyXXSeqXXTEXXRun}[1]{\cndrule[#1]{%
\cnpremise{ident  {:}  \cnnt{arg} \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mapsto  texpr \, \in \, \cnkw{Globals}}%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \cdot  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  pval_{\cnmv{i}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnkw{false}  \wedge  \cnkw{I}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \cdot  \vdash  \cnkw{run} \, ident \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}}  \Leftarrow  \cnkw{false}  \wedge  \cnkw{I}}{%
{\cndrulename{Ty\_Seq\_TE\_Run}}{}%
}}


\newcommand{\cndruleTyXXSeqXXTEXXBound}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  is\_texpr  \Leftarrow  \cnnt{ret}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{bound} \, \cnsym{[}  int  \cnsym{]}  \cnsym{(}  is\_texpr  \cnsym{)}  \Leftarrow  \cnnt{ret}}{%
{\cndrulename{Ty\_Seq\_TE\_Bound}}{}%
}}

\newcommand{\cndefnTyXXSeqXXTE}[1]{\begin{cndefnblock}[#1]{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  seq\_texpr  \Leftarrow  \cnnt{ret}$}{}
\cnusedrule{\cndruleTyXXSeqXXTEXXTVal{}}
\cnusedrule{\cndruleTyXXSeqXXTEXXLetP{}}
\cnusedrule{\cndruleTyXXSeqXXTEXXLetPT{}}
\cnusedrule{\cndruleTyXXSeqXXTEXXLet{}}
\cnusedrule{\cndruleTyXXSeqXXTEXXLetT{}}
\cnusedrule{\cndruleTyXXSeqXXTEXXCase{}}
\cnusedrule{\cndruleTyXXSeqXXTEXXIf{}}
\cnusedrule{\cndruleTyXXSeqXXTEXXRun{}}
\cnusedrule{\cndruleTyXXSeqXXTEXXBound{}}
\end{cndefnblock}}

%% defn Is_TE
\newcommand{\cndruleTyXXIsXXTEXXLetS}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}'  \vdash  is\_expr  \Rightarrow  \cnnt{ret_{{\mathrm{1}}}}}%
\cnpremise{\Phi  \vdash \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret_{{\mathrm{1}}}}  \leadsto  \mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \mathcal{L}_{{\mathrm{1}}}  \cnsym{;}  \Phi_{{\mathrm{1}}}  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}}%
\cnpremise{\mathcal{C}  \cnsym{,}  \mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \mathcal{L}  \cnsym{,}  \mathcal{L}_{{\mathrm{1}}}  \cnsym{;}  \Phi  \cnsym{,}  \Phi_{{\mathrm{1}}}  \cnsym{;}  \mathcal{R}  \cnsym{,}  \mathcal{R}_{{\mathrm{1}}}  \vdash  texpr  \Leftarrow  \cnnt{ret_{{\mathrm{2}}}}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}'  \cnsym{,}  \mathcal{R}  \vdash  \cnkw{let} \, \cnkw{strong} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, =  is\_expr \, \cnkw{in} \, texpr  \Leftarrow  \cnnt{ret_{{\mathrm{2}}}}}{%
{\cndrulename{Ty\_Is\_TE\_LetS}}{}%
}}

\newcommand{\cndefnTyXXIsXXTE}[1]{\begin{cndefnblock}[#1]{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  is\_texpr  \Leftarrow  \cnnt{ret}$}{}
\cnusedrule{\cndruleTyXXIsXXTEXXLetS{}}
\end{cndefnblock}}

%% defn TE
\newcommand{\cndruleTyXXTEXXIs}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  is\_texpr  \Leftarrow  \cnnt{ret}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  is\_texpr  \Leftarrow  \cnnt{ret}}{%
{\cndrulename{Ty\_TE\_Is}}{}%
}}


\newcommand{\cndruleTyXXTEXXSeq}[1]{\cndrule[#1]{%
\cnpremise{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  seq\_texpr  \Leftarrow  \cnnt{ret}}%
}{
\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  seq\_texpr  \Leftarrow  \cnnt{ret}}{%
{\cndrulename{Ty\_TE\_Seq}}{}%
}}

\newcommand{\cndefnTyXXTE}[1]{\begin{cndefnblock}[#1]{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  texpr  \Leftarrow  \cnnt{ret}$}{}
\cnusedrule{\cndruleTyXXTEXXIs{}}
\cnusedrule{\cndruleTyXXTEXXSeq{}}
\end{cndefnblock}}


\newcommand{\cndefnstexprXXjtype}{
\cndefnTyXXSeqXXTE{}\cndefnTyXXIsXXTE{}\cndefnTyXXTE{}}

% defns subs_jtype
%% defn Decons_Value_
\newcommand{\cndruleSubsXXDeconsXXValueXXNoXXSymXXAnnot}[1]{\cndrule[#1]{%
}{
\cnmv{\_}  {:}  \_  =  pval  \leadsto  \cdot}{%
{\cndrulename{Subs\_Decons\_Value\_No\_Sym\_Annot}}{}%
}}


\newcommand{\cndruleSubsXXDeconsXXValueXXSymXXAnnot}[1]{\cndrule[#1]{%
}{
\cnmv{x}  {:}  \_  =  pval  \leadsto  pval  \cnsym{/}  \cnmv{x}  \cnsym{,}  \cdot}{%
{\cndrulename{Subs\_Decons\_Value\_Sym\_Annot}}{}%
}}


\newcommand{\cndruleSubsXXDeconsXXValueXXCons}[1]{\cndrule[#1]{%
\cnpremise{pattern_{{\mathrm{1}}}  =  pval_{{\mathrm{1}}}  \leadsto  \sigma_{{\mathrm{1}}}}%
\cnpremise{pattern_{{\mathrm{2}}}  =  pval_{{\mathrm{2}}}  \leadsto  \sigma_{{\mathrm{2}}}}%
}{
\cnkw{Cons}  \cnsym{(}  pattern_{{\mathrm{1}}}  \cnsym{,}  pattern_{{\mathrm{2}}}  \cnsym{)}  =  \cnkw{Cons}  \cnsym{(}  pval_{{\mathrm{1}}}  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{)}  \leadsto  \sigma_{{\mathrm{1}}}  \cnsym{,}  \sigma_{{\mathrm{2}}}}{%
{\cndrulename{Subs\_Decons\_Value\_Cons}}{}%
}}


\newcommand{\cndruleSubsXXDeconsXXValueXXTuple}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{pattern_{\cnmv{i}}  =  pval_{\cnmv{i}}  \leadsto  \sigma_{\cnmv{i}}}{\cnmv{i}}}%
}{
\cnkw{Tuple}  \cnsym{(} \, \cncomp{pattern_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}  =  \cnkw{Tuple}  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}  \leadsto  \cncomp{\sigma_{\cnmv{i}}}{\cnmv{i}}}{%
{\cndrulename{Subs\_Decons\_Value\_Tuple}}{}%
}}


\newcommand{\cndruleSubsXXDeconsXXValueXXArray}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{pattern_{\cnmv{i}}  =  pval_{\cnmv{i}}  \leadsto  \sigma_{\cnmv{i}}}{\cnmv{i}}}%
}{
\cnkw{Array}  \cnsym{(} \, \cncomp{pattern_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}  =  \cnkw{Array}  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}  \leadsto  \cncomp{\sigma_{\cnmv{i}}}{\cnmv{i}}}{%
{\cndrulename{Subs\_Decons\_Value\_Array}}{}%
}}


\newcommand{\cndruleSubsXXDeconsXXValueXXSpecified}[1]{\cndrule[#1]{%
\cnpremise{pattern  =  pval  \leadsto  \sigma}%
}{
\cnkw{Specified}  \cnsym{(}  pattern  \cnsym{)}  =  pval  \leadsto  \sigma}{%
{\cndrulename{Subs\_Decons\_Value\_Specified}}{}%
}}

\newcommand{\cndefnSubsXXDeconsXXValueXX}[1]{\begin{cndefnblock}[#1]{$pattern  =  pval  \leadsto  \sigma$}{}
\cnusedrule{\cndruleSubsXXDeconsXXValueXXNoXXSymXXAnnot{}}
\cnusedrule{\cndruleSubsXXDeconsXXValueXXSymXXAnnot{}}
\cnusedrule{\cndruleSubsXXDeconsXXValueXXCons{}}
\cnusedrule{\cndruleSubsXXDeconsXXValueXXTuple{}}
\cnusedrule{\cndruleSubsXXDeconsXXValueXXArray{}}
\cnusedrule{\cndruleSubsXXDeconsXXValueXXSpecified{}}
\end{cndefnblock}}

%% defn Decons_Value'_
\newcommand{\cndruleSubsXXDeconsXXValuePPXXSym}[1]{\cndrule[#1]{%
}{
\cnmv{x}  =  pval  \leadsto  pval  \cnsym{/}  \cnmv{x}  \cnsym{,}  \cdot}{%
{\cndrulename{Subs\_Decons\_Value'\_Sym}}{}%
}}


\newcommand{\cndruleSubsXXDeconsXXValuePPXXPattern}[1]{\cndrule[#1]{%
\cnpremise{pattern  =  pval  \leadsto  \sigma}%
}{
pattern  =  pval  \leadsto  \sigma}{%
{\cndrulename{Subs\_Decons\_Value'\_Pattern}}{}%
}}

\newcommand{\cndefnSubsXXDeconsXXValuePPXX}[1]{\begin{cndefnblock}[#1]{$ident\_or\_pattern  =  pval  \leadsto  \sigma$}{}
\cnusedrule{\cndruleSubsXXDeconsXXValuePPXXSym{}}
\cnusedrule{\cndruleSubsXXDeconsXXValuePPXXPattern{}}
\end{cndefnblock}}

%% defn Decons_Res
\newcommand{\cndruleSubsXXDeconsXXResXXEmp}[1]{\cndrule[#1]{%
}{
\cnkw{emp}  =  \cnkw{emp}  \leadsto  \cdot}{%
{\cndrulename{Subs\_Decons\_Res\_Emp}}{}%
}}


\newcommand{\cndruleSubsXXDeconsXXResXXVar}[1]{\cndrule[#1]{%
}{
ident  =  \cnnt{res\_term}  \leadsto  \cnnt{res\_term}  \cnsym{/}  ident  \cnsym{,}  \cdot}{%
{\cndrulename{Subs\_Decons\_Res\_Var}}{}%
}}


\newcommand{\cndruleSubsXXDeconsXXResXXPair}[1]{\cndrule[#1]{%
\cnpremise{\cnnt{res\_pattern_{{\mathrm{1}}}}  =  \cnnt{res\_term_{{\mathrm{1}}}}  \leadsto  \sigma_{{\mathrm{1}}}}%
\cnpremise{\cnnt{res\_pattern_{{\mathrm{2}}}}  =  \cnnt{res\_term_{{\mathrm{2}}}}  \leadsto  \sigma_{{\mathrm{2}}}}%
}{
\langle  \cnnt{res\_pattern_{{\mathrm{1}}}}  \cnsym{,}  \cnnt{res\_pattern_{{\mathrm{2}}}}  \rangle  =  \langle  \cnnt{res\_term_{{\mathrm{1}}}}  \cnsym{,}  \cnnt{res\_term_{{\mathrm{2}}}}  \rangle  \leadsto  \sigma_{{\mathrm{1}}}  \cnsym{,}  \sigma_{{\mathrm{2}}}}{%
{\cndrulename{Subs\_Decons\_Res\_Pair}}{}%
}}


\newcommand{\cndruleSubsXXDeconsXXResXXPack}[1]{\cndrule[#1]{%
\cnpremise{\cnnt{res\_pattern}  =  \cnnt{res\_term}  \leadsto  \sigma}%
}{
\cnkw{pack} \, \cnsym{(}  ident  \cnsym{,}  \cnnt{res\_pattern}  \cnsym{)}  =  \cnkw{pack} \, \cnsym{(}  pval  \cnsym{,}  \cnnt{res\_term}  \cnsym{)}  \leadsto  pval  \cnsym{/}  ident  \cnsym{,}  \sigma}{%
{\cndrulename{Subs\_Decons\_Res\_Pack}}{}%
}}


\newcommand{\cndruleSubsXXDeconsXXResXXFold}[1]{\cndrule[#1]{%
\cnpremise{\cnnt{res\_pattern}  =  \cnnt{res\_term}  \leadsto  \sigma}%
}{
\cnkw{fold} \, \cnsym{(}  \cnnt{res\_pattern}  \cnsym{)}  =  \cnnt{res\_term}  \leadsto  \sigma}{%
{\cndrulename{Subs\_Decons\_Res\_Fold}}{}%
}}

\newcommand{\cndefnSubsXXDeconsXXRes}[1]{\begin{cndefnblock}[#1]{$\cnnt{res\_pattern}  =  \cnnt{res\_term}  \leadsto  \sigma$}{}
\cnusedrule{\cndruleSubsXXDeconsXXResXXEmp{}}
\cnusedrule{\cndruleSubsXXDeconsXXResXXVar{}}
\cnusedrule{\cndruleSubsXXDeconsXXResXXPair{}}
\cnusedrule{\cndruleSubsXXDeconsXXResXXPack{}}
\cnusedrule{\cndruleSubsXXDeconsXXResXXFold{}}
\end{cndefnblock}}

%% defn Decons_Ret
\newcommand{\cndruleSubsXXDeconsXXRetXXEmpty}[1]{\cndrule[#1]{%
}{
\,  \leadsto  \cdot}{%
{\cndrulename{Subs\_Decons\_Ret\_Empty}}{}%
}}


\newcommand{\cndruleSubsXXDeconsXXRetXXComp}[1]{\cndrule[#1]{%
\cnpremise{ident\_or\_pattern  =  pval  \leadsto  \sigma}%
\cnpremise{\cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \leadsto  \psi}%
}{
\cnkw{comp} \, ident\_or\_pattern  =  pval  \cnsym{,} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \leadsto  \sigma  \cnsym{,}  \psi}{%
{\cndrulename{Subs\_Decons\_Ret\_Comp}}{}%
}}


\newcommand{\cndruleSubsXXDeconsXXRetXXLog}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \leadsto  \psi}%
}{
\cnkw{log} \, ident  =  pval  \cnsym{,} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \leadsto  pval  \cnsym{/}  ident  \cnsym{,}  \psi}{%
{\cndrulename{Subs\_Decons\_Ret\_Log}}{}%
}}


\newcommand{\cndruleSubsXXDeconsXXRetXXRes}[1]{\cndrule[#1]{%
\cnpremise{\cnnt{res\_pattern}  =  \cnnt{res\_term}  \leadsto  \sigma}%
\cnpremise{\cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \leadsto  \psi}%
}{
\texttt{res} \, \cnnt{res\_pattern}  =  \cnnt{res\_term}  \cnsym{,} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \leadsto  \sigma  \cnsym{,}  \psi}{%
{\cndrulename{Subs\_Decons\_Ret\_Res}}{}%
}}

\newcommand{\cndefnSubsXXDeconsXXRet}[1]{\begin{cndefnblock}[#1]{$\cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \leadsto  \sigma$}{}
\cnusedrule{\cndruleSubsXXDeconsXXRetXXEmpty{}}
\cnusedrule{\cndruleSubsXXDeconsXXRetXXComp{}}
\cnusedrule{\cndruleSubsXXDeconsXXRetXXLog{}}
\cnusedrule{\cndruleSubsXXDeconsXXRetXXRes{}}
\end{cndefnblock}}

%% defn Decons_Arg
\newcommand{\cndruleSubsXXDeconsXXArgXXEmpty}[1]{\cndrule[#1]{%
}{
\,  \mathbin{ {:} {:} }  \cnnt{ret}  \gg  \cdot  \cnsym{;}  \cnnt{ret}}{%
{\cndrulename{Subs\_Decons\_Arg\_Empty}}{}%
}}


\newcommand{\cndruleSubsXXDeconsXXArgXXComp}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}}%
}{
\cnmv{x}  =  pval  \cnsym{,} \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \Pi \, \cnmv{x}  {:}  \beta  . \:  \cnnt{arg}  \gg  pval  \cnsym{/}  \cnmv{x}  \cnsym{,}  \sigma  \cnsym{;}  \cnnt{ret}}{%
{\cndrulename{Subs\_Decons\_Arg\_Comp}}{}%
}}


\newcommand{\cndruleSubsXXDeconsXXArgXXLog}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}}%
}{
\cnmv{x}  =  pval  \cnsym{,} \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \forall \, \cnmv{x}  {:}  \beta  . \:  \cnnt{arg}  \gg  pval  \cnsym{/}  \cnmv{x}  \cnsym{,}  \sigma  \cnsym{;}  \cnnt{ret}}{%
{\cndrulename{Subs\_Decons\_Arg\_Log}}{}%
}}


\newcommand{\cndruleSubsXXDeconsXXArgXXRes}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}}%
}{
\cnmv{x}  =  \cnnt{res\_term}  \cnsym{,} \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{res}  \multimap  \cnnt{arg}  \gg  \cnnt{res\_term}  \cnsym{/}  \cnmv{x}  \cnsym{,}  \sigma  \cnsym{;}  \cnnt{ret}}{%
{\cndrulename{Subs\_Decons\_Arg\_Res}}{}%
}}


\newcommand{\cndruleSubsXXDeconsXXArgXXPhi}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}}%
}{
\cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  term  \supset  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}}{%
{\cndrulename{Subs\_Decons\_Arg\_Phi}}{}%
}}

\newcommand{\cndefnSubsXXDeconsXXArg}[1]{\begin{cndefnblock}[#1]{$\cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}$}{}
\cnusedrule{\cndruleSubsXXDeconsXXArgXXEmpty{}}
\cnusedrule{\cndruleSubsXXDeconsXXArgXXComp{}}
\cnusedrule{\cndruleSubsXXDeconsXXArgXXLog{}}
\cnusedrule{\cndruleSubsXXDeconsXXArgXXRes{}}
\cnusedrule{\cndruleSubsXXDeconsXXArgXXPhi{}}
\end{cndefnblock}}


\newcommand{\cndefnssubsXXjtype}{
\cndefnSubsXXDeconsXXValueXX{}\cndefnSubsXXDeconsXXValuePPXX{}\cndefnSubsXXDeconsXXRes{}\cndefnSubsXXDeconsXXRet{}\cndefnSubsXXDeconsXXArg{}}

% defns pure_opsem_jtype
%% defn PE_PE
\newcommand{\cndruleOpXXPEXXPEXXArrayShift}[1]{\cndrule[#1]{%
\cnpremise{mem\_ptr' \, \equiv \, mem\_ptr  \mathbin{ {+}_{ \mathrm{ptr} } }   mem\_int   \times   \mathrm{size\_of}(  \tau  ) }%
}{
\langle  \cnkw{array\_shift} \, \cnsym{(}  mem\_ptr  \cnsym{,}  \tau  \cnsym{,}  mem\_int  \cnsym{)}  \rangle  \longrightarrow  \langle  mem\_ptr'  \rangle}{%
{\cndrulename{Op\_PE\_PE\_ArrayShift}}{}%
}}


\newcommand{\cndruleOpXXPEXXPEXXMemberShift}[1]{\cndrule[#1]{%
\cnpremise{mem\_ptr' \, \equiv \, mem\_ptr  \mathbin{ {+}_{ \mathrm{ptr} } }   \mathrm{offset\_of}_{  tag  }(  member  ) }%
}{
\langle  \cnkw{member\_shift} \, \cnsym{(}  mem\_ptr  \cnsym{,}  tag  \cnsym{,}  member  \cnsym{)}  \rangle  \longrightarrow  \langle  mem\_ptr'  \rangle}{%
{\cndrulename{Op\_PE\_PE\_MemberShift}}{}%
}}


\newcommand{\cndruleOpXXPEXXPEXXNotXXTrue}[1]{\cndrule[#1]{%
}{
\langle  \cnkw{not} \, \cnsym{(}  \cnkw{True}  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnkw{False}  \rangle}{%
{\cndrulename{Op\_PE\_PE\_Not\_True}}{}%
}}


\newcommand{\cndruleOpXXPEXXPEXXNotXXFalse}[1]{\cndrule[#1]{%
}{
\langle  \cnkw{not} \, \cnsym{(}  \cnkw{False}  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnkw{True}  \rangle}{%
{\cndrulename{Op\_PE\_PE\_Not\_False}}{}%
}}


\newcommand{\cndruleOpXXPEXXPEXXArithXXBinop}[1]{\cndrule[#1]{%
\cnpremise{ mem\_int  \, \equiv \,   mem\_int_{{\mathrm{1}}}    \mathbin{ binop_{arith} }    mem\_int_{{\mathrm{2}}}  }%
}{
\langle  mem\_int_{{\mathrm{1}}} \, \mathbin{ binop_{arith} } \, mem\_int_{{\mathrm{2}}}  \rangle  \longrightarrow  \langle  mem\_int  \rangle}{%
{\cndrulename{Op\_PE\_PE\_Arith\_Binop}}{}%
}}


\newcommand{\cndruleOpXXPEXXPEXXRelXXBinop}[1]{\cndrule[#1]{%
\cnpremise{ bool\_value  \, \equiv \,   mem\_int_{{\mathrm{1}}}    \mathbin{ binop_{rel} }    mem\_int_{{\mathrm{2}}}  }%
}{
\langle  mem\_int_{{\mathrm{1}}} \, \mathbin{ binop_{rel} } \, mem\_int_{{\mathrm{2}}}  \rangle  \longrightarrow  \langle  bool\_value  \rangle}{%
{\cndrulename{Op\_PE\_PE\_Rel\_Binop}}{}%
}}


\newcommand{\cndruleOpXXPEXXPEXXBoolXXBinop}[1]{\cndrule[#1]{%
\cnpremise{ bool\_value  \, \equiv \,   bool\_value_{{\mathrm{1}}}    \mathbin{ binop_{bool} }    bool\_value_{{\mathrm{2}}}  }%
}{
\langle  bool\_value_{{\mathrm{1}}} \, \mathbin{ binop_{bool} } \, bool\_value_{{\mathrm{2}}}  \rangle  \longrightarrow  \langle  bool\_value  \rangle}{%
{\cndrulename{Op\_PE\_PE\_Bool\_Binop}}{}%
}}


\newcommand{\cndruleOpXXPEXXPEXXAssertXXUndef}[1]{\cndrule[#1]{%
}{
\langle  \cnkw{assert\_undef} \, \cnsym{(}  \cnkw{True}  \cnsym{,}   \, \cnmv{UB\_name}  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnkw{Unit}  \rangle}{%
{\cndrulename{Op\_PE\_PE\_Assert\_Undef}}{}%
}}


\newcommand{\cndruleOpXXPEXXPEXXBoolXXToXXIntegerXXTrue}[1]{\cndrule[#1]{%
}{
\langle  \cnkw{bool\_to\_integer} \, \cnsym{(}  \cnkw{True}  \cnsym{)}  \rangle  \longrightarrow  \langle   1   \rangle}{%
{\cndrulename{Op\_PE\_PE\_Bool\_To\_Integer\_True}}{}%
}}


\newcommand{\cndruleOpXXPEXXPEXXBoolXXToXXIntegerXXFalse}[1]{\cndrule[#1]{%
}{
\langle  \cnkw{bool\_to\_integer} \, \cnsym{(}  \cnkw{False}  \cnsym{)}  \rangle  \longrightarrow  \langle   0   \rangle}{%
{\cndrulename{Op\_PE\_PE\_Bool\_To\_Integer\_False}}{}%
}}


\newcommand{\cndruleOpXXPEXXPEXXWrapI}[1]{\cndrule[#1]{%
\cnpremise{\cnmv{abbrev_{{\mathrm{1}}}} \, \equiv \,  \mathrm{max\_int}_{  \tau  }   \cnsym{-}   \mathrm{min\_int}_{  \tau  }   \cnsym{+}   1 }%
\cnpremise{\cnmv{abbrev_{{\mathrm{2}}}} \, \equiv \,  pval  \, \cnkw{rem\_f} \, \cnmv{abbrev_{{\mathrm{1}}}}}%
\cnpremise{ mem\_int'  \, \equiv \, \cnkw{if} \, \cnmv{abbrev_{{\mathrm{2}}}}  \leq   \mathrm{max\_int}_{  \tau  }  \, \cnkw{then} \, \cnmv{abbrev_{{\mathrm{2}}}} \, \cnkw{else} \, \cnmv{abbrev_{{\mathrm{2}}}}  \cnsym{-}  \cnmv{abbrev_{{\mathrm{1}}}}}%
}{
\langle  \cnkw{wrapI} \, \cnsym{(}  \tau  \cnsym{,}  mem\_int  \cnsym{)}  \rangle  \longrightarrow  \langle  mem\_int'  \rangle}{%
{\cndrulename{Op\_PE\_PE\_WrapI}}{}%
}}

\newcommand{\cndefnOpXXPEXXPE}[1]{\begin{cndefnblock}[#1]{$\langle  pexpr  \rangle  \longrightarrow  \langle  pexpr'  \rangle$}{}
\cnusedrule{\cndruleOpXXPEXXPEXXArrayShift{}}
\cnusedrule{\cndruleOpXXPEXXPEXXMemberShift{}}
\cnusedrule{\cndruleOpXXPEXXPEXXNotXXTrue{}}
\cnusedrule{\cndruleOpXXPEXXPEXXNotXXFalse{}}
\cnusedrule{\cndruleOpXXPEXXPEXXArithXXBinop{}}
\cnusedrule{\cndruleOpXXPEXXPEXXRelXXBinop{}}
\cnusedrule{\cndruleOpXXPEXXPEXXBoolXXBinop{}}
\cnusedrule{\cndruleOpXXPEXXPEXXAssertXXUndef{}}
\cnusedrule{\cndruleOpXXPEXXPEXXBoolXXToXXIntegerXXTrue{}}
\cnusedrule{\cndruleOpXXPEXXPEXXBoolXXToXXIntegerXXFalse{}}
\cnusedrule{\cndruleOpXXPEXXPEXXWrapI{}}
\end{cndefnblock}}

%% defn PE_TPE
\newcommand{\cndruleOpXXPEXXTPEXXCall}[1]{\cndrule[#1]{%
\cnpremise{name  {:}  \cnnt{pure\_arg} \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mapsto  tpexpr \, \in \, \cnkw{Globals}}%
\cnpremise{\cncomp{\cnmv{x_{\cnmv{i}}}  =  pval_{\cnmv{i}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{pure\_arg}  \gg  \sigma  \cnsym{;}  \Sigma \, \cnmv{y}  {:}  \beta  . \:  \cnnt{term}  \wedge  \cnkw{I}}%
}{
\langle  name  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}  \rangle  \longrightarrow  \langle   \sigma  (  tpexpr  )   {:}  \cnsym{(}  \cnmv{y}  {:}  \beta  . \:   \sigma  (  \cnnt{term}  )   \cnsym{)}  \rangle}{%
{\cndrulename{Op\_PE\_TPE\_Call}}{}%
}}

\newcommand{\cndefnOpXXPEXXTPE}[1]{\begin{cndefnblock}[#1]{$\langle  pexpr  \rangle  \longrightarrow  \langle  tpexpr  {:}  \cnsym{(}  \cnmv{y}  {:}  \beta  . \:  term  \cnsym{)}  \rangle$}{}
\cnusedrule{\cndruleOpXXPEXXTPEXXCall{}}
\end{cndefnblock}}

%% defn TPE_TPE
\newcommand{\cndruleOpXXTPEXXTPEXXCase}[1]{\cndrule[#1]{%
\cnpremise{pattern_{\cnmv{j}}  =  pval  \leadsto  \sigma_{\cnmv{j}}}%
\cnpremise{\forall \, \cnmv{i}  \cnsym{<}  \cnmv{j}  . \: \, \cnkw{not} \, \cnsym{(}  pattern_{\cnmv{i}}  =  pval  \leadsto  \sigma_{\cnmv{i}}  \cnsym{)}}%
}{
\langle  \cnkw{case} \, pval \, \cnkw{of} \, \cncomp{\mid  pattern_{\cnmv{i}}  \Rightarrow  tpexpr_{\cnmv{i}}}{\cnmv{i}} \, \cnkw{end}  \rangle  \longrightarrow  \langle   \sigma_{\cnmv{j}}  (  tpexpr_{\cnmv{j}}  )   \rangle}{%
{\cndrulename{Op\_TPE\_TPE\_Case}}{}%
}}


\newcommand{\cndruleOpXXTPEXXTPEXXLetXXSub}[1]{\cndrule[#1]{%
\cnpremise{ident\_or\_pattern  =  pval  \leadsto  \sigma}%
}{
\langle  \cnkw{let} \, ident\_or\_pattern  =  pval \, \cnkw{in} \, tpexpr  \rangle  \longrightarrow  \langle   \sigma  (  tpexpr  )   \rangle}{%
{\cndrulename{Op\_TPE\_TPE\_Let\_Sub}}{}%
}}


\newcommand{\cndruleOpXXTPEXXTPEXXLetXXLet}[1]{\cndrule[#1]{%
\cnpremise{\langle  pexpr  \rangle  \longrightarrow  \langle  pexpr'  \rangle}%
}{
\langle  \cnkw{let} \, ident\_or\_pattern  =  pexpr \, \cnkw{in} \, tpexpr  \rangle  \longrightarrow  \langle  \cnkw{let} \, ident\_or\_pattern  =  pexpr' \, \cnkw{in} \, tpexpr  \rangle}{%
{\cndrulename{Op\_TPE\_TPE\_Let\_Let}}{}%
}}


\newcommand{\cndruleOpXXTPEXXTPEXXLetXXLetT}[1]{\cndrule[#1]{%
\cnpremise{\langle  pexpr  \rangle  \longrightarrow  \langle  tpexpr_{{\mathrm{1}}}  {:}  \cnsym{(}  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}  \cnsym{)}  \rangle}%
}{
\langle  \cnkw{let} \, ident\_or\_pattern  =  pexpr \, \cnkw{in} \, tpexpr_{{\mathrm{2}}}  \rangle  \longrightarrow  \langle  \cnkw{let} \, ident\_or\_pattern  {:}  \cnsym{(}  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}  \cnsym{)}  =  tpexpr_{{\mathrm{1}}} \, \cnkw{in} \, tpexpr_{{\mathrm{2}}}  \rangle}{%
{\cndrulename{Op\_TPE\_TPE\_Let\_LetT}}{}%
}}


\newcommand{\cndruleOpXXTPEXXTPEXXLetTXXSub}[1]{\cndrule[#1]{%
\cnpremise{ident\_or\_pattern  =  pval  \leadsto  \sigma}%
}{
\langle  \cnkw{let} \, ident\_or\_pattern  {:}  \cnsym{(}  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}  \cnsym{)}  =  \cnkw{done} \, pval \, \cnkw{in} \, tpexpr  \rangle  \longrightarrow  \langle   \sigma  (  tpexpr  )   \rangle}{%
{\cndrulename{Op\_TPE\_TPE\_LetT\_Sub}}{}%
}}


\newcommand{\cndruleOpXXTPEXXTPEXXLetTXXLetT}[1]{\cndrule[#1]{%
\cnpremise{\langle  tpexpr_{{\mathrm{1}}}  \rangle  \longrightarrow  \langle  tpexpr'_{{\mathrm{1}}}  \rangle}%
}{
\langle  \cnkw{let} \, ident\_or\_pattern  {:}  \cnsym{(}  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}  \cnsym{)}  =  tpexpr_{{\mathrm{1}}} \, \cnkw{in} \, tpexpr_{{\mathrm{2}}}  \rangle  \longrightarrow  \langle  \cnkw{let} \, ident\_or\_pattern  {:}  \cnsym{(}  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}  \cnsym{)}  =  tpexpr'_{{\mathrm{1}}} \, \cnkw{in} \, tpexpr_{{\mathrm{2}}}  \rangle}{%
{\cndrulename{Op\_TPE\_TPE\_LetT\_LetT}}{}%
}}


\newcommand{\cndruleOpXXTPEXXTPEXXIfXXTrue}[1]{\cndrule[#1]{%
}{
\langle  \cnkw{if} \, \cnkw{True} \, \cnkw{then} \, tpexpr_{{\mathrm{1}}} \, \cnkw{else} \, tpexpr_{{\mathrm{2}}}  \rangle  \longrightarrow  \langle  tpexpr_{{\mathrm{1}}}  \rangle}{%
{\cndrulename{Op\_TPE\_TPE\_If\_True}}{}%
}}


\newcommand{\cndruleOpXXTPEXXTPEXXIfXXFalse}[1]{\cndrule[#1]{%
}{
\langle  \cnkw{if} \, \cnkw{False} \, \cnkw{then} \, tpexpr_{{\mathrm{1}}} \, \cnkw{else} \, tpexpr_{{\mathrm{2}}}  \rangle  \longrightarrow  \langle  tpexpr_{{\mathrm{2}}}  \rangle}{%
{\cndrulename{Op\_TPE\_TPE\_If\_False}}{}%
}}

\newcommand{\cndefnOpXXTPEXXTPE}[1]{\begin{cndefnblock}[#1]{$\langle  tpexpr  \rangle  \longrightarrow  \langle  tpexpr'  \rangle$}{}
\cnusedrule{\cndruleOpXXTPEXXTPEXXCase{}}
\cnusedrule{\cndruleOpXXTPEXXTPEXXLetXXSub{}}
\cnusedrule{\cndruleOpXXTPEXXTPEXXLetXXLet{}}
\cnusedrule{\cndruleOpXXTPEXXTPEXXLetXXLetT{}}
\cnusedrule{\cndruleOpXXTPEXXTPEXXLetTXXSub{}}
\cnusedrule{\cndruleOpXXTPEXXTPEXXLetTXXLetT{}}
\cnusedrule{\cndruleOpXXTPEXXTPEXXIfXXTrue{}}
\cnusedrule{\cndruleOpXXTPEXXTPEXXIfXXFalse{}}
\end{cndefnblock}}


\newcommand{\cndefnspureXXopsemXXjtype}{
\cndefnOpXXPEXXPE{}\cndefnOpXXPEXXTPE{}\cndefnOpXXTPEXXTPE{}}

% defns opsem_jtype
%% defn SE_TE
\newcommand{\cndruleOpXXSEXXTEXXCCall}[1]{\cndrule[#1]{%
\cnpremise{ident  {:}  \cnnt{arg} \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mapsto  texpr \, \in \, \cnkw{Globals}}%
\cnpremise{\cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}}%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{ccall} \, \cnsym{(}  \tau  \cnsym{,}  ident  \cnsym{,}  \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}}  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}   \sigma  (  texpr  )   {:}   \sigma  (  \cnnt{ret}  )   \rangle}{%
{\cndrulename{Op\_SE\_TE\_CCall}}{}%
}}


\newcommand{\cndruleOpXXSEXXTEXXPCall}[1]{\cndrule[#1]{%
\cnpremise{name  {:}  \cnnt{arg} \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mapsto  texpr \, \in \, \cnkw{Globals}}%
\cnpremise{\cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}}%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{pcall} \, \cnsym{(}  name  \cnsym{,}  \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}}  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}   \sigma  (  texpr  )   {:}   \sigma  (  \cnnt{ret}  )   \rangle}{%
{\cndrulename{Op\_SE\_TE\_PCall}}{}%
}}

\newcommand{\cndefnOpXXSEXXTE}[1]{\begin{cndefnblock}[#1]{$\langle  \cnnt{h}  \cnsym{;}  seq\_expr  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  texpr  {:}  \cnnt{ret}  \rangle$}{}
\cnusedrule{\cndruleOpXXSEXXTEXXCCall{}}
\cnusedrule{\cndruleOpXXSEXXTEXXPCall{}}
\end{cndefnblock}}

%% defn STE_TE
\newcommand{\cndruleOpXXSTEXXTEXXRun}[1]{\cndrule[#1]{%
\cnpremise{ident  {:}  \cnnt{arg} \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mapsto  texpr \, \in \, \cnkw{Globals}}%
\cnpremise{\cncomp{\cnmv{x_{\cnmv{i}}}  =  pval_{\cnmv{i}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnkw{false}  \wedge  \cnkw{I}}%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{run} \, ident \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}   \sigma  (  texpr  )   \rangle}{%
{\cndrulename{Op\_STE\_TE\_Run}}{}%
}}


\newcommand{\cndruleOpXXSTEXXTEXXCase}[1]{\cndrule[#1]{%
\cnpremise{pattern_{\cnmv{j}}  =  pval  \leadsto  \sigma_{\cnmv{j}}}%
\cnpremise{\forall \, \cnmv{i}  \cnsym{<}  \cnmv{j}  . \: \, \cnkw{not} \, \cnsym{(}  pattern_{\cnmv{i}}  =  pval  \leadsto  \sigma_{\cnmv{i}}  \cnsym{)}}%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{case} \, pval \, \cnkw{of} \, \cncomp{\mid  pattern_{\cnmv{i}}  \Rightarrow  texpr_{\cnmv{i}}}{\cnmv{i}} \, \cnkw{end}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}   \sigma_{\cnmv{j}}  (  texpr_{\cnmv{j}}  )   \rangle}{%
{\cndrulename{Op\_STE\_TE\_Case}}{}%
}}


\newcommand{\cndruleOpXXSTEXXTEXXLetPXXSub}[1]{\cndrule[#1]{%
\cnpremise{ident\_or\_pattern  =  pval  \leadsto  \sigma}%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{let} \, ident\_or\_pattern  =  pval \, \cnkw{in} \, texpr  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}   \sigma  (  texpr  )   \rangle}{%
{\cndrulename{Op\_STE\_TE\_LetP\_Sub}}{}%
}}


\newcommand{\cndruleOpXXSTEXXTEXXLetPXXLetP}[1]{\cndrule[#1]{%
\cnpremise{\langle  pexpr  \rangle  \longrightarrow  \langle  pexpr'  \rangle}%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{let} \, ident\_or\_pattern  =  pexpr \, \cnkw{in} \, texpr  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  \cnkw{let} \, ident\_or\_pattern  =  pexpr' \, \cnkw{in} \, texpr  \rangle}{%
{\cndrulename{Op\_STE\_TE\_LetP\_LetP}}{}%
}}


\newcommand{\cndruleOpXXSTEXXTEXXLetPXXLetTP}[1]{\cndrule[#1]{%
\cnpremise{\langle  pexpr  \rangle  \longrightarrow  \langle  tpexpr  {:}  \cnsym{(}  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}  \cnsym{)}  \rangle}%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{let} \, ident\_or\_pattern  =  pexpr \, \cnkw{in} \, texpr  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  \cnkw{let} \, ident\_or\_pattern  {:}  \cnsym{(}  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}  \cnsym{)}  =  tpexpr \, \cnkw{in} \, texpr  \rangle}{%
{\cndrulename{Op\_STE\_TE\_LetP\_LetTP}}{}%
}}


\newcommand{\cndruleOpXXSTEXXTEXXLetTPXXSub}[1]{\cndrule[#1]{%
\cnpremise{ident\_or\_pattern  =  pval  \leadsto  \sigma}%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{let} \, ident\_or\_pattern  {:}  \cnsym{(}  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}  \cnsym{)}  =  \cnkw{done} \, pval \, \cnkw{in} \, texpr  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}   \sigma  (  texpr  )   \rangle}{%
{\cndrulename{Op\_STE\_TE\_LetTP\_Sub}}{}%
}}


\newcommand{\cndruleOpXXSTEXXTEXXLetTPXXLetTP}[1]{\cndrule[#1]{%
\cnpremise{\langle  tpexpr  \rangle  \longrightarrow  \langle  tpexpr'  \rangle}%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{let} \, ident\_or\_pattern  {:}  \cnsym{(}  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}  \cnsym{)}  =  tpexpr \, \cnkw{in} \, texpr  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  \cnkw{let} \, ident\_or\_pattern  {:}  \cnsym{(}  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}  \cnsym{)}  =  tpexpr' \, \cnkw{in} \, texpr  \rangle}{%
{\cndrulename{Op\_STE\_TE\_LetTP\_LetTP}}{}%
}}


\newcommand{\cndruleOpXXSTEXXTEXXLetTXXSub}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \leadsto  \sigma}%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret}  =  \cnkw{done} \, \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \cnkw{in} \, texpr  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}   \sigma  (  texpr  )   \rangle}{%
{\cndrulename{Op\_STE\_TE\_LetT\_Sub}}{}%
}}


\newcommand{\cndruleOpXXSTEXXTEXXLetXXLetT}[1]{\cndrule[#1]{%
\cnpremise{\langle  \cnnt{h}  \cnsym{;}  seq\_expr  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  texpr_{{\mathrm{1}}}  {:}  \cnnt{ret}  \rangle}%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, =  seq\_expr \, \cnkw{in} \, texpr_{{\mathrm{2}}}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret}  =  texpr_{{\mathrm{1}}} \, \cnkw{in} \, texpr_{{\mathrm{2}}}  \rangle}{%
{\cndrulename{Op\_STE\_TE\_Let\_LetT}}{}%
}}


\newcommand{\cndruleOpXXSTEXXTEXXLetTXXLetT}[1]{\cndrule[#1]{%
\cnpremise{\langle  \cnnt{h}  \cnsym{;}  texpr_{{\mathrm{1}}}  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  texpr'_{{\mathrm{1}}}  \rangle}%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret}  =  texpr_{{\mathrm{1}}} \, \cnkw{in} \, texpr_{{\mathrm{2}}}  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret}  =  texpr'_{{\mathrm{1}}} \, \cnkw{in} \, texpr_{{\mathrm{2}}}  \rangle}{%
{\cndrulename{Op\_STE\_TE\_LetT\_LetT}}{}%
}}


\newcommand{\cndruleOpXXSTEXXTEXXIfXXTrue}[1]{\cndrule[#1]{%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{if} \, \cnkw{True} \, \cnkw{then} \, texpr_{{\mathrm{1}}} \, \cnkw{else} \, texpr_{{\mathrm{2}}}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  texpr_{{\mathrm{1}}}  \rangle}{%
{\cndrulename{Op\_STE\_TE\_If\_True}}{}%
}}


\newcommand{\cndruleOpXXSTEXXTEXXIfXXFalse}[1]{\cndrule[#1]{%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{if} \, \cnkw{False} \, \cnkw{then} \, texpr_{{\mathrm{1}}} \, \cnkw{else} \, texpr_{{\mathrm{2}}}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  texpr_{{\mathrm{2}}}  \rangle}{%
{\cndrulename{Op\_STE\_TE\_If\_False}}{}%
}}


\newcommand{\cndruleOpXXSTEXXTEXXBound}[1]{\cndrule[#1]{%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{bound} \, \cnsym{[}  int  \cnsym{]}  \cnsym{(}  is\_texpr  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  is\_texpr  \rangle}{%
{\cndrulename{Op\_STE\_TE\_Bound}}{}%
}}

\newcommand{\cndefnOpXXSTEXXTE}[1]{\begin{cndefnblock}[#1]{$\langle  \cnnt{h}  \cnsym{;}  seq\_texpr  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  texpr  \rangle$}{}
\cnusedrule{\cndruleOpXXSTEXXTEXXRun{}}
\cnusedrule{\cndruleOpXXSTEXXTEXXCase{}}
\cnusedrule{\cndruleOpXXSTEXXTEXXLetPXXSub{}}
\cnusedrule{\cndruleOpXXSTEXXTEXXLetPXXLetP{}}
\cnusedrule{\cndruleOpXXSTEXXTEXXLetPXXLetTP{}}
\cnusedrule{\cndruleOpXXSTEXXTEXXLetTPXXSub{}}
\cnusedrule{\cndruleOpXXSTEXXTEXXLetTPXXLetTP{}}
\cnusedrule{\cndruleOpXXSTEXXTEXXLetTXXSub{}}
\cnusedrule{\cndruleOpXXSTEXXTEXXLetXXLetT{}}
\cnusedrule{\cndruleOpXXSTEXXTEXXLetTXXLetT{}}
\cnusedrule{\cndruleOpXXSTEXXTEXXIfXXTrue{}}
\cnusedrule{\cndruleOpXXSTEXXTEXXIfXXFalse{}}
\cnusedrule{\cndruleOpXXSTEXXTEXXBound{}}
\end{cndefnblock}}

%% defn Memop_Tval
\newcommand{\cndruleOpXXMemopXXTValXXRelXXBinop}[1]{\cndrule[#1]{%
\cnpremise{ bool\_value  \, \equiv \,   mem\_int_{{\mathrm{1}}}    \mathbin{ binop_{rel} }    mem\_int_{{\mathrm{2}}}  }%
}{
\langle  \cnnt{h}  \cnsym{;}  mem\_int_{{\mathrm{1}}} \, \mathbin{ binop_{rel} } \, mem\_int_{{\mathrm{2}}}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  \cnkw{done} \, bool\_value  \rangle}{%
{\cndrulename{Op\_Memop\_TVal\_Rel\_Binop}}{}%
}}


\newcommand{\cndruleOpXXMemopXXTValXXIntFromPtr}[1]{\cndrule[#1]{%
\cnpremise{ mem\_int  \, \equiv \, \cnkw{cast\_ptr\_to\_int} \,  mem\_ptr }%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{intFromPtr} \, \cnsym{(}  \tau_{{\mathrm{1}}}  \cnsym{,}  \tau_{{\mathrm{2}}}  \cnsym{,}  mem\_ptr  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  \cnkw{done} \, mem\_int  \rangle}{%
{\cndrulename{Op\_Memop\_TVal\_IntFromPtr}}{}%
}}


\newcommand{\cndruleOpXXMemopXXTValXXPtrFromInt}[1]{\cndrule[#1]{%
\cnpremise{ mem\_ptr  \, \equiv \, \cnkw{cast\_ptr\_to\_int} \,  mem\_int }%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{ptrFromInt} \, \cnsym{(}  \tau_{{\mathrm{1}}}  \cnsym{,}  \tau_{{\mathrm{2}}}  \cnsym{,}  mem\_int  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  \cnkw{done} \, mem\_ptr  \rangle}{%
{\cndrulename{Op\_Memop\_TVal\_PtrFromInt}}{}%
}}


\newcommand{\cndruleOpXXMemopXXTValXXPtrValidForDeref}[1]{\cndrule[#1]{%
\cnpremise{ bool\_value  \, \equiv \, \cnkw{aligned} \, \cnsym{(}  \tau  \cnsym{,}   mem\_ptr   \cnsym{)}}%
}{
\langle  \cnnt{h}  \cnsym{+}  \cnsym{\{}    mem\_ptr   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }  \_   \cnsym{\}}  \cnsym{;}  \cnkw{ptrValidForDeref} \, \cnsym{(}  \tau  \cnsym{,}  mem\_ptr  \cnsym{,}    mem\_ptr   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }  \_   \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{+}  \cnsym{\{}    mem\_ptr   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }  \_   \cnsym{\}}  \cnsym{;}  \cnkw{done} \, bool\_value  \cnsym{,}    mem\_ptr   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }  \_   \rangle}{%
{\cndrulename{Op\_Memop\_TVal\_PtrValidForDeref}}{}%
}}


\newcommand{\cndruleOpXXMemopXXTValXXPtrWellAligned}[1]{\cndrule[#1]{%
\cnpremise{ bool\_value  \, \equiv \, \cnkw{aligned} \, \cnsym{(}  \tau  \cnsym{,}   mem\_ptr   \cnsym{)}}%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{ptrWellAligned} \, \cnsym{(}  \tau  \cnsym{,}  mem\_ptr  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  \cnkw{done} \, bool\_value  \rangle}{%
{\cndrulename{Op\_Memop\_TVal\_PtrWellAligned}}{}%
}}


\newcommand{\cndruleOpXXMemopXXTValXXPtrArrayShift}[1]{\cndrule[#1]{%
\cnpremise{ mem\_ptr'  \, \equiv \,  mem\_ptr   \mathbin{ {+}_{ \mathrm{ptr} } }  \cnsym{(}   mem\_int   \times   \mathrm{size\_of}(  \tau  )   \cnsym{)}}%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{ptrArrayShift} \, \cnsym{(}  mem\_ptr  \cnsym{,}  \tau  \cnsym{,}  mem\_int  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  \cnkw{done} \, mem\_ptr'  \rangle}{%
{\cndrulename{Op\_Memop\_TVal\_PtrArrayShift}}{}%
}}

\newcommand{\cndefnOpXXMemopXXTval}[1]{\begin{cndefnblock}[#1]{$\langle  \cnnt{h}  \cnsym{;}  mem\_op  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  tval  \rangle$}{}
\cnusedrule{\cndruleOpXXMemopXXTValXXRelXXBinop{}}
\cnusedrule{\cndruleOpXXMemopXXTValXXIntFromPtr{}}
\cnusedrule{\cndruleOpXXMemopXXTValXXPtrFromInt{}}
\cnusedrule{\cndruleOpXXMemopXXTValXXPtrValidForDeref{}}
\cnusedrule{\cndruleOpXXMemopXXTValXXPtrWellAligned{}}
\cnusedrule{\cndruleOpXXMemopXXTValXXPtrArrayShift{}}
\end{cndefnblock}}

%% defn Action_Tval
\newcommand{\cndruleOpXXActionXXTvalXXCreate}[1]{\cndrule[#1]{%
\cnpremise{\cnkw{fresh} \, \cnsym{(}  mem\_ptr  \cnsym{)}}%
\cnpremise{\cnkw{representable} \, \cnsym{(}  \tau  *  \cnsym{,}   mem\_ptr   \cnsym{)}}%
\cnpremise{\cnkw{alignedI} \, \cnsym{(}   mem\_int   \cnsym{,}   mem\_ptr   \cnsym{)}}%
\cnpremise{pval  {:}   \beta_{  \tau  } }%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{create} \, \cnsym{(}  mem\_int  \cnsym{,}  \tau  \cnsym{)}    \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{+}  \cnsym{\{}    mem\_ptr   \mathbin{ { \overset{   {  \times  }   }{ \mapsto } }_{  \tau  } }   pval    \cnsym{\}}  \cnsym{;}  \cnkw{done} \, mem\_ptr  \cnsym{,}  pval  \cnsym{,}    mem\_ptr   \mathbin{ { \overset{   {  \times  }   }{ \mapsto } }_{  \tau  } }   pval    \rangle}{%
{\cndrulename{Op\_Action\_Tval\_Create}}{}%
}}


\newcommand{\cndruleOpXXActionXXTvalXXLoad}[1]{\cndrule[#1]{%
}{
\langle  \cnnt{h}  \cnsym{+}  \cnsym{\{}    mem\_ptr   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }   pval    \cnsym{\}}  \cnsym{;}  \cnkw{load} \, \cnsym{(}  \tau  \cnsym{,}  mem\_ptr  \cnsym{,}  \_  \cnsym{,}    mem\_ptr   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }   pval    \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{+}  \cnsym{\{}    mem\_ptr   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }   pval    \cnsym{\}}  \cnsym{;}  \cnkw{done} \, pval  \cnsym{,}    mem\_ptr   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }   pval    \rangle}{%
{\cndrulename{Op\_Action\_Tval\_Load}}{}%
}}


\newcommand{\cndruleOpXXActionXXTvalXXStore}[1]{\cndrule[#1]{%
}{
\langle  \cnnt{h}  \cnsym{+}  \cnsym{\{}    mem\_ptr   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }  \_   \cnsym{\}}  \cnsym{;}  \cnkw{store} \, \cnsym{(}  \_  \cnsym{,}  \tau  \cnsym{,}  mem\_ptr  \cnsym{,}  pval  \cnsym{,}  \_  \cnsym{,}    mem\_ptr   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }  \_   \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{+}  \cnsym{\{}    mem\_ptr   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }   pval    \cnsym{\}}  \cnsym{;}  \cnkw{done} \, \cnkw{Unit}  \cnsym{,}    mem\_ptr   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }   pval    \rangle}{%
{\cndrulename{Op\_Action\_Tval\_Store}}{}%
}}


\newcommand{\cndruleOpXXActionXXTvalXXKillXXStatic}[1]{\cndrule[#1]{%
}{
\langle  \cnnt{h}  \cnsym{+}  \cnsym{\{}    mem\_ptr   \mathbin{ { \overset{    }{ \mapsto } }_{  \tau  } }  \_   \cnsym{\}}  \cnsym{;}  \cnkw{kill} \, \cnsym{(}  \cnkw{static} \, \tau  \cnsym{,}  mem\_ptr  \cnsym{,}    mem\_ptr   \mathbin{ { \overset{    }{ \mapsto } }_{  \tau  } }  \_   \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  \cnkw{done} \, \cnkw{Unit}  \rangle}{%
{\cndrulename{Op\_Action\_Tval\_Kill\_Static}}{}%
}}

\newcommand{\cndefnOpXXActionXXTval}[1]{\begin{cndefnblock}[#1]{$\langle  \cnnt{h}  \cnsym{;}  mem\_action  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  tval  \rangle$}{}
\cnusedrule{\cndruleOpXXActionXXTvalXXCreate{}}
\cnusedrule{\cndruleOpXXActionXXTvalXXLoad{}}
\cnusedrule{\cndruleOpXXActionXXTvalXXStore{}}
\cnusedrule{\cndruleOpXXActionXXTvalXXKillXXStatic{}}
\end{cndefnblock}}

%% defn IsE_IsE
\newcommand{\cndruleOpXXIsEXXIsEXXMemop}[1]{\cndrule[#1]{%
\cnpremise{\langle  \cnnt{h}  \cnsym{;}  mem\_op  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  tval  \rangle}%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{memop} \, \cnsym{(}  mem\_op  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  tval  \rangle}{%
{\cndrulename{Op\_IsE\_IsE\_Memop}}{}%
}}


\newcommand{\cndruleOpXXIsEXXIsEXXAction}[1]{\cndrule[#1]{%
\cnpremise{\langle  \cnnt{h}  \cnsym{;}  mem\_action  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  tval  \rangle}%
}{
\langle  \cnnt{h}  \cnsym{;}     \, mem\_action  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  tval  \rangle}{%
{\cndrulename{Op\_IsE\_IsE\_Action}}{}%
}}


\newcommand{\cndruleOpXXIsEXXIsEXXNegXXAction}[1]{\cndrule[#1]{%
\cnpremise{\langle  \cnnt{h}  \cnsym{;}  mem\_action  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  tval  \rangle}%
}{
\langle  \cnnt{h}  \cnsym{;}   \texttt{neg}  \, mem\_action  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  tval  \rangle}{%
{\cndrulename{Op\_IsE\_IsE\_Neg\_Action}}{}%
}}

\newcommand{\cndefnOpXXIsEXXIsE}[1]{\begin{cndefnblock}[#1]{$\langle  \cnnt{h}  \cnsym{;}  is\_expr  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  is\_expr'  \rangle$}{}
\cnusedrule{\cndruleOpXXIsEXXIsEXXMemop{}}
\cnusedrule{\cndruleOpXXIsEXXIsEXXAction{}}
\cnusedrule{\cndruleOpXXIsEXXIsEXXNegXXAction{}}
\end{cndefnblock}}

%% defn IsTE_TE
\newcommand{\cndruleOpXXIsTEXXIsTEXXLetSXXSub}[1]{\cndrule[#1]{%
\cnpremise{\cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \leadsto  \sigma}%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{let} \, \cnkw{strong} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, =  \cnkw{done} \, \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \cnkw{in} \, texpr  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}   \sigma  (  texpr  )   \rangle}{%
{\cndrulename{Op\_IsTE\_IsTE\_LetS\_Sub}}{}%
}}


\newcommand{\cndruleOpXXIsTEXXIsTEXXLetSXXLetS}[1]{\cndrule[#1]{%
\cnpremise{\langle  \cnnt{h}  \cnsym{;}  is\_expr  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  is\_expr'  \rangle}%
}{
\langle  \cnnt{h}  \cnsym{;}  \cnkw{let} \, \cnkw{strong} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, =  is\_expr \, \cnkw{in} \, texpr  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  \cnkw{let} \, \cnkw{strong} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, =  is\_expr' \, \cnkw{in} \, texpr  \rangle}{%
{\cndrulename{Op\_IsTE\_IsTE\_LetS\_LetS}}{}%
}}

\newcommand{\cndefnOpXXIsTEXXTE}[1]{\begin{cndefnblock}[#1]{$\langle  \cnnt{h}  \cnsym{;}  is\_texpr  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  texpr  \rangle$}{}
\cnusedrule{\cndruleOpXXIsTEXXIsTEXXLetSXXSub{}}
\cnusedrule{\cndruleOpXXIsTEXXIsTEXXLetSXXLetS{}}
\end{cndefnblock}}

%% defn TE_TE
\newcommand{\cndruleOpXXTEXXTEXXSeq}[1]{\cndrule[#1]{%
\cnpremise{\langle  \cnnt{h}  \cnsym{;}  seq\_texpr  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  texpr  \rangle}%
}{
\langle  \cnnt{h}  \cnsym{;}  seq\_texpr  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  texpr  \rangle}{%
{\cndrulename{Op\_TE\_TE\_Seq}}{}%
}}


\newcommand{\cndruleOpXXTEXXTEXXIs}[1]{\cndrule[#1]{%
\cnpremise{\langle  \cnnt{h}  \cnsym{;}  is\_texpr  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  texpr  \rangle}%
}{
\langle  \cnnt{h}  \cnsym{;}  is\_texpr  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  texpr  \rangle}{%
{\cndrulename{Op\_TE\_TE\_Is}}{}%
}}

\newcommand{\cndefnOpXXTEXXTE}[1]{\begin{cndefnblock}[#1]{$\langle  \cnnt{h}  \cnsym{;}  texpr  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  texpr'  \rangle$}{}
\cnusedrule{\cndruleOpXXTEXXTEXXSeq{}}
\cnusedrule{\cndruleOpXXTEXXTEXXIs{}}
\end{cndefnblock}}


\newcommand{\cndefnsopsemXXjtype}{
\cndefnOpXXSEXXTE{}\cndefnOpXXSTEXXTE{}\cndefnOpXXMemopXXTval{}\cndefnOpXXActionXXTval{}\cndefnOpXXIsEXXIsE{}\cndefnOpXXIsTEXXTE{}\cndefnOpXXTEXXTE{}}

\newcommand{\cndefnss}{
\cndefnslemmaXXjtype
\cndefnsresXXjtype
\cndefnsobjectXXvalueXXjtype
\cndefnspvalXXjtype
\cndefnsspineXXjtype
\cndefnspexprXXjtype
\cndefnscompXXpatternXXjtype
\cndefnsresXXpatternXXjtype
\cndefnsretXXpatternXXjtype
\cndefnstpvalXXjtype
\cndefnstpexprXXjtype
\cndefnsactionXXjtype
\cndefnsmemopXXjtype
\cndefnstvalXXjtype
\cndefnsseqXXexprXXjtype
\cndefnsisXXexprXXjtype
\cndefnstexprXXjtype
\cndefnssubsXXjtype
\cndefnspureXXopsemXXjtype
\cndefnsopsemXXjtype
}

\newcommand{\cnall}{\cnmetavars\\[0pt]
\cngrammar\\[5.0mm]
\cndefnss}

