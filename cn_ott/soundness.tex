% vim: ft=tex
\documentclass[11pt]{article}%

\usepackage{amsmath,amssymb}%
% supertabular package required if using the default grammar tabular
\usepackage{supertabular}
\usepackage[margin=1in]{geometry}


% the un-wrapped (-tex_wrap false) generated LaTeX file for CN
\include{cn_included}
\geometry{a4paper,portrait}
% the package that allows customized layout described in this document
\usepackage{ottlayout}
% the automatically generated file (with our Makefile) to link the generated
% LaTeX with the ottlayout package
\include{cn_override}


\usepackage{pf2}
\beforePfSpace{15pt, 10pt, 10pt, 10pt, 5pt, 2pt}
\afterPfSpace{15pt, 10pt, 10pt, 10pt, 5pt, 2pt}
\interStepSpace{15pt, 10pt, 10pt, 10pt, 5pt, 2pt}
\pflongindent%

\newcommand{\ctxC}{\mathcal{C}}%
\newcommand{\ctxL}{\mathcal{L}}%
\newcommand{\ctxN}{\Phi}%
\newcommand{\ctxR}{\mathcal{R}}%
\newcommand{\CLNR}{\ctxC ; \ctxL ; \ctxN ; \ctxR}
\newcommand{\CLNRp}{\ctxC' ; \ctxL' ; \ctxN' ; \ctxR'}
\newcommand{\stepsto}{\longrightarrow}%
\newcommand{\reducesto}{\mathrel{{\longrightarrow}^\ast}}%
\newcommand{\checks}{\Leftarrow}%
\newcommand{\synths}{\Rightarrow}%
\newcommand{\conf}[1]{\langle #1 \rangle}%
\newcommand{\sych}{\Leftrightarrow}%
\newcommand{\hconf}[2]{\langle #1 ; #2 \rangle}%
\newcommand{\lolly}{\multimap}

\title{Explicit CN Soundness Proof}
\author{Dhruv Makwana}

\begin{document}
\ottstyledefaults{premiselayout=justify}%

\maketitle

\section{Weakening}

If $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \sqsubseteq  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'$ and $\CLNR \vdash J$ then
$\CLNRp \vdash J$.

\begin{proof}

    \assume{%
        \begin{pfenum}
            \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \sqsubseteq  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'$.
            \item $\CLNR \vdash J$.\\
        \end{pfenum}
    }

    \prove{$\CLNRp \vdash J$.\\}

    \pfsketch{ Consider only the below cases, the rest are functorial in the environment.}

    \step{<1>1}{%
        \case{%
            \textsc{Ty\_PVal\_Var\_\{Comp,Log\}}.
        }{
            \pf\ By \textsc{Weak\_Cons\_\{Comp,Log\}}, if $\cnmv{x}  {:}  \beta \, \in \, \mathcal{C}$ (or $\cnmv{x}  {:}  \beta \, \in \, \mathcal{L}$) then $\cnmv{x}  {:}  \beta \, \in \, \mathcal{C}'$ (or $\cnmv{x}  {:}  \beta \, \in \, \mathcal{L}$).
        }
    }

    \step{<1>2}{%
        \case{%
            \textsc{Ty\_PVal\_Error}, \textsc{Ty\_Res\_Eq\_\{PointsTo,Term\}},
            \textsc{Ty\_Res\_\{PointsTo,\\
            Var,Conj,Fold\}}, \textsc{Ty\_Spine\_Res\_Phi},
            \textsc{Ty\_PE\_AssertUndef},\\
            \textsc{Ty\_TPVal\_\{Undef,Done\}},
            \textsc{Ty\_Action\_\{Load,Store,Kill\}},\\
            \textsc{Ty\_Memop\_PtrValidForDeref},
            \textsc{Ty\_TVal\_\{Phi,Undef\}}.
        }{%
        }
    }

    \begin{proof}

        \assume{ $\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  \cnnt{term'}  \cnsym{)}$.}

        \prove{ $\cnkw{smt} \, \cnsym{(}  \Phi'  \Rightarrow  \cnnt{term'}  \cnsym{)}$.\\}

        \step{<2>1}{If $\cnnt{term} \in \Phi$ then $\cnnt{term} \in \Phi'$.
            \pf\ By \textsc{Weak\_Cons\_Phi}.}

        \step{<2>2}{Any extra constraints in $\Phi'$ (by \textsc{Weak\_Skip\_Phi})
            would either be irrelevant, redundant, or inconsistent.}

        \step{<2>3}{In all cases, $\cnkw{smt} \, \cnsym{(}  \Phi'  \Rightarrow  \cnnt{term'}  \cnsym{)}$ as required.}

    \end{proof}
    %   

    \step{<1>3}{%
        \case{%
            \textsc{Ty\_Res\_\{Emp,SepConj,Pack\}},
            \textsc{Ty\_Spine\_\{Empty,Res\}},\\
            \textsc{Ty\_Action\_Create},
            \textsc{Ty\_TVal\_Res}, \textsc{Ty\_Memop\_\{Rel\_Binop,\\
            IntFromPtr, PtrFromInt,
            WellAligned, PtrArrayShift\}},\\
            \textsc{Ty\_TVal\_\{I,Undef\}},
            \textsc{Ty\_Seq\_TE\_\{Let,LetT,Run\}},
            \textsc{Ty\_IS\_TE\_LetS}.
        }{
        }
    }

    \begin{proof}

        \step{<2>1}{$\mathcal{R} = \mathcal{R}'$.\\
            \pf\ Only \textsc{Weak\_Cons\_Res} exists, no \textsc{Weak\_Skip\_Res}.}

        \step{<2>2}{All the rules are otherwise functorial in $\mathcal{C}, \mathcal{L}, \Phi$,
        .}

        \step{<2>3}{So $\mathcal{C}' ; \mathcal{L}' ; \Phi' ; \mathcal{R}'  \vdash  J$ as required.}

    \end{proof}

\end{proof}

\section{Substitution}

\subsection{Weakening for Substitution}

Weakening for substitution: as above, but with $J= ( \sigma ) : ( \ctxC'' ;
\ctxL'' ; \ctxN'' ; \ctxR'' )$.

\begin{proof}

    \assume{%
        \begin{pfenum}
            \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \sqsubseteq  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'$.
            \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}''  \cnsym{;}  \mathcal{L}''  \cnsym{;}  \Phi''  \cnsym{;}  \mathcal{R}''  \cnsym{)}$.\\
        \end{pfenum}
    }

    \prove{$\mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}''  \cnsym{;}  \mathcal{L}''  \cnsym{;}  \Phi''  \cnsym{;}  \mathcal{R}''  \cnsym{)}$.\\}

    \pfsketch{ By weakening and induction over the substitution.}

\end{proof}


\subsection{Substitutions preserve SMT results}\label{subsec:sub_smt}

\begin{proof}
    \assume{%
        \begin{pfenum}
            \item $\cnkw{smt} \, \cnsym{(}  \Phi'  \Rightarrow  \cnnt{term}  \cnsym{)}$.\label{sub_smt-assm1}
            \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \cnsym{)}$.\label{sub_smt-assm2}\\
        \end{pfenum}}

    \prove{$\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow   \sigma  (  \cnnt{term}  )   \cnsym{)}$.\\}

    \step{<1>1}{$\cnkw{smt} \, \cnsym{(}  \Phi'  \Rightarrow   \sigma  (  \cnnt{term}  )   \cnsym{)}$.\\
        \pf\ By assumption \ref{sub_smt-assm1}, which means it is true for
        all (well-typed) instantiations of its free variables.}

    \step{<1>2}{$\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow   \sigma  (  \cnnt{term}  )   \cnsym{)}$.\\
        \pf\ By $\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  \cnnt{term}  \cnsym{)}$ for each $ \cnnt{term} \in \Phi' $
        (from assumption \ref{sub_smt-assm2}) and \stepref{<1>1}.}

\end{proof}

\subsection{Resource equality is an equivalence relation}\label{subsec:res_eq_eqrel}

\pfsketch{ By induction.}

\subsection{Resource typing subsumption}\label{subsec:res_subsum}

\begin{proof}
    \assume{%
        \begin{pfenum}
            \item $\Phi  \vdash  \cnnt{res} \, \equiv \, \cnnt{res'}$.
            \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnnt{res\_term}  \Leftarrow  \cnnt{res}$.\\
        \end{pfenum}}

    \prove{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnnt{res\_term}  \Leftarrow  \cnnt{res'}$.\\}

    \pfsketch{ Induction over $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnnt{res\_term}  \Leftarrow  \cnnt{res}$.\\}

    \step{<1>1}{%
        \case{%
            \textsc{Ty\_Res\_Emp}
        }{%
            \pf\ $\cnnt{res} = \cnnt{res'} = \cnnt{res\_term} = \cnkw{emp}$.
        }
    }

    \step{<1>2}{%
        \case{%
            \textsc{Ty\_Res\_PointsTo}
        }{%
            $\cnnt{res} = \cnnt{points\_to''} , \cnnt{res\_term} = \cnnt{points\_to'}$,
            $\cnnt{res'} = \cnnt{points\_to_{{\mathrm{1}}}}$, $\mathcal{R} = \cdot  \cnsym{,}  \cnmv{\_}  {:}  \cnnt{points\_to}$.
        }
    }

    \begin{proof}
        \step{<2>1}{$\Phi  \vdash  \cnnt{points\_to} \, \equiv \, \cnnt{points\_to'}$ and $\Phi  \vdash  \cnnt{points\_to'} \, \equiv \, \cnnt{points\_to''}$ by inversion.}

        \step{<2>2}{$\Phi  \vdash  \cnnt{points\_to'} \, \equiv \, \cnnt{points\_to_{{\mathrm{1}}}}$ by transitivity
            (lemma \ref{subsec:res_eq_eqrel}).}

        \step{<2>3}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \cdot  \cnsym{,}  \cnmv{\_}  {:}  \cnnt{points\_to}  \vdash  \cnnt{points\_to'}  \Leftarrow  \cnnt{points\_to_{{\mathrm{1}}}}$ as required.}
    \end{proof}

    \step{<1>3}{%
        \case{%
            \textsc{Ty\_Res\_Var}
        }{%
            \pf\ By transitivity (lemma \ref{subsec:res_eq_eqrel}).
        }
    }

    \step{<1>4}{%
        \case{%
            \textsc{Ty\_Res\_SepConj}
        }{%
            \pf\ By induction.
        }
    }

    \step{<1>5}{%
        \case{%
            \textsc{Ty\_Res\_Conj}
        }{%
            \pf\ We know $\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  \cnsym{(}  \cnnt{term}  \rightarrow  \cnnt{term'}  \cnsym{)}  \cnsym{)}$ (by inversion on
            the equality) and $\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  \cnnt{term}  \cnsym{)}$ (by inversion on the
            typing rule) so $\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow  \cnnt{term'}  \cnsym{)}$. Rest follows by induction.
        }
    }

    \step{<1>6}{%
        \case{%
            \textsc{Ty\_Res\_Pack}
        }{%
            $\cnnt{res\_term} = \cnkw{pack} \, \cnsym{(}  pval  \cnsym{,}  \cnnt{res\_term'}  \cnsym{)}$, $\cnnt{res} = \exists \, \cnmv{y}  {:}  \beta  . \:  \cnnt{res_{{\mathrm{1}}}}$, $\cnnt{res'} = \exists \, \cnmv{y}  {:}  \beta  . \:  \cnnt{res'_{{\mathrm{1}}}}$.
        }
    }

    \begin{proof}

        \step{<2>1}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnnt{res\_term'}  \Leftarrow   pval  \cnsym{/}  \cnmv{y}  \cnsym{,}  \cdot  (  \cnnt{res'_{{\mathrm{1}}}}  ) $ by induction.}

        \step{<2>2}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{pack} \, \cnsym{(}  pval  \cnsym{,}  \cnnt{res\_term'}  \cnsym{)}  \Leftarrow  \exists \, \cnmv{y}  {:}  \beta  . \:  \cnnt{res'_{{\mathrm{1}}}}$ as required.}

    \end{proof}

    \step{<1>7}{%
        \case{%
            \textsc{Ty\_Res\_Fold}
        }{%
            \pf\ $\cnnt{res} = \cnnt{res'} = { \alpha }  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}$.
        }
    }


\end{proof}

\subsection{Substitution Lemma}\label{subsec:sub_lemma}

If $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \cnsym{)}$ and $\CLNRp \vdash
J$ then $\ctxC ; \ctxL ; \ctxN ; \ctxR \vdash \sigma ( J )$.

\begin{proof}
    \pfsketch{ Induction over the typing judgements.\\}

    \assume{%
        \begin{pfenum}
            \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \cnsym{)}$.
            \item $\CLNRp \vdash J$.\\
        \end{pfenum}
    }

    \prove{$\ctxC ; \ctxL ; \ctxN ; \ctxR \vdash \sigma ( J )$.\\}

    \step{<1>1}{%
        \case{%
            \textsc{Ty\_PVal\_Obj*},
            \textsc{Ty\_PVal\_\{Obj,Loaded,Unit,True,False,Ctor\_Nil\}}.
        }{%
            \pf\ No free variables in $J$ so $\sigma ( J ) = J$ and the rules
            do not depend on the environment, so we are done.
        }
    }

    \step{<1>2}{%
        \case{%
            \textsc{Ty\_PVal\_\{List,Tuple,Ctor\_Cons,Ctor\_Tuple,Ctor\_Array,Ctor\_Specified\}}.
        }{%
            \pf\ By induction and then definition of substitution over values.
        }
    }

    \step{<1>3}{%
        \case{%
            \textsc{Ty\_PVal\_Var}.
        }{%
            $\mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \vdash  \cnmv{x}  \Rightarrow  \beta$
        }
    }

    \begin{proof}
        \step{<2>1}{$\cnmv{x}  {:}  \beta \, \in \, \mathcal{C}'$ (or $\cnmv{x}  {:}  \beta \, \in \, \mathcal{L}'$) by inversion.}
        \step{<2>2}{So $\exists pval.\ \mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow  \beta$
            by \textsc{Ty\_Subs\_Cons\_\{Comp,Log\}}.}
        \step{<2>3}{Since $pval = \sigma(x)$, we are done.}
    \end{proof}

    \step{<1>4}{%
        \case{%
            \textsc{Ty\_PVal\_Error}.
        }{%
            \pf\ Substitutions preserve SMT results (lemma \ref{subsec:sub_smt}).
        }
    }

    \step{<1>5}{%
        \case{%
            \textsc{Ty\_PVal\_Struct}.
        }{%
            $\mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \vdash  \cnsym{(} \, \cnkw{struct} \, tag  \cnsym{)}  \cnsym{\{} \, \cncomp{. \, member_{\cnmv{i}}  =  pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{\}}  \Rightarrow  \cnkw{struct} \, tag$
        }
    }

    \begin{proof}
        \step{<2>1}{$\cncomp{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash   \sigma  (  pval_{\cnmv{i}}  )   \Rightarrow   \beta_{  \tau_{\cnmv{i}}  } }{\cnmv{i}}$ by induction.}

        \step{<2>2}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  \cnsym{(} \, \cnkw{struct} \, tag  \cnsym{)}  \cnsym{\{} \, \cncomp{. \, member_{\cnmv{i}}  =   \sigma  (  pval_{\cnmv{i}}  ) }{\cnmv{i}} \, \cnsym{\}}  \Rightarrow  \cnkw{struct} \, tag$ }
    \end{proof}

    \step{<1>6}{%
        \case{%
            \textsc{Ty\_Eq\_Emp}
        }{
            \pf\ True trivially (no free variables).
        }
    }

    \step{<1>7}{%
        \case{%
            \textsc{Ty\_Res\_Eq\_PointsTo}.
        }{
            \pf\ Substitutions preserver SMT results (lemma \ref{subsec:sub_smt}).
        }
    }

    \step{<1>8}{%
        \case{%
            \textsc{Ty\_Res\_Eq\_SepConj}.
        }{
            \pf\ By induction.
        }
    }

    \step{<1>9}{%
        \case{%
            \textsc{Ty\_Res\_Eq\_Exists}.
        }{
            \pf\ By induction.
        }
    }

    \step{<1>10}{%
        \case{%
            \textsc{Ty\_Res\_Eq\_Term}.
        }{
            \pf\ By induction and substitutions preserving SMT results (lemma
            \ref{subsec:sub_smt}).
        }
    }

    \step{<1>11}{%
        \case{%
            \textsc{Ty\_Res\_Emp}.
        }{
            \pf True trivially (no free variables).
        }
    }

    \step{<1>12}{%
        \case{%
            \textsc{Ty\_Res\_PointsTo}.
        }{%
            $\mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \cdot  \cnsym{,}  \cnmv{\_}  {:}  \cnnt{pt}  \vdash  \cnnt{pt'}  \Leftarrow  \cnnt{pt''}$.
            \prove{ $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash   \sigma  (  \cnnt{pt'}  )   \Leftarrow   \sigma  (  \cnnt{pt''}  ) $.}
        }
    }

    \begin{proof}

    \step{<2>1}{Since $\mathcal{R}' = \cdot  \cnsym{,}  \cnmv{\_}  {:}  \cnnt{pt}$, $\sigma$ was
        derived using \textsc{Ty\_Subs\_Cons\_Res}.}

    \step{<2>2}{$\Phi'  \vdash  \cnnt{pt} \, \equiv \, \cnnt{pt'}$ and $\Phi'  \vdash  \cnnt{pt'} \, \equiv \, \cnnt{pt''}$ by inversion on the case.}

    \step{<2>3}{So $\Phi  \vdash   \sigma  (  \cnnt{pt}  )  \, \equiv \,  \sigma  (  \cnnt{pt'}  ) $ and $\Phi  \vdash   \sigma  (  \cnnt{pt'}  )  \, \equiv \,  \sigma  (  \cnnt{pt''}  ) $ because substitutions preserve SMT results (lemma \ref{subsec:sub_smt}).}

    \step{<2>4}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnnt{res\_term}  \Leftarrow   \sigma  (  \cnnt{pt}  ) $ by inversion on \stepref{<2>1}.}

    \step{<2>5}{$\cnnt{res\_term} = \cnnt{pt_{{\mathrm{3}}}}$ for some $\cnnt{pt_{{\mathrm{3}}}}$ by inversion
        on \stepref{<2>4} (\textsc{Ty\_Res\_PointsTo}).}

    \step{<2>6}{$\Phi  \vdash  \cnnt{pt_{{\mathrm{3}}}} \, \equiv \,  \sigma  (  \cnnt{pt}  ) $ by inversion on \stepref{<2>3}.}

    \step{<2>7}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash   \sigma  (  \cnnt{pt'}  )   \Leftarrow  \cnnt{pt_{{\mathrm{3}}}}$.\\
        \pf\ \textsc{Ty\_Res\_PointsTo} is symmetric in all its $\cnnt{pt}$
        arguments (because resource equality is an equivalence relation, lemma
        \ref{subsec:res_eq_eqrel}).}

    \step{<2>8}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash   \sigma  (  \cnnt{pt'}  )   \Leftarrow   \sigma  (  \cnnt{pt''}  ) $.\\
        \pf\ By \stepref{<2>3}, resource equality an equivalence relation
        (lemma \ref{subsec:res_eq_eqrel}) and resource typing subsumption
        (lemma \ref{subsec:res_subsum}).}

    \end{proof}

    \step{<1>13}{%
        \case{%
            \textsc{Ty\_Res\_Var}.
        }{%
            $\mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \cdot  \cnsym{,}  \cnmv{r}  {:}  \cnnt{res}  \vdash  \cnmv{r}  \Leftarrow  \cnnt{res'}$.
        }
    }

    \begin{proof}
        \step{<2>1}{From $\mathcal{R}' = \cdot  \cnsym{,}  \cnmv{r}  {:}  \cnnt{res}$, we know $\sigma$
            was derived using \textsc{Ty\_Subs\_Cons\_Res}.}

        \step{<2>2}{$\sigma = \cnnt{res\_term}  \cnsym{/}  \cnmv{r}  \cnsym{,}  \sigma'$ and $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnnt{res\_term}  \Leftarrow   \sigma'  (  \cnnt{res}  ) $ by inversion on \stepref{<2>1}.}

        \step{<2>3}{$\Phi'  \vdash  \cnnt{res} \, \equiv \, \cnnt{res'}$ by inversion on \textsc{Ty\_Res\_Var}.}

        \step{<2>4}{$\Phi  \vdash  \cnnt{res} \, \equiv \, \cnnt{res'}$ and $\Phi  \vdash   \sigma  (  \cnnt{res}  )  \, \equiv \,  \sigma  (  \cnnt{res'}  ) $
            by \stepref{<2>3} and substitution lemma over \textsc{Ty\_Res\_Eq*} cases.}

        \step{<2>5}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnnt{res\_term}  \Leftarrow   \sigma'  (  \cnnt{res}  ) $ by
            inversion on \textsc{Ty\_Subs\_Cons\_Res}.}

        \step{<2>6}{$ \sigma  (  \cnmv{r}  )  = \cnnt{res\_term}$ by \stepref{<2>2}.}

        \step{<2>7}{$ \sigma'  (  \cnnt{res'}  )  =  \sigma  (  \cnnt{res'}  ) $ (and same for $\cnnt{res}$)
            because $r$ cannot occur in either.}

        \step{<2>8}{\suffices{ $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnnt{res\_term}  \Leftarrow   \sigma'  (  \cnnt{res'}  ) $ by
            \stepref{<2>3} and \stepref{<2>7}.}
            \pf\ Resource typing subsumption (lemma \ref{subsec:res_subsum}) and \stepref{<2>4}.}

    \end{proof}

    \step{<1>14}{%
        \case{%
            \textsc{Ty\_Res\_SepConj}.
        }{%
            \pf\ By induction.
        }
    }

    \step{<1>15}{%
        \case{%
            \textsc{Ty\_Res\_Conj}.
        }{%
            $\mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \vdash  \cnnt{res\_term}  \Leftarrow  term  \wedge  \cnnt{res}$.
        }
    }

    \begin{proof}
        \step{<2>1}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash   \sigma  (  \cnnt{res\_term}  )   \Leftarrow   \sigma  (  \cnnt{res}  ) $.\\
            \pf\ By induction.}

        \step{<2>2}{$\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow   \sigma  (  \cnnt{term}  )   \cnsym{)}$.\\
            \pf\ Substitutions preserve SMT results (lemma \ref{subsec:sub_smt}).}

        \step{<2>3}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash   \sigma  (  \cnnt{res\_term}  )   \Leftarrow   \sigma  (  term  \wedge  \cnnt{res}  ) $
            as required.}

    \end{proof}

    \step{<1>16}{%
        \case{%
            \textsc{Ty\_Res\_Pack}.
        }{%
            $\mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \vdash  \cnkw{pack} \, \cnsym{(}  pval  \cnsym{,}  \cnnt{res\_term}  \cnsym{)}  \Leftarrow  \exists \, \cnmv{y}  {:}  \beta  . \:  \cnnt{res}$.
        }
    }

    \begin{proof}
        \step{<2>1}{By induction,\begin{pfenum}
            \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash   \sigma  (  pval  )   \Rightarrow  \beta$.
            \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash   \sigma  (  \cnnt{res\_term}  )   \Leftarrow   \sigma  \cnsym{,}  pval  \cnsym{/}  \cnmv{y}  \cnsym{,}  \cdot  (  \cnnt{res}  ) $.
        \end{pfenum}}

        \step{<2>2}{So $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash   \sigma  (  \cnkw{pack} \, \cnsym{(}  pval  \cnsym{,}  \cnnt{res\_term}  \cnsym{)}  )   \Leftarrow   \sigma  (  \exists \, \cnmv{y}  {:}  \beta  . \:  \cnnt{res}  ) $.}
    \end{proof}
    
    \step{<1>16a}{%
        \case{%
            \textsc{Ty\_Res\_Fold}
        }{%
            $\mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \vdash  \cnkw{fold} \, \cnsym{(}  \cnnt{res\_term}  \cnsym{)}  \Leftarrow  { \alpha }  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}$
        }
    }

    \begin{proof}
        \step{<2>1}{By induction,\begin{pfenum}
            \item ${ \alpha } \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}  {:}  \beta_{\cnmv{i}}}{\cnmv{i}} \, \mapsto  \cnnt{res} \, \in \, \cnkw{Globals}$
            \item $\cncomp{\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash   \sigma  (  pval_{\cnmv{i}}  )   \Rightarrow  \beta_{\cnmv{i}}}{\cnmv{i}}$
            \item $\Phi  \vdash   \sigma  (  \cnnt{res'}  )   = \, \cnkw{strip\_ifs} \, \cnsym{(}   \sigma  (   \cncomp{pval_{\cnmv{i}}  \cnsym{/}  \cnmv{x_{\cnmv{i}}}  \cnsym{,}  \cdot}{\cnmv{i}}  (  \cnnt{res}  )   )   \cnsym{)}$
            \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash   \sigma  (  \cnnt{res\_term}  )   \Leftarrow   \sigma  (  \cnnt{res'}  ) $
        \end{pfenum}}

        \step{<2>2}{So $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash   \sigma  (  \cnkw{fold} \, \cnsym{(}  \cnnt{res\_term}  \cnsym{)}  )   \Leftarrow   \sigma  (  { \alpha }  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}  ) $.}

    \end{proof}

    \step{<1>17}{%
        \case{%
            \textsc{Ty\_Spine\_Empty}.
        }{
            \pf\ $\cnnt{ret}$ can be anything, including $ \sigma  (  \cnnt{ret}  ) $ and
            the rule does not depend on the environment, so we are done.
        }
    }

    \step{<1>18}{%
        \case{%
            \textsc{Ty\_Spine\_Comp}.
        }{
            $\mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \vdash  \cnmv{x}  =  pval  \cnsym{,} \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \Pi \, \cnmv{x}  {:}  \beta  . \:  \cnnt{arg}  \gg  pval  \cnsym{/}  \cnmv{x}  \cnsym{,}  \psi  \cnsym{;}  \cnnt{ret}$.
        }
    }

    \begin{proof}
        \step{<2>1}{By induction,\begin{pfenum}
            \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash   \sigma  (  pval  )   \Rightarrow  \beta$.
            \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =   \sigma  (  \cnnt{spine\_elem_{\cnmv{i}}}  ) }{\cnmv{i}} \, \mathbin{ {:} {:} }   \sigma  (  \cnnt{arg}  )   \gg   \sigma  (  \psi  )   \cnsym{;}   \sigma  (  \cnnt{ret}  ) $.
        \end{pfenum}}

        \step{<2>2}{So $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnmv{x}  =   \sigma  (  pval  )   \cnsym{,} \, \cncomp{\cnmv{x_{\cnmv{i}}}  =   \sigma  (  \cnnt{spine\_elem_{\cnmv{i}}}  ) }{\cnmv{i}} \, \mathbin{ {:} {:} }   \sigma  (  \Pi \, \cnmv{x}  {:}  \beta  . \:  \cnnt{arg}  )   \gg   \sigma  (   pval  \cnsym{/}  \cnmv{x}  \cnsym{,}  \psi   )   \cnsym{;}   \sigma  (  \cnnt{ret}  ) $.}
    \end{proof}

    \step{<1>19}{%
        \case{%
            \textsc{Ty\_Spine\_Log}.
        }{
            \pf\ Similar to \textsc{Ty\_Spine\_Comp}.
        }
    }

    \step{<1>20}{%
        \case{%
            \textsc{Ty\_Spine\_Res}.
        }{%
            $\mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'_{{\mathrm{1}}}  \cnsym{,}  \mathcal{R}_{{\mathrm{2}}}  \vdash  \cnmv{x}  =  \cnnt{res\_term}  \cnsym{,} \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{res}  \multimap  \cnnt{arg}  \gg  \cnnt{res\_term}  \cnsym{/}  \cnmv{x}  \cnsym{,}  \psi  \cnsym{;}  \cnnt{ret}$
        }
    }

    \begin{proof}
        \step{<2>1}{By inversion and then induction,
        \begin{pfenum}
            \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \vdash   \sigma  (  \cnnt{res\_term}  )   \Leftarrow   \sigma  (  \cnnt{res}  ) $.
            \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}_{{\mathrm{2}}}  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =   \sigma  (  \cnnt{spine\_elem_{\cnmv{i}}}  ) }{\cnmv{i}} \, \mathbin{ {:} {:} }    \sigma  (  \cnnt{res}  )    \multimap   \sigma  (  \cnnt{arg}  )   \gg   \sigma  (  \psi  )   \cnsym{;}   \sigma  (  \cnnt{ret}  ) $.
        \end{pfenum}}

        \step{<2>2}{Hence $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{R}_{{\mathrm{2}}}  \vdash  \cnmv{x}  =   \sigma  (  \cnnt{res\_term}  )   \cnsym{,} \, \cncomp{\cnmv{x_{\cnmv{i}}}  =   \sigma  (  \cnnt{spine\_elem_{\cnmv{i}}}  ) }{\cnmv{i}} \, \mathbin{ {:} {:} }   \sigma  (   \cnnt{res}  \multimap  \cnnt{arg}   )   \gg   \sigma  (   \cnnt{res\_term}  \cnsym{/}  \cnmv{x}  \cnsym{,}  \psi   )   \cnsym{;}   \sigma  (  \cnnt{ret}  ) $ as required.}
    \end{proof}

    \step{<1>21}{%
        \case{%
            \textsc{Ty\_Spine\_Phi}.
        }{%
            $\mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  term  \supset  \cnnt{arg}  \gg  \psi  \cnsym{;}  \cnnt{ret}$
        }
    }

    \begin{proof}
        \step{<2>1}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =   \sigma  (  \cnnt{spine\_elem_{\cnmv{i}}}  ) }{\cnmv{i}} \, \mathbin{ {:} {:} }    \sigma  (  \cnnt{res}  )    \multimap   \sigma  (  \cnnt{arg}  )   \gg   \sigma  (  \psi  )   \cnsym{;}   \sigma  (  \cnnt{ret}  ) $.\\
            \pf\ By induction.}

        \step{<2>2}{$\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow   \sigma  (  \cnnt{term}  )   \cnsym{)}$.\\
            \pf\ Substitutions preserve SMT results (lemma \ref{subsec:sub_smt}).}

        \step{<2>3}{Hence $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{R}_{{\mathrm{2}}}  \vdash  \cnmv{x}  =   \sigma  (  \cnnt{res\_term}  )   \cnsym{,} \, \cncomp{\cnmv{x_{\cnmv{i}}}  =   \sigma  (  \cnnt{spine\_elem_{\cnmv{i}}}  ) }{\cnmv{i}} \, \mathbin{ {:} {:} }   \sigma  (   \cnnt{res}  \multimap  \cnnt{arg}   )   \gg   \sigma  (   \cnnt{res\_term}  \cnsym{/}  \cnmv{x}  \cnsym{,}  \psi   )   \cnsym{;}   \sigma  (  \cnnt{ret}  ) $ as required.}
    \end{proof}


    \step{<1>22}{%
        \case{%
            \textsc{Ty\_PE\_Val}
        }{%
            \pf\ By induction.
        }
    }

    \step{<1>23}{%
        \case{%
            \textsc{Ty\_PE\_Array\_Shift}.
        }{%
            $\mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \vdash  \cnkw{array\_shift} \, \cnsym{(}  pval_{{\mathrm{1}}}  \cnsym{,}  \tau  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{)}  \Rightarrow  \cnmv{y}  {:}  \cnkw{loc}  . \:  \cnmv{y}  =   pval_{{\mathrm{1}}}   \mathbin{ {+}_{ \mathrm{ptr} } }  \cnsym{(}   pval_{{\mathrm{2}}}   \times   \mathrm{size\_of}(  \tau  )   \cnsym{)}$
        }
    }

    \begin{proof}
        \step{<2>1}{By induction,
            \begin{pfenum}
                \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash   \sigma  (  pval_{{\mathrm{1}}}  )   \Rightarrow  \cnkw{loc}$
                \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash   \sigma  (  pval_{{\mathrm{2}}}  )   \Rightarrow  \cnkw{integer}$
            \end{pfenum}}

        \step{<2>2}{So, $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash   \sigma  (  \cnkw{array\_shift} \, \cnsym{(}  pval_{{\mathrm{1}}}  \cnsym{,}  \tau  \cnsym{,}  pval_{{\mathrm{2}}}  \cnsym{)}  )   \Rightarrow  \cnmv{y}  {:}  \cnkw{loc}  . \:   \sigma  (  \cnsym{(}  \cnmv{y}  =   pval_{{\mathrm{1}}}   \mathbin{ {+}_{ \mathrm{ptr} } }  \cnsym{(}   pval_{{\mathrm{2}}}   \times   \mathrm{size\_of}(  \tau  )   \cnsym{)}  \cnsym{)}  ) $.}
    \end{proof}

    \step{<1>24}{%
        \case{%
            \textsc{Ty\_PE\_Member\_Shift}.
        }{%
            \pf\ Similar to \textsc{Ty\_PE\_Array\_Shift}.
        }
    }

    \step{<1>25}{%
        \case{%
            \textsc{Ty\_PE\_\{Not,Arith\_Binop,Rel\_Binop,Bool\_Binop\}}.
        }{%
            \pf\ By induction.
        }
    }

    \step{<1>26}{%
        \case{%
            \textsc{Ty\_PE\_Call}.
        }{%
            See \textsc{Ty\_Seq\_E\_CCall} for more general case and proof.
        }
    }

    \step{<1>27}{%
        \case{%
            \textsc{Ty\_PE\_\{Assert\_Undef,Bool\_To\_Integer,WrapI\}}.
        }{%
            \pf\ By induction.
        }
    }

    \step{<1>28}{%
        \case{%
            \textsc{Ty\_TPVal\_Undef}
        }{%
            See \textsc{Ty\_TVal\_Undef} for a more general case and proof.
        }
    }

    \step{<1>29}{%
        \case{%
            \textsc{Ty\_TPVal\_Done}
        }{%
            $\mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \vdash  \cnkw{done} \, pval  \Leftarrow  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}$.
        }
    }

    \begin{proof}
        \step{<2>1}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash   \sigma  (  pval  )   \Rightarrow  \beta$.\\
            \pf\ By induction.}

        \step{<2>2}{$\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow   \sigma  \cnsym{,}  pval  \cnsym{/}  \cnmv{y}  \cnsym{,}  \cdot  (  \cnnt{term}  )   \cnsym{)}$.\\
            \pf\ Substitutions preserve SMT results (lemma \ref{subsec:sub_smt}).}

        \step{<2>3}{So $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash   \sigma  (  \cnkw{done} \, pval  )   \Leftarrow  \cnmv{y}  {:}  \beta  . \:   \sigma  (  \cnnt{term}  ) $.}
    \end{proof}

    \step{<1>30}{%
        \case{%
            \textsc{Ty\_TPE\_\{Let,LetT\}}.
        }{%
            See \textsc{Ty\_Seq\_TE\_\{Let,LetT\}} for a more general case and proof.
        }
    }

    \step{<1>31}{%
        \case{%
            \textsc{Ty\_TPE\_If}.
        }{%
            \pf\ By induction.
        }
    }

    \step{<1>32}{%
        \case{%
            \textsc{Ty\_TPE\_Case}.
        }{%
            \pf\ See \textsc{Ty\_Seq\_TE\_Case} for more general case and proof.
        }
    }

    \step{<1>33}{%
        \case{%
            \textsc{Ty\_\{Action*,Memop*\}}.
        }{%
            \pf\ By induction and lemma \ref{subsec:sub_smt} (substitutions preserve SMT results).
        }
    }

    \step{<1>34}{%
        \case{%
            \textsc{Ty\_TVal\_I}
        }{%
            \pf\ Trivially (no free variables nor requirements on constraint context).
        }
    }

    \step{<1>35}{%
        \case{%
            \textsc{Ty\_TVal\_\{Comp,Log\}}.
        }{%
            Only focusing on logical case; computational one is similar.\\
            $\mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \vdash  \cnkw{done} \, pval  \cnsym{,} \, \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}}  \Leftarrow  \exists \, \cnmv{y}  {:}  \beta  . \:  \cnnt{ret}$.
        }
    }

    \begin{proof}
        \step{<2>1}{By inversion and then induction,
        \begin{pfenum}
            \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash   \sigma  (  pval  )   \Rightarrow  \beta$
            \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash   \sigma  (  \cnkw{done} \, \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}}  )   \Leftarrow   \sigma  (   pval  \cnsym{/}  \cnmv{y}  \cnsym{,}  \cdot  (  \cnnt{ret}  )   ) $.
        \end{pfenum}}

        \step{<2>2}{Therefore $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash   \sigma  (  \cnkw{done} \, pval  \cnsym{,} \, \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}}  )   \Leftarrow  \exists \, \cnmv{y}  {:}  \beta  . \:   \sigma  (  \cnnt{ret}  ) $.}
    \end{proof}

    \step{<1>36}{%
        \case{%
            \textsc{Ty\_TVal\_Phi}
        }{%
            $\mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \vdash  \cnkw{done} \, \cnnt{spine}  \Leftarrow  term  \wedge  \cnnt{ret}$
        }
    }

    \begin{proof}
        \step{<2>1}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash   \sigma  (  \cnkw{done} \, \cnnt{spine}  )   \Leftarrow   \sigma  (  \cnnt{ret}  ) $.\\
            \pf\ By induction.}

        \step{<2>2}{$\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow   \sigma  (  \cnnt{term}  )   \cnsym{)}$.\\
            \pf\ Substitutions preserve SMT results (lemma \ref{subsec:sub_smt}).}

        \step{<2>3}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash   \sigma  (  \cnkw{done} \, \cnnt{spine}  )   \Leftarrow   \sigma  (  term  \wedge  \cnnt{ret}  ) $ as required.}
    \end{proof}

    \step{<1>37}{%
        \case{%
            \textsc{Ty\_TVal\_Res}
        }{%
            \pf\ Similar to \textsc{Ty\_TVal\_Phi}, except with resource
            environments being split.
        }
    }

    \step{<1>38}{%
        \case{%
            \textsc{Ty\_TVal\_Undef}
        }{%
            \pf\ $\cnnt{ret}$ can be anything, including $ \sigma  (  \cnnt{ret}  ) $.
        }
    }

    \step{<1>39}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_\{TVal,If,Bound\}}.
        }{%
            \pf\ By induction.
        }
    }

    \step{<1>40}{%
        \case{%
            \textsc{Ty\_Seq\_E\_\{CCall,Proc,Run\}}.
        }{%
            Only focusing on CCall, rest are similar.\\
        }
    }

    \begin{proof}

        \step{<2>1}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =   \sigma  (  \cnnt{spine\_elem_{\cnmv{i}}}  ) }{\cnmv{i}} \, \mathbin{ {:} {:} }   \sigma  (  \cnnt{arg}  )   \gg   \sigma  (  \psi  )   \cnsym{;}   \sigma  (  \cnnt{ret}  ) $.\\
            \pf\ By induction.}

        \step{<2>2}{$ident  {:}  \cnnt{arg} \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mapsto  texpr \, \in \, \cnkw{Globals}$ is unaffected by the substitution.}

        \step{<2>3}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{ccall} \, \cnsym{(}  \tau  \cnsym{,}  ident  \cnsym{,}  \cncomp{ \sigma  (  \cnnt{spine\_elem_{\cnmv{i}}}  ) }{\cnmv{i}}  \cnsym{)}  \Rightarrow   \sigma  \cnsym{,}  \psi  (  \cnnt{ret}  ) $ as required.}

    \end{proof}

    \step{<1>41}{%
        \case{%
            \textsc{Ty\_Is\_\{Memop,Neg\_Action,Action\}}
        }{
            \pf\ By induction.
        }
    }

    \step{<1>42}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_\{LetP,LetPT\}}.
        }{
            \pf\ See \textsc{Ty\_Seq\_TE\_\{Let,LetT\}}.
        }
    }

    \step{<1>43}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_\{Let,LetT,LetS\}}.
        }{
            Only doing \textsc{Let} case, \textsc{LetT} and \textsc{LetS} are similar.\\
            $\mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'''  \cnsym{,}  \mathcal{R}''  \vdash  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, =  seq\_expr \, \cnkw{in} \, texpr  \Leftarrow  \cnnt{ret_{{\mathrm{2}}}}$.
        }
    }

    \begin{proof}
        \step{<2>1}{By induction,
        \begin{pfenum}
            \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}'  \vdash   \sigma  (  seq\_expr  )   \Rightarrow   \sigma  (  \cnnt{ret_{{\mathrm{1}}}}  ) $.
            \item $\mathcal{C}  \cnsym{,}  \mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \mathcal{L}  \cnsym{,}  \mathcal{L}_{{\mathrm{1}}}  \cnsym{;}  \Phi  \cnsym{,}  \Phi_{{\mathrm{1}}}  \cnsym{;}  \mathcal{R}  \cnsym{,}  \mathcal{R}_{{\mathrm{1}}}  \vdash   \sigma  (  texpr  )   \Leftarrow   \sigma  (  \cnnt{ret_{{\mathrm{2}}}}  ) $.
        \end{pfenum}}

        \step{<2>2}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}'  \cnsym{,}  \mathcal{R}  \vdash   \sigma  (  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, =  seq\_expr \, \cnkw{in} \, texpr  )   \Leftarrow   \sigma  (  \cnnt{ret_{{\mathrm{2}}}}  ) $ as required.}
    \end{proof}

    \step{<1>44}{
        \case{%
            \textsc{Ty\_Seq\_TE\_Case}.
        }{
            $\mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \vdash  \cnkw{case} \, pval \, \cnkw{of} \, \cncomp{\mid  pattern_{\cnmv{i}}  \Rightarrow  texpr_{\cnmv{i}}}{\cnmv{i}} \, \cnkw{end}  \Leftarrow  \cnnt{ret}$.
        }
    }

    \begin{proof}
        \step{<2>1}{By induction,
            \begin{pfenum}
                \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash   \sigma  (  pval  )   \Rightarrow  \beta_{{\mathrm{1}}}$.
                \item $\cncomp{\mathcal{C}  \cnsym{,}  \mathcal{C}_{\cnmv{i}}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{,}  term_{\cnmv{i}}  =    \sigma  (  pval  )    \cnsym{;}  \mathcal{R}  \vdash   \sigma  (  texpr_{\cnmv{i}}  )   \Leftarrow   \sigma  (  \cnnt{ret}  ) }{\cnmv{i}}$.
            \end{pfenum}}

        \step{<2>2}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash   \sigma  (  \cnkw{case} \, pval \, \cnkw{of} \, \cncomp{\mid  pattern_{\cnmv{i}}  \Rightarrow  texpr_{\cnmv{i}}}{\cnmv{i}} \, \cnkw{end}  )   \Leftarrow   \sigma  (  \cnnt{ret}  ) $ as required.}

    \end{proof}

    \step{<1>45}{%
        \case{%
            \textsc{Ty\_TE\_\{Is,Seq\}}.
        }{
            \pf\ By induction.
        }
    }

\end{proof}

\subsection{Identity Extension}

If $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \cnsym{)}$ then $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{,}   \mathrm{id}   \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}  \cnsym{,}  \mathcal{C}'  \cnsym{;}  \mathcal{L}  \cnsym{,}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{R}'  \cnsym{)}$.

\begin{proof}
    \pfsketch{ Induction over the substitution.\\}

    \assume{%
        $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \cnsym{)}$.\\
    }

    \prove{%
        $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{,}   \mathrm{id}   \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}  \cnsym{,}  \mathcal{C}'  \cnsym{;}  \mathcal{L}  \cnsym{,}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{R}'  \cnsym{)}$.\\
    }

    \step{<1>1}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \vdash  \cnsym{(}   \mathrm{id}   \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \cnsym{)}$.\\
        \pf\ By induction on each of $\ctxC ; \ctxL ; \ctxN ; \ctxR_1$.}

    \step{<1>2}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{,}   \mathrm{id}   \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}  \cnsym{,}  \mathcal{C}'  \cnsym{;}  \mathcal{L}  \cnsym{,}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{R}'  \cnsym{)}$ \\
        \pf\ By induction on $\sigma$ with base case as above.}

\end{proof}


\subsection{Let-friendly Substitution Lemma}\label{subsec:let_sub_lemma}

If $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \cnsym{)}$ and $\ctxC ,
\ctxC' ; \ctxL , \ctxL' ; \ctxN ; \ctxR_1 , \ctxR' \vdash J$ then
$\ctxC ; \ctxL ; \sigma ( \ctxN ) ; \ctxR_1 , \ctxR \vdash \sigma ( J )$.

\begin{proof}
    \pfsketch{ Apply identity extension then substitution lemma.\\}

    \assume{%
        \begin{pfenum}
            \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}'  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'  \cnsym{)}$.\label{usl1}
            \item $\ctxC , \ctxC' ; \ctxL , \ctxL' ; \ctxN' ; \ctxR_1 , \ctxR' \vdash J$.\\
        \end{pfenum}
    }

    \prove{%
        $\ctxC ; \ctxL ; \sigma ( \ctxN ) ; \ctxR_1 , \ctxR \vdash \sigma ( J )$.\\
    }

    \step{<1>1}{$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{,}   \mathrm{id}   \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}  \cnsym{,}  \mathcal{C}'  \cnsym{;}  \mathcal{L}  \cnsym{,}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{R}'  \cnsym{)}$.\\
        \pf\ Apply identity extension to \ref{usl1}.}\pflabel{usl2}

    \step{<1>2}{$\ctxC ; \ctxL ; \sigma ( \ctxN ) ; \ctxR_1 , \ctxR \vdash ( \sigma , \mathrm{id} ) ( J )$.\\
    \pf\ Apply substitution lemma (\ref{subsec:sub_lemma}) to \pfref{usl2}.}

    \step{<1>3}{$\ctxC ; \ctxL ; \sigma( \ctxN ) ; \ctxR_1 , \ctxR \vdash \sigma ( J )$.\\
        \pf\ $\mathrm{id}( J )  = J$.}

\end{proof}

\section{Progress}\label{sec:progress}

\subsection{\textsc{Ty\_Spine\_*} and \textsc{Decons\_Arg\_*} construct same
substitution and return type}\label{subsec:spine_decons_same}

If $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}$ and
$\cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma'  \cnsym{;}  \cnnt{ret'}$ then $\sigma =
\sigma'$ and $\cnnt{ret} = \cnnt{ret'}$.

\pfsketch{ Induction over $\cnnt{arg}$.}

\subsection{Progress Statement and Proof}\label{subsec:progress}

If $\cdot ; \cdot ; \cdot ; \ctxR \vdash e \sych t$ and all patterns in $e$ are
exhaustive then either $e$ is a value, or it is unreachable, or $\forall h
: R.\ \exists e' , h' .\ \hconf{h}{e} \stepsto \hconf{h'}{e'}$.

\begin{proof}
    \pfsketch{ Induction over the typing rules.\\}

    \assume{%
        \begin{pfenum}
            \item $\cdot ; \cdot ; \cdot ; \ctxR \vdash e \sych t$.
            \item All patterns in $e$ are exhaustive.
        \end{pfenum}
    }

    \prove{%
        Either $e$ is a value, or it is unreachable, or $\forall h : R.\
        \exists e' , h' .\ \hconf{h}{e} \stepsto \hconf{h'}{e'}$.\\
    }

    \step{<1>1}{%
        \case{%
            \textsc{Ty\_PVal\_Obj*}, \textsc{Ty\_PVal*}, \textsc{Ty\_PE\_Val}, \textsc{Ty\_TPVal*},
            \textsc{Ty\_TVal*}, \textsc{Ty\_Seq\_TE\_TVal}.
        }{
            \pf\ All these judgements/rules give types to syntactic values; and there
            are no operational rules corresponding to them (see Section~\ref{sec:opsem}).
        }
    }

    \step{<1>2}{%
        \case{%
            \textsc{Ty\_PE\_Array\_Shift}.
        }{
            \pf\ By inversion on $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  pval_{{\mathrm{1}}}  \Rightarrow  \cnkw{loc}$,
            $pval_{{\mathrm{1}}}$ must be a $mem\_ptr$ (\textsc{Ty\_PVal\_Obj\_Ptr}).
            Similarly $pval_{{\mathrm{2}}}$ must be a $mem\_int$,
            so rule \textsc{Op\_PE\_PE\_ArrayShift} applies.
        }
    }

    \step{<1>3}{%
        \case{%
            \textsc{Ty\_PE\_Member\_Shift}.
        }{%
            \pf\ $pval$ must be a $mem\_ptr$ so
            \textsc{Op\_PE\_PE\_MemberShift}.
        }
    }

    \step{<1>4}{%
        \case{%
            \textsc{Ty\_PE\_Not}.
        }{%
            \pf\ $pval$ must be a $bool\_value$ so
            \textsc{Op\_PE\_PE\_Not\_\{True,False\}}.
        }
    }

    \step{<1>5}{%
        \case{%
            \textsc{Ty\_PE\_\{Arith,Rel\}\_Binop}.
        }{%
            \pf\ $pval_{{\mathrm{1}}}$ and $pval_{{\mathrm{2}}}$ must be $mem\_int$s so
            \textsc{Op\_PE\_PE\_\{Arith,Rel\}\_Binop} respectively.
        }
    }

    \step{<1>6}{%
        \case{%
            \textsc{Ty\_PE\_Bool\_Binop}.
        }{%
            \pf\ $pval_{{\mathrm{1}}}$ and $pval_{{\mathrm{2}}}$ must be $bool\_value$s so
            \textsc{Op\_PE\_PE\_Bool\_Binop}.
        }
    }

    \step{<1>7}{%
        \case{%
            \textsc{Ty\_PE\_Call}.
        }{%
            \pf\ By inversion we have $name  {:}  \cnnt{pure\_arg} \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mapsto  tpexpr \, \in \, \cnkw{Globals}$ and $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  pval_{\cnmv{i}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{pure\_arg}  \gg  \sigma  \cnsym{;}  \Sigma \, \cnmv{y}  {:}  \beta  . \:  \cnnt{term}  \wedge  \cnkw{I}$, with the latter implying $\cncomp{\cnmv{x_{\cnmv{i}}}  =  pval_{\cnmv{i}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{pure\_arg}  \gg  \sigma  \cnsym{;}  \Sigma \, \cnmv{y}  {:}  \beta  . \:  \cnnt{term}  \wedge  \cnkw{I}$ (lemma
            \ref{subsec:spine_decons_same}). Thus it can step with
           \textsc{Op\_PE\_TPE\_Call}.
        }
    }

    \step{<1>8}{%
        \case{%
            \textsc{Ty\_PE\_Assert\_Undef}.
        }{%
            \pf\ $pval$ must be a $bool\_value$ and
            $\cnkw{smt} \, \cnsym{(}  \Phi  \Rightarrow   pval   \cnsym{)}$. If it is $\cnkw{False}$, then by the latter,
            we have an inconsistent constraints context, meaning the code is unreachable.
            If it is $\cnkw{True}$, we may step with \textsc{Op\_PE\_PE\_Assert\_Undef}.
        }
    }

    \step{<1>9}{%
        \case{%
            \textsc{Ty\_PE\_Bool\_To\_Integer}.
        }{%
            \pf\ $pval$ must be a $bool\_value$ and so
            \textsc{Op\_PE\_PE\_Bool\_To\_Integer\_\{True,False\}}.
        }
    }

    \step{<1>10}{%
        \case{%
            \textsc{Ty\_PE\_WrapI}.
        }{%
            \pf\ $pval$ must be a $mem\_int$ and so
            \textsc{Op\_PE\_PE\_WrapI}.
        }
    }

    \step{<1>11}{%
        \case{%
            \textsc{Ty\_TPE\_\{If,Let,LetT,Case\}}.
        }{%
            \pf\ See \textsc{Ty\_Seq\_TE\_\{If,Let,LetT,Case\}} cases for more
            general cases and proofs.
        }
    }


    \step{<1>12}{%
        \case{%
            \textsc{Ty\_Action\_Create}.
        }{%
            \pf\ $pval$ must be a $mem\_int$ and $\cnnt{h}$ must
            be $\cdot$, so \textsc{Op\_Action\_TVal\_Create}
            ($mem\_ptr$ and $pval  {:}   \beta_{  \tau  } $ are free
            in the premises and so can be constructed to satisfy the requirements).
        }
    }

    \step{<1>13}{%
        \case{%
            \textsc{Ty\_Action\_Load}.
        }{%
            \pf\ $pval_{{\mathrm{0}}}$ must be a $mem\_ptr$ and $\cnnt{h} = \cdot  \cnsym{+}  \cnsym{\{}    pval_{{\mathrm{1}}}   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }   pval_{{\mathrm{2}}}    \cnsym{\}}$, so
            \textsc{Op\_Action\_TVal\_Load}.
        }
    }

    \step{<1>14}{%
        \case{%
            \textsc{Ty\_Action\_Store}.
        }{%
            \pf\ $pval_{{\mathrm{0}}}$ and $pval_{{\mathrm{2}}}$ must be the same
            $mem\_ptr$, so \textsc{Op\_Action\_TVal\_Store}.
        }
    }

    \step{<1>15}{%
        \case{%
            \textsc{Ty\_Action\_Kill\_Static}.
        }{%
            \pf\ $pval_{{\mathrm{0}}}$ and $pval_{{\mathrm{1}}}$ must be the same
            $mem\_ptr$, so
            \textsc{Op\_Action\_TVal\_Kill\_Static}.
        }
    }

    \step{<1>16}{%
        \case{%
            \textsc{Ty\_Memop\_Rel\_Binop}.
        }{%
            \pf\ Similar to \textsc{Ty\_PE\_\{Arith,Rel\}\_Binop}.
        }
    }

    \step{<1>17}{%
        \case{%
            \textsc{Ty\_Memop\_IntFromPtr}.
        }{%
            \pf\ $pval$ must be a $mem\_ptr$ so
            \textsc{Op\_Memop\_TVal\_Rel\_IntFromPtr}.
        }
    }


    \step{<1>18}{%
        \case{%
            \textsc{Ty\_Memop\_PtrFromInt}.
        }{%
            \pf\ $pval$ must be a $mem\_int$ so
            \textsc{Op\_Memop\_TVal\_Rel\_PtrFromInt}.
        }
    }

    \step{<1>19}{%
        \case{%
            \textsc{Ty\_Memop\_PtrValidForDeref}.
        }{%
            \pf\ $pval$ must be a $mem\_ptr$ and $\cnnt{h}$ must be
            $\cdot  \cnsym{+}  \cnsym{\{}    mem\_ptr   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }  \_   \cnsym{\}}$so it can
            take a step with \textsc{Op\_Memop\_TVal\_Rel\_PtrValidForDeref}.
        }
    }

    \step{<1>20}{%
        \case{%
            \textsc{Ty\_Memop\_PtrWellAligned}.
        }{%
            \pf\ $pval$ must be a $mem\_ptr$ and so
            \textsc{Op\_Memop\_TVal\_PtrWellAligned}.
        }
    }

    \step{<1>21}{%
        \case{%
            \textsc{Ty\_Memop\_PtrArrayShift}.
        }{%
            \pf\ $pval_{{\mathrm{1}}}$ must be a $mem\_ptr$ and
            $pval_{{\mathrm{2}}}$ must be a $mem\_int$ and so\\
            \textsc{Op\_Memop\_TVal\_PtrArrayShift}.
        }
    }

    \step{<1>22}{%
        \case{%
            \textsc{Ty\_Seq\_E\_CCall}.
        }{%
            \pf\ By inversion we have $ident  {:}  \cnnt{arg} \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mapsto  texpr \, \in \, \cnkw{Globals}$ and $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}$, with the latter
            implying $\cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}$
            (lemma \ref{subsec:spine_decons_same}.  Thus it can step with
            \textsc{Op\_SE\_TE\_CCall}.
        }
    }

    \step{<1>23}{%
        \case{%
            \textsc{Ty\_Seq\_E\_Proc}.
        }{%
            \pf\ Similar to \textsc{Ty\_Seq\_E\_CCall}.
        }
    }

    \step{<1>24}{%
        \case{%
            \textsc{Ty\_Is\_E\_Memop}.
        }{%
            \pf\ By induction, if $mem\_op$ is unreachable, then the whole
            expression is so. Memops are not values. Only stepping cases applies,
            so \textsc{Op\_IsE\_IsE\_Memop}.
        }
    }

    \step{<1>25}{%
        \case{%
            \textsc{Ty\_Is\_E\_\{Neg\_\}Action}.
        }{%
            \pf\ By induction, if $mem\_action$ is unreachable, then the whole
            expression is so. Actions are not values. Only stepping case
            applies, so \textsc{Op\_IsE\_IsE\_\{Neg\_\}Action}.
        }
    }

    \step{<1>26}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_\{LetP,LetPT\}}.
        }{%
            \pf\ See \textsc{Ty\_Seq\_TE\_\{Let,LetT\}} for more general cases
            and proofs.
        }
    }

    \step{<1>27}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_Let}.
        }{%
            \pf\ By induction, since $seq\_expr$ is not value, if it is
            unreachable, the whole expression is so. If it takes a step, then
            \textsc{Op\_STE\_TE\_Let\_LetT}.
        }
    }

    \step{<1>28}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_LetT}.
        }{%
            \pf\ By induction, if $texpr$ is unreachable, so is the
            whole expression.  If if it a $tval$ then
            \textsc{Op\_STE\_TE\_LetT\_Sub}.  If if takes a step, then
            \textsc{Op\_STE\_TE\_LetT\_LetT}.
        }
    }

    \step{<1>29}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_Case}.
        }{%
            \pf\ By assumption that all patterns are exhaustive, there is
            at least one pattern against which $pval$ will match,
            so \textsc{Op\_STE\_TE\_Case}.
        }
    }

    \step{<1>30}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_If}.
        }{%
            \pf\ $pval$ must be a $bool\_value$ and so
            \textsc{Op\_STE\_TE\_If\_\{True,False\}}.
        }
    }

    \step{<1>31}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_Run}.
        }{%
            \pf\ Similar to \textsc{Ty\_Seq\_E\_CCall}.
        }
    }

    \step{<1>32}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_Bound}.
        }{%
            \pf\ By \textsc{Op\_STE\_TE\_Bound}.
        }
    }

    \step{<1>33}{%
        \case{%
            \textsc{Ty\_Is\_TE\_LetS}.
        }{%
            \pf\ Similar to \textsc{Ty\_Seq\_TE\_LetT}.
        }
    }

\end{proof}

\section{Type Preservation}

\subsection{Pointed-to values have type $ \beta_{  \tau  } $}\label{subsec:pt_val_type}

For $pt  =  \cnmv{\_}  \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }   pval  $,
if $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnnt{pt}  \Leftarrow  \cnnt{pt}$ then
$\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval  \Rightarrow   \beta_{  \tau  } $.

\pfsketch{ Induction over the typing judgements. Only
    \textsc{Ty\_Action\_Store} create such permissions, and its premise $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{{\mathrm{1}}}  \Rightarrow   \beta_{  \tau  } $ ensures the desired property.
    \textsc{Ty\_Action\_Load} simply preserves the property.}

\subsection{Terms derived from patterns are ``equal to'' matching
values}\label{subsec:pattern_term}

\begin{proof}
    \assume{%
        \begin{pfenum}
        \item $pattern  {:}  \beta  \leadsto  \mathcal{C} \, \cnkw{with} \, term$.
        \item $pattern  =  pval  \leadsto  \sigma$.\\
    \end{pfenum}}

    \prove{ The constraint $term  =   pval $ holds.\\}

    \pfsketch{ Induction over $pattern$.}

\end{proof}

\subsection{\texttt{strip\_ifs} is idempotent}\label{strip_ifs_idemp}
\pfsketch{ Induction over the definition.}

\subsection{Deconstructing a stripped resource produces the same
environment}\label{stripped_same_env}

\begin{proof}
    \assume{%
        \begin{pfenum}
        \item $\Phi  \vdash  \cnnt{res\_pattern}  {:}  \cnnt{res}  \leadsto  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}$.\label{stripped_same_env-assm1}
        \item $\Phi  \vdash  \cnnt{res'}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  \cnnt{res}  \cnsym{)}$.\label{stripped_same_env-assm2}
        \end{pfenum}}

    \prove{%
        $\Phi  \vdash  \cnnt{res\_pattern}  {:}  \cnnt{res'}  \leadsto  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}$.\\
    }

    \step{<1>1}{\suffices{ $\Phi  \vdash  \cnnt{res'}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  \cnnt{res'}  \cnsym{)}$.}
        \pf\ By \texttt{strip\_ifs} idempotent and assumption~\ref{stripped_same_env-assm2}.}

    \step{<1>2}{$\Phi  \vdash  \cnnt{res'} \, \cnkw{as} \, \cnnt{res\_pattern}  \leadsto  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}$ by inversion
        on~\ref{stripped_same_env-assm1}.}

    \step{<1>3}{By definiton of $\Phi  \vdash  \cnnt{res\_pattern}  {:}  \cnnt{res}  \leadsto  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}$ and
        \stepref{<1>1} and \stepref{<1>2} we are done.}

\end{proof}

\subsection{Deconstructing a pattern leads to a well-typed
substitution}\label{subsec:wt_sub}

First, computational part.
\begin{proof}
    \assume{%
        \begin{pfenum}
        \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  pval  \Rightarrow  \beta_{{\mathrm{1}}}$.\label{wt_sub_comp-assm1}
        \item $ident\_or\_pattern  {:}  \beta  \leadsto  \mathcal{C} \, \cnkw{with} \, term$.\label{wt_sub_comp-assm2}
        \item $ident\_or\_pattern  =  pval  \leadsto  \sigma$.\label{wt_sub_comp-assm3}
        \end{pfenum}}

    \prove{%
        $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{)}$.\\
    }

    \pfsketch{ By induction over \ref{wt_sub_comp-assm2}.}

    \step{<1>1}{%
        \case{%
            \textsc{Ty\_Pat\_Sym\_Or\_Pattern\_Sym} and \textsc{Ty\_Pat\_Comp\_Sym\_Annot}.
        }{
            $\sigma = pval  \cnsym{/}  \cnmv{x}  \cnsym{,}  \cdot$ and
            $\mathcal{C} = \cdot  \cnsym{,}  \cnmv{x}  {:}  \beta$.\\
            \pf\ By \textsc{Ty\_Subs\_Cons\_Comp} and \ref{wt_sub_comp-assm1}.
        }
    }

    \step{<1>2}{%
        \case{%
            \textsc{Ty\_Pat\_No\_Sym\_Annot} and \textsc{Ty\_Pat\_Comp\_Nil}.
        }{%
            $\sigma$ and $\mathcal{C}$ are empty.\\
            \pf\ By \textsc{Ty\_Subs\_Empty}, we are done.
        }
    }

    \step{<1>3}{%
        \case{%
            \textsc{Ty\_Pat\_Comp\_\{Specified,Cons,Tuple,Array\}}.
        }{%
            \pf\ By induction (and concatenating well-typed substitutions).
        }
    }

\end{proof}

Now, resource part (of deconstructing a pattern leads to a well-typed
substitution).

\begin{proof}
    \assume{%
        \begin{pfenum}
        \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash  \cnnt{res\_term}  \Leftarrow  \cnnt{res}$.\label{wt_sub_res-assm1}
        \item $\Phi  \vdash  \cnnt{res\_pattern}  {:}  \cnnt{res}  \leadsto  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'$.\label{wt_sub_res-assm2}
        \item $\cnnt{res\_pattern}  =  \cnnt{res\_term}  \leadsto  \sigma$.\label{wt_sub_res-assm3}
        \end{pfenum}}

    \prove{%
        $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \cdot  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}'  \cnsym{)}$.\\
    }

    \pfsketch{ By induction over \ref{wt_sub_res-assm1}.}

    \step{<1>1}{%
        \case{%
            \textsc{Ty\_Res\_Empty}.
        }{%
            $\cnnt{res\_pattern} = \cnnt{res\_term} = \cnnt{res} = \cnkw{emp}$.
            $\sigma, \mathcal{L}, \Phi, \mathcal{R}, \mathcal{R}'$ are all empty.\\
            \pf\ By \textsc{Ty\_Subs\_Empty}, we are done.
        }
    }

    \step{<1>2}{%
        \case{%
            \textsc{Ty\_Res\_PointsTo}.
        }{%
            $\cnnt{res\_pattern} = \cnmv{r}$, $\cnnt{res\_term} = \cnnt{pt}$, $\sigma = \cnnt{pt}  \cnsym{/}  \cnmv{r}  \cnsym{,}  \cdot$,
            $\mathcal{L} = \cdot$, $\Phi = \cdot$, $\mathcal{R} = \mathcal{R}' = \cdot  \cnsym{,}  \cnmv{r}  {:}  \cnnt{pt}$.\\
            \pf\ By \textsc{Ty\_Subs\_Cons\_Res}.
        }
    }

    \step{<1>3}{%
        \case{%
            \textsc{Ty\_Res\_Var}.
        }{%
            $\cnnt{res\_pattern} = \cnmv{r}$, $\sigma = \cnnt{res\_term}  \cnsym{/}  \cnmv{r}  \cnsym{,}  \cdot$,
            $\mathcal{L} = \cdot$, $\Phi = \cdot$, $\mathcal{R} = \mathcal{R}' = \cdot  \cnsym{,}  \cnmv{r}  {:}  \cnnt{res}$.\\
            \pf\ By \textsc{Ty\_Subs\_Cons\_Res}.
        }
    }

    \step{<1>4}{%
        \case{%
            \textsc{Ty\_Res\_SepConj}.
        }{%
            \pf\ By induction (and concatenating well-typed substitutions).
        }
    }

    \step{<1>5}{%
        \case{%
            \textsc{Ty\_Res\_Conj}.
        }{%
            \pf\ By $\cnkw{smt} \, \cnsym{(}  \cdot  \Rightarrow  term  \cnsym{)}$ (from \ref{wt_sub_res-assm1})
            and induction with \textsc{Ty\_Sub\_Cons\_Phi}.
        }
    }

    \step{<1>6}{%
        \case{%
            \textsc{Ty\_Res\_Pack}.
        }{%
            $\cnnt{res\_pattern} = \cnkw{pack} \, \cnsym{(}  \cnmv{x}  \cnsym{,}  \cnnt{res\_pattern'}  \cnsym{)}$,
            $\cnnt{res\_term} = \cnkw{pack} \, \cnsym{(}  pval  \cnsym{,}  \cnnt{res\_term'}  \cnsym{)}$,
            $\cnnt{res} = \exists \, \cnmv{x}  {:}  \beta  . \:  \cnnt{res'}$.
            $\sigma = pval  \cnsym{/}  \cnmv{x}  \cnsym{,}  \sigma'$, $\mathcal{L} = \mathcal{L}'  \cnsym{,}  \cnmv{x}  {:}  \beta$,
            $\mathcal{R} = \mathcal{R}'$.\\
            \pf\ By induction and \textsc{Ty\_Subs\_Cons\_Log}.
        }
    }

    \step{<1>7}{%
        \case{%
            \textsc{Ty\_Res\_Fold}.
        }{%
            $\cnnt{res\_pattern} = \cnkw{fold} \, \cnsym{(}  \cnnt{res\_pattern'}  \cnsym{)}$,
            $\cnnt{res\_term} = \cnkw{fold} \, \cnsym{(}  \cnnt{res\_term'}  \cnsym{)}$,
            $\cnnt{res} = { \alpha }  \cnsym{(} \, \cncomp{pval_{\cnmv{i}}}{\cnmv{i}} \, \cnsym{)}$.
        }
    }

    \begin{proof}

        \step{<2>1}{\begin{pfenum}
            \item ${ \alpha } \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}  {:}  \beta_{\cnmv{i}}}{\cnmv{i}} \, \mapsto  \cnnt{res'} \, \in \, \cnkw{Globals}$.
            \item $\Phi  \vdash  \cnnt{res''}  = \, \cnkw{strip\_ifs} \, \cnsym{(}  \cnnt{res'}  \cnsym{)}$.
            \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}  \vdash  \cnnt{res\_term'}  \Leftarrow  \cnnt{res''}$.
            \end{pfenum}
        \pf\ Inversion on~\ref{wt_sub_res-assm1}.}

        \step{<2>2}{$\Phi  \vdash  \cnnt{res\_pattern'}  {:}   \cncomp{pval_{\cnmv{i}}  \cnsym{/}  \cnmv{x_{\cnmv{i}}}  \cnsym{,}  \cdot}{\cnmv{i}}  (  \cnnt{res'}  )   \leadsto  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'$.\\
        \pf\ Inversion on~\ref{wt_sub_res-assm2}.}

        \step{<2>3}{$\Phi  \vdash  \cnnt{res\_pattern'}  {:}  \cnnt{res''}  \leadsto  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'$.\\
        \pf\ By \stepref{<2>1}.2, \stepref{<2>2} and deconstructing a stripped
        resource produces the same environment (lemma~\ref{stripped_same_env}).}

        \step{<2>4}{$\cnnt{res\_pattern'}  =  \cnnt{res\_term'}  \leadsto  \sigma$.\\
        \pf\ By inversion on \ref{wt_sub_res-assm3}.}

        \step{<2>5}{$\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \cdot  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}'  \cnsym{)}$.\\
        \pf\ By induction on~\stepref{<2>1}.3,~\stepref{<2>3} and~\stepref{<2>4}.}

    \end{proof}

\end{proof}

Now, full proof (of deconstructing a pattern leads to a well-typed
substitution).

\begin{proof}

    \assume{%
        \begin{pfenum}
            \item $\cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \leadsto  \sigma$.\label{wt_sub-assm1}
            \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{done} \, \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}}  \Leftarrow  \cnnt{ret}$.\label{wt_sub-assm2}
            \item $\Phi  \vdash \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret}  \leadsto  \mathcal{C}  \cnsym{;}  \mathcal{L}'  \cnsym{;}  \Phi'  \cnsym{;}  \mathcal{R}'$.\label{wt_sub-assm3}
        \end{pfenum}
    }

    \prove{%
        $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}'  \cnsym{)}$.\\
    }

    \pfsketch{ Induction on \ref{wt_sub-assm3}.}

    \step{<1>1}{
        \case{%
            \textsc{Ty\_Ret\_Pat\_Empty}
        }{%
            \pf\ By \textsc{Ty\_Subs\_Empty}.
        }
    }

    \step{<1>2}{
        \case{%
            \textsc{Ty\_Ret\_Pat\_\{Comp,Res\}}
        }{%
            \pf\ By induction, well-typed computational / resource
            substitutions and concatenating well-typed substitutions.
        }
    }

    \step{<1>3}{
        \case{%
            \textsc{Ty\_Ret\_Path\_Log}.
        }{%
            \pf\ By induction.
        }
    }

    \step{<1>4}{
        \case{%
            \textsc{Ty\_Ret\_Pat\_Phi}
        }{%
            \pf\ By induction and inversion on \ref{wt_sub-assm2} to conclude
            $\cnkw{smt} \, \cnsym{(}  \cdot  \Rightarrow  term  \cnsym{)}$\\
            (required by \textsc{Ty\_Subs\_Cons\_Phi}).
        }
    }

\end{proof}


\subsection{Type Preservation Statement and Proof}

If $\cdot ; \cdot ; \cdot ; \ctxR \vdash e \sych t$ then
$\forall h {:} \ctxR, f, e' , h'.\ \hconf{h + f}{e} \stepsto \hconf{h'}{e'}
\implies \\ \exists h'' {:} \ctxR'.\ h' = h'' + f \wedge \cdot ; \cdot ; \cdot ;
\ctxR' \vdash e' \sych t$.

\begin{proof}
    \pfsketch{ Induction over the typing rules.\\}

    \assume{%
        \begin{pfenum}
            \item $\cdot ; \cdot ; \cdot ; \ctxR_1 \vdash e \sych t$
            \item arbitrary $h {:} \ctxR_1, f, e' , h'$
            \item $\hconf{h + f}{e} \stepsto \hconf{h'}{e'}$.\\
        \end{pfenum}
    }

    \prove{%
        $\exists h' {:} \ctxR_1'.\ h' = h' + f \wedge \cdot ; \cdot ; \cdot
        ; \ctxR_1' \vdash e' \sych t$.\\
    }

    \step{<1>1}{%
        \case{%
            \textsc{Ty\_PE\_Array\_Shift}.
        }{%
            \pflet{%
                $term =  mem\_ptr   \mathbin{ {+}_{ \mathrm{ptr} } }  \cnsym{(}   mem\_int   \times   \mathrm{size\_of}(  \tau  )   \cnsym{)}$.
            }
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  \cnkw{array\_shift} \, \cnsym{(}  mem\_ptr  \cnsym{,}  \tau  \cnsym{,}  mem\_int  \cnsym{)}  \Rightarrow  \cnmv{y}  {:}  \cnkw{loc}  . \:  \cnmv{y}  =  \cnnt{term}$.

                    \item $\langle  \cnkw{array\_shift} \, \cnsym{(}  mem\_ptr  \cnsym{,}  \tau  \cnsym{,}  mem\_int  \cnsym{)}  \rangle  \longrightarrow  \langle  mem\_ptr'  \rangle$.\label{array-shift-assm2}
                \end{pfenum}}
            \prove{%
                $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  mem\_ptr'  \Rightarrow  \cnmv{y}  {:}  \cnkw{loc}  . \:  \cnmv{y}  =  \cnnt{term}$ \\
                (because this is a pure expression, heaps are irrelevant).
            }
            \pf\ By \textsc{Ty\_PVal\_Obj\_Int}, \textsc{Ty\_PVal\_Obj},
                \textsc{Ty\_PE\_Val} and construction of $mem\_ptr'$
                (inversion on \ref{array-shift-assm2}).
        }
    }

    \step{<1>2}{%
        \case{%
            \textsc{Ty\_PE\_Member\_Shift}.
        }{%
            \pfsketch\ Similar to \textsc{Ty\_Array\_Shift}.
        }
    }

    \step{<1>3}{%
        \case{%
            \textsc{Ty\_PE\_Not}.
        }{%
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  \cnkw{not} \, \cnsym{(}  bool\_value  \cnsym{)}  \Rightarrow  \cnmv{y}  {:}  \cnkw{bool}  . \:  \cnmv{y}  =  \neg \,  bool\_value $.

                    \item $\langle  \cnkw{not} \, \cnsym{(}  \cnkw{True}  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnkw{False}  \rangle$
                        or $\langle  \cnkw{not} \, \cnsym{(}  \cnkw{False}  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnkw{True}  \rangle$.\label{not-assm2}
                \end{pfenum}}
            \prove{%
                $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  bool\_value'  \Rightarrow  \cnmv{y}  {:}  \cnkw{bool}  . \:  \cnmv{y}  =  \neg \,  bool\_value $ \\
                (because this is a pure expression, heaps are irrelevant).
            }
            \pf\ By \textsc{Ty\_PVal\_\{True,False\}}, \textsc{Ty\_PE\_Val} and
                \ref{not-assm2}.
        }
    }

    \step{<1>4}{%
        \case{%
            \textsc{Ty\_PE\_Arith\_Binop}.
        }{%
            \pflet{%
                $term =   mem\_int_{{\mathrm{1}}}    \mathbin{ binop_{arith} }    mem\_int_{{\mathrm{2}}}  $.
            }
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  mem\_int_{{\mathrm{1}}} \, \mathbin{ binop_{arith} } \, mem\_int_{{\mathrm{2}}}  \Rightarrow  \cnmv{y}  {:}  \cnkw{integer}  . \:  \cnmv{y}  =  \cnnt{term}$.

                    \item $\langle  mem\_int_{{\mathrm{1}}} \, \mathbin{ binop_{arith} } \, mem\_int_{{\mathrm{2}}}  \rangle  \longrightarrow  \langle  mem\_int  \rangle$.\label{arith-binop-assm2}
                \end{pfenum}}
            \prove{%
                $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  mem\_int  \Rightarrow  \cnmv{y}  {:}  \cnkw{integer}  . \:  \cnmv{y}  =  \cnnt{term}$ \\
                (because this is a pure expression, heaps are irrelevant).
            }
            \pf\ By \textsc{Ty\_PVal\_Obj\_Int}, \textsc{Ty\_PVal\_Obj},
                \textsc{Ty\_PE\_Val} and construction of $mem\_int$
                (inversion on \ref{arith-binop-assm2}).
        }
    }

    \step{<1>5}{%
        \case{%
            \textsc{Ty\_PE\_\{Rel,Bool\}\_Binop}.
        }{%
            \pfsketch\ Similar to \textsc{Ty\_PE\_Arith\_Binop}.
        }
    }

    \step{<1>6}{%
        \case{%
            \textsc{Ty\_PE\_Call}.
        }{%
            \pf\ See \textsc{Ty\_Seq\_E\_Call} for a more general case and proof.
        }
    }

    \step{<1>7}{%
        \case{%
            \textsc{Ty\_PE\_Assert\_Undef}.
        }{%
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  \cnkw{assert\_undef} \, \cnsym{(}  \cnkw{True}  \cnsym{,}   \, \cnmv{UB\_name}  \cnsym{)}  \Rightarrow  \cnmv{y}  {:}  \cnkw{unit}  . \:  \cnmv{y}  =  \cnkw{unit}$.

                    \item $\langle  \cnkw{assert\_undef} \, \cnsym{(}  \cnkw{True}  \cnsym{,}   \, \cnmv{UB\_name}  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnkw{Unit}  \rangle$.
                \end{pfenum}}
            \prove{%
                $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  \cnkw{Unit}  \Rightarrow  \cnmv{y}  {:}  \cnkw{unit}  . \:  \cnmv{y}  =  \cnkw{unit}$ \\
                (because this is a pure expression, heaps are irrelevant).
            }
            \pf\ By \textsc{Ty\_PVal\_Unit} and \textsc{Ty\_PE\_Val}.
        }
    }

    \step{<1>8}{%
        \case{%
            \textsc{Ty\_PE\_Bool\_To\_Integer}.
        }{%
            \pflet{%
                $term = \cnkw{if} \,  bool\_value  \, \cnkw{then} \,  1  \, \cnkw{else} \,  0 $.
            }
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  \cnkw{bool\_to\_integer} \, \cnsym{(}  bool\_value  \cnsym{)}  \Rightarrow  \cnmv{y}  {:}  \cnkw{integer}  . \:  \cnmv{y}  =  \cnnt{term}$.

                    \item $\langle  \cnkw{bool\_to\_integer} \, \cnsym{(}  \cnkw{True}  \cnsym{)}  \rangle  \longrightarrow  \langle   1   \rangle$ or $\langle  \cnkw{bool\_to\_integer} \, \cnsym{(}  \cnkw{False}  \cnsym{)}  \rangle  \longrightarrow  \langle   0   \rangle$.
                \end{pfenum}}
            \prove{%
                $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  mem\_int  \Rightarrow  \cnmv{y}  {:}  \cnkw{integer}  . \:  \cnmv{y}  =  \cnnt{term}$ \\
                (because this is a pure expression, heaps are irrelevant).
            }
            \pf\ By cases on $bool\_value$, then applying
                \textsc{Ty\_PVal\_\{True,False\}} and \textsc{Ty\_PE\_Val}.
        }
    }

    \step{<1>9}{%
        \case{%
            \textsc{Ty\_PE\_WrapI}.
        }{%
            \pfsketch\ Similar to \textsc{Ty\_PE\_Bool\_To\_Integer}, except by
                cases on $\cnmv{abbrev_{{\mathrm{2}}}}  \leq   \mathrm{max\_int}_{  \tau  } $, then applying
                \textsc{Ty\_PVal\_Obj\_Int}, \textsc{Ty\_PVal\_Obj} and
                \textsc{Ty\_PE\_Val}.
        }
    }

    \step{<1>10}{%
        \case{%
            \textsc{Ty\_TPE\_If}.
        }{%
            \pf\ See \textsc{Ty\_Seq\_TE\_If} for a more general case and proof.
        }
    }

    \step{<1>11}{%
        \case{%
            \textsc{Ty\_TPE\_Let}.
        }{%
            \pf\ See \textsc{Ty\_Seq\_TE\_Let} for a more general case and proof.
        }
    }

    \step{<1>12}{%
        \case{%
            \textsc{Ty\_TPE\_LetT}.
        }{%
            \pf\ See \textsc{Ty\_Seq\_TE\_LetT} for a more general case and proof.
        }
    }

    \step{<1>13}{%
        \case{%
            \textsc{Ty\_TPE\_Case}.
        }{%
            \pf\ See \textsc{Ty\_Seq\_TE\_Case} for a more general case and proof.
        }
    }

    \step{<1>14}{%
        \case{%
            \textsc{Ty\_Action\_Create}.
        }{%
            \pflet{%
                $pt =   mem\_ptr   \mathbin{ { \overset{   {  \times  }   }{ \mapsto } }_{  \tau  } }   pval  $.\\
                $ term = \cnkw{representable} \, \cnsym{(}  \tau  *  \cnsym{,}  { y_p }  \cnsym{)}  \wedge  \cnkw{alignedI} \, \cnsym{(}   mem\_int   \cnsym{,}  { y_p }  \cnsym{)}$.\\
                $ret = \Sigma \, { y_p }  {:}  \cnkw{loc}  . \:  \cnnt{term}  \wedge  \exists \, \cnmv{y}  {:}   \beta_{  \tau  }   . \:    { y_p }  \mathbin{ { \overset{   {  \times  }   }{ \mapsto } }_{  \tau  } }  \cnmv{y}    \otimes  \cnkw{I}$.\\
                $h = \cdot$ so $h' = \cdot  \cnsym{+}  \cnsym{\{}  \cnnt{pt}  \cnsym{\}}$.
            }
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  \cnkw{create} \, \cnsym{(}  mem\_int  \cnsym{,}  \tau  \cnsym{)}    \Rightarrow  \cnnt{ret}$.
                    \item $\langle  \cnnt{f}  \cnsym{;}  \cnkw{create} \, \cnsym{(}  mem\_int  \cnsym{,}  \tau  \cnsym{)}    \rangle  \longrightarrow  \langle  \cnnt{f}  \cnsym{+}  \cnsym{\{}  \cnnt{pt}  \cnsym{\}}  \cnsym{;}  \cnkw{done} \, mem\_ptr  \cnsym{,}  pval  \cnsym{,}  \cnnt{pt}  \rangle$.
                \end{pfenum}}
            \prove{%
                $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{,}  \cnmv{\_}  {:}  \cnnt{pt}  \vdash  \cnkw{done} \, mem\_ptr  \cnsym{,}  pval  \cnsym{,}  \cnnt{pt}  \Leftarrow  \cnnt{ret}$.
            }
        }
    }

    \begin{proof}
        \step{<2>1}{$\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  mem\_ptr  \Rightarrow  \cnkw{loc}$ by
            \textsc{Ty\_PVal\_Obj\_Int} and \textsc{Ty\_PVal\_Obj}.}

        \step{<2>2}{$\cnkw{smt} \, \cnsym{(}  \cdot  \Rightarrow  \cnnt{term}  \cnsym{)}$ by construction of $mem\_ptr$.}

        \step{<2>3}{$\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  pval  \Rightarrow   \beta_{  \tau  } $
            by construction of $pval$.}

        \step{<2>4}{$\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{,}  \cnmv{\_}  {:}  \cnnt{pt}  \vdash  \cnnt{pt}  \Leftarrow  \cnnt{pt}$ by
            \textsc{Ty\_Res\_PointsTo}.}

        \step{<2>5}{By \textsc{Ty\_TVal\_I} and then \stepref{<2>4} -- \stepref{<2>1} with
            \textsc{Ty\_TVal\_\{Res,Log,Phi,Comp\}} respectively, we are done.}
    \end{proof}

    \step{<1>15}{%
        \case{%
            \textsc{Ty\_Action\_Load}.
        }{%
            \pflet{%
                $pt  =   mem\_ptr   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }   pval  $.\\
                $ret = \Sigma \, \cnmv{y}  {:}   \beta_{  \tau  }   . \:  \cnmv{y}  =   pval   \wedge  \cnnt{pt}  \otimes  \cnkw{I}$.\\
                $h = h' = \cdot  \cnsym{+}  \cnsym{\{}  \cnnt{pt}  \cnsym{\}}$.
            }
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{load} \, \cnsym{(}  \tau  \cnsym{,}  mem\_ptr  \cnsym{,}  \_  \cnsym{,}  \cnnt{pt}  \cnsym{)}  \Rightarrow  \cnnt{ret}$.\label{load-assm1}

                    \item $\langle  \cnnt{f}  \cnsym{+}  \cnsym{\{}  \cnnt{pt}  \cnsym{\}}  \cnsym{;}  \cnkw{load} \, \cnsym{(}  \tau  \cnsym{,}  mem\_ptr  \cnsym{,}  \_  \cnsym{,}  \cnnt{pt}  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{f}  \cnsym{+}  \cnsym{\{}  \cnnt{pt}  \cnsym{\}}  \cnsym{;}  \cnkw{done} \, pval  \cnsym{,}  \cnnt{pt}  \rangle$.\label{load-assm2}
                \end{pfenum}}
            \prove{%
                $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{done} \, pval  \cnsym{,}  \cnnt{pt}  \Leftarrow  \cnnt{ret}$
            }
        }
    }

    \begin{proof}
        \step{<2>1}{$\mathcal{R} = \cdot  \cnsym{,}  \cnmv{\_}  {:}  \cnnt{pt'}$ where $\cdot  \vdash  \cnnt{pt'} \, \equiv \, \cnnt{pt}$
            by inversion on \ref{load-assm1}.}

        \step{<2>2}{$\cnkw{smt} \, \cnsym{(}  \cdot  \Rightarrow   pval   =   pval   \cnsym{)}$ trivially.}

        \step{<2>3}{$\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  pval  \Rightarrow   \beta_{  \tau  } $ by \stepref{<2>1}
            and pointed-values have the right type (lemma \ref{subsec:pt_val_type}).}

        \step{<2>4}{By \textsc{Ty\_TVal\_I} and then \stepref{<2>1} --
            \stepref{<2>3} with \textsc{Ty\_TVal\_\{Res,Phi,Comp\}}
            respectively, we are done.}
    \end{proof}

    \step{<1>16}{%
        \case{%
            \textsc{Ty\_Action\_Store}.
        }{%
            \pflet{%
                $pt  =   mem\_ptr   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }  \_ $.\\
                $pt' =   mem\_ptr   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }   pval  $.\\
                $ret = \Sigma \, \cnmv{\_}  {:}  \cnkw{unit}  . \:  \cnnt{pt'}  \otimes  \cnkw{I}$.\\
                $h = h' = \cdot  \cnsym{+}  \cnsym{\{}  \cnnt{pt}  \cnsym{\}}$.
            }
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{store} \, \cnsym{(}  \_  \cnsym{,}  \tau  \cnsym{,}  pval_{{\mathrm{0}}}  \cnsym{,}  pval_{{\mathrm{1}}}  \cnsym{,}  \_  \cnsym{,}  \cnnt{pt}  \cnsym{)}  \Rightarrow  \cnnt{ret}$.

                    \item $\langle  \cnnt{f}  \cnsym{+}  \cnsym{\{}  \cnnt{pt}  \cnsym{\}}  \cnsym{;}  \cnkw{store} \, \cnsym{(}  \_  \cnsym{,}  \tau  \cnsym{,}  mem\_ptr  \cnsym{,}  pval  \cnsym{,}  \_  \cnsym{,}  \cnnt{pt}  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{f}  \cnsym{+}  \cnsym{\{}  \cnnt{pt'}  \cnsym{\}}  \cnsym{;}  \cnkw{done} \, \cnkw{Unit}  \cnsym{,}  \cnnt{pt'}  \rangle$.
                \end{pfenum}}
            \prove{%
                $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{,}  \cnmv{\_}  {:}  \cnnt{pt'}  \vdash  \cnkw{done} \, \cnkw{Unit}  \cnsym{,}  \cnnt{pt'}  \Leftarrow  \cnnt{ret}$.
            }
        }
    }

    \begin{proof}
        \step{<2>1}{$\mathcal{R} = \cdot  \cnsym{,}  \cnmv{\_}  {:}  \cnnt{pt''}$ where $\cdot  \vdash  \cnnt{pt''} \, \equiv \, \cnnt{pt}$,
            by inversion on the typing assumption.}

        \step{<2>2}{$\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  \cnkw{Unit}  \Rightarrow  \cnkw{unit}$ by \textsc{Ty\_PVal\_Unit}.}

        \step{<2>3}{$\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{,}  \cnmv{\_}  {:}  \cnnt{pt'}  \vdash  \cnnt{pt'}  \Leftarrow  \cnnt{pt'}$
            by \textsc{Ty\_Res\_PointsTo}.}

        \step{<2>4}{By \textsc{Ty\_TVal\_I} and \stepref{<2>2} and \stepref{<2>3}
            with \textsc{Ty\_TVal\_\{Res,Comp\}} respectively, we are done.}
    \end{proof}

    \step{<1>17}{%
        \case{%
            \textsc{Ty\_Action\_Kill\_Static}.
        }{%
            \pflet{%
                $pt =   mem\_ptr   \mathbin{ { \overset{    }{ \mapsto } }_{  \tau  } }  \_ $. \\
                $\mathcal{R} = \cdot  \cnsym{,}  \cnmv{\_}  {:}  \cnnt{pt'}$ where $\cdot  \vdash  \cnnt{pt'} \, \equiv \, \cnnt{pt}$.\\
                $h = \cdot  \cnsym{+}  \cnsym{\{}  \cnnt{pt}  \cnsym{\}}$ so $h' = \cdot$.
            }
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{kill} \, \cnsym{(}  \cnkw{static} \, \tau  \cnsym{,}  pval_{{\mathrm{0}}}  \cnsym{,}  \cnnt{pt}  \cnsym{)}  \Rightarrow  \Sigma \, \cnmv{\_}  {:}  \cnkw{unit}  . \:  \cnkw{I}$.

                    \item $\langle  \cnnt{f}  \cnsym{+}  \cnsym{\{}  \cnnt{pt}  \cnsym{\}}  \cnsym{;}  \cnkw{kill} \, \cnsym{(}  \cnkw{static} \, \tau  \cnsym{,}  mem\_ptr  \cnsym{,}  \cnnt{pt}  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{f}  \cnsym{;}  \cnkw{done} \, \cnkw{Unit}  \rangle$.
                \end{pfenum}}
            \prove{%
                $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  \cnkw{done} \, \cnkw{Unit}  \Leftarrow  \Sigma \, \cnmv{\_}  {:}  \cnkw{unit}  . \:  \cnkw{I}$
            }
            \pf\ By \textsc{Ty\_TVal\_I}, \textsc{Ty\_PVal\_Unit} and then \textsc{Ty\_TVal\_Comp}.
        }
    }

    \step{<1>18}{%
        \case{%
            \textsc{Ty\_Memop\_Rel\_Binop}.
        }{%
            \pf\  Similar \textsc{Ty\_PE\_Rel\_Binop}, except with
            \textsc{Ty\_TVal\_\{I,Phi,Comp\}} at the end.
        }
    }

    \step{<1>19}{%
        \case{%
            \textsc{Ty\_Memop\_IntFromPtr}.
        }{%
            \pflet{%
                $ret = \Sigma \, \cnmv{y}  {:}  \cnkw{integer}  . \:  \cnmv{y}  =  \cnkw{cast\_ptr\_to\_int} \,  mem\_ptr   \wedge  \cnkw{I}$.\\
                $h = \cdot$ so $h' = \cdot$.
            }
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  \cnkw{intFromPtr} \, \cnsym{(}  \tau_{{\mathrm{1}}}  \cnsym{,}  \tau_{{\mathrm{2}}}  \cnsym{,}  mem\_ptr  \cnsym{)}  \Rightarrow  \cnnt{ret}$.

                    \item $\langle  \cnnt{f}  \cnsym{;}  \cnkw{intFromPtr} \, \cnsym{(}  \tau_{{\mathrm{1}}}  \cnsym{,}  \tau_{{\mathrm{2}}}  \cnsym{,}  mem\_ptr  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{f}  \cnsym{;}  \cnkw{done} \, mem\_int  \rangle$.\label{intfromptr-assm2}
                \end{pfenum}}
            \prove{%
                $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  \cnkw{done} \, mem\_int  \Leftarrow  \cnnt{ret}$
            }
        }
    }

    \begin{proof}
        \step{<2>1}{$\cnkw{smt} \, \cnsym{(}  \cdot  \Rightarrow   mem\_int   =  \cnkw{cast\_ptr\_to\_int} \,  mem\_ptr   \cnsym{)}$
            by construction of $mem\_int$ (inversion on \ref{intfromptr-assm2}).}

        \step{<2>2}{$\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  mem\_int  \Rightarrow  \cnkw{integer}$
            by \textsc{Ty\_PVal\_Obj\_Int} and \textsc{Ty\_PVal\_Obj}.}

        \step{<2>3}{By \textsc{Ty\_TVal\_I} and \stepref{<2>1} and \stepref{<2>2}
            with \textsc{Ty\_TVal\_\{Phi,Comp\}} respectively, we are done.}
    \end{proof}

    \step{<1>20}{%
        \case{%
            \textsc{Ty\_Memop\_PtrFromInt}.
        }{%
            \pf\ Similar to \textsc{Ty\_Memop\_IntFromPtr}, swapping base types
            $\cnkw{integer}$ and $\cnkw{loc}$.
        }
    }

    \step{<1>21}{%
        \case{%
            \textsc{Ty\_Memop\_PtrValidForDeref}.
        }{%
            \pflet{%
                $pt =   mem\_ptr   \mathbin{ { \overset{  \checkmark  }{ \mapsto } }_{  \tau  } }  \_ $.\\
                $ret = \Sigma \, \cnmv{y}  {:}  \cnkw{bool}  . \:  \cnmv{y}  =  \cnkw{aligned} \, \cnsym{(}  \tau  \cnsym{,}   mem\_ptr   \cnsym{)}  \wedge  \cnnt{pt}  \otimes  \cnkw{I}$.\\
                $h = \cdot  \cnsym{+}  \cnsym{\{}  \cnnt{pt}  \cnsym{\}}$ so $h' = h$.
            }
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{ptrValidForDeref} \, \cnsym{(}  \tau  \cnsym{,}  mem\_ptr  \cnsym{,}  \cnnt{pt}  \cnsym{)}  \Rightarrow  \cnnt{ret}$.\label{ptrValid-assm1}

                    \item $\langle  \cnnt{f}  \cnsym{+}  \cnsym{\{}  \cnnt{pt}  \cnsym{\}}  \cnsym{;}  \cnkw{ptrValidForDeref} \, \cnsym{(}  \tau  \cnsym{,}  mem\_ptr  \cnsym{,}  \cnnt{pt}  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{f}  \cnsym{+}  \cnsym{\{}  \cnnt{pt}  \cnsym{\}}  \cnsym{;}  \cnkw{done} \, bool\_value  \cnsym{,}  \cnnt{pt}  \rangle$.\label{ptrValid-assm2}
                \end{pfenum}}
            \prove{%
                $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{,}  \cnmv{\_}  {:}  \cnnt{pt}  \vdash  \cnkw{done} \, bool\_value  \cnsym{,}  \cnnt{pt}  \Leftarrow  \cnnt{ret}$.
            }
        }
    }

    \begin{proof}
        \step{<2>1}{$\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{,}  \cnmv{\_}  {:}  \cnnt{pt'}  \vdash  \cnnt{pt}  \Leftarrow  \cnnt{pt}$, by inversion on
            \ref{ptrValid-assm1}. \\
            Note: $\mathcal{R} = \cdot  \cnsym{,}  \cnmv{\_}  {:}  \cnnt{pt'}$ where $\cdot  \vdash  \cnnt{pt'} \, \equiv \, \cnnt{pt}$.}

        \step{<2>2}{$bool\_value = \cnkw{aligned} \, \cnsym{(}  \tau  \cnsym{,}   mem\_ptr   \cnsym{)}$ by
            construction of $bool\_value$ (inversion on \ref{ptrValid-assm2}).}

        \step{<2>3}{$\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  bool\_value  \Rightarrow  \cnkw{bool}$ by
            \textsc{Ty\_PVal\_\{True,False\}}.}

        \step{<2>4}{By \textsc{Ty\_TVal\_I}, and then \stepref{<2>1} --
            \stepref{<2>3} with \textsc{Ty\_TVal\_\{Res,Phi,Comp\}}
            respectively, we are done.}
    \end{proof}


    \step{<1>22}{%
        \case{%
            \textsc{Ty\_Memop\_PtrWellAligned}.
        }{%
            \pflet{%
                $ret = \Sigma \, \cnmv{y}  {:}  \cnkw{bool}  . \:  \cnmv{y}  =  \cnkw{aligned} \, \cnsym{(}  \tau  \cnsym{,}   mem\_ptr   \cnsym{)}  \wedge  \cnkw{I}$.\\
                $h = \cdot$ so $h' = \cdot$.
            }
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  \cnkw{ptrWellAligned} \, \cnsym{(}  \tau  \cnsym{,}  mem\_ptr  \cnsym{)}  \Rightarrow  \cnnt{ret}$.

                    \item $\langle  \cnnt{f}  \cnsym{;}  \cnkw{ptrWellAligned} \, \cnsym{(}  \tau  \cnsym{,}  mem\_ptr  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{f}  \cnsym{;}  \cnkw{done} \, bool\_value  \rangle$.\label{wellaligned-assm2}
                \end{pfenum}}
            \prove{%
                $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  \cnkw{done} \, bool\_value  \Rightarrow  \cnnt{ret}$.
            }
        }
    }

    \begin{proof}
        \step{<2>1}{$\cnkw{smt} \, \cnsym{(}  \cdot  \Rightarrow   bool\_value   =  \cnkw{aligned} \, \cnsym{(}  \tau  \cnsym{,}   mem\_ptr   \cnsym{)}  \cnsym{)}$
            by construction of $bool\_value$ (inversion on \ref{wellaligned-assm2}).}

        \step{<2>2}{$\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  bool\_value  \Rightarrow  \cnkw{bool}$ by
            \textsc{Ty\_PVal\_\{True,False\}}.}

        \step{<2>3}{By \textsc{Ty\_TVal\_I} and \stepref{<2>1} and \stepref{<2>2}
            with \textsc{Ty\_TVal\_\{Phi,Comp\}} respectively, we are done.}
    \end{proof}

    \step{<1>23}{%
        \case{%
            \textsc{Ty\_Memop\_PtrArrayShift}.
        }{%
            \pf\ Similiar to \textsc{Ty\_PE\_Array\_Shift}, except with
            \textsc{Ty\_TVal\_\{I,Phi,Comp\}} at the end.
        }
    }

    \step{<1>24}{%
        \case{%
            \textsc{Ty\_Seq\_E\_CCall}.
        }{%
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{ccall} \, \cnsym{(}  \tau  \cnsym{,}  ident  \cnsym{,}  \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}}  \cnsym{)}  \Rightarrow   \sigma  (  \cnnt{ret}  ) $.\label{ccall-assm1}

                    \item $\langle  \cnnt{h}  \cnsym{+}  \cnnt{f}  \cnsym{;}  \cnkw{ccall} \, \cnsym{(}  \tau  \cnsym{,}  ident  \cnsym{,}  \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}}  \cnsym{)}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{+}  \cnnt{f}  \cnsym{;}   \sigma'  (  texpr  )   {:}   \sigma'  (  \cnnt{ret}  )   \rangle$.
                \end{pfenum}}
            \prove{%
                $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash   \sigma  (  texpr  )   \Leftarrow   \sigma  (  \cnnt{ret}  ) $ \\
                (because the heap does not change).
            }
        }
    }

    \begin{proof}
        \step{<2>1}{$ident  {:}  \cnnt{arg} \, \equiv \, \cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mapsto  texpr \, \in \, \cnkw{Globals}$
            by inversion (on either assumption).}

        \step{<2>2}{$\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash \, \cncomp{\cnmv{x_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \gg  \sigma  \cnsym{;}  \cnnt{ret}$ by
            inversion on \ref{ccall-assm1}.}

        \step{<2>3}{$\sigma = \sigma'$ and $\cnnt{ret} = \cnnt{ret'}$
            by induction on $\cnnt{arg}$.\\
            \pf\ \textsc{Ty\_Spine\_*} and \textsc{Decons\_Arg\_*} construct same
            substitution and return type (lemma \ref{subsec:spine_decons_same}).}

        \step{<2>4}{
            \pflet{$\ctxC ; \ctxL ; \ctxN ; \ctxR'$ be the the type of
                substitution $\sigma$: $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}'  \cnsym{)}$.}
            \pf\ From \stepref{<2>2} we may deduce
            \begin{pfenum}
                \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \vdash  pval_{\cnmv{i}}  \Rightarrow  \beta_{\cnmv{i}}$ for each
                    $\cnmv{x_{\cnmv{i}}}  {:}  \beta_{\cnmv{i}} \, \in \, \mathcal{C}$ or $\cnmv{x_{\cnmv{i}}}  {:}  \beta_{\cnmv{i}} \, \in \, \mathcal{L}$.
                \item $\mathcal{C}  \cnsym{;}  \mathcal{L}  \cnsym{;}  \Phi  \cnsym{;}  \mathcal{R}'  \vdash  \cnnt{res\_term_{\cnmv{i}}}  \Leftarrow  \cnnt{res_{\cnmv{i}}}$ for each $ res_i \in \ctxR'$.
                \item $\cnkw{smt} \, \cnsym{(}  \cdot  \Rightarrow  \cnnt{term}  \cnsym{)}$ for each $ term \in \Phi$.
            \end{pfenum}}

        \step{<2>5}{$\mathcal{C}''  \cnsym{;}  \mathcal{L}''  \cnsym{;}  \Phi''  \cnsym{;}  \mathcal{R}''  \vdash  texpr  \Leftarrow  \cnnt{ret''}$ where
            $\cncomp{\cnmv{x_{\cnmv{i}}}}{\cnmv{i}} \, \mathbin{ {:} {:} }  \cnnt{arg}  \leadsto  \mathcal{C}''  \cnsym{;}  \mathcal{L}''  \cnsym{;}  \Phi''  \cnsym{;}  \mathcal{R}''  \mid  \cnnt{ret''}$ formalises
            the assumption that all global functions and labels are well-typed.}

        \step{<2>6}{$\mathcal{C} = \mathcal{C}''$ , $\Phi = \Phi''$ , $\mathcal{L} = \mathcal{L}''$ ,
            $\mathcal{R}' = \mathcal{R}''$ and $\cnnt{ret} = \cnnt{ret''}$.\\
            \pf\ By induction on $\cnnt{arg}$.}

        \step{<2>7}{Apply substitution lemma (\ref{subsec:sub_lemma}) to \stepref{<2>4} and
            \stepref{<2>5} to finish proof.}

    \end{proof}


    \step{<1>25}{%
        \case{%
            \textsc{Ty\_Seq\_E\_Proc}.
        }{%
            \pf\  Similar to \textsc{Ty\_Seq\_E\_CCall}.
        }
    }

    \step{<1>26}{%
        \case{%
            \textsc{Ty\_Is\_E\_Memop}.
        }{%
            \pf\ By induction on \textsc{Ty\_Memop*} cases.
        }
    }

    \step{<1>27}{%
        \case{%
            \textsc{Ty\_Is\_E\_\{Neg\_\}Action}.
        }{%
            \pf\ By induction on \textsc{Ty\_Action*} cases.
        }
    }

    \step{<1>28}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_LetP}.
        }{%
            \pfsketch{ Only covering case $\langle  pexpr  \rangle  \longrightarrow  \langle  pexpr'  \rangle$ here.\\
                See \textsc{Ty\_Seq\_TE\_Let} for a more general version and
                proof for the remaining $\langle  pexpr  \rangle  \longrightarrow  \langle  tpexpr  {:}  \cnsym{(}  \cnmv{y}  {:}  \beta  . \:  term  \cnsym{)}  \rangle$ case.
            }
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  \cnkw{let} \, ident\_or\_pattern  =  pexpr \, \cnkw{in} \, tpexpr  \Leftarrow  \cnmv{y_{{\mathrm{2}}}}  {:}  \beta_{{\mathrm{2}}}  . \:  \cnnt{term_{{\mathrm{2}}}}$.\label{letp-assm1}
                    \item $\langle  \cnkw{let} \, ident\_or\_pattern  =  pexpr \, \cnkw{in} \, tpexpr  \rangle  \longrightarrow  \langle  \cnkw{let} \, ident\_or\_pattern  =  pexpr' \, \cnkw{in} \, tpexpr  \rangle$.\label{letp-assm2}
                \end{pfenum}
            }
            \prove{%
                $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  \cnkw{let} \, ident\_or\_pattern  =  pexpr' \, \cnkw{in} \, tpexpr  \Leftarrow  \cnmv{y_{{\mathrm{2}}}}  {:}  \beta_{{\mathrm{2}}}  . \:  \cnnt{term_{{\mathrm{2}}}}$ \\
                (because this is a pure expression, heaps are irrelevant).
            }
        }
    }

    \begin{proof}
        \step{<2>1}{ \begin{pfenum}
                \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  pexpr  \Rightarrow  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}$.
                \item $ident\_or\_pattern  {:}  \beta  \leadsto  \mathcal{C}_{{\mathrm{1}}} \, \cnkw{with} \, term_{{\mathrm{1}}}$.
                \item $\mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{,}   term_{{\mathrm{1}}}  \cnsym{/}  \cnmv{y}  \cnsym{,}  \cdot  (  \cnnt{term}  )   \cnsym{,}  \Phi_{{\mathrm{1}}}  \cnsym{;}  \mathcal{R}  \vdash  texpr  \Leftarrow  \cnnt{ret}$.
            \end{pfenum}
            \pf\ Invert assumption \ref{letp-assm1}.}

        \step{<2>2}{$\langle  pexpr  \rangle  \longrightarrow  \langle  pexpr'  \rangle$.\\
            \pf\ Invert assumption \ref{letp-assm2}.}

        \step{<2>3}{$\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  pexpr'  \Rightarrow  \cnmv{y}  {:}  \beta  . \:  \cnnt{term}$.\\
            \pf\ By induction on \stepref{<2>1}.1 and \stepref{<2>2}.}

        \step{<2>4}{ $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  \cnkw{let} \, ident\_or\_pattern  =  pexpr' \, \cnkw{in} \, tpexpr  \Leftarrow  \cnmv{y_{{\mathrm{2}}}}  {:}  \beta_{{\mathrm{2}}}  . \:  \cnnt{term_{{\mathrm{2}}}}$.\\
            \pf\ By \textsc{Ty\_Seq\_TE\_LetP} using \stepref{<2>1}.2,3 and \stepref{<2>3}.}
    \end{proof}

    \step{<1>29}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_LetPT}.
        }{%
            \pf\ See \textsc{Ty\_Seq\_TE\_LetT} for a more general case and proof.
        }
    }

    \step{<1>30}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_Let}.
        }{%
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}'  \cnsym{,}  \mathcal{R}  \vdash  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, =  seq\_expr \, \cnkw{in} \, texpr_{{\mathrm{2}}}  \Leftarrow  \cnnt{ret_{{\mathrm{2}}}}$.\label{let_letT-assm1}

                    \item $\langle  \cnnt{h}  \cnsym{+}  \cnnt{f}  \cnsym{;}  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, =  seq\_expr \, \cnkw{in} \, texpr_{{\mathrm{2}}}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{+}  \cnnt{f}  \cnsym{;}  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret'_{{\mathrm{1}}}}  =  texpr_{{\mathrm{1}}} \, \cnkw{in} \, texpr_{{\mathrm{2}}}  \rangle$.\label{let_letT-assm2}
                \end{pfenum}}

            \prove{$\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}'  \cnsym{,}  \mathcal{R}  \vdash  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret_{{\mathrm{1}}}}  =  texpr_{{\mathrm{1}}} \, \cnkw{in} \, texpr_{{\mathrm{2}}}  \Leftarrow  \cnnt{ret_{{\mathrm{2}}}}$ \\
                (because the heap does not change).
            }
        }
    }

    \begin{proof}
        \step{<2>1}{\begin{pfenum}
                \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}'  \vdash  seq\_expr  \Rightarrow  \cnnt{ret_{{\mathrm{1}}}}$.
                \item $\Phi  \vdash \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret_{{\mathrm{1}}}}  \leadsto  \mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \mathcal{L}_{{\mathrm{1}}}  \cnsym{;}  \Phi_{{\mathrm{1}}}  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}$.
                \item $\mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \mathcal{L}_{{\mathrm{1}}}  \cnsym{;}  \Phi_{{\mathrm{1}}}  \cnsym{;}  \mathcal{R}  \cnsym{,}  \mathcal{R}_{{\mathrm{1}}}  \vdash  texpr  \Leftarrow  \cnnt{ret_{{\mathrm{2}}}}$.
            \end{pfenum}
            \pf\ By inversion on \ref{let_letT-assm1}.}

        \step{<2>2}{$\langle  \cnnt{h}  \cnsym{;}  seq\_expr  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{;}  texpr_{{\mathrm{1}}}  {:}  \cnnt{ret'_{{\mathrm{1}}}}  \rangle$.\\
            \pf\ By inversion on \ref{let_letT-assm2}.}

        \step{<2>3}{$\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}'  \vdash  texpr_{{\mathrm{1}}}  \Leftarrow  \cnnt{ret_{{\mathrm{1}}}}$.\\
            \pf\ By induction on \stepref{<2>1}.1 and \stepref{<2>2}.}

        \step{<2>4}{$\cnnt{ret_{{\mathrm{1}}}} = \cnnt{ret'_{{\mathrm{1}}}}$.\\
            \pf\ By cases \textsc{Ty\_Seq\_E\_\{CCall,PCall\}}.}

        \step{<2>5}{By \textsc{Ty\_Seq\_TE\_Let} with \stepref{<2>1}.2,3 and
            \stepref{<2>3}, we are done.}
    \end{proof}

    \step{<1>31}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_LetT}.
        }{%
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}'  \cnsym{,}  \mathcal{R}  \vdash  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret_{{\mathrm{1}}}}  =  \cnkw{done} \, \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \cnkw{in} \, texpr_{{\mathrm{2}}}  \Leftarrow  \cnnt{ret_{{\mathrm{2}}}}$.\label{letT_sub-assm1}

                    \item $\langle  \cnnt{h}  \cnsym{+}  \cnnt{f}  \cnsym{;}  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret_{{\mathrm{1}}}}  =  \cnkw{done} \, \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \cnkw{in} \, texpr  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{+}  \cnnt{f}  \cnsym{;}   \sigma  (  texpr_{{\mathrm{2}}}  )   \rangle$.\label{letT_sub-assm2}
                \end{pfenum}}
            \prove{%
                $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}'  \cnsym{,}  \mathcal{R}  \vdash   \sigma  (  texpr_{{\mathrm{2}}}  )   \Leftarrow   \sigma  (  \cnnt{ret_{{\mathrm{2}}}}  ) $ \\
                (because the heap does not change).
            }
        }
    }

    \begin{proof}
        \step{<2>1}{\begin{pfenum}
                \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}'  \vdash  \cnkw{done} \, \cncomp{\cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}}  \Leftarrow  \cnnt{ret_{{\mathrm{1}}}}$.
                \item $\Phi  \vdash \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret_{{\mathrm{1}}}}  \leadsto  \mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \mathcal{L}_{{\mathrm{1}}}  \cnsym{;}  \Phi_{{\mathrm{1}}}  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}$.
                \item $\mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \mathcal{L}_{{\mathrm{1}}}  \cnsym{;}  \Phi_{{\mathrm{1}}}  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{R}  \vdash  texpr_{{\mathrm{2}}}  \Leftarrow  \cnnt{ret_{{\mathrm{2}}}}$.
            \end{pfenum}
            \pf\ By inversion on \ref{letT_sub-assm1}.}

        \step{<2>2}{$\cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}  =  \cnnt{spine\_elem_{\cnmv{i}}}}{\cnmv{i}} \, \leadsto  \sigma$.\\
            \pf\ By inversion on \ref{letT_sub-assm2}.}

        \step{<2>3}{$\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}'  \vdash  \cnsym{(}  \sigma  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \mathcal{L}_{{\mathrm{1}}}  \cnsym{;}  \Phi_{{\mathrm{1}}}  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \cnsym{)}$.\\
            \pf\ By \stepref{<2>1}.1,2 and \stepref{<2>2} using
            lemma \ref{subsec:wt_sub} (deconstructing a pattern produces a
            well-typed substitution).}

        \step{<2>4}{By \stepref{<2>1}.3 and \stepref{<2>3} and the let-friendly
            substitution lemma \ref{subsec:let_sub_lemma}, we are done.}
    \end{proof}

    \step{<1>32}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_LetT}.
        }{%
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}'  \cnsym{,}  \mathcal{R}  \vdash  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret_{{\mathrm{1}}}}  =  texpr_{{\mathrm{1}}} \, \cnkw{in} \, texpr_{{\mathrm{2}}}  \Leftarrow  \cnnt{ret_{{\mathrm{2}}}}$.\label{letT_letT-assm1}

                    \item $\langle  \cnnt{h}  \cnsym{+}  \cnnt{f}  \cnsym{;}  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret}  =  texpr_{{\mathrm{1}}} \, \cnkw{in} \, texpr_{{\mathrm{2}}}  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret}  =  texpr'_{{\mathrm{1}}} \, \cnkw{in} \, texpr_{{\mathrm{2}}}  \rangle$.\label{letT_letT-assm2}
                \end{pfenum}}
            \prove{%
                $\exists \cnnt{h''}  {:}  \mathcal{R}''  \cnsym{,}  \mathcal{R}.\ h' = h'' + f \\ \wedge \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}''  \cnsym{,}  \mathcal{R}  \vdash  \cnkw{let} \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret_{{\mathrm{1}}}}  =  texpr'_{{\mathrm{1}}} \, \cnkw{in} \, texpr_{{\mathrm{2}}}  \Leftarrow  \cnnt{ret_{{\mathrm{2}}}}$.
            }
        }
    }

    \begin{proof}
        \step{<2>1}{\begin{pfenum}
                \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}'  \vdash  texpr_{{\mathrm{1}}}  \Leftarrow  \cnnt{ret_{{\mathrm{1}}}}$.
                \item $\Phi  \vdash \, \cncomp{\cnnt{ret\_pattern_{\cnmv{i}}}}{\cnmv{i}} \, {:}  \cnnt{ret_{{\mathrm{1}}}}  \leadsto  \mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \mathcal{L}_{{\mathrm{1}}}  \cnsym{;}  \Phi_{{\mathrm{1}}}  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}$.
                \item $\mathcal{C}_{{\mathrm{1}}}  \cnsym{;}  \mathcal{L}_{{\mathrm{1}}}  \cnsym{;}  \Phi_{{\mathrm{1}}}  \cnsym{;}  \mathcal{R}_{{\mathrm{1}}}  \cnsym{,}  \mathcal{R}  \vdash  texpr_{{\mathrm{2}}}  \Leftarrow  \cnnt{ret_{{\mathrm{2}}}}$.
            \end{pfenum}
            \pf\ By inversion on \ref{letT_letT-assm1}.}

        \step{<2>2}{$\langle  \cnnt{h}  \cnsym{+}  \cnnt{f}  \cnsym{;}  texpr_{{\mathrm{1}}}  \rangle  \longrightarrow  \langle  \cnnt{h'}  \cnsym{;}  texpr'_{{\mathrm{1}}}  \rangle$.\\
            \pf\ By inversion on \ref{letT_letT-assm2}.}

        \step{<2>3}{$h = h_1 + h_2$ where $\cnnt{h_{{\mathrm{1}}}}  {:}  \mathcal{R}'$ and $\cnnt{h_{{\mathrm{2}}}}  {:}  \mathcal{R}$.\\
            \pf\ By induction on $\mathcal{R}$.}

        \step{<2>3}{$\exists h_1' {:} R''.\ h' = h_1' + h_2 + f \wedge \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}''  \vdash  texpr'_{{\mathrm{1}}}  \Leftarrow  \cnnt{ret_{{\mathrm{1}}}}$.\\
            \pf\ By induction with $\cnnt{h_{{\mathrm{1}}}}  {:}  \mathcal{R}'$ and $h2 + f$ as the frame,
            using \stepref{<2>1}.1 and \stepref{<2>2}.}

        \step{<2>4}{By \stepref{<2>3}, \stepref{<2>2}.2,3 using
            \textsc{Ty\_Seq\_TE\_LetT}, and $h'' = h_1' + h_2$ (so $\cnnt{h''}  {:}  \mathcal{R}''  \cnsym{,}  \mathcal{R}$) we are done.}

    \end{proof}

    \step{<1>33}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_Case}.
        }{%
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{case} \, pval \, \cnkw{of} \, \cncomp{\mid  pattern_{\cnmv{i}}  \Rightarrow  texpr_{\cnmv{i}}}{\cnmv{i}} \, \cnkw{end}  \Leftarrow  \cnnt{ret}$.\label{case-assm1}

                    \item $\langle  \cnnt{h}  \cnsym{+}  \cnnt{f}  \cnsym{;}  \cnkw{case} \, pval \, \cnkw{of} \, \cncomp{\mid  pattern_{\cnmv{i}}  \Rightarrow  texpr_{\cnmv{i}}}{\cnmv{i}} \, \cnkw{end}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{+}  \cnnt{f}  \cnsym{;}   \sigma_{\cnmv{j}}  (  texpr_{\cnmv{j}}  )   \rangle$.\label{case-assm2}
                \end{pfenum}}
            \prove{%
                $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash   \sigma_{\cnmv{j}}  (  texpr_{\cnmv{j}}  )   \Leftarrow  \cnnt{ret}$ \\
                (because the heap does not change).
            }
        }
    }

    \begin{proof}
        \step{<2>1}{\begin{pfenum}
                \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  pval  \Rightarrow  \beta_{{\mathrm{1}}}$.
                \item $\cncomp{pattern_{\cnmv{i}}  {:}  \beta_{{\mathrm{1}}}  \leadsto  \mathcal{C}_{\cnmv{i}} \, \cnkw{with} \, term_{\cnmv{i}}}{\cnmv{i}}$.
                \item $\cncomp{\mathcal{C}_{\cnmv{i}}  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{,}  term_{\cnmv{i}}  =   pval   \cnsym{;}  \mathcal{R}  \vdash  texpr_{\cnmv{i}}  \Leftarrow  \cnnt{ret}}{\cnmv{i}}$.
            \end{pfenum}
        \pf\ By inversion on \ref{case-assm1}.}

        \step{<2>2}{\begin{pfenum}
                \item $pattern_{\cnmv{j}}  =  pval  \leadsto  \sigma_{\cnmv{j}}$.
                \item $\forall \, \cnmv{i}  \cnsym{<}  \cnmv{j}  . \: \, \cnkw{not} \, \cnsym{(}  pattern_{\cnmv{i}}  =  pval  \leadsto  \sigma_{\cnmv{i}}  \cnsym{)}$.
            \end{pfenum}
            \pf\ By inversion on \ref{case-assm2}.}

        \step{<2>3}{$term_{\cnmv{j}}  =   pval $.\\
            \pf\ By \stepref{<2>1}.2 and terms derived from patterns are
            ``equal to'' matching values (lemma \ref{subsec:pattern_term}).}

        \step{<2>4}{$\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \vdash  \cnsym{(}  \sigma_{\cnmv{j}}  \cnsym{)}  {:}  \cnsym{(}  \mathcal{C}_{\cnmv{j}}  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{,}  term_{\cnmv{j}}  =   pval   \cnsym{;}  \cdot  \cnsym{)}$.\\
            \pf\ By \stepref{<2>3} and lemma \ref{subsec:wt_sub}
            (deconstructing a pattern produces a well-typed substitution).}

        \step{<2>5}{By \stepref{<2>4}, \stepref{<2>1}.3 and substitution lemma
            \ref{subsec:sub_lemma}, we are done.}

    \end{proof}

    \step{<1>34}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_If}.\\
            Only covering $\cnkw{True}$ case, $\cnkw{False}$ is almost identical.
        }{%
            \assume{%
                \begin{pfenum}
                    \item $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash  \cnkw{if} \, \cnkw{True} \, \cnkw{then} \, texpr_{{\mathrm{1}}} \, \cnkw{else} \, texpr_{{\mathrm{2}}}  \Leftarrow  \cnnt{ret}$.\label{if-assm1}

                    \item $\langle  \cnnt{h}  \cnsym{+}  \cnnt{f}  \cnsym{;}  \cnkw{if} \, \cnkw{True} \, \cnkw{then} \, texpr_{{\mathrm{1}}} \, \cnkw{else} \, texpr_{{\mathrm{2}}}  \rangle  \longrightarrow  \langle  \cnnt{h}  \cnsym{+}  \cnnt{f}  \cnsym{;}  texpr_{{\mathrm{1}}}  \rangle$.\label{if-assm2}
                \end{pfenum}}
            \prove{%
                $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash  texpr_{{\mathrm{1}}}  \Leftarrow  \cnnt{ret}$ \\
                (because the heap does not change).
            }
            \pf\ Invert \ref{if-assm1}, note $\cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \mathcal{R}  \vdash  \cnsym{(}   \mathrm{id}   \cnsym{)}  {:}  \cnsym{(}  \cdot  \cnsym{;}  \cdot  \cnsym{;}  \cdot  \cnsym{,}  \cnkw{true}  =  \cnkw{true}  \cnsym{;}  \mathcal{R}  \cnsym{)}$ and then
            apply substitution lemma (\ref{subsec:sub_lemma}).
        }
    }


    \step{<1>35}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_Run}.
        }{%
            \pfsketch\ Similar to case \textsc{Ty\_Seq\_E\_\{CCall,PCall\}}.
        }
    }

    \step{<1>36}{%
        \case{%
            \textsc{Ty\_Seq\_TE\_Bound}.
        }{%
            \pf\ By inversion on the typing rule.
        }
    }

    \step{<1>37}{%
        \case{%
            \textsc{Ty\_Is\_TE\_LetS}.
        }{%
            \pfsketch\ Similar to \textsc{Ty\_Seq\_TE\_LetT}.
        }
    }

\end{proof}

\pagebreak%
\section{Typing Judgements}

\cngrammartabular{
\cnobjectXXvalueXXjtype\cninterrule%
\cnpvalXXjtype\cninterrule%
\cnresXXjtype\cninterrule%
\cnspineXXjtype\cninterrule%
\cnpexprXXjtype\cninterrule%
\cntpvalXXjtype\cninterrule%
\cntpexprXXjtype\cninterrule%
\cnactionXXjtype\cninterrule%
\cnmemopXXjtype\cninterrule%
\cnseqXXexprXXjtype\cninterrule%
\cnisXXexprXXjtype\cninterrule%
\cntvalXXjtype\cninterrule%
\cntexprXXjtype\cninterrule%
}

\pagebreak%
\section{Opsem Judgements}\label{sec:opsem}

\cngrammartabular{
\cnpureXXopsemXXjtype\cninterrule%
\cnopsemXXjtype\cninterrule%
}


\end{document}
