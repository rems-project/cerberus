(* NEW AND FINAL Cabs to Ail translation *)

(* TODO: ignoring locations for now *)

(* TODO: not doing the linkages stuff for now *)







(*


val desugar_storages: list C.storage -> E.t (option A.storage_duration)
let desugar_storages = function
  | []               -> E.return None
  | [C.AUTO]         -> E.return (Some A.AUTOMATIC)
  | [C.STATIC]       -> E.return (Some A.STATIC)
  | [C.EXTERN]       -> E.fail (Errors.CSEM_NOT_SUPPORTED "storage class extern")
  | [C.THREAD_LOCAL] -> E.fail (Errors.CSEM_NOT_SUPPORTED "storage class _Thread_local")
  | [C.REGISTER]     -> E.fail (Errors.CSEM_NOT_SUPPORTED "storage class register")
  | [C.TYPEDEF]      -> E.return None (* TODO: typedef is not really a storage class, but should be get the class of the aliased type??? *)
  | _                -> E.fail Errors.CABS_TO_AIL_MULTIPLE_STORAGE_CLASS
end









(* We follow the multiset mapping from §6.7.2#2 (except that `void' is matched in [desugar_type]
   instead) *)
(* TODO: we should do something about `char' here (implementation-defined choice) *)
(* TODO: is this only used by [desugar_spec_elem_list]? *)
val desugar_specifier: multiset C.typeSpecifier -> E.t (A.basic_type)
let desugar_specifier specifiers =
  let mk_mset = Multiset.from_list in
  let desugar_map =
    List.fold_left
      (fun m (x, y) -> Pmap.add x y m)
      (Ocaml.Pmap.empty Multiset.compare_int)
      (
        (* TODO: maybe move that somewhere else *)
          [(mk_mset [C.Tchar], A.CHAR)]

        @ [(mk_mset [C.Tsigned; C.Tchar], A.INTEGER (A.SIGNED A.ICHAR))]
        @ [(mk_mset [C.Tunsigned; C.Tchar], A.INTEGER (A.UNSIGNED A.ICHAR))]
        @ List.map (fun s -> (mk_mset s, A.INTEGER (A.SIGNED A.SHORT)))
          [ [C.Tshort];
            [C.Tsigned; C.Tshort];
            [C.Tshort; C.Tint];
            [C.Tsigned; C.Tshort; C.Tint]
          ]
        @ List.map (fun s -> (mk_mset s, A.INTEGER (A.UNSIGNED A.SHORT)))
          [ [C.Tunsigned; C.Tshort];
            [C.Tunsigned; C.Tshort; C.Tint]
          ]
        @ List.map (fun s -> (mk_mset s, A.INTEGER (A.SIGNED A.INT)))
          [ [C.Tint];
            [C.Tsigned];
            [C.Tsigned; C.Tint]
          ]
        @ List.map (fun s -> (mk_mset s, A.INTEGER (A.UNSIGNED A.INT)))
          [ [C.Tunsigned];
            [C.Tunsigned; C.Tint]
          ]
        @ List.map (fun s -> (mk_mset s, A.INTEGER (A.SIGNED A.LONG)))
          [ [C.Tlong];
            [C.Tsigned; C.Tlong];
            [C.Tlong; C.Tint];
            [C.Tsigned; C.Tlong; C.Tint]
          ]
        @ List.map (fun s -> (mk_mset s, A.INTEGER (A.UNSIGNED A.LONG)))
          [ [C.Tunsigned; C.Tlong];
            [C.Tunsigned; C.Tlong; C.Tint]
          ]
        @ List.map (fun s -> (mk_mset s, A.INTEGER (A.SIGNED A.LONG_LONG)))
          [ [C.Tlong; C.Tlong];
            [C.Tsigned; C.Tlong; C.Tlong];
            [C.Tlong; C.Tlong; C.Tint];
            [C.Tsigned; C.Tlong; C.Tlong; C.Tint]
          ]
        @ List.map (fun s -> (mk_mset s, A.INTEGER (A.UNSIGNED A.LONG_LONG)))
          [ [C.Tunsigned; C.Tlong; C.Tlong];
            [C.Tunsigned; C.Tlong; C.Tlong; C.Tint]
          ]
        @ [(mk_mset [C.Tfloat], A.REAL_FLOATING A.FLOAT)]
        @ [(mk_mset [C.Tdouble], A.REAL_FLOATING A.DOUBLE)]
        @ [(mk_mset [C.Tlong; C.Tdouble], A.REAL_FLOATING A.LONG_DOUBLE)]
        @ [(mk_mset [C.T_Bool], A.INTEGER A.BOOL)]
(*
        @ [(mk_mset [C.Tfloat; C.COMPLEX], A.COMPLEX A.FLOAT)]
        @ [(mk_mset [C.Tdouble; C.COMPLEX], A.COMPLEX A.DOUBLE)]
        @ [(mk_mset [C.Tlong; C.Tdouble; C.COMPLEX], A.COMPLEX A.LONG_DOUBLE)]
*)
      ) in
  E.of_option (Errors.OTHER "[Cabs_to_ail.desugar_specifier] found a Cabs type that we don't yet handled.")
              (Map_.find specifiers desugar_map)

val desugar_unary_operator: C.unary_operator -> A.unary_operator
let desugar_unary_operator = function
  | C.MINUS   -> A.MINUS
  | C.PLUS    -> A.PLUS
  | C.BNOT    -> A.BNOT
  | C.MEMOF   -> A.INDIRECTION
  | C.ADDROF  -> A.ADDRESS
  | C.POSINCR -> A.POSTFIX_INCR
  | C.POSDECR -> A.POSTFIX_DECR

  (* These cases cannot occurs since these constructors are translated away. *)
  | C.NOT     -> Boot.assert_false "[Cabs_to_ail.desugar_unary_operator] NOT"
  | C.PREINCR -> Boot.assert_false "[Cabs_to_ail.desugar_unary_operator] PREINCR"
  | C.PREDECR -> Boot.assert_false "[Cabs_to_ail.desugar_unary_operator] PREDECR"
end


val desugar_arithmetic_operator: C.binary_operator -> A.arithmetic_operator
let desugar_arithmetic_operator = function
  | C.ADD  -> A.ADD
  | C.SUB  -> A.SUB
  | C.MUL  -> A.MUL
  | C.DIV  -> A.DIV
  | C.MOD  -> A.MOD
  | C.BAND -> A.BAND
  | C.XOR  -> A.XOR
  | C.BOR  -> A.BOR
  | C.SHL  -> A.SHL
  | C.SHR  -> A.SHR
  | _ -> Boot.assert_false "[Cabs0_to_ail.desugar_arithmetic_operator] should only be called on \
                            operators allowed for compound assignments [§6.5.16#1]."
end


val desugar_binary_operator: C.binary_operator -> A.binary_operator
let desugar_binop = function
  | C.AND   -> A.AND
  | C.OR    -> A.OR
  | C.EQ    -> A.EQ
  | C.NE    -> A.NE
  | C.LT    -> A.LT
  | C.GT    -> A.GT
  | C.LE    -> A.LE
  | C.GE    -> A.GE
  | C.COMMA -> A.COMMA
  | op      -> A.ARITHMETIC (desugar_arithmetic_operator op)
end







*)
open Global

module C = Cabs0
module A = Ail

module O = Option



module Effect = struct

  type state = <|
    symbol_counter: Symbol.counter;
    (* table (with stacked scopes) associating C identifiers to symbols *)
    registered_identifiers: Symbol_table.t string Symbol.t;
(*    registered_labels:   *)
    is_inside_switch: bool;

    id_map       : map Symbol.t A.declaration;                  (* map associating identifiers to their (Ail) declaration *)
    fn_map       : map Symbol.t (list Symbol.t * A.statement_l unit); (* functions map        *)


  |>

  type t 'a = State_exception.t 'a state Errors.t

  val return: forall 'a. 'a -> t 'a
  let return = State_exception.return

  val fail: forall 'a. Errors.cause -> t 'a
  let fail err = State_exception.fail (Location.dummy, err)

  val make_file: Symbol.t -> t (A.file unit)
  let make_file startup =
    State_exception.read (fun s ->
      <| A.main    = startup;
         A.id_map  = s.id_map;
         A.globals = []; (* TODO: popoulate *)
         A.fn_map  = s.fn_map
      |>
    )

  val mapM: forall 'a 'b. ('a -> t 'b) -> list 'a -> t (list 'b)
  val mapM_: forall 'a 'b. ('a -> t 'b) -> list 'a -> t unit
  let mapM = State_exception.mapM
  let mapM_ = State_exception.mapM_

  val tryWith: forall 'a. Errors.t -> t 'a -> t 'a
  let tryWith = State_exception.tryWith

  module Operators = struct
    let (>>=)    = State_exception.bind
    let (>>) m f = m >>= fun _ -> f

    val (<$>): forall 'a 'b. ('a -> 'b) -> t 'a -> t 'b
    val (<*>): forall 'a 'b. t ('a -> 'b) -> t 'a -> t 'b
    let (<$>) = State_exception.fmap
    let (<*>) = State_exception.app

    val ifElse: forall 'a. t bool -> t 'a -> t 'a -> t 'a
    let ifElse mb m1 m2 =
      mb >>= function
	| true  -> m1
	| false -> m2
      end
  end

  open Operators

  (* given a computation producing the symbolic name of the startup function,
     produce the desugared Ail file *)
  val eval: t Symbol.t -> Exception.t (Ail.file unit) Errors.t
  let eval m =
    let initial_state : state = <|
      symbol_counter = Symbol.init;
      registered_identifiers = Symbol_table.create_scope Symbol_table.empty;
      is_inside_switch = false;

      id_map              = Pmap.empty;
      fn_map              = Pmap.empty
    |> in
    State_exception.eval (m >>= make_file) initial_state

  val resolve_identifier: string -> t Symbol.t
  let resolve_identifier name =
    State_exception.read (fun st -> Symbol_table.find name st.registered_identifiers) >>= function
      | Some x  -> return x
      | Nothing -> fail (Errors.CABS_TO_AIL_UNDECLARED_IDENTIFIER name)
    end

  val is_inside_switch: t bool
  let is_inside_switch =
    State_exception.read (fun st -> st.is_inside_switch)

  val create_scope: t unit
  let create_scope =
    State_exception.update (fun st ->
      <| st with registered_identifiers= Symbol_table.create_scope st.registered_identifiers |>)

  val destroy_scope: t (list Symbol.t)
  let destroy_scope =
    State_exception.modify (fun st ->
      (Symbol_table.symbols st.registered_identifiers,
       <| st with registered_identifiers= Symbol_table.destroy_scope st.registered_identifiers |>)
    )

  val fresh : t Symbol.t
  let fresh =
    State_exception.modify (fun st ->
      let (sym, symbol_counter) = Symbol.fresh st.symbol_counter in
      (sym, <| st with symbol_counter = symbol_counter |>)
    )

  val fresh_name : string -> t Symbol.t
  let fresh_name name =
    State_exception.modify (fun st ->
      let (sym, symbol_counter) = Symbol.fresh_pretty name st.symbol_counter in
      (sym, <| st with symbol_counter = symbol_counter |>)
    )

  val register_name_translation : string -> Symbol.t -> t unit
  let register_name_translation name symbol =
    State_exception.update (fun st ->
      <| st with registered_identifiers = Symbol_table.add name symbol st.registered_identifiers |>
    )

  val name_in_scope : string -> t bool
  let name_in_scope name =
    State_exception.read (fun st ->
      Symbol_table.mem name (Symbol_table.return_scope st.registered_identifiers)
    )

  val register_name : string -> t Symbol.t
  let register_name name =
    name_in_scope name >>= function
      | true  ->
          State_exception.fail (Location.dummy, Errors.CABS_TO_AIL_MULTIPLE_REGISTRATION)
      | false ->
          fresh_name name                    >>= fun sym ->
          register_name_translation name sym >>
          State_exception.return sym
      end

  (* TODO: storage_duration *)
  val add_declaration : Symbol.t -> A.ctype -> t unit
  let add_declaration v t =
    State_exception.update (fun s ->
    <| s with id_map = Pmap.add v (t, None) s.id_map |>)

end


module E = Effect
open E.Operators

val register_label: C.atom -> E.t A.label
let register_label l_name =
  Boot.assert_false "HIP: register_label"

val register_labels: C.statement -> E.t unit
let register_labels stmt =
  Boot.assert_false "HIP: register_labels"

val fetch_label: C.atom -> E.t A.label
let fetch_label l_name =
  Boot.assert_false "HIP: fetch_label"

(* TODO: better name? *)
type declarationKind =
  | Object
  | Function

(* Scopes of identifiers *)
type scope =
  | FunctionScope
  | FileScope
  | BlockScope
(*  | FunctionPrototypeScope *)

type pre_integer_constant =
  | StrictIntegerConstant of int
  | ImplDefined (* TODO: arg *)

(* ============================================================================================== *)

(* TODO: relook at this with linkage stuff *)

(* (§6.7.1#2) At most, one storage-class specifier may be given in the
   declaration specifiers in a declaration, except that _Thread_local may appear
   with static or extern. 120) *)

(* TODO: (§6.7.1#3) [...] If _Thread_local appears in any declaration of an object, it shall be present in every declaration of that object. *)
(* TODO: (§6.7.1#8) f an aggregate or union object is declared with a storage-class specifier other than typedef, the properties resulting from the storage-class specifier, except with respect to linkage, also apply to the members of the object, and so on recursively for any aggregate or union member objects. *)

val desugar_storages: declarationKind -> scope -> list C.storage -> E.t (option A.storage_duration)
let desugar_storages kind scope ss =
  (* (§6.7.1#7) The declaration of an identifier for a function that has block
     scope shall have no explicit storage-class specifier other than extern. *)
  if kind = Function && scope = BlockScope then
    match ss with
      | [] ->
	  E.return None
      | [C.EXTERN] ->
	  E.fail (Errors.CSEM_NOT_SUPPORTED "storage class extern")
      | _ ->
	  E.fail Errors.CABS_TO_AIL_BLOCK_FUNCTION_STORAGE
    end
  else
    match ss with
      | [C.THREAD_LOCAL] ->
          (* (§6.7.1#3) In the declaration of an object with block scope, if the
             declaration specifiers include _Thread_local, they shall also include
	     either static or extern. [...] *)
          if kind = Function then
	    E.fail Errors.CABS_TO_AIL_THREAD_LOCAL_FUNCTION
	  else if scope = BlockScope then
	    E.fail Errors.CABS_TO_AIL_BLOCK_THREAD_LOCAL_ALONE
	  else
	    E.return (Some A.THREAD)
      | [C.THREAD_LOCAL; C.STATIC] ->
	  if kind = Function then
	    E.fail Errors.CABS_TO_AIL_THREAD_LOCAL_FUNCTION
	  else
	    E.fail (Errors.CSEM_HIP "desugar_storages: THREAD_LOCAL + STATIC")
      | [C.STATIC; C.THREAD_LOCAL] ->
	  if kind = Function then
	    E.fail Errors.CABS_TO_AIL_THREAD_LOCAL_FUNCTION
	  else
	    E.fail (Errors.CSEM_HIP "desugar_storages: STATIC + THREAD_LOCAL")
      | [C.THREAD_LOCAL; C.EXTERN] ->
	  if kind = Function then
	    E.fail Errors.CABS_TO_AIL_THREAD_LOCAL_FUNCTION
	  else
	    E.fail (Errors.CSEM_HIP "desugar_storages: THREAD_LOCAL + EXTERN")
      | [C.EXTERN; C.THREAD_LOCAL] ->
	  if kind = Function then
	    E.fail Errors.CABS_TO_AIL_THREAD_LOCAL_FUNCTION
	  else
	    E.fail (Errors.CSEM_HIP "desugar_storages: EXTERN + THREAD_LOCAL")

      | [] ->
  	  E.return None
      | [C.AUTO] ->
	  E.return (Some A.AUTOMATIC)
      | [C.STATIC] ->
	  E.return (Some A.STATIC)
      | [C.REGISTER] ->
	  E.fail (Errors.CSEM_NOT_SUPPORTED "storage class register")
      | [C.EXTERN] ->
	  E.fail (Errors.CSEM_NOT_SUPPORTED "storage class extern")
      | [C.TYPEDEF] -> E.return None  (* TODO: typedef is not really a storage class, but should be get the class of the aliased type??? *)

      | _::_::_ -> E.fail Errors.CABS_TO_AIL_MULTIPLE_STORAGE_CLASS
    end

(*
  type C.definition =
  | FUNDEF of list spec_elem * name * statement * cabsloc
  | DECDEF of init_name_group * cabsloc (* global variable(s), or function prototype *)
 | PRAGMA of atom * cabsloc

--------------------

type A.file 'a = <|
  (* the main function name *)
  main:    id;
  id_map:  map id declaration;               (* declared identifiers *)
  globals: list (id * expression_t 'a);      (* *)
  fn_map:  map id (list id * statement_l 'a) (* functions *)
|>
*)

(*
val desugar_program: string -> list C.g_defn_l -> E.t (Ail.file unit)
let desugar_program startup global_defns =
  E.iter (desugar_global_defn initial_desugar_state) global_defns      >>= fun ()   ->
  E.option (Errors.CABS_TO_AIL_NO_STARTUP startup) (E.resolve startup) >>= fun main ->
  E.to_program main
*)

(* TODO: I'm trying to see if this function can be only used where we do not need to remember a storage *)
val mk_ctype: list C.spec_elem -> C.decl_type -> E.t A.ctype
let mk_ctype specs decl_t =
  (* TODO *)
  E.return A.VOID
(*  Boot.assert_false "HIP: mk_ctype" *)


open O.Operators
val     desugar_integer_constant_expression: C.expression -> O.t pre_integer_constant
let rec desugar_integer_constant_expression expr =
  let f x = desugar_integer_constant_expression x in
  match expr with
  | C.UNARY C.MINUS expr ->
      f expr >>= function
| ImplDefined -> Boot.assert_false "TODO"
        (* TODO: promotion *)
        | StrictIntegerConstant n -> O.return $ StrictIntegerConstant (Int.neg n)
      end

  | C.UNARY C.PLUS expr ->
      f expr >>= function
        | ImplDefined -> Boot.assert_false "TODO"
        (* TODO: promotion *)
        | StrictIntegerConstant n -> O.return $ StrictIntegerConstant n
      end

  | C.UNARY C.NOT expr ->
      f expr >>= function
        | ImplDefined -> Boot.assert_false "TODO"
        | StrictIntegerConstant n ->
            O.return $ StrictIntegerConstant
              (if Int.eq n (Int.int 0) then Int.int 1 else Int.int 0)
      end

  | C.UNARY C.BNOT expr ->
      Boot.assert_false "HIP: desugar_integer_constant_expression, UNARY BNOT"


  | C.BINARY bop expr1 expr2 ->
      Boot.assert_false "HIP: desugar_integer_constant_expression, BINARY"

(*
  | C.QUESTION expr1 expr2 expr3 ->
      (* when evaluating the test expression, 0 stands for false and
         any other value for true *)
      f expr1 >>= function
        | 0 -> f expr3
        | _ -> f expr2
      end
      <|>

      (* even if the test expression is not constant, the whole conditional is
         still constant if the two other expressions evaluate to the same value *)
      f expr2 >>= fun n2 ->
      f expr3 >>= fun n3 ->
      if n2 = n3 then
        O.return n2
      else
        O.empty

*)


(*
      | C.CAST of (list spec_elem * decl_type) * init_expression

    (*
      | C.C11_ATOMIC_INIT expr1 expr2 ->

      | C.C11_ATOMIC_STORE expr1 expr2 expr3 ->

      | C.C11_ATOMIC_LOAD expr1 expr2 ->

      | C.C11_ATOMIC_EXCHANGE expr1 expr2 expr3 ->

      | C.C11_ATOMIC_COMPARE_EXCHANGE_STRONG expr1 expr2 expr3 expr4 expr5 ->

      | C.C11_ATOMIC_COMPARE_EXCHANGE_WEAK of expression * expression * expression * expression * expression
      | C.C11_ATOMIC_FETCH_KEY of expression * expression * expression
    *)

  | C.CALL of expression * list expression
  | C.BUILTIN_VA_ARG of expression * (list spec_elem * decl_type)
  | C.CONSTANT of constant
  | C.VARIABLE of atom
  | C.EXPR_SIZEOF of expression
  | C.TYPE_SIZEOF of (list spec_elem * decl_type)
  | C.ALIGNOF of (list spec_elem * decl_type)
  | C.INDEX expr1 expr 2->
  | C.MEMBEROF expr at ->

  | C.MEMBEROFPTR expr at ->

  | C.OFFSETOF of (list spec_elem * decl_type) * atom
*)

    | _ -> None
  end



val desugar_expression: C.expression -> E.t (A.expression_t unit)
let desugar_expression expr =
  Boot.assert_false "HIP: desugar_expression"

val desugar_integer_constant: C.atom -> option C.integer_suffix -> A.integer_constant
let desugar_integer_constant str suff_opt =
  let desugar_integer_suffix = function
    | C.SUFFIX_UNSIGNED           -> A.SUFFIX_UNSIGNED
    | C.SUFFIX_UNSIGNED_LONG      -> A.SUFFIX_UNSIGNED_LONG
    | C.SUFFIX_UNSIGNED_LONG_LONG -> A.SUFFIX_UNSIGNED_LONG_LONG
    | C.SUFFIX_LONG               -> A.SUFFIX_LONG
    | C.SUFFIX_LONG_LONG          -> A.SUFFIX_LONG_LONG
  end in
  let (n, basis) = Decode.decode_integer_constant str in
  match suff_opt with
    | Some suff -> (n, basis, Some (desugar_integer_suffix suff))
    | None      -> (n, basis, None)
  end

val desugar_character_constant: option C.character_prefix -> C.atom -> A.character_constant
(* TODO: decoding + impl-def independence (and Ail should store an integer, instead of a string) *) 
  let desugar_character_constant pref_opt str =
  let desugar_character_prefix = function
    | C.PREFIX_L -> A.PREFIX_L
    | C.PREFIX_u -> A.PREFIX_u
    | C.PREFIX_U -> A.PREFIX_U
  end in
  let n = Decode.decode_character_constant str in
  match pref_opt with
    | Some pref -> (Some (desugar_character_prefix pref), n)
    | None      -> (None, n)
  end

val desugar_constant: C.constant -> E.t A.constant
let desugar_constant = function
  | C.CONST_INT str suff_opt ->
      E.return $ A.CONST_INT (desugar_integer_constant str suff_opt)
  | C.CONST_FLOAT str ->
      E.fail (Errors.CSEM_NOT_SUPPORTED "float constants")
  | C.CONST_CHAR pref_opt str ->
      E.return $ A.CONST_CHAR (desugar_character_constant pref_opt str)
end

(*
type C.constant =
  (* The atom is the textual representation of the constant in
     the source code. It does include quotes. *)
  | CONST_INT of atom * option integer_suffix
  | CONST_FLOAT of atom
  | CONST_CHAR of option character_prefix * atom
  | CONST_STRING of atom (* TODO *)



type A.constant =
  | CONST_INT of integer_constant
  | CONST_FLOAT of string (* the textual representaton *)
  | CONST_CHAR of character_constant
  | CONST_ENUM of string
(* 
(* TODO *)
  | CONST_CHAR of list int64
  | CONST_WCHAR of list int64
*)

*)

open E.Operators

val desugar_cvspecs: list C.cvspec -> A.qualifiers
let desugar_cvspecs =
  List.fold_left (fun qs ->
    function
    | C.CV_CONST    -> <| qs with A.const    = true |>
    | C.CV_RESTRICT -> <| qs with A.restrict = true |>
    | C.CV_VOLATILE -> <| qs with A.volatile = true |>
    | C.CV_ATOMIC   -> <| qs with A.atomic_q = true |>
    end
  ) A.no_qualifiers

val desugar_decl_type : C.decl_type -> A.ctype -> A.ctype
val desugar_parameter : C.parameter -> A.qualifiers * A.ctype
val desugar_parameters : list C.parameter -> list (A.qualifiers * A.ctype)

let rec desugar_decl_type dt =
  match dt with
  | C.JUSTBASE ->
      fun t -> t
  | C.ARRAY dt cvs _ None ->
      fun t ->
        (desugar_decl_type dt)
        (A.ARRAY (desugar_cvspecs cvs) t None)
  | C.ARRAY dt cvs _ (Some (C.CONSTANT (C.CONST_INT n s))) ->
      Boot.assert_false "TODO: integer constant"
  | C.ARRAY dt cvs _ (Some (C.CONSTANT e)) ->
      Boot.assert_false "Constant expressions other than integer constant not yet supported."
  | C.PTR cvs _ dt ->
      fun t ->
        (desugar_decl_type dt)
        (A.POINTER (desugar_cvspecs cvs) t)
  (* The bool is true for variable length parameters. *)
  | C.PROTO dt (ps, b) ->
      fun t ->
        (desugar_decl_type dt)
        (A.FUNCTION t (desugar_parameters ps))
  end

and desugar_parameter p =
  let C.PARAM specs name_opt dt _ _ = p in
  (A.no_qualifiers, desugar_decl_type dt A.VOID) (* TODO *)

and desugar_parameters ps =
  List.map desugar_parameter ps

val desugar_statement : C.statement  -> E.t (A.statement_l unit)

val desugar_declaration: C.init_name_group -> E.t (list (Symbol.t * A.expression_t unit))
val desugar_definition: C.definition -> E.t (sum (list (Symbol.t * A.expression_t unit)) (Symbol.t * list Symbol.t * A.statement_l unit))

val desugar_init_name : C.init_name -> E.t (Symbol.t * (A.ctype -> A.ctype) * option (A.expression_t unit))

let rec desugar_statement stmt =
  Product.make Location.dummy <$>
    match stmt with
      | C.NOP _ ->
          E.return A.SKIP
      | C.COMPUTATION expr _ ->
          A.EXPRESSION <$> desugar_expression expr
      | C.BLOCK stmts _ ->
          (* TODO: documentation *)
          E.create_scope                 >>
          E.mapM desugar_statement stmts >>= fun d_stmts ->
          E.destroy_scope                >>= fun ids     ->
          E.return $ A.BLOCK ids d_stmts
      | C.If expr stmt1 stmt2_opt _ ->
          (* (§6.8.3#3) allows us to add null operation without changing the
                       semantics of a statement *)
          A.IF <$> desugar_expression expr
               <*> desugar_statement stmt1
               <*> Option.option (E.return (Location.dummy, A.SKIP)) desugar_statement stmt2_opt
      | C.WHILE expr stmt _ ->
          A.WHILE <$> desugar_expression expr
                  <*> desugar_statement stmt
      | C.DOWHILE expr stmt _ ->
          A.DO <$> desugar_expression expr
               <*> desugar_statement stmt
      | C.FOR fc_opt expr1_opt expr2_opt stmt _ ->
          Boot.assert_false "HIP: desugar_statement FOR"
      | C.BREAK _ ->
          E.return A.BREAK
      | C.CONTINUE _ ->
          E.return A.CONTINUE
      | C.RETURN None _ ->
          E.return A.RETURN_VOID
      | C.RETURN (Some expr) _f ->
          A.RETURN_EXPRESSION <$> desugar_expression expr
      | C.SWITCH expr stmt _ ->
          Boot.assert_false "HIP: desugar_statement  SWITCH"
      | C.CASE expr stmt _ ->
          (* (§6.8.1#2) "A case label shall appear only in a switch statement." *)
          ifElse E.is_inside_switch begin
          (* TODO: for now we only support impl-independent constant
                   expressions *)
(*
           desugar_integer_constant_expression expr >>= function
             | 
                 A.CASE <$> 

E.fail Errors.CABS_TO_AIL_CASE_NOT_INTEGER_CONSTANT_EXRESSION

*)	    

	    Boot.assert_false "HIP: desugar_statement CASE"
	  end (E.fail Errors.DEFAULT_OUTSIDE_SWITCH)
      | C.DEFAULT stmt _ ->
          (* (§6.8.1#2) "A default label shall appear only in a switch statement." *)
	  ifElse E.is_inside_switch
            (A.DEFAULT <$> desugar_statement stmt)
	    (E.fail Errors.DEFAULT_OUTSIDE_SWITCH)
      | C.LABEL lab stmt _ ->
	  A.LABEL <$> fetch_label lab
	          <*> desugar_statement stmt
      | C.GOTO lab _ ->
          A.GOTO <$> fetch_label lab
      | C.DEFINITION (C.DECDEF ing _) -> (*TODO: location*)
      	  A.DECLARATION <$> desugar_declaration ing
      | C.PAR stmts _ ->
          A.PAR <$> E.mapM desugar_statement stmts
  end

and desugar_init_expression ie =
  match ie with
  | C.NO_INIT         -> E.return None
  | C.SINGLE_INIT   e -> Some <$> desugar_expression e
  | C.COMPOUND_INIT _ -> Boot.assert_false "COMPOUND_INIT"
  end

and desugar_init_name iname =
  let C.Init_name (C.Name name decl _ _) ie = iname in
  E.register_name name       >>= fun v       ->
  desugar_init_expression ie >>= fun e_opt   ->
  E.return (v, desugar_decl_type decl, e_opt)
    

and desugar_declaration (specs, ins) : E.t (list (Symbol.t * A.expression_t unit)) =
  Boot.assert_false "desugar_declaration"
(*
  (List.map (desugar_specifier specs) <$> E.mapM desugar_init_name ins) >>=
  filter_opt <$>
    E.mapM (fun (v, t, e_opt) ->
      E.add_declaration v t >>
      match e_opt with
      | Some e -> Some (v, e)
      | None   -> None
      end
    )
*)

and desugar_definition def =
  match def with
  | C.FUNDEF specs (C.Name fname decl [] _) stmt _ ->

(*
t
specs: list spec_elem

fname: string (* function name *)
decl:  decl_type
stmt:  statement

*)
      mk_ctype specs decl >>= fun f_ty ->
(*      let (ftype, scs) = mk_ctype specs decl in *)

      register_labels stmt >>
      desugar_statement stmt    >>= fun d_s ->


(*
        (* TODO: should be doing something with [attrs] *)
        let (ftype, scs) = mk_c_type specs decl in
        (C.FUNCTION_DEFINITION ((fname, ftype, scs), Location.dummy) (translate_statement s), Location.dummy)
*)
      Boot.assert_false "HIP: desugar_definition FUNDEF"

    (* TODO: I think this correspond to the def of a struct/union (typedef?) *)
  | C.DECDEF (specs, []) loc ->
      Boot.assert_false "HIP: desugar_definition DECDEF (case 1)"
(*
        (C.EXTERNAL_DECLARATION
          [(C.TYPE_DEF (fst $ mk_c_type specs C0.JUSTBASE), Location.dummy)], Location.dummy)
*)

  | C.DECDEF ing loc ->
      Boot.assert_false "HIP: desugar_definition DECDEF (case 2)"
  | C.PRAGMA at loc ->
      E.fail (Errors.CSEM_NOT_SUPPORTED "PRAGMA definitions")
end

(*
let desugar_global_definition st (defn, l) =
  match defn with
  | C.FUNCTION_DEFINITION decl s ->
      desugar_function_decl decl             >>= fun (id, formals) ->
      register_labels s >> desugar_stmt st s >>= fun d_s           ->
      E.destroy_scope                        >>= fun ()            ->
      E.add_fn id formals d_s

  | C.EXTERNAL_DECLARATION defns ->
      let f = function
        | (id, Some e, l) -> (id, e)
        | (id, None,   l) -> Boot.assert_false "[Cabs_to_ail.desugar_global_defn] EXTERNAL_DECLARATION: (id, (l, Ail_aux.const_int (Int.int 0)))"
      end in
      List.map f -| filter_opt <$> E.mapM desugar_defn defns >>= fun d_defns ->
      E.add_globals d_defns
   end
*)

val desugar_program : string -> list C.definition -> E.t (Symbol.t)
let desugar_program startup defs =
  E.mapM_ desugar_definition defs >>
  E.tryWith (Location.dummy, Errors.CABS_TO_AIL_NO_STARTUP startup) (E.resolve_identifier startup)  

(* desugar "main" defs *)
val desugar: string -> list C.definition -> Exception.t (A.file unit) Errors.t
let desugar startup defs =
  E.eval $ desugar_program startup defs
