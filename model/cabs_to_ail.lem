open import Pervasives Utils Cabs AilSyntax Std
import Utils

open import Cabs_to_ail_aux
import Cabs_to_ail_effect

import Debug Pp Cabs Multiset Decode UniqueId
import AilSyntaxAux AilTypes AilTypesAux Builtins

import Errors

import WipFrontend


open import {hol} `pp_ailTheory` `utilTheory`

module ATypes = AilTypes


module E = Cabs_to_ail_effect

let inline (>>=)    = E.bind
let inline (>>) m f = m >>= fun _ -> f (* NOTE: the inline is important *)
let inline (<$>)    = E.fmap
let inline (<*>)    = E.app



(* STD §6.9.2#2, sentence 1 *)
(* TODO replace the bool by this type? *)
type tentative_definition_bool =
  | IsTentativeDefinition
  | NotTentativeDefinition

type declaration_context =
  | Object_decl_context
  | Function_decl_context

instance (Eq declaration_context)
  let (=)  = unsafe_structural_equality
  let (<>) = unsafe_structural_inequality
end










(* KKK initialisation *)

type init_element =
  | Elem_array of integer
  | Elem_member of cabs_identifier
(*   | Elem_union of cabs_identifier *)

type init_path = list init_element


let init_elementEqual elem1 elem2 =
  match (elem1, elem2) with
    | (Elem_array n1, Elem_array n2) ->
        n1 = n2
    | (Elem_member ident1, Elem_member ident2) ->
        ident1 = ident2
    | _ ->
        false
  end

instance (Eq init_element)
  let (=) elem1 elem2 =
    init_elementEqual elem1 elem2
  let (<>) elem1 elem2 =
    not (init_elementEqual elem1 elem2)
end


let stringFromInit_element = function
  | Elem_array n ->
      "[" ^ show n ^ "]"
  | Elem_member ident ->
      "." ^ show ident
end

let stringFromInit_path xs =
  String.concat "" (List.map stringFromInit_element xs)









(* ====================================================================================================================== *)

(*
val     elemPathFromCtype_aux3: map identifier tag_definition -> (init_path * ATypes.ctype) -> ATypes.ctype -> list (init_path * (init_path * ATypes.ctype))
*)
let rec wip tagDefs acc path_prefix (outer_path, outer_ty) = function
  | ATypes.Void ->
      error "elemPathFromCtype_aux3, Void"
  | ATypes.Function _ _ _ _ ->
      error "elemPathFromCtype_aux3, Function"
  | ATypes.Basic _ ->
      (path_prefix, outer_path, outer_ty) :: acc
  | ATypes.Pointer _ _ ->
      (path_prefix, outer_path, outer_ty) :: acc
  | ATypes.Array _ Nothing ->
      error "elemPathFromCtype_aux3, Array Nothing"
  | ATypes.Array elem_ty (Just n) ->
      List.foldl (fun acc i ->
        wip tagDefs acc (Elem_array i :: path_prefix) (Elem_array i :: path_prefix, elem_ty) elem_ty
      ) (wip tagDefs acc (Elem_array 0 :: path_prefix) (outer_path, outer_ty) elem_ty)
        (Utils.mkListFromTo 1 (n-1))
  | ATypes.Atomic atom_ty ->
      wip tagDefs acc path_prefix (outer_path, outer_ty) atom_ty
  | ATypes.Struct tag_sym ->
      match Map.lookup tag_sym tagDefs with
        | Just (Struct_definition isAnonymous ((first_memb_ident, (_, first_memb_ty)) :: xs)) ->
            let () = if isAnonymous then
              Debug.print_debug 1 [] (fun () ->
                "elemPathFromCtype_aux3: this may be WRONG ==> anonymous Struct"
              )
            else () in
            List.foldl (fun acc (memb_ident, (_, memb_ty)) ->
              wip tagDefs acc
                (Elem_member memb_ident :: path_prefix)
                (Elem_member memb_ident :: path_prefix, memb_ty)
                memb_ty
            ) (wip tagDefs acc
                 (Elem_member first_memb_ident :: path_prefix)
                 (outer_path, outer_ty) 
                 first_memb_ty)
              xs
        | _ ->
            error "elemPathFromCtype_aux3, Struct"
      end
  | ATypes.Union tag_sym ->
      error "elemPathFromCtype_aux3, Union"
  | ATypes.Builtin _ ->
      (* TODO? *)
      error "elemPathFromCtype_aux3, Builtin"
end

val elemPathFromCtype3: bool -> map identifier tag_definition -> ATypes.ctype -> list (init_path * init_path * ATypes.ctype)
let elemPathFromCtype3 is_unknown_size tagDefs entity_ty =
  match entity_ty with
    | ATypes.Array _ Nothing ->
        error "TODO: elemPathFromCtype3, array with unknown size"
    | _ ->
        let (outer_path, outer_ty) = match entity_ty with
          | ATypes.Array elem_ty _ ->
              ([Elem_array 0], if is_unknown_size then entity_ty else elem_ty)
          | ATypes.Struct tag_sym ->
              match Map.lookup tag_sym tagDefs with
                | Just (Struct_definition isAnonymous ((first_memb_ident, (_, first_memb_ty)) :: _)) ->
                    let () = if isAnonymous then
                      Debug.print_debug 1 [] (fun () ->
                        "elemPathFromCtype3_aux: this may be WRONG ==> anonymous Struct"
                      )
                    else () in
                    ([Elem_member first_memb_ident], if is_unknown_size then entity_ty else first_memb_ty)
                | _ ->
                    error "elemPathFromCtype3, Struct"
              end
          | ATypes.Union tag_sym ->
              error "elemPathFromCtype3, Union"
          | _ ->
              ([], entity_ty)
        end in
        let xs =
          wip tagDefs
            []              (* acc *)
            []              (* current path prefix *)
            (outer_path, outer_ty) (* current outer path and it's type *)
            entity_ty in
        List.map (fun (path, outer_path, ty) ->
          (List.reverse path, List.reverse outer_path, ty)
        ) (List.reverse xs)
  end

type path_elem =
  init_path * init_path * ATypes.ctype




let rec skipTo_aux acc path = function
  | [] ->
      Nothing
  | ((path', _, _) as x) :: xs ->
      let () = Debug.print_debug 1 [] (fun () ->
        "path: " ^ stringFromInit_path path ^ " <--> " ^
        "path': " ^ stringFromInit_path path' ^ " === " ^
        (if List.isPrefixOf path path' then "true" else "false")
      ) in
      if List.isPrefixOf path path' then
        Just (x :: xs, List.reverse acc)
      else
        skipTo_aux (x :: acc) path xs
end
let skipTo path elems =
  skipTo_aux [] path elems


(*

skipTo cursor_path elems

take1 elem

splitAt

update inner elements

*)

type withElemsM 'a = State.stateM 'a (list path_elem)

val skipToPath: init_path -> withElemsM (list path_elem)
let skipToPath path =
  State.bind State.get (fun elems ->
  match skipTo path elems with
    | Nothing ->
        error "WIP: skipToPath"
    | Just (elems', skipped) ->
        State.bind (State.put elems') begin fun () ->
        State.return skipped
        end
  end)


val getElem: withElemsM (maybe path_elem)
let getElem =
  State.bind State.get function
    |  [] ->
        State.return Nothing
    | x::xs ->
        State.bind (State.put xs) (fun () -> State.return (Just x))
  end


val getElems: integer -> withElemsM (list path_elem)
let getElems n =
  State.bind State.get begin fun elems ->
    let (xs,ys) = List.splitAt (natFromInteger n) elems in
    State.bind (State.put ys) (fun () -> State.return xs)
  end






(*
type elemPathMaker = <|
  skipTo: init_path -> maybe ((list path_elem * list path_elem) * elemPathMaker);
  getElem: unit -> (path_elem * elemPathMaker);
  getElems: integer -> (list path_elem * elemPathMaker);
|>

val mk_elemsPathFromCtype: map identifier tag_definition -> ATypes.ctype -> elemPathMaker
let mk_elemsPathFromCtype tagDefs ty =
  let elems = elemPathFromCtype3 tagDefs ty in
  <|
    skipTo=
      fun path -> match skipTo path elems with
        | Nothing -> Nothing
        | Just 
      end
 |>
*)




let rec cardinalityOfCtype tagDefs = function
  | ATypes.Array _ Nothing ->
      error "cardinalityOfCtype: Array Nothing"
  | ATypes.Array elem_ty (Just n) ->
      n * cardinalityOfCtype tagDefs elem_ty
  | ATypes.Struct tag_sym ->
      match Map.lookup tag_sym tagDefs with
        | Just (Struct_definition isAnonymous xs) ->
            let () = if isAnonymous then
              Debug.print_debug 1 [] (fun () ->
                "cardinalityOfCtype: this may be WRONG ==> anonymous Struct"
              )
            else () in
            List.foldl (fun acc (_, (_, memb_ty)) ->
              cardinalityOfCtype tagDefs memb_ty + acc
            ) 0 xs
        |  _ ->
            error "cardinalityOfCtype: Struct"
      end
  | ATypes.Atomic atom_ty ->
      cardinalityOfCtype tagDefs atom_ty
  | _ ->
      1
end















val     ctypeAtPath: map identifier tag_definition -> ATypes.ctype -> init_path -> ATypes.ctype
let rec ctypeAtPath tagDefs ty path =
  match (ty, path) with
    | (_, []) ->
        ty
    | (ATypes.Array elem_ty (Just n1), Elem_array n2 :: path') ->
        if n1 <= n2 then
          error "ctypeAtPath: array type smaller than path needed"
        else
          ctypeAtPath tagDefs elem_ty path'
    | (ATypes.Struct tag_sym, Elem_member memb_ident :: path') ->
        match Map.lookup tag_sym tagDefs with
          | Just (Struct_definition _ xs) ->
              match List.lookup memb_ident xs with
                | Nothing ->
                    error "ctypeAtPath: Struct, invalid member"
                | Just (_, memb_ty) ->
                    ctypeAtPath tagDefs memb_ty path'
              end
          | _ ->
              error "ctypeAtPath: Struct"
        end
    (* TODO: union *)
    | _ ->
        error ("ctypeAtPath: wildcard ==> " ^
               Pp.stringFromAil_ctype ATypes.no_qualifiers ty ^
               " --- path: " ^ stringFromInit_path path)
  end


let rec innerCtype tagDefs ty =
  match ty with
    | ATypes.Void ->
        error "innerCtype: Void"
    | ATypes.Basic _ ->
        ty
    | ATypes.Array elem_ty _ ->
        innerCtype tagDefs elem_ty
    | ATypes.Function _ _ _ _ ->
        error "innerCtype: Function"
    | ATypes.Pointer _ _ ->
        ty
    | ATypes.Atomic atom_ty ->
        (* TODO: check *)
        innerCtype tagDefs atom_ty
    | ATypes.Struct tag_sym ->
        match Map.lookup tag_sym tagDefs with
          | Just (Struct_definition _ ((_, (_, memb_ty)) :: xs)) ->
              innerCtype tagDefs memb_ty
          | _ ->
              error "innerCtype: Struct"
        end
    | ATypes.Union tag_sym ->
        (* TODO: this may be wrong when called in a Desig context ... *)
        match Map.lookup tag_sym tagDefs with
          | Just (Union_definition _ ((_, (_, memb_ty)) :: xs)) ->
              innerCtype tagDefs memb_ty
          | _ ->
              error "innerCtype: Union"
        end
    | ATypes.Builtin _ ->
        ty
  end




val     outerValidPath: map identifier tag_definition -> ATypes.ctype -> list (init_element) -> init_path
let rec outerValidPath_aux tagDefs ty path acc =
  match (ty, path) with
    | (_, []) ->
        List.reverse acc
    | (ATypes.Array elem_ty _, Elem_array n :: path') ->
        if n = 0 then
          


          match path' with
            | [] ->
                List.reverse (Elem_array n :: acc)
            | _ ->
                outerValidPath_aux tagDefs elem_ty path' (Elem_array n :: acc)
          end
        else (* n > 0 *)
          List.reverse acc
    | (ATypes.Struct tag_sym, Elem_member memb_ident :: path') ->
        match Map.lookup tag_sym tagDefs with
          | Just (Struct_definition _ ((first_memb_ident, (_, memb_ty)) :: _)) ->
              if first_memb_ident = memb_ident then
                match path' with
                  | [] ->
                      List.reverse (Elem_member memb_ident :: acc)
                  | _ ->
                      outerValidPath_aux tagDefs memb_ty path' (Elem_member memb_ident :: acc)
                end
              else
                List.reverse acc
          | _ ->
              error "outerValidPath: Struct"
        end
    (* TODO: union *)
    | _ ->
        error "outerValidPath: wildcard"
  end

let outerValidPath tagDefs ty path =
  outerValidPath_aux tagDefs ty path []


(*
type init_element =
  | Elem_array of integer
  | Elem_member of cabs_identifier

type init_path = list init_element * ATypes.ctype
*)

(*
E.desugM (list (init_path * expression unit) * list (init_path * init_path * ATypes.ctype)) =
*)

val constructValue: map identifier tag_definition -> list (init_path * expression unit) -> ATypes.ctype -> expression unit
let rec constructValue_aux tagDefs path elems = function
  | ATypes.Array elem_ty Nothing ->
      let () = Debug.print_debug 0 [] (fun () ->
        "==> " ^ stringFromList (stringFromPair stringFromInit_path Pp.stringFromAil_expression) elems
      ) in
      error "constructValue_aux: Array Nothing"
  | ATypes.Array elem_ty (Just n) ->
      let es =
        List.map (fun i ->
          Just (constructValue_aux tagDefs (path ++ [Elem_array i]) elems elem_ty)
        ) (Utils.mkListN n) in
      AnnotatedExpression () [] Loc.unknown begin
        AilEarray false(*TODO*) elem_ty es
      end
  | ATypes.Struct tag_sym ->
      match Map.lookup tag_sym tagDefs with
        | Just (Struct_definition isAnonymous xs) ->
            let () = if isAnonymous then
              Debug.print_debug 1 [] (fun () ->
                "cardinalityOfCtype: this may be WRONG ==> anonymous Struct"
              )
            else () in
            let membrs = List.map (fun (memb_ident, (_, memb_ty)) ->
              (memb_ident, Just (constructValue_aux tagDefs (path ++ [Elem_member memb_ident]) elems memb_ty))
            ) xs in
            AnnotatedExpression () [] Loc.unknown begin
              AilEstruct tag_sym membrs
            end
        | _ ->
            error "constructValue_aux, Struct"
      end
  | ATypes.Union tag_sym ->
      error "TODO: Struct"
  | ATypes.Atomic atom_ty ->
      error "TODO: Atomic"
  | ty ->
      match List.lookup path elems with
        | Nothing ->
            mk_zeroInit tagDefs ty
        | Just e ->
            e
      end
end
let constructValue tagDefs elems ty =
  constructValue_aux tagDefs [] elems ty





























(* BEGIN predicates on Ail syntax *)
(* see §6.6#6 *)
(* TODO: make the function pure, when complete *)
val     is_integer_constant_expression: expression unit -> E.desugM bool
let rec is_integer_constant_expression (AnnotatedExpression () _ loc expr_ as expr) =
  STD_ "§6.6#6" match expr_ with
    | AilEunary uop e ->
        match uop with
          | Plus ->
              is_integer_constant_expression e
          | Minus ->
              is_integer_constant_expression e
          | Bnot ->
              is_integer_constant_expression e
          | Address ->
              E.return false
          | Indirection ->
              E.return false
          | PostfixIncr ->
              E.return false
          | PostfixDecr ->
              E.return false
        end
    | AilEcast _ _ _ ->
        E.fail loc (Errors.Desugar_NotyetSupported "cast operator in `integer constant expressions'")
    | AilEassert _ ->
        E.return false
    | AilEoffsetof _ _ ->
        E.fail loc (Errors.Desugar_NotyetSupported "offsetof() in `integer constant expressions'")
(*
    | AilEgeneric of expression 'a * list (generic_association 'a)
    | AilEarray of bool * ctype * list (maybe (expression 'a))
    | AilEstruct of identifier * list (Cabs.cabs_identifier * maybe (expression 'a)) (* tag, pairs of member id, expression *)
    | AilEunion of identifier * Cabs.cabs_identifier * maybe (expression 'a)
    | AilEcompound of ctype * expression 'a
    | AilEmemberof of expression 'a * Cabs.cabs_identifier
    | AilEmemberofptr of expression 'a * Cabs.cabs_identifier
    | AilEbuiltin of string (* TODO: see if that can be moved to [constant] *)
    | AilEstr of stringLiteral
    | AilEconst of constant
    | AilEident of identifier
*)
    | AilEannot _ e ->
        is_integer_constant_expression e

    | AilEva_start _ _ ->
        E.return false
    | AilEva_arg _ _ ->
        E.return false
    | AilEprint_type e ->
        is_integer_constant_expression e
    | AilErvalue _ ->
        (* NOTE: this only exists after the Ail typing *)
        E.fail loc Errors.Desugar_impossible
    | AilEarray_decay _ ->
        (* NOTE: this only exists after the Ail typing *)
        E.fail Loc.unknown Errors.Desugar_impossible
    | AilEfunction_decay _ ->
        (* NOTE: this only exists after the Ail typing *)
        E.fail Loc.unknown Errors.Desugar_impossible



    | AilEconst (ConstantInteger _) ->
        (* NOTE: this includes enumeration constants *)
        E.return true
    | AilEconst (ConstantCharacter _) ->
        E.return true
    | AilEsizeof _ ty ->
        if AilTypesAux.is_vla ty then
          (* STD §6.5.3.4#2, sentence 4 *)
          E.return false
        else
          E.return true
    | AilEsizeof_expr _ ->
        (* TODO: this is wrong if the expression is a VLA *)
        (* but I can't easily ask the Ail typing for now ... *)
(*
        if AilTypesAux.is_vla ty then
          (* STD §6.5.3.4#2, sentence 4 *)
          E.return false
        else
*)
          E.return true
    | AilEalignof _ _ ->
        E.return true


(*

floating constants that are the immediate operands of casts.

Cast operators in an integer constant expression shall only convert arithmetic types to integer types, except as part of an operand to the sizeof or _Alignof operator.
*)


(*
Constant expressions shall not


increment

decrement

function-call

or comma operators

except when they are contained within a subexpression that is not evaluated.115)
*)

    | AilEassign _ _ ->
        (* STD §6.6#3 *)
        E.return false
    | AilEcompoundAssign _ _ _ ->
        (* STD §6.6#3 *)
        E.return false

    | AilEcall _ _ ->
        (* STD §6.6#3 *)
        E.return false
    | AilEbinary _ Comma _ ->
        (* STD §6.6#3 *)
        E.return false
    | AilEbinary e1 _ e2 ->
        is_integer_constant_expression e1 >>= fun b1 ->
        if b1 then
          is_integer_constant_expression e2
        else
          E.return false
    
    
    | AilEcond _ _ _ ->
        (* TODO: location *)
        E.fail loc (Errors.Desugar_NotyetSupported "conditional operator in `integer constant expressions'")
    
    
    | AilEmemberof _ _ ->
        E.return false
    | AilEmemberofptr _ _ ->
        E.return false
    
    
    | AilEident _ ->
        E.return false
    

    
    | _ ->
        error ("TODO: Cabs_to_ail.is_integer_constant_expression, wildcard ==> " ^
               Pp.stringFromAil_expression expr)
end




























(* STD §6.6#8 *)
(* TODO: this is super partial and hackish *)
(* TODO: I assume from the "shall only have operands" that arithmetic operations are allowed *)
val     is_arithmetic_constant_expression: bool -> expression unit -> E.desugM bool
let rec is_arithmetic_constant_expression is_lvalue ((AnnotatedExpression () _ loc expr) as a_expr) =
  match expr with
    | AilEconst (ConstantInteger _) ->
        E.return true
    | AilEconst (ConstantFloating _) ->
        E.return true
    | AilEconst (ConstantCharacter _) ->
        E.return true
(*
    | AilEconst (ConstantArray _) ->
        (* NOTE: is Ail specific *)
        E.return true
*)

    | AilEident _ ->
        E.return is_lvalue

    (* TODO: not sure about this! but I want to include enumerations *)
    | AilEannot _ e ->
        is_arithmetic_constant_expression true e

    | AilEunary Address e ->
        is_arithmetic_constant_expression true e
    | AilEunary _ e ->
        is_arithmetic_constant_expression is_lvalue e

    | AilEbinary e1 _ e2 ->
        is_arithmetic_constant_expression is_lvalue e1 >>= fun b1 ->
        is_arithmetic_constant_expression is_lvalue e2 >>= fun b2 ->
        E.return (b1 && b2)

    | AilEsizeof _ ty ->
        (* TODO: sizeof expressions whose results are integer constants *)
        E.return (not (AilTypesAux.is_vla ty))
    | AilEalignof _ _ ->
        E.return true
    | AilEcast _ ty e ->
        if not (AilTypesAux.is_arithmetic ty) then
          E.return false
        else
          E.print_debugM 1 (fun () -> "WARNING[Cabs_to_ail.is_arithmetic_constant_expression] AilEcast: annoying ==> need to typecheck e...") >>
(*          E.return true *)
          (* TODO: is_lvalue might be wrong depending on the type of e? *)
          is_arithmetic_constant_expression is_lvalue e
        
    | _ ->
        E.return false

  end


val     is_lvalue_to_static_object: expression unit -> E.desugM bool
let rec is_lvalue_to_static_object (AnnotatedExpression () _ loc expr) =
  match expr with
    | AilEident sym ->
        E.fetch_object_declaration sym >>= fun (_, dur, _, _, _) ->
        match dur with
          | ATypes.Static ->
              E.return true
          | _ ->
              E.return false
        end
(* The array-subscript [] and member-access . and -> operators, the address & and indirection * unary operators, and pointer casts may be used in the creation of an address constant, but the value of an object shall not be accessed by use of these operators. *)
    | AilEbinary e1 (Arithmetic Add) e2 ->
        (* NOTE: this case corresponds to array-subcript *)
        is_lvalue_to_static_object e1        >>= fun b11 ->
        is_arithmetic_constant_expression false (* TODO check *) e1 >>= fun b12 ->
        is_lvalue_to_static_object e2        >>= fun b21 ->
        is_arithmetic_constant_expression false (* TODO check *) e2 >>= fun b22 ->
        E.return (b11 && b22 || b12 && b21)
    | AilEmemberofptr e memb_ident ->
        (* TODO: not sure *)
        is_lvalue_to_static_object e
    | AilEcast _ ty e ->
        (* TODO: check *)
        if not (AilTypesAux.is_pointer ty) then
          E.return false
        else
          is_lvalue_to_static_object e

(* TODO
    | AilEmemberof e ident ->
*)
    | _ ->
        E.return false
  end



(* STD §6.6#9 *)
val is_address_constant: expression unit -> E.desugM bool
let is_address_constant a_expr =
  (* TODO: not sure is_null_pointer_constant is the right predicate *)
  (* An address constant (...) *)
  if AilSyntaxAux.is_null_pointer_constant a_expr then
    (* (...) is a null pointer, *)
    E.return true
  
  else match a_expr with
    | AnnotatedExpression () _ _ (AilEunary Address expr) ->
        is_lvalue_to_static_object expr
    | AnnotatedExpression () _ _ (AilEcast _ Pointer expr) ->
        is_lvalue_to_static_object expr >>= function
          | true ->
              E.return true
          | false ->
              is_integer_constant_expression expr
        end
    | _ ->
        E.return false
  end




(* As defined in STD §6.6#7, in the context of initializers, "constant expressions" 
   can have more things in them *)
(* TODO: "or evaluate to" *)
val is_initializer_constant_expression: expression unit -> E.desugM bool
let is_initializer_constant_expression (AnnotatedExpression () _ loc expr as a_expr) =
  is_arithmetic_constant_expression false (* TODO check *) a_expr >>= fun b1 ->
  is_address_constant a_expr               >>= fun b2 ->
  (* STD §6.6#7, bullets 1 - 3 *)
  if b1 || AilSyntaxAux.is_null_pointer_constant a_expr || b2 then
    E.return true
  
  (* STD §6.6#7, bullets 4 *)
  else match expr with
    | AilEbinary e1 (Arithmetic Add) e2 ->
        is_address_constant e1            >>= fun b11 ->
        is_integer_constant_expression e2 >>= fun b12 ->
        is_address_constant e2            >>= fun b21 ->
        is_integer_constant_expression e1 >>= fun b22 ->
        E.return (b11 && b12 || b21 && b22)
    | AilEbinary e1 (Arithmetic Sub) e2 ->
        is_address_constant e1            >>= fun b11 ->
        is_integer_constant_expression e2 >>= fun b12 ->
        is_address_constant e2            >>= fun b21 ->
        is_integer_constant_expression e1 >>= fun b22 ->
        E.return (b11 && b12 || b21 && b22)
    | AilEstr _ ->
        E.return true
    | _ ->
        E.return false
  end
(* END predicates on Ail syntax *)




















type fundef =
  | IsFunDef
  | NotFunDef


type qs_ctype_builder =
  ATypes.qualifiers -> ATypes.ctype -> (ATypes.qualifiers * ATypes.ctype)


val desugar_struct_declaration:
  struct_declaration -> E.desugM (list (cabs_identifier * (ATypes.qualifiers * ATypes.ctype)))

val desugar_struct_declarator:
  struct_declarator -> E.desugM (cabs_identifier * qs_ctype_builder)

val desugar_init_declarator_BROKEN:
  ATypes.qualifiers -> ATypes.ctype -> list storage_class_specifier -> init_declarator ->
  E.desugM (cabs_identifier * bool * (ATypes.qualifiers * ATypes.ctype) *
            (unit -> E.desugM (maybe (ATypes.ctype * expression unit))))

val desugar_init_declarator:
  bool(* isAtomic *) -> ATypes.qualifiers -> ATypes.ctype ->
  list storage_class_specifier -> init_declarator ->
  E.desugM (maybe (Loc.t * linkage * identifier * bool * (ATypes.qualifiers * ATypes.ctype) *
            (unit -> E.desugM (maybe (ATypes.ctype * expression unit)))))

val desugar_generic_association:
  cabs_generic_association -> E.desugM (generic_association unit)

val check_storage_class_specifiers:
  declaration_context -> list storage_class_specifier -> E.desugM unit

val desugar_enumerator:
  enumerator -> E.desugM (cabs_identifier * maybe (Loc.t * integer))

val desugar_alignment_specifier:
  alignment_specifier -> E.desugM unit

val desugar_parameter_type_list:
  fundef -> parameter_type_list -> E.desugM (list (maybe cabs_identifier * (ATypes.qualifiers * ATypes.ctype * bool)) * bool)

val desugar_type_name:
  type_name -> E.desugM (ATypes.qualifiers * AilTypes.ctype)

val desugar_initializer_:
  initializer_ -> E.desugM (expression unit)

val desugar_designator:
  designator -> E.desugM unit

val desugar_and_register_static_assert_declaration:
  static_assert_declaration -> E.desugM unit

val desugar_for_clause:
  for_clause -> E.desugM unit

(* TODO: WIP *)
val wip_desugar_initializer_:
  Loc.t -> ATypes.storageDuration -> ATypes.ctype -> initializer_ -> E.desugM (ATypes.ctype * expression unit)

val static_thread_implicit_initializer:
  map identifier tag_definition -> ATypes.ctype -> constant



































val translate_integer_suffix: cabs_integer_suffix -> integerSuffix
let translate_integer_suffix = function
  | CabsSuffix_U   -> U
  | CabsSuffix_UL  -> UL
  | CabsSuffix_ULL -> ULL
  | CabsSuffix_L   -> L
  | CabsSuffix_LL  -> LL
end

val translate_integer_constant: cabs_integer_constant -> integerConstant
let translate_integer_constant (str, suff_opt) =
  let (basis, n) = Decode.decode_integer_constant str in
  match suff_opt with
    | Just suff -> IConstant n basis (Just (translate_integer_suffix suff))
    | Nothing   -> IConstant n basis Nothing
  end

val translate_floating_suffix: cabs_floating_suffix -> floatingSuffix
let translate_floating_suffix = function
  | CabsFloatingSuffix_F -> Fsuf_F
  | CabsFloatingSuffix_L -> Fsuf_L
end

val translate_floating_constant: cabs_floating_constant -> floatingConstant
let translate_floating_constant (str, suff_opt) =
  (str, maybe Nothing (Just -| translate_floating_suffix) suff_opt)


val translate_character_constant: cabs_character_prefix -> characterPrefix
let translate_character_constant = function
  | CabsPrefix_L -> Pref_L
  | CabsPrefix_u -> Pref_u
  | CabsPrefix_U -> Pref_U
end


val desugar_character_constant: cabs_character_constant -> E.desugM characterConstant
let desugar_character_constant (pref_opt, str) =
  E.return (maybe Nothing (Just -| translate_character_constant) pref_opt, str)










val     evaluate_integer_constant_expression: Loc.t -> maybe ATypes.ctype -> expression unit -> E.desugM integer
let rec evaluate_integer_constant_expression loc ty_opt expr =
  E.get_core_eval_stuff >>= fun  (core_env, sym_suppl) ->
  E.get_sigma_sofar >>= fun sigm ->
  E.liftException
      (WipFrontend.evalIntegerConstantExpression loc "TODO:std location" core_env sigm sym_suppl ty_opt expr)




















val translate_unary_operator: cabs_unary_operator -> unaryOperator
let translate_unary_operator = function
  | CabsAddress     -> Address
  | CabsIndirection -> Indirection
  | CabsPlus        -> Plus
  | CabsMinus       -> Minus
  | CabsBnot        -> Bnot
  (* This case cannot occurs since Not is translated away. *)
  | CabsNot         -> error "[Cabs_to_ail.translate_unary_operator] Not"
end


val translate_arithmetic_operator: cabs_binary_operator -> arithmeticOperator
let translate_arithmetic_operator = function
  | CabsAdd  -> Add
  | CabsSub  -> Sub
  | CabsMul  -> Mul
  | CabsDiv  -> Div
  | CabsMod  -> Mod
  | CabsBand -> Band
  | CabsBxor -> Bxor
  | CabsBor  -> Bor
  | CabsShl  -> Shl
  | CabsShr  -> Shr
  | _ -> error "[Cabs0_to_ail.translate_arithmetic_operator] should only be called on \
                operators allowed for compound assignments [§6.5.16#1]."
end


val translate_binary_operator: cabs_binary_operator -> binaryOperator
let translate_binary_operator = function
  | CabsAnd   -> And
  | CabsOr    -> Or
  | CabsEq    -> Eq
  | CabsNe    -> Ne
  | CabsLt    -> Lt
  | CabsGt    -> Gt
  | CabsLe    -> Le
  | CabsGe    -> Ge
  | op      -> Arithmetic (translate_arithmetic_operator op)
end


val translate_assignment_operator: cabs_assignment_operator -> maybe arithmeticOperator
let translate_assignment_operator = function
  | Assign      -> Nothing
  | Assign_Mul  -> Just Mul
  | Assign_Div  -> Just Div
  | Assign_Mod  -> Just Mod
  | Assign_Add  -> Just Add
  | Assign_Sub  -> Just Sub
  | Assign_Shl  -> Just Shl
  | Assign_Shr  -> Just Shr
  | Assign_Band -> Just Band
  | Assign_Bxor -> Just Bxor
  | Assign_Bor  -> Just Bor
end






val desugar_cabs_constant: Loc.t -> cabs_constant -> E.desugM constant
let desugar_cabs_constant loc = function
  | CabsInteger_const iCst ->
      E.return (ConstantInteger (translate_integer_constant iCst))
  | CabsFloating_const fCst ->
      E.return (ConstantFloating (translate_floating_constant fCst))
  | CabsCharacter_const cCst ->
      desugar_character_constant cCst >>= fun d_cCst ->
      E.return (ConstantCharacter d_cCst)
end


val translate_cabs_encoding_prefix: cabs_encoding_prefix -> encodingPrefix
let translate_cabs_encoding_prefix = function
  | CabsEncPrefix_u8 ->
      Enc_u8
  | CabsEncPrefix_u ->
      Enc_u
  | CabsEncPrefix_U ->
      Enc_U
  | CabsEncPrefix_L ->
      Enc_L
end


val translate_cabs_string_literal: cabs_string_literal -> stringLiteral
let translate_cabs_string_literal (pref_opt, str) =
   (maybe Nothing (Just -| translate_cabs_encoding_prefix) pref_opt, str)


val project_base_type_specifier: cabs_type_specifier -> maybe cabs_base_type_specifier
let project_base_type_specifier = function
  | TSpec_void ->
      Just BTSpec_void
  | TSpec_char ->
      Just BTSpec_char
  | TSpec_short ->
      Just BTSpec_short
  | TSpec_int ->
      Just BTSpec_int
  | TSpec_long ->
      Just BTSpec_long
  | TSpec_float ->
      Just BTSpec_float
  | TSpec_double ->
      Just BTSpec_double
  | TSpec_signed ->
      Just BTSpec_signed
  | TSpec_unsigned ->
      Just BTSpec_unsigned
  | TSpec_Bool ->
      Just BTSpec_Bool
  | TSpec_Complex ->
      Just BTSpec_Complex
  | _ ->
      Nothing
 end


val     project_base_type_specifiers: list cabs_type_specifier -> maybe (list cabs_base_type_specifier)
let rec project_base_type_specifiers_aux acc = function
  | [] ->
      Just (List.reverse acc)
  | spec :: specs' ->
      match project_base_type_specifier spec with
        | Just z ->
            project_base_type_specifiers_aux (z::acc) specs'
        | Nothing ->
            Nothing
      end
  end


let project_base_type_specifiers =
  project_base_type_specifiers_aux []






(* TODO: this is temporary *)
val     is_fully_non_designated: list (maybe (list designator) * initializer_) -> bool
let rec is_fully_non_designated xs =
  List.all function
    | (Nothing, Init_expr _) ->
        true
    | (Nothing, Init_list xs') ->
        is_fully_non_designated xs'
    | _ ->
        false
  end xs

(*
List.all (function
                            | (Nothing, Init_expr _)  -> true
                            | (Nothing, Init_list xs) -> List.all 
                            | _                       -> false
                          end)
*)





val desugar_basic_type_specifiers: Multiset.t cabs_base_type_specifier -> E.desugM (maybe ATypes.basicType)
let desugar_basic_type_specifiers specs =
STD_ "§6.7.2#2, sentence 2 (non `void' case)" $
  if specs = Multiset.from_list [BTSpec_float; BTSpec_Complex] then
    (* STD §6.7.2#2, item 17 *)
    E.fail Loc.unknown (Errors.Desugar_NeverSupported "_Complex types")
  else if specs = Multiset.from_list [BTSpec_double; BTSpec_Complex] then
    (* STD §6.7.2#2, item 18 *)
    E.fail Loc.unknown (Errors.Desugar_NeverSupported "_Complex types")
  else if specs = Multiset.from_list [BTSpec_long; BTSpec_double; BTSpec_Complex] then
    (* STD §6.7.2#2, item 19 *)
    E.fail Loc.unknown (Errors.Desugar_NeverSupported "_Complex types")
  
  else
    E.return $
      if specs = Multiset.from_list [BTSpec_char] then
        (* STD §6.7.2#2, item 2 *)
        Just (ATypes.Integer ATypes.Char)
      else if specs = Multiset.from_list [BTSpec_signed; BTSpec_char] then
        (* STD §6.7.2#2, item 3 *)
        Just (ATypes.Integer (ATypes.Signed ATypes.Ichar))
      else if specs = Multiset.from_list [BTSpec_unsigned; BTSpec_char] then
        (* STD §6.7.2#2, item 4 *)
        Just (ATypes.Integer (ATypes.Unsigned ATypes.Ichar))
      else if List.any (fun z -> specs = z) [
                Multiset.from_list [BTSpec_short];
                Multiset.from_list [BTSpec_signed; BTSpec_short];
                Multiset.from_list [BTSpec_short; BTSpec_int];
                Multiset.from_list [BTSpec_signed; BTSpec_short; BTSpec_int] ] then
        (* STD §6.7.2#2, item 5 *)
        Just (ATypes.Integer (ATypes.Signed ATypes.Short))
      else if List.any (fun z -> specs = z) [
                Multiset.from_list [BTSpec_unsigned; BTSpec_short];
                Multiset.from_list [BTSpec_unsigned; BTSpec_short; BTSpec_int] ] then
        (* STD §6.7.2#2, item 6 *)
        Just (ATypes.Integer (ATypes.Unsigned ATypes.Short))
      else if List.any (fun z -> specs = z) [
                Multiset.from_list [BTSpec_int];
                Multiset.from_list [BTSpec_signed];
                Multiset.from_list [BTSpec_signed; BTSpec_int] ] then
        (* STD §6.7.2#2, item 7 *)
        Just (ATypes.Integer (ATypes.Signed ATypes.Int_))
      else if List.any (fun z -> specs = z) [
                Multiset.from_list [BTSpec_unsigned];
                Multiset.from_list [BTSpec_unsigned; BTSpec_int] ] then
        (* STD §6.7.2#2, item 8 *)
        Just (ATypes.Integer (ATypes.Unsigned ATypes.Int_))
      else if List.any (fun z -> specs = z) [
                Multiset.from_list [BTSpec_long];
                Multiset.from_list [BTSpec_signed; BTSpec_long];
                Multiset.from_list [BTSpec_long; BTSpec_int];
                Multiset.from_list [BTSpec_signed; BTSpec_long; BTSpec_int] ]then
        (* STD §6.7.2#2, item 9 *)
        Just (ATypes.Integer (ATypes.Signed ATypes.Long))
      else if List.any (fun z -> specs = z) [
                Multiset.from_list [BTSpec_unsigned; BTSpec_long];
                Multiset.from_list [BTSpec_unsigned; BTSpec_long; BTSpec_int] ] then
        (* STD §6.7.2#2, item 10 *)
        Just (ATypes.Integer (ATypes.Unsigned ATypes.Long))
      else if List.any (fun z -> specs = z) [
                Multiset.from_list [BTSpec_long; BTSpec_long];
                Multiset.from_list [BTSpec_signed; BTSpec_long; BTSpec_long];
                Multiset.from_list [BTSpec_long; BTSpec_long; BTSpec_int];
                Multiset.from_list [BTSpec_signed; BTSpec_long; BTSpec_long; BTSpec_int] ] then
        (* STD §6.7.2#2, item 11 *)
        Just (ATypes.Integer (ATypes.Signed ATypes.LongLong))
      else if List.any (fun z -> specs = z) [
                Multiset.from_list [BTSpec_unsigned; BTSpec_long; BTSpec_long];
                Multiset.from_list [BTSpec_unsigned; BTSpec_long; BTSpec_long; BTSpec_int] ] then
        (* STD §6.7.2#2, item 12 *)
        Just (ATypes.Integer (ATypes.Unsigned ATypes.LongLong))
      else if specs = Multiset.from_list [BTSpec_float] then
        (* STD §6.7.2#2, item 13 *)
        Just (ATypes.Floating (ATypes.RealFloating ATypes.Float))
      else if specs = Multiset.from_list [BTSpec_double] then
        (* STD §6.7.2#2, item 14 *)
        Just (ATypes.Floating (ATypes.RealFloating ATypes.Double))
      else if specs = Multiset.from_list [BTSpec_long; BTSpec_double] then
        (* STD §6.7.2#2, item 15 *)
        Just (ATypes.Floating (ATypes.RealFloating ATypes.LongDouble))
      else if specs = Multiset.from_list [BTSpec_Bool] then
        (* STD §6.7.2#2, item 16 *)
        Just (ATypes.Integer (ATypes.Bool))
      else
        Nothing


val translate_type_qualifiers: list cabs_type_qualifier -> bool * ATypes.qualifiers
let translate_type_qualifiers qs =
STD_ "§6.7.3#5" $ (* TODO: except for "or via one or more typedefs" *)
  ( List.elem Q_Atomic qs
  , ATypes.make_qualifiers
      (List.elem Q_const qs) (List.elem Q_restrict qs)
      (List.elem Q_volatile qs)  )














type under_array =
  | IsUnderArray
  | NotUnderArray



val desugar_array_declarator:
  under_array -> array_declarator -> E.desugM (ATypes.qualifiers -> ATypes.ctype -> (ATypes.qualifiers * ATypes.ctype))
val desugar_pointer_declarator:
  pointer_declarator -> E.desugM (ATypes.qualifiers -> ATypes.ctype -> (ATypes.qualifiers * ATypes.ctype))
val desugar_abstract_declarator:
  under_array -> abstract_declarator -> E.desugM (ATypes.qualifiers -> ATypes.ctype -> (ATypes.qualifiers * ATypes.ctype))
val desugar_direct_abstract_declarator:
  under_array -> direct_abstract_declarator -> E.desugM (ATypes.qualifiers -> ATypes.ctype -> (ATypes.qualifiers * ATypes.ctype))










val arrayFromStringLiteral: maybe int -> stringLiteral -> expression unit
let arrayFromStringLiteral size_opt (pref_opt, strs) =
  let ns = List.map Decode.decode_character_constant strs in
  error "TODO"




















(* STD §6.7.2.1#3, except for the flexible array part *)
let check_members membrDefs =
  E.mapM_ (fun (ident, (_, ty)) ->
    E.is_incomplete ty >>= function
      | true ->
          E.fail (Loc.locOf ident)
            (Errors.Desugar_ConstraintViolation "§6.7.2.1#3, incomplete")
      | false ->
          if AilTypesAux.is_function ty then
            E.fail (Loc.locOf ident)
              (Errors.Desugar_ConstraintViolation "§6.7.2.1#3, function")
          else
            E.return ()
    end
  ) membrDefs

type struct_or_union =
  | STRUCT
  | UNION




val     desugar_type_specifiers: list cabs_type_specifier -> E.desugM (ATypes.qualifiers * ATypes.ctype)
let rec desugar_type_specifiers specs =
  match project_base_type_specifiers specs with
    | Just z ->
        desugar_basic_type_specifiers (Multiset.from_list z)
    | Nothing ->
        E.return Nothing
  end >>= function
    | Just bty ->
        E.return (ATypes.no_qualifiers, ATypes.Basic bty)
    | Nothing ->
        let desugar_new_struct_or_union struct_or_union tag_ident_opt sdecls =
          let (kind_ctor, def_ctor, type_ctor) =
            match struct_or_union with
              | STRUCT ->
                  (E.Kind_struct, Struct_definition, ATypes.Struct)
              | UNION ->
                  (E.Kind_union, Union_definition, ATypes.Union)
            end in
          (* STD §6.7.2.1#8, sentence 1 *)
          (* NOTE: the std say that because we have a 'Just sdecls', a new
             type is being declared within the translation unit *)
          E.register_tag kind_ctor tag_ident_opt >>= fun tag_sym ->
          (* TODO: check that is indeed the UB I'm thinking of... *)
          List.concat <$> E.mapM desugar_struct_declaration sdecls >>= fun all_membDefs ->
          begin
            if List.length all_membDefs = 1 || struct_or_union = UNION then
              check_members all_membDefs
            else match Utils.last all_membDefs with
              | Nothing ->
                  (* xs was an empty list *)
                  (* STD §6.7.2.1#8, sentence 3 *)
                  E.fail Loc.unknown
                    (Errors.Desugar_UndefinedBehaviour Undefined.UB061_no_named_members)
              | Just ((last_ident, (_, lastMemb_ty)), membDefs) ->
                  (* STD §6.7.2.1#3 *)
                  check_members membDefs >>
                  if AilTypesAux.is_function lastMemb_ty then
                    E.fail (Loc.locOf last_ident)
                      (Errors.Desugar_ConstraintViolation "§6.7.2.1#3, function")
                  else
                    E.is_incomplete lastMemb_ty >>= function
                      | true ->
                          if AilTypesAux.is_array_unknown_size lastMemb_ty then
                            E.return ()
                          else
                            E.fail (Loc.locOf last_ident)
                              (Errors.Desugar_ConstraintViolation "§6.7.2.1#3, incomplete")
                      | false ->
                          E.return ()
                    end
            end
          end >>
          let loc = match tag_ident_opt with
            | Nothing ->
                Loc.unknown
            | Just tag_ident ->
                Loc.locOf tag_ident
          end in
          E.register_tag_definition loc tag_sym
            (def_ctor (isNothing tag_ident_opt) all_membDefs) >>
          E.return (ATypes.no_qualifiers, type_ctor tag_sym) in
        match specs with
          | [] ->
              STD_ "§6.7.2#2, sentence 1"
                E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "§6.7.2#2, 1st sentence")
          
          | [TSpec_void] ->
              STD_ "§6.7.2#2, sentence 2 (`void' case)"
                E.return (ATypes.no_qualifiers, ATypes.Void)
          
          | [TSpec_struct Nothing Nothing] ->
              error "TODO: TSpec_struct Nothing, Nothing"
          
          | [TSpec_union Nothing Nothing] ->
              error "TODO: TSpec_union Nothing, Nothing"
          
          | [TSpec_enum (Just tag_ident) Nothing] ->
              (* STD §6.7.2.3#9, enum *)
              E.resolve_extraordinary_identifier tag_ident E.Namespace_tag >>= function
                | Nothing ->
                    (* TODO: find if there is a better quote *)
                    E.fail (Loc.locOf tag_ident)
                      (Errors.Desugar_OtherViolation "footnote 131")
                | Just (_, (tag_sym, _)) ->
                    E.resolve_tag_definition tag_sym >>= function
                      | Nothing ->
                          (* STD §6.7.2.3#3 *)
                          E.fail (Loc.locOf tag_ident)
                            (Errors.Desugar_ConstraintViolation "§6.7.2.3#3")
                      | Just _ ->
                          E.return ( ATypes.no_qualifiers
                                   , ATypes.Basic (ATypes.Integer (ATypes.Enum tag_sym)) )
                    end
              end
          
          | [TSpec_struct (Just tag_ident) Nothing] ->
              (* NOTE: 'desugar_type_specifiers' must NOT be called on a
                 specifier occuring in the form described by §6.7.2.3#7 *)
              E.resolve_extraordinary_identifier tag_ident E.Namespace_tag >>= function
                | Just (_, (tag_sym, E.Kind_tag E.Kind_struct)) ->
                    (* STD §6.7.2.3#9 *)
                    E.return (ATypes.no_qualifiers, ATypes.Struct tag_sym)
                | Just _ ->
                    E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "§6.7.2.3#2")
                | Nothing ->
                    (* STD §6.7.2.3#8 *)
                    (* TODO: check, but this seems right *)
                    E.register_tag E.Kind_struct (Just tag_ident) >>= fun tag_sym ->
                    E.return (ATypes.no_qualifiers, ATypes.Struct tag_sym)
              end
          
          | [TSpec_union (Just tag_ident) Nothing] ->
              (* NOTE: 'desugar_type_specifiers' must NOT be called on a
                 specifier occuring in the form described by §6.7.2.3#7 *)
              E.resolve_extraordinary_identifier tag_ident E.Namespace_tag >>= function
                | Just (_, (tag_sym, E.Kind_tag E.Kind_union)) ->
                    (* STD §6.7.2.3#9 *)
                    E.return (ATypes.no_qualifiers, ATypes.Union tag_sym)
                | Just _ ->
                    E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "§6.7.2.3#2")
                | Nothing ->
                    (* STD §6.7.2.3#8 *)
                    (* TODO: check, but this seems right *)
                    E.register_tag E.Kind_union (Just tag_ident) >>= fun tag_sym ->
                    E.return (ATypes.no_qualifiers, ATypes.Union tag_sym)
              end
          
          | [TSpec_struct tag_ident_opt (Just sdecls)] ->
              desugar_new_struct_or_union STRUCT tag_ident_opt sdecls
          
          | [TSpec_union tag_ident_opt (Just sdecls)] ->
              desugar_new_struct_or_union UNION tag_ident_opt sdecls
          
          | [TSpec_Atomic tyname] ->
              desugar_type_name tyname >>= fun (qs, ty) ->
              (* STD §6.7.2.4#3 *)
              (* TODO: shouldn't this be done by the Ail typing? *)
              if    AilTypesAux.is_array ty
                 || AilTypesAux.is_function ty
                 || AilTypesAux.is_atomic ty
                 || not (AilTypesAux.is_unqualified qs) then
                E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "§6.7.2.4#3")
              else
                (* TODO: qualifiers *)
                E.return (qs, ATypes.Atomic ty)
          
          | [TSpec_enum Nothing Nothing] ->
              (* the C parsing should have failed *)
              E.fail Loc.unknown Errors.Desugar_impossible
          
          | [TSpec_enum tag_ident_opt (Just enums)] ->
              E.register_tag E.Kind_enum tag_ident_opt >>= fun tag_sym ->
              let loc = match tag_ident_opt with
                | Just ident -> Loc.locOf ident
                | Nothing    -> Loc.other "TODO_anonymous_enum"
              end in
              register_enumerators loc tag_sym enums >>= fun ns_rev ->
              let loc = match tag_ident_opt with
                | Nothing ->
                    Loc.unknown
                | Just tag_ident ->
                    Loc.locOf tag_ident
              end in
              (* NOTE: this function doesn't care about the order of the integers *)
              E.register_tag_definition loc tag_sym (Enum_definition ns_rev) >>
              E.return (ATypes.no_qualifiers, ATypes.Basic (ATypes.Integer (ATypes.Enum tag_sym)))
          
          (* *)
          | [TSpec_name ((CabsIdentifier loc str) as ident)] ->
              E.print_debugM 2 (fun () -> "Cabs_to_ail, TSpec_name ==> " ^ str) >>
              match Builtins.translate_builtin_typenames str with
                | Just ty ->
                    E.return (ATypes.no_qualifiers, ty)
                | Nothing ->
                    (* TODO: check the namespace *)
                    E.resolve_identifier ident E.Namespace_ordinary >>= function
                      | Just (_, (sym, E.Kind_typedef, _)) ->
                          E.resolve_typedef sym >>= fun (qs, ty) ->
                          E.return (qs, ty)
                      | Just _ ->
                          E.fail loc (Errors.Desugar_NotyetSupported "TODO: Tspec_name, not King_typedef")
                      | Nothing ->
                          E.fail loc (Errors.Desugar_NotyetSupported "TODO: Tspec_name, not resolved")
                    end
              end
          
          | _ ->
              E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "§6.7.2#2, 2nd sentence")
        end
end


(* val register_enumerators: Symbol.sym -> list enumerator -> E.desugM unit *)
and register_enumerators tag_loc tag_sym enums =
  (* STD §6.7.2.2#3 *)
  E.foldlM (fun (current_n, acc) enum ->
    desugar_enumerator enum >>= fun (ident, loc_n_opt) ->
    let (loc, n) = match loc_n_opt with
      | Nothing ->
          (Loc.other "TODO: register_enumerators", current_n)
      | Just loc_n ->
          loc_n
    end in
    let d_e =
      AilEannot (ATypes.Basic (ATypes.Integer (ATypes.Signed ATypes.Int_))) (
        AnnotatedExpression () ["§6.7.2.2#3"] loc (
          AilEconst (ConstantInteger (IConstant n Decimal Nothing))
        )
      ) in
    (* STD §6.2.1#7, sentence 2 *)
    (* the scope  of an enumeration constant start just after it's appearance in
       the enumerator list *)
    E.register_enum_constant ident d_e >>
    E.return (n + 1, n :: acc)
  ) (0, []) enums >>= fun (_, ns_rev) ->
  E.return ns_rev







(*
int                                     int
int *                                   pointer to int
int *[3]                                array of three pointers to int
int ( * )[3]                            pointer to an array of three ints
int ( * )[*]                            pointer to a variable length array of an unspecified number of ints,
int *()                                 function with no parameter specification returning a pointer to int
int ( * )(void)                         pointer to function with no parameters returning an int
int ( * const [])(unsigned int, ...)    array of an unspecified number of constant pointers to functions, each with
                                        one parameter that has type unsigned int and an unspecified number of other
                                        parameters, returning an int.



*)












and desugar_array_declarator under_array (ADecl loc tquals is_static a_decltor_size_opt) =
  let (isAtomic, tquals_qs) = translate_type_qualifiers tquals in
  (* NOTE: if we are in prototype scope, then we are dealing with
     a function parameter *)
  E.get_scope >>= function
     | E.Scope_prototype ->
         if under_array = IsUnderArray && (tquals <> [] || is_static) then
STD_ "§6.7.6.2#1, sentence 5, not outermost" $
           E.fail Loc.unknown
             (Errors.Desugar_ConstraintViolation "§6.7.6.2#1, 5th sentence, not outermost")
         else
           (* TODO: check, but after rereading the STD I think adjustment should only
              happen when the whole type of a parameter is "array of". But NOT for the
              inner array types. (Hence the commented code) *)
(*
           (* STD §6.7.6.3#7, sentence 1 *)
           E.return (fun qs ty ->
             match ty with
               | ATypes.Array elem_ty _ ->
                   (* NOTE: these are the qualifiers of the pointer *)
                   ( AilTypesAux.combine_qualifiers qs tquals_qs
                   , (if isAtomic then ATypes.Atomic else id) (ATypes.Pointer ATypes.no_qualifiers elem_ty) )
               | ty ->
                   (qs, ty)
             end)
*)
           E.return (fun qs ty ->
             ( AilTypesAux.combine_qualifiers qs tquals_qs
             , (if isAtomic then ATypes.Atomic else id) ty )
           )

     | _ ->
         if tquals <> [] || is_static then
STD_ "§6.7.6.2#1, sentence 5, not function parameter" $
           E.fail Loc.unknown
             (Errors.Desugar_ConstraintViolation "§6.7.6.2#1, 5th sentence, not function parameter")
         else
           (* not dealing with a parameter, so no adjustement needed *)
           E.return (fun qs ty -> (qs, ty))
  end >>= fun perform_adjust ->
  
  (* TODO: is_static not yet supported *)
  if is_static then
    E.fail loc (Errors.Desugar_NotyetSupported "array parameter with the static keyword")
  
  else match a_decltor_size_opt with
    | Just (ADeclSize_expression e) ->
        (* here the array declarator: has no qualifiers, is not static, and has
           a size expression *)
        (* STD §6.7.6.2#4, sentence 3 *)
        desugar_expression e >>= fun d_e ->
        is_integer_constant_expression d_e >>= function
          | false ->
              E.fail loc (Errors.Desugar_NotyetSupported "variable length array type 2")
          | true ->
             (* STD §6.7.6.2#1, sentence 2 *)
             (* NOTE: the preceding STD clause is performed by a typecheck done by
                [WipFrontend.evalIntegerConstantExpression] *)
             evaluate_integer_constant_expression loc Nothing d_e >>= fun n ->
              if n <= 0 then
                E.fail loc (Errors.Desugar_ConstraintViolation "§6.7.6.2#1, sentence 3")
              else
                E.return (fun qs ty -> perform_adjust qs (ATypes.Array ty (Just n)))
        end
    
    | Just ADeclSize_asterisk ->
        E.get_scope >>= function
          | E.Scope_prototype ->
              (* STD §6.7.6.2#4, sentence 2 *)
              E.fail loc (Errors.Desugar_NotyetSupported "variable length array type")
          | _ ->
              E.fail loc (Errors.Desugar_ConstraintViolation "§6.7.6.2#4, sentence 2")
        end
    
    | Nothing ->
        (* here the array declarator: has no size expression *)
        E.return (fun qs ty -> perform_adjust qs (ATypes.Array ty Nothing))
  end


(* TYPE: pointer_declarator -> E.desugM (ATypes.qualifiers -> ATypes.ctype -> (ATypes.qualifiers * ATypes.ctype)) *)
and desugar_pointer_declarator (PDecl tquals ptr_decltor_opt)  =
  (* if ptr_decltor_opt = Nothing, these qualifiers are of the current pointer
     type we are building; otherwise, they are of the referenced type of the
     inner [ptr_decltor] *)
  let (isAtomic, tquals_qs) = translate_type_qualifiers tquals in
  let mk_pointer_ctype ref_qs ref_ty =
    (if isAtomic then ATypes.Atomic else id) (ATypes.Pointer ref_qs ref_ty) in
  (* STD  §6.7.6.1#1 *)
  match ptr_decltor_opt with
    (* in this case [tquals_qs] are the qualifiers of the referenced type of
       the inner [ptr_decltor] *)
    | Just ptr_decltor ->
        (* the INNER [ptr_decltor] gets desugared to an OUTER pointer type,
           and [tquals_qs] are the qualifiers of the referenced type that OUTER
           pointer type *)
        desugar_pointer_declarator ptr_decltor >>= fun mk_outer_pointer_ctype ->
        E.return (
          fun base_qs base_ty ->
            mk_outer_pointer_ctype tquals_qs (mk_pointer_ctype base_qs base_ty)
        )
    | Nothing ->
        (* in this case [tquals_qs] are the qualifiers of the pointer type we
           are currently building *)
        E.return (
          fun base_qs base_ty -> (tquals_qs, mk_pointer_ctype base_qs base_ty)
        )
  end


and desugar_abstract_declarator under_array = function
  | AbsDecl_pointer ptr_decltor ->
      desugar_pointer_declarator ptr_decltor
  | AbsDecl_direct ptr_decltor_opt dabs_decltor ->
      maybe (E.return (fun qs ty -> (qs, ty))) desugar_pointer_declarator
        ptr_decltor_opt >>= fun mk_pointer_qs_ctype ->
      desugar_direct_abstract_declarator under_array dabs_decltor >>= fun mk_qs_ctype ->
      E.return (
        fun base_qs base_ty ->
          let (ptr_qs, ptr_ty) = mk_pointer_qs_ctype base_qs base_ty in
          mk_qs_ctype ptr_qs ptr_ty
      )
end


and desugar_direct_abstract_declarator under_array = function
  | DAbs_abs_declarator abs_decltor ->
      desugar_abstract_declarator under_array abs_decltor
  | DAbs_array dabs_decltor_opt a_decltor ->
      (* NOTE: the recursive call is "under an array" declaration *)
      maybe (E.return (fun qs ty -> (qs, ty)))
        (desugar_direct_abstract_declarator IsUnderArray) dabs_decltor_opt >>= fun mk_outer_qs_ctype ->
      desugar_array_declarator under_array a_decltor                       >>= fun mk_array_qs_ctype ->
      E.return (
        fun base_qs base_ty ->
          let (array_qs, array_ty) = mk_array_qs_ctype base_qs base_ty in
          mk_outer_qs_ctype array_qs array_ty
      )
  | DAbs_function dabs_decltor_opt param_tys ->
      (* TODO: documentation (the code the same as for desugar_direct_declarator, DDecl_function *)
      maybe (E.return (fun qs ty -> (qs, ty)))
        (desugar_direct_abstract_declarator under_array) dabs_decltor_opt >>= fun mk_qs_ctype ->
      E.with_scope E.Scope_prototype
        (desugar_parameter_type_list NotFunDef param_tys) >>= fun (_, (params, isVariadic)) ->
      match params with
        | [(Nothing, (qs, ATypes.Void, _))] ->
            if not (AilTypesAux.is_unqualified qs) then
              let () = Debug.warn [Debug.DB_desugaring] (fun () -> 
                "(UNSURE) forbidding the 'void' parameter to have qualifiers") in
              (* NOTE: I can't find if the STD actually requires this, but
                 allowing qualifiers would be meaningless and compilers (at
                 least clang and gcc) do the same *)
              E.fail Loc.unknown (Errors.Desugar_OtherViolation "'void' as parameter must not be qualified")
            else
              (* STD §6.7.6.3#10 *)
              E.return []
        | _ ->
            E.return (
              List.map (fun (opt, (qs, ty, isRegister)) ->
                (qs, ty, isRegister)
              ) params
            )
      end >>= fun params ->
      (* TODO: this is morally wrong: it should check that we are not building
         a function type returning a function or an array. Technically, the
         Ail typing does catch that error afterwards, but it's still tasteless *)
      E.return (
        fun base_qs base_ty ->
          mk_qs_ctype ATypes.no_qualifiers
            (ATypes.Function false (base_qs, base_ty) params isVariadic)
      )
end

(* TYPE: E.desugM (cabs_identifier * (ATypes.qualifiers -> ATypes.ctype -> (ATypes.qualifiers * ATypes.ctype))) *)
and desugar_direct_declarator fundef under_array = function
  | DDecl_identifier ident ->
      E.return (ident, fun base_qs base_ty -> (base_qs, base_ty))
  
  | DDecl_declarator decltor ->
      desugar_declarator fundef decltor
  
  | DDecl_array ddecltor a_decltor ->
      (* NOTE: the recursive call is "under an array" declaration *)
      desugar_direct_declarator fundef IsUnderArray ddecltor >>= fun (ident, mk_outer_qs_ctype) ->
      desugar_array_declarator under_array a_decltor         >>= fun mk_array_qs_ctype          ->
      E.return ( ident
               , fun base_qs base_ty ->
                   let (array_qs, array_ty) = mk_array_qs_ctype base_qs base_ty in
                   mk_outer_qs_ctype array_qs array_ty )
  
  | DDecl_function ddecltor param_tys ->
      (* TODO: check the NotFunDef *)
      desugar_direct_declarator NotFunDef under_array ddecltor >>= fun (ident, mk_qs_ctype) ->
      match fundef with
        | IsFunDef ->
            desugar_parameter_type_list fundef param_tys
        | NotFunDef ->
            E.with_scope E.Scope_prototype
              (desugar_parameter_type_list fundef param_tys) >>= fun (_, ret) ->
            E.return ret
      end >>= fun (_params, isVariadic) ->
      
      let params =
        (* NOTE2: but our current parser doesn't support identifier-list (this is an old syntax) *)
        List.map (fun (opt, (qs, ty, isRegister)) ->
          (qs, ty, isRegister)
        ) _params in
      (* TODO: this is morally wrong: it should check that we are not building
         a function type returning a function or an array. Technically, the
         Ail typing does catch that error afterwards, but it's still tasteless *)
      (* NOTE: this function is NEVER called for a function definition, so
         hasProto = false *)
      E.return ( ident
               , fun base_qs base_ty ->
                   mk_qs_ctype ATypes.no_qualifiers
                     (ATypes.Function false (base_qs, base_ty) params isVariadic) )
end



and desugar_parameter_type_list fundef (Params param_decls isVariadic) =
  match param_decls with
    | [] ->
        E.return []
    | x::xs ->
        desugar_parameter_declaration (* is_first *)true fundef x >>= fun p  ->
        E.mapM (desugar_parameter_declaration false fundef) xs    >>= fun ps ->
        E.return (p::ps)
  end >>= fun params ->
  
  match params with
    | [(Nothing, (qs, ATypes.Void, isRegister))] ->
        (* NOTE: the (illegal) case where there is a identifier is dealt with
           inside 'desugar_parameter_declaration' *)
        if not (AilTypesAux.is_unqualified qs) || isRegister then
          (* NOTE: this is undefined according to annex J.2, though
             I don't undestand why when reading the text (at §6.7.6.3) *)
          E.fail Loc.unknown (Errors.Desugar_UndefinedBehaviour Undefined.UB078_modified_void_parameter)
        else
          (* STD §6.7.6.3#10 *)
          E.return ([], isVariadic)
    | _ ->
        E.return (params, isVariadic)
  end


and desugar_parameter_declaration is_first fundef param_decl =
  match param_decl with
    | PDeclaration_decl specifs decltor ->
        if List.any (fun sc -> sc <> SC_register) specifs.storage_classes then
          E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "§6.7.6.3#2")
        else
          (* NOTE: specs_qs <> no_qualifiers when the specifiers had a type-name or _Atomic *)
          desugar_type_specifiers specifs.type_specifiers >>= fun (specs_qs, base_ty)  ->
          desugar_declarator NotFunDef decltor            >>= fun (ident, mk_qs_ctype) ->
          let (isAtomic, tquals_qs) = translate_type_qualifiers specifs.type_qualifiers in
          (* STD §6.9.1#7, sentence 4 *)
          let (_qs, _ty) =
            mk_qs_ctype (AilTypesAux.combine_qualifiers specs_qs tquals_qs) base_ty in
          
          if AilTypesAux.is_void _ty then
            match fundef with
              | IsFunDef ->
                  E.fail Loc.unknown
                    (Errors.Desugar_ConstraintViolation "§6.9.1#5, sentence 1")
              | NotFunDef ->
                  (* STD §6.7#7 *)
                  (* NOTE: this paragraph applies here because identifiers declared to
                     be a function parameter have no linkage *)
                  E.fail Loc.unknown (Errors.Desugar_UndefinedBehaviour Undefined.UB059_incomplete_no_linkage_identifier)
            end
          else
            let (qs, ty) = AilTypesAux.adjust _qs _ty in
            E.is_incomplete ty >>= function
              | true ->
                  match fundef with
                    | IsFunDef ->
                        (* STD §6.9.1#7, sentence 4 *)
                        (* NOTE(TODO): at the same time, §6.7.6.3#4 seems to
                           make this a constraint violation, but then there is
                           also §6.7#7 that should apply here (making it UB
                           afterall) ... *)
                        E.fail Loc.unknown
                          (Errors.Desugar_UndefinedBehaviour Undefined.UB086_incomplete_adjusted_parameter)
                    | NotFunDef ->
                        (* NOTE: §6.7.6.3#12, explicitly says non-fundef can have
                           incomplete (adjusted) parameter types, but I assume they
                           only mean this so unammed ones?? *)
                        (* STD §6.7#7 *)
                        (* NOTE: this paragraph applies here because identifiers declared to
                           be a function parameter have no linkage *)
                        E.fail Loc.unknown (Errors.Desugar_UndefinedBehaviour Undefined.UB059_incomplete_no_linkage_identifier)
                  end
              | false ->
                  let isRegister = List.elem SC_register specifs.storage_classes in
                  let scs = specifs.storage_classes in
                  E.register_ordinary_identifier ident (E.OK_object true) scs >>= fun (link, sym) ->
                  (* TODO: check this registration *)
                  let dur = determinate_storage_duration link scs in
                  E.register_internal_object_declaration (Loc.locOf ident) sym (dur, isRegister, qs, ty) >>
                  E.return (Just ident, ( qs
                                      , if isAtomic then ATypes.Atomic ty else ty
                                      , isRegister ))
            end
    | PDeclaration_abs_decl specifs abs_decltor_opt ->
        if List.any (fun sc -> sc <> SC_register) specifs.storage_classes then
          E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "§6.7.6.3#2")
        else
          (* NOTE: specs_qs <> no_qualifiers when the specifiers had a type-name or _Atomic *)
          desugar_type_specifiers specifs.type_specifiers >>= fun (specs_qs, base_ty)  ->
          maybe (E.return (fun qs ty -> (qs, ty)))
            (desugar_abstract_declarator NotUnderArray) abs_decltor_opt >>= fun mk_qs_ctype ->
          let (isAtomic, tquals_qs) = translate_type_qualifiers specifs.type_qualifiers in
          (* STD §6.9.1#7, sentence 4 *)
          let (_qs, _ty) =
            mk_qs_ctype (AilTypesAux.combine_qualifiers specs_qs tquals_qs) base_ty in
          let (qs, ty) = AilTypesAux.adjust _qs _ty in
          let ret = (Nothing, ( qs
                              , if isAtomic then ATypes.Atomic ty else ty
                              , List.elem SC_register specifs.storage_classes )) in
          match fundef with
            | IsFunDef ->
                if not (is_first && AilTypesAux.is_void ty) then
                  E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "§6.9.1#5")
                else
                  E.return ret
            | NotFunDef ->
                if not is_first && AilTypesAux.is_void ty then
                  (* TODO: check this *)
                  E.fail Loc.unknown
                    (Errors.Desugar_OtherViolation "found a void parameter (in a non-fundef). \
                       This is probably forbidden, but can't find the STD saying so")
                else
                  (* NOTE: base on §6.7.6.3#12, this allows incomplete types *)
                  E.return ret
          end
  end




(* TYPE: E.desugM (cabs_identifier * (AilTypes.qualifiers -> AilTypes.ctype -> (AilTypes.qualifiers * AilTypes.ctype))) *)
and desugar_declarator fundef (Declarator ptr_decltor_opt ddecltor) =
  maybe (E.return (fun qs ty -> (qs, ty))) desugar_pointer_declarator
    ptr_decltor_opt >>= fun mk_pointer_qs_ctype ->
  desugar_direct_declarator fundef NotUnderArray ddecltor >>= fun (ident, mk_qs_ctype) ->
  (* TODO: check, but seems correct *)
  E.return ( ident
           , fun base_qs base_ty ->
               let (ptr_qs, ptr_ty) = mk_pointer_qs_ctype base_qs base_ty in
               mk_qs_ctype ptr_qs ptr_ty )



























(* val     desugar_expression: cabs_expression -> E.desugM (expression unit) *)
and desugar_expression (CabsExpression loc expr) =
  AnnotatedExpression () [] loc <$>
  match expr with
    | CabsEident ident ->
        let (CabsIdentifier _ str) = ident in (* DEBUG *)
        E.print_debugM 2 (fun () -> "DESUGARING, CabsEident: " ^ str) >>= fun () -> (* DEBUG *)
STD_ "§6.5.1#2" $
        E.resolve_ordinary_identifier loc ident >>= function
          | Just (_, Left enum_cst_sym) ->
              E.resolve_enum_constant enum_cst_sym
          | Just (_, Right (sym, kind, _)) ->
              (* I love the fact that it is a footnote that says that undeclared
                 identifiers are syntax errors ... *)
              if not (E.is_object_kind kind || kind = E.OK_function) then
                E.fail (Loc.locOf ident) (Errors.Desugar_OtherViolation "§6.5.1#2")
              else
                E.add_used_identifier sym >>
                (* TODO(check): this is to let the Ail typechecker know about
                   identifiers used before their type have been completed *)
                (* TODO: only had that annotation if sym_ty is incomplete? *)
                match kind with
                  | E.OK_object _ ->
                      E.print_debugM 2 (fun () -> "before fetch_object_declaration ==> " ^ show (Loc.stringFromLocation (Loc.locOf ident))) >>
                      E.fetch_object_declaration sym >>= fun (isTentative, _, _, sym_qs, sym_ty) ->
                      E.return begin
(*                  AilEannot sym_ty (AnnotatedExpression () [] loc (AilEident sym)) *)
                        AilEident sym
                      end
                  | _ ->
                      E.return (AilEident sym)
                end
          | Nothing ->
              match Builtins.translate_builtin_varnames ident with
                | Just (d_e, _) ->
                    E.return d_e
                | Nothing ->
                    E.fail (Loc.locOf ident)
                      (* TODO: std §6.5.1#2 *)
                      (* TODO: check the quote *)
                      (Errors.Desugar_UndeclaredIdentifier (show ident))
              end
        end
    
    | CabsEconst cst ->
        AilEconst <$> desugar_cabs_constant loc cst
    | CabsEstring lit ->
        E.return (AilEstr $ translate_cabs_string_literal lit)
    | CabsEgeneric e gas ->
        AilEgeneric <$> desugar_expression e
                    <*> E.mapM desugar_generic_association gas
    
    | CabsEsubscript e1 e2 ->
STD_ "§6.5.2.1#2, sentence 2" $
        AilEunary Indirection <$> (
          AnnotatedExpression () [] loc <$>
          (AilEbinary <$> desugar_expression e1
                      <*> E.return (Arithmetic Add)
                      <*> desugar_expression e2)
        )
    | CabsEcall e es ->
        (* TODO: STD check + annot *)
        AilEcall <$> desugar_expression e <*> E.mapM desugar_expression es
    | CabsEmemberof e ident ->
        (* NOTE: we don't desugar the field name here because we need to know the type of [e] ... *)
        AilEmemberof <$> desugar_expression e <*> (E.return ident)
    | CabsEmemberofptr e ident ->
        (* NOTE: we don't desugar the field name here because we need to know the type of [e] ... *)
        AilEmemberofptr <$> desugar_expression e <*> (E.return ident)
    | CabsEpostincr e ->
        AilEunary PostfixIncr <$> desugar_expression e
    | CabsEpostdecr e ->
        AilEunary PostfixDecr <$> desugar_expression e
    | CabsEcompound tyname inits ->
        desugar_type_name tyname >>= fun (qs, ty) ->
        (* TODO: the storage duration is wrong here, if we are inside the body of a function, it should be automatic *)
        (* NOTE: there is no need to do the check for STD §6.7.9#3 here, because of the ail typing *)
        wip_desugar_initializer_ loc ATypes.Static ty (Init_list inits) >>= fun (ty', d_e) ->
        E.return (AilEcompound qs ty' d_e)
    | CabsEpreincr e ->
STD_ "§6.5.3.1#2, sentence 3" $
(*
        desugar_expression e >>= fun d_e ->
        E.return $ AilEcompoundAssign d_e Add oneAil
*)
        (* TODO: temporary hack, while the elab doesn't support compound assigns *)
        desugar_expression e >>= fun d_e ->
        E.return $ AilEassign d_e (AnnotatedExpression () [] loc (AilEbinary d_e (Arithmetic Add) oneAil))
    | CabsEpredecr e ->
STD_ "§6.5.3.1#3" $
(*
        desugar_expression e >>= fun d_e ->
        E.return $ AilEcompoundAssign d_e Sub oneAil
*)
        (* TODO: temporary hack, while the elab doesn't support compound assigns *)
        desugar_expression e >>= fun d_e ->
        E.return $ AilEassign d_e (AnnotatedExpression () [] loc (AilEbinary d_e (Arithmetic Sub) oneAil))

      (* (§6.5.3.3#5) *)
    | CabsEunary CabsNot e ->
        desugar_expression e >>= fun d_e ->
        E.return $ AilEbinary zeroAil Eq d_e
    
    | CabsEunary uop e ->
        desugar_expression e >>= fun d_e ->
        E.return $ AilEunary (translate_unary_operator uop) d_e
    | CabsEsizeof_expr e ->
        AilEsizeof_expr <$> desugar_expression e
    | CabsEsizeof_type tyname ->
        (* TODO: STD check + annot *)
        desugar_type_name tyname >>= fun (qs, ty) ->
        E.return $ AilEsizeof qs ty
    | CabsEalignof tyname ->
        (* TODO: STD check + annot *)
        desugar_type_name tyname >>= fun (qs, ty) ->
        E.return $ AilEalignof qs ty
    | CabsEcast tyname e ->
        (* TODO: check *)
        desugar_type_name tyname >>= fun (qs, ty) ->
        desugar_expression e     >>= fun d_e      ->
        E.return (AilEcast qs ty d_e)
    
    | CabsEbinary bop e1 e2 ->
        AilEbinary <$> desugar_expression e1
                   <*> E.return (translate_binary_operator bop)
                   <*> desugar_expression e2
    | CabsEcond e1 e2 e3 ->
        AilEcond <$> desugar_expression e1
                 <*> desugar_expression e2
                 <*> desugar_expression e3
    | CabsEassign aop e1 e2 ->
        match translate_assignment_operator aop with
          | Nothing  ->
              AilEassign <$> desugar_expression e1
                         <*> desugar_expression e2
          | Just aop ->
              (* TODO: temporary hack, while the elab doesn't support compound assigns *)
              desugar_expression e1 >>= fun d_e1 ->
              desugar_expression e2 >>= fun d_e2 ->
              E.return $ AilEassign d_e1 (AnnotatedExpression () [] loc (AilEbinary d_e1 (Arithmetic aop) d_e2))
        end 
    | CabsEcomma e1 e2 ->
        AilEbinary <$> desugar_expression e1
                   <*> E.return Comma
                   <*> desugar_expression e2
    | CabsEassert e ->
        AilEassert <$> desugar_expression e
    | CabsEoffsetof tyname ident ->
        (* TODO: do something with the qualifiers? *)
        desugar_type_name tyname >>= fun (qs, ty) ->
        E.return (AilEoffsetof ty ident)
    | CabsEva_start e (CabsIdentifier loc str as ident) ->
        desugar_expression e                                       >>= fun d_e ->
        desugar_expression (CabsExpression loc (CabsEident ident)) >>= function
          | AnnotatedExpression _ _ _ (AilEident sym) ->
              E.return (AilEva_start d_e sym)
          | _ ->
              E.fail Loc.unknown (Errors.Desugar_TODOCTOR "the second operand of va_start() was not paramN")
        end
    | CabsEva_arg e tyname ->
        (* TODO: do something with the qualifiers? *)
        desugar_expression e     >>= fun d_e      ->
        desugar_type_name tyname >>= fun (qs, ty) ->
        E.return (AilEva_arg d_e ty)
    | CabsEprint_type e ->
        AilEprint_type <$> desugar_expression e
  end

and desugar_generic_association gas =
  match gas with
    | GA_type tyname e ->
        desugar_type_name tyname >>= fun (_, ty) ->
        (* TODO: (§6.5.1.1#2, sentence 2), ty must be complete and not variably modified *)
        desugar_expression e     >>= fun d_e     ->
        E.return (AilGAtype ty d_e)
    | GA_default e ->
        AilGAdefault <$> desugar_expression e
  end






(* TODO: rename this function *)
and check_storage_class_specifiers decl_ctxt scs =
  E.get_scope >>= fun scope ->
  if    List.length scs > 1
     && not (   List.all (fun z -> z = SC_Thread_local || z = SC_static) scs
             || List.all (fun z -> z = SC_Thread_local || z = SC_extern) scs) then
STD_ "§6.7.1#2" $
    E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "§6.7.1#2")
  
  else if not (decl_ctxt = Object_decl_context && E.is_block_scope scope &&
               List.elem SC_Thread_local scs -->
                 (List.elem SC_static scs || List.elem SC_extern scs)
              ) then
STD_ "§6.7.1#3, sentence 1" $
         E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "§6.7.1#3, 1st sentence")
  
  else if decl_ctxt = Function_decl_context && List.elem SC_Thread_local scs then
STD_ "§6.7.1#4" $
    E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "§6.7.1#4")
  
  else if not (decl_ctxt = Function_decl_context && E.is_block_scope scope -->
               scs = [] || scs = [SC_extern]) then
STD_ "§6.7.1#7" $
    E.fail Loc.unknown
      (Errors.Desugar_UndefinedBehaviour Undefined.UB060_block_scope_function_with_storage_class)
  else
STD_ "§6.7.1#8" $
    (* TODO *)
    E.return ()

(*
<|
  C.storage_classes:      list storage_class_specifier;
  C.type_specifiers:      list type_specifier;
  C.type_qualifiers:      list type_qualifier;
  C.function_specifiers:  list function_specifier;
  C.alignment_specifiers: list alignment_specifier;
|>
*)

(* TODO: get rid of this function *)
(* E.desugM (cabs_identifier * ATypes.qualifiers * ATypes.ctype * desugM (unit -> maybe expression unit)) *)
and desugar_init_declarator_BROKEN base_qs base_ty (scs: list storage_class_specifier) idecltor =
  let () = Debug.print_debug 1 [] (fun () ->
    "TODO ==> USING `desugar_init_declarator_BROKEN'"
  ) in
  (* NOTE: this function does NOT check the wf of the storage classes *)
  E.get_scope >>= fun scope ->
  match idecltor with
    | InitDecl loc decltor Nothing ->
        desugar_declarator NotFunDef decltor >>= fun (ident, mk_qs_ctype) ->
        let (qs, ty) = mk_qs_ctype base_qs base_ty in
        let mk_desug_init =
          fun () -> E.return Nothing in
        (* STD §6.9.2#2, sentence 1 *)
        let is_tentative = match scope with
          | E.Scope_file ->
              AilTypesAux.is_object ty && (List.elem SC_static scs || scs = [])
          | _ ->
              false
        end in
        E.return (ident, is_tentative, (qs, ty), mk_desug_init)
    
    | InitDecl loc decltor (Just init) ->
        desugar_declarator NotFunDef decltor >>= fun (ident, mk_qs_ctype) ->
        let (qs, ty) = mk_qs_ctype base_qs base_ty in
        
        (* TODO: check that we really never have parameter objects here *)
        let kind = if AilTypesAux.is_function ty then E.OK_function else E.OK_object false in
        (* TODO: I don't like the fact that we are using this function directly here *)
        E.determinate_linkage ident E.Namespace_ordinary kind scs >>= fun link ->
        
        (* STD §6.7.9#3 *)
        if not (   AilTypesAux.is_array_unknown_size ty
                || (AilTypesAux.is_object ty && not (AilTypesAux.is_vla ty)) ) then
          E.fail loc (Errors.Desugar_ConstraintViolation "§6.7.9#3")
        
        (* STD §6.7.9#5 *)
        else if E.is_block_scope scope && (link = Linkage_external || link = Linkage_internal) then
          E.fail loc (Errors.Desugar_ConstraintViolation "§6.7.9#5")
        
        else
(*
          if AilTypesAux.is_array ty then
            (*  *)
            match init with
              | Init_expr (CabsExpression e_loc (CabsEstring lit)) ->
                  error ("initialisation of array with string literal ==> " ^ Loc.stringFromLocation e_loc)
              | Init_list [(Nothing, Init_expr (CabsExpression e_loc (CabsEstring lit)))] ->
                  error ("initialisation of array with string literal in braces ==> " ^ Loc.stringFromLocation e_loc)
              | _ ->
                  error "initialisation of array with something else"
            end

          else
*)



          (* postponing the desugaring of the initialiser since the identifier
             (which gets register after the current function) need to be in scope *)
          let mk_desug_init () =
            (* NOTE: not using <$> because of a bug in Lem *)
            wip_desugar_initializer_ loc (determinate_storage_duration link scs) ty init >>= fun z ->
            E.return (Just z) in
          E.return (ident, false, (qs, ty), mk_desug_init)
  end



and desugar_init_declarator isAtomic base_qs base_ty (scs: list storage_class_specifier) idecltor =
  (* NOTE: this function does NOT check the wf of the storage classes *)
  E.get_scope >>= fun scope ->
  match idecltor with
    | InitDecl loc decltor Nothing ->
        desugar_declarator NotFunDef decltor >>= fun (ident, mk_qs_ctype) ->
        let (qs, _ty) = mk_qs_ctype base_qs base_ty in
        let ty = if isAtomic then ATypes.Atomic _ty else _ty in
        let mk_desug_init =
          fun () -> E.return Nothing in
        (* STD §6.9.2#2, sentence 1 *)
        let is_tentative = match scope with
          | E.Scope_file ->
              AilTypesAux.is_object ty && (List.elem SC_static scs || scs = [])
          | _ ->
              false
        end in
        if scs = [SC_typedef] then
          E.register_typedef ident (qs, ty) >>= fun () ->
          E.return Nothing
        else
          let (ctx, ok) =
            if AilTypesAux.is_function ty then
              (Function_decl_context, E.OK_function)
            else
              (Object_decl_context, E.OK_object false) in
          check_storage_class_specifiers ctx scs >>= fun () ->
          E.register_ordinary_identifier ident ok scs >>= fun (link, sym) ->
          E.return (Just (Loc.locOf ident, link, sym, is_tentative, (qs, ty), mk_desug_init))
    
    | InitDecl loc decltor (Just init) ->
        if scs = [SC_typedef] then
          E.fail loc (Errors.Desugar_OtherViolation "TODO(find std): typedef can't have a initializer")
        else
          desugar_declarator NotFunDef decltor >>= fun (ident, mk_qs_ctype) ->
          let (qs, _ty) = mk_qs_ctype base_qs base_ty in
          let ty = if isAtomic then ATypes.Atomic _ty else _ty in
          (* TODO: check that we really never have parameter objects here *)
          let kind = if AilTypesAux.is_function ty then E.OK_function else E.OK_object false in
          (* TODO: I don't like the fact that we are using this function directly here *)
          E.determinate_linkage ident E.Namespace_ordinary kind scs >>= fun link ->
          (* STD §6.7.9#3 *)
          if not (   AilTypesAux.is_array_unknown_size ty
                  || (AilTypesAux.is_object ty && not (AilTypesAux.is_vla ty)) ) then
            E.fail loc (Errors.Desugar_ConstraintViolation "§6.7.9#3")
          (* STD §6.7.9#5 *)
          else if E.is_block_scope scope && (link = Linkage_external || link = Linkage_internal) then
            E.fail loc (Errors.Desugar_ConstraintViolation "§6.7.9#5")
          else
            (* postponing the desugaring of the initialiser since the identifier
               (which gets register after the current function) need to be in scope *)
            let mk_desug_init () =
              (* NOTE: not using <$> because of a bug in Lem *)
              wip_desugar_initializer_ loc (determinate_storage_duration link scs) ty init >>= fun z ->
              E.return (Just z) in
            
            let (ctx, ok) =
              if AilTypesAux.is_function ty then
                (Function_decl_context, E.OK_function)
              else
                (Object_decl_context, E.OK_object false) in
            check_storage_class_specifiers ctx scs >>= fun () ->
            E.register_ordinary_identifier ident ok scs >>= fun (link, sym) ->
            E.return (Just (Loc.locOf ident, link, sym, false, (qs, ty), mk_desug_init))
  end


and desugar_struct_declaration struct_decl =
  match struct_decl with
    | Struct_declaration specs tquals sdecltors ->
        desugar_type_specifiers specs >>= fun (specs_qs, base_ty) ->
        let (isAtomic, tquals_qs) = translate_type_qualifiers tquals in
        if List.null sdecltors then
          E.get_anonymous_struct_or_union base_ty >>= function
            | Just membrs ->
                (* STD §6.7.2.1#13 *)
                (* this is an unammed anonymous structure or union *)
                E.return membrs
            | Nothing ->
                (* STD §6.7.2.1#2 *)
                E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "§6.7.2.1#2")
          end
        else
          E.mapM (fun sdecltor ->
            desugar_struct_declarator sdecltor >>= fun (ident, mk_qs_ctype) ->
            (* NOTE: the checks for §6.7.2.1#3 are done by
               desugar_type_specifiers because we need to special case the last
               member. *)
            let (qs, ty) =
              mk_qs_ctype (AilTypesAux.combine_qualifiers tquals_qs specs_qs) base_ty in
            E.return (ident, (qs, if isAtomic then ATypes.Atomic ty else ty))
          ) sdecltors
    
    | Struct_assert sa_decl ->
        desugar_and_register_static_assert_declaration sa_decl >>
        E.return []
  end

and desugar_struct_declarator struct_decltor =
  match struct_decltor with
    | SDecl_simple decltor ->
        desugar_declarator NotFunDef decltor
    | SDecl_bitfield declor_opt (CabsExpression loc _) ->
        E.fail loc (Errors.Desugar_NotyetSupported "SDecl_bitfield")
  end

and desugar_enumerator (ident, e_opt) =
  match e_opt with
    | Nothing ->
      E.return (ident, Nothing)
    | Just e ->
        let loc = Loc.locOf e in
        desugar_expression e >>= fun d_e ->
        (* STD §6.7.2.2#2 *)
        is_integer_constant_expression d_e >>= function
          | false ->
              (* TODO: the integer must also be representable as an int *)
              E.fail loc (Errors.Desugar_ConstraintViolation "§6.7.2.2#2")
          | true ->
              (* TODO: the type provided to the evaluator should be the integer type
                 compatible with the enum? *)
              evaluate_integer_constant_expression loc Nothing d_e >>= fun n ->
              E.return (ident, Just (loc, n))
        end
  end




and desugar_alignment_specifier align_spec =
  match align_spec with
    | AS_type tyname ->
      error "TODO 40"
    | AS_expr e ->
      error "TODO 41"
  end






























(*  desugar_type_name: type_name -> E.desugM (ATypes.qualifiers * ATypes.ctype) *)
and desugar_type_name (Type_name specs tquals abs_decltor_opt) =
  desugar_type_specifiers specs >>= fun (specs_qs, base_ty) ->
  maybe (E.return (fun qs ty -> (qs, ty)))
    (desugar_abstract_declarator NotUnderArray) abs_decltor_opt >>= fun mk_qs_ctype ->
  let (isAtomic, tquals_qs) = translate_type_qualifiers tquals in
  
  let (qs, ty) =
    mk_qs_ctype (AilTypesAux.combine_qualifiers specs_qs tquals_qs) base_ty in
  E.return (qs, if isAtomic then ATypes.Atomic ty else ty)














(*

DESUGARING (DUH)

2-  No initializer shall attempt to provide a value for an object not contained within the entity being initialized.


STATIC-TYPING

3-  The type of the entity to be initialized shall be an array of unknown size or a complete object type that is not a variable length array type.


OTHER

4-  All the expressions in an initializer for an object that has static or thread storage duration shall be constant expressions or string literals.



5-  If the declaration of an identifier has block scope, and the identifier has external or internal linkage, the declaration shall have no initializer for the identifier.


*)




(* STD §6.7.9#10, second sentence *)
and static_thread_implicit_initializer tagDefs ty =
  let () = Debug.print_debug 8 [Debug.DB_desugaring]
      (fun () -> "ENTERING Cabs_to_ail.static_thread_implicit_initializer: " ^ Pp.stringFromAil_ctype ATypes.no_qualifiers ty) in
  match ty with
    | ATypes.Pointer _ _ ->
        ConstantNull
    | ATypes.Basic _ ->
        if AilTypesAux.is_arithmetic ty then
          ConstantInteger (IConstant 0 Octal Nothing)
        else
          error ("type error 1: " ^ Pp.stringFromAil_ctype ATypes.no_qualifiers ty)
    | ATypes.Array elem_ty n_opt ->
        match n_opt with
          | Just n ->
              ConstantArray (Utils.replicate_list (static_thread_implicit_initializer tagDefs elem_ty) (natFromInteger n))
          | Nothing ->
              error "type error, (TODO find quote): subarray with no size"
        end
    
    | ATypes.Struct tag_sym ->
        match Map.lookup tag_sym tagDefs with
          | Just (Struct_definition _ xs) ->
              ConstantStruct tag_sym $
                List.map (fun (ident, (_, ty)) ->
                  (* we ignore the qualifiers, initialisers don't care about them *)
                  (ident, static_thread_implicit_initializer tagDefs ty)
                ) xs
          | _ ->
              error "Cabs_to_ail.static_thread_implicit, Struct, not Struct_definition"
        end
    
    | ATypes.Union tag_sym ->
        match Map.lookup tag_sym tagDefs with
          | Just (Union_definition _ xs) ->
              let (ident, (_, ty)) = match xs with
                | [] ->
                    (* NOTE: I don't the parser can produce an empty Union_definition *)
                    error "Cabs_to_ail.static_thread_implicit, Union, empty definition"
                | z :: _ ->
                    z
              end in
              (* we ignore the qualifiers, initialisers don't care about them *)
              ConstantUnion tag_sym ident (static_thread_implicit_initializer tagDefs ty)
          | _ ->
              error "Cabs_to_ail.static_thread_implicit, Union, not Union_definition"
        end

    | _ ->
        error ("type error 2: " ^ Pp.stringFromAil_ctype ATypes.no_qualifiers ty)
(*  | Function ty qs_tys is_variadic ->
        
    | Atomic ty ->
        
    | Struct of identifier * list (Cabs.cabs_identifier * ctype) (* TODO: no bitfields for now *)
    | Union of identifier * list (Cabs.cabs_identifier * ctype) (* TODO: no bitfields for now *)
    | Builtin of string          *)
  end




















(* KKK: new initializer_ *)

(*val pathFromDesigs: list designator -> E.desugM init_path *)
and pathFromDesigs_aux acc = function
  | [] ->
      E.return (List.reverse acc)
  | Desig_array e :: xs ->
      desugar_expression e               >>= fun d_e ->
      is_integer_constant_expression d_e >>= function
        | false ->
            E.fail (Loc.locOf e) (Errors.Desugar_ConstraintViolation "§6.7.9#6")
        | true ->
            evaluate_integer_constant_expression (Loc.locOf e) Nothing d_e >>= fun n ->
            if n < 0 then
              error "TODO: pathFromDesigs_aux, n < 0"
            else
              pathFromDesigs_aux (Elem_array n :: acc) xs
      end
  | Desig_member memb_ident :: xs ->
      pathFromDesigs_aux (Elem_member memb_ident :: acc) xs
end
and pathFromDesigs desigs =
  pathFromDesigs_aux [] desigs


(*
val foo_aux:
  list init_path -> initializer_ ->
  E.desugM (list (init_path * maybe (expression unit)) * list init_path)
*)

and foo_aux
(*  (entity_ty: ATypes.ctype) *)
  (acc: list (init_path * expression unit))
  (elems: list (init_path * init_path * ATypes.ctype))
  (unknown_array: maybe (integer * list (init_path * init_path * ATypes.ctype)))
  (xs: list (maybe (list designator) * initializer_))
  : E.desugM (list (init_path * expression unit) * list (init_path * init_path * ATypes.ctype) * maybe integer) =
  
  match xs with
    | [] ->
        E.get_tag_definitions >>= fun tagDefs ->
        let pad = List.map (fun (path, _, outer_ty) ->
          (path, mk_zeroInit tagDefs (innerCtype tagDefs outer_ty))
        ) elems in
        let n_opt = match unknown_array with
          | Nothing     -> Nothing
          | Just (n, _) -> Just n
        end in
        E.return (List.reverse acc ++ pad, [], n_opt)
    | (Just desigs, init_) :: xs' ->
        pathFromDesigs desigs >>= fun cursor_path ->
        match skipTo cursor_path elems with
          | Nothing ->
              error "foo_aux, TODO: Just desigs ==> backward"
          | Just (elems', skipped_elems) ->
              (* TODO: hackish *)
              E.get_tag_definitions >>= fun tagDefs ->
              let acc' = List.foldl (fun acc (path, _, outer_ty) ->
                (path, mk_zeroInit tagDefs (innerCtype tagDefs outer_ty)) :: acc
              ) acc skipped_elems in
              foo_aux (*entity_ty*) acc' elems' unknown_array ((Nothing, init_) :: xs')
        end
    | (Nothing, init_) :: xs' ->
        match elems with
          | [] ->
              match unknown_array with
                | Nothing ->
                    (* TODO: check this, are we missing anything? *)
                    foo_aux (*entity_ty*) acc elems unknown_array xs'
                | Just (i, elems_) ->
                    let elems =
                      List.map (fun (path, opath, ty) ->
                        (Elem_array (i+1) :: path, Elem_array (i+1) :: opath, ty)
                      ) elems_ in
                    foo_aux acc elems (Just (i+1, elems_)) xs
              end
          | (cursor_path, outer_path, outer_ty) :: elems' ->
              let do_scalar e =
                E.get_tag_definitions >>= fun tagDefs ->
                let cursor_ty = innerCtype tagDefs outer_ty in
                desugar_expression e >>= fun d_e ->
                let () = Debug.print_debug 1 [] (fun () ->
                  "Init_expr, cursor_ty: " ^ Pp.stringFromAil_ctype ATypes.no_qualifiers cursor_ty ^
                  ", outer_ty: " ^ Pp.stringFromAil_ctype ATypes.no_qualifiers outer_ty ^
                  " ===> " ^ Pp.stringFromAil_expression d_e
                ) in
                (* TODO: should use Ail typing instead of this *)
(*
                    match AilSyntaxAux.strip_expression d_e with
                      | AnnotatedExpression () _ loc (AilEconst (ConstantStruct e_tag_sym e_xs)) ->
                          if not (AilTypesAux.is_struct outer_ty) then
                            error "TODO: error ConstantStruct trying to init a non struct type"
                          else
                            error "TODO: Init_expr ConstantStruct"
                      | AnnotatedExpression () _ loc (AilEconst (ConstantUnion e_tag_sym membr_ident membr_cst)) ->
                          if not (AilTypesAux.is_union outer_ty) then
                            error "TODO: error ConstantUnion trying to init a non union type"
                          else
                            error "TODO: Init_expr ConstantUnion"
                      | AnnotatedExpression () _ loc (AilEstruct e_tag_sym e_xs) ->
                          if not (AilTypesAux.is_struct outer_ty) then
                            error "TODO: error AilEstruct trying to init a non struct type"
                          else
                            error "TODO: Init_expr AilEstruct"
                      | AnnotatedExpression () _ loc (AilEunion e_tag_sym membr_ident membr_e_opt) ->
                          if not (AilTypesAux.is_union outer_ty) then
                            error "TODO: error AilEunion trying to init a non union type"
                          else
                            error "TODO: Init_expr AilEunion"
                      | AnnotatedExpression () _ loc (AilEstr lit) ->
                            | _ ->
                                error "TODO: Init_expr AilEstr"
                          end
                      | _ ->
*)
                      let d_e' =
                        if AilTypesAux.is_pointer cursor_ty && AilSyntaxAux.is_null_pointer_constant d_e then
                          A.AnnotatedExpression () [] Loc.unknown (AilEconst A.ConstantNull)
                        else
                          d_e in
                      foo_aux (*entity_ty*) ((cursor_path, d_e') :: acc) elems' unknown_array xs'
(*                    end *)
              in

              let do_string_literal loc lit =
                if not (AilTypesAux.is_array_of_character outer_ty) then
                  (* TODO: this is wrong *)
                  E.fail loc (Errors.Desugar_ConstraintViolation "§6.7.9#14")
                else
                  let size = match AilTypesAux.unatomic outer_ty with
                    | ATypes.Array _ (Just n) ->
                        natFromInteger n
                    | _ ->
                        error "foo_aux: string literal"
                  end in
                  match lit with
                    | (Nothing, strs) ->
                        let str_xs = List.map (fun str ->
                          (Nothing, Init_expr (CabsExpression loc (CabsEconst (CabsCharacter_const (Nothing, str)))))
                        ) strs ++ begin
                          List.replicate (max 1 (size - List.length strs))
                            (Nothing, Init_expr (CabsExpression loc (CabsEconst (CabsCharacter_const (Nothing, "\\0")))))
                        end in
                        foo_aux acc elems unknown_array (str_xs ++ xs')
                    | _ ->
                        error "TODO(foo_aux): CabsEstring with encoding prefix"
                  end in
              match init_ with
                | Init_expr (CabsExpression loc (CabsEstring lit) as e) ->
                    if AilTypesAux.is_scalar outer_ty then
                      do_scalar e
                    else
                      do_string_literal loc lit
                | Init_list [(Nothing, Init_expr (CabsExpression loc (CabsEstring lit) as e))] ->
                    if AilTypesAux.is_scalar outer_ty then
                      do_scalar e
                    else
                      do_string_literal loc lit
                | Init_expr e ->
                    do_scalar e
                | Init_list ys ->
                    E.get_tag_definitions >>= fun tagDefs ->
                    let outerCard = cardinalityOfCtype tagDefs outer_ty in
                    let (inner_elems_, elems') = List.splitAt (natFromInteger outerCard) elems in
                    
                    let inner_elems = match inner_elems_ with
                      | [] ->
                          error "foo_aux, Init_list, inner_elems = []"
                      | (path, opath, ty) :: zs ->
                          let ty' = match ty with
                            | ATypes.Array elem_ty _ ->
                                elem_ty
                            | ATypes.Struct tag_sym ->
                                match Map.lookup tag_sym tagDefs with
                                  | Just (Struct_definition isAnonymous ((_, (_, first_memb_ty)) :: _)) ->
                                      let () = if isAnonymous then
                                        Debug.print_debug 1 [] (fun () ->
                                          "foo_aux: this may be WRONG ==> anonymous Struct"
                                        )
                                      else () in
                                      first_memb_ty
                                  | _ ->
                                      error "foo_aux: Init_list, Struct"
                                end
                            | _ ->
                                ty
                          end in
                          (path, opath, ty') :: zs
                    end in
                    
                    foo_aux (*outer_ty*) [] inner_elems (*unknown_array*)Nothing ys >>= fun (inner, _, _) ->
                    foo_aux (*entity_ty*) (List.reverse inner ++ acc) elems' unknown_array xs'
              end
        end
  end

(*
and bar i elems acc xs =
  let elems' =
    List.map (fun path ->
      Elem_array i :: path
    ) elems in
  foo_aux [] elems' xs >>= fun (xs', acc2) ->
  let acc' = acc ++ acc2 in
  match xs' with
    | [] ->
        E.return acc'
    | _ ->
        bar (i+1) elems acc' xs'
  end
*)

(* val foo: ATypes.ctype -> initializer_ -> E.desugM (list (init_path * maybe (expression unit))) *)
and foo entity_ty init_ : E.desugM (ATypes.ctype * list (init_path * expression unit)) =
  E.get_tag_definitions >>= fun tagDefs ->
  match (entity_ty, init_) with
    | (ATypes.Array elem_ty Nothing, Init_list xs) ->
        let elems = elemPathFromCtype3 true tagDefs elem_ty in
        let elems' =
          List.map (fun (path, opath, ty) ->
            (Elem_array 0 :: path, Elem_array 0 :: opath, ty)
          ) elems in
        foo_aux [] elems' (Just (0, elems)) xs >>= fun (ret, _, n_opt) ->
        match n_opt with
          | Nothing ->
              error "foo: Array Nothing"
          | Just n ->
              E.return (ATypes.Array elem_ty (Just (n+1)), ret)
        end
    | (ATypes.Array _ _, Init_list xs) ->
        let elems = elemPathFromCtype3 false tagDefs entity_ty in
        foo_aux (*entity_ty*) [] elems Nothing xs >>= fun (ret, _, _) ->
        E.return (entity_ty, ret)
    | (ATypes.Struct _, Init_list xs) ->
        let elems = elemPathFromCtype3 false tagDefs entity_ty in
        foo_aux (*entity_ty*) [] elems Nothing xs >>= fun (ret, _, _) ->
        E.return (entity_ty, ret)
    | _ ->
        let elems = elemPathFromCtype3 false tagDefs entity_ty in
        foo_aux (*entity_ty*) [] elems Nothing [(Nothing, init_)] >>= fun (ret, _, _) ->
        E.return (entity_ty, ret)
  end























(*  wip_desugar_initializer_: storageDuration -> ctype -> initializer_ -> E.desugM ? *)

(* NOTE: the check for STD §6.7.9#3 is done by [desugar_init_declarator] *)
and wip_desugar_initializer_ loc dur current_ty init =
(*
  E.get_tag_definitions >>= fun tagDefs ->
  foo current_ty init >>= fun xs ->
  
  let expr = constructValue tagDefs xs current_ty in

  let () = Debug.print_debug 0 [] (fun () ->
    "HELLO INITIALIZER_ ==> current_ty: " ^ Pp.stringFromAil_ctype ATypes.no_qualifiers current_ty ^
(*    "\n desigs ==> " ^ stringFromList stringFromInit_path (elemPathFromCtype_aux tagDefs current_ty) ^ *)

    "\n desigs ==> " ^ stringFromList (fun (path, outer_path, outer_ty) ->
                         stringFromInit_path path ^ " --> outer: " ^
                         stringFromInit_path outer_path ^ " (" ^
                         Pp.stringFromAil_ctype ATypes.no_qualifiers outer_ty ^ ")"
                       ) (elemPathFromCtype3 tagDefs current_ty) ^
    "\n FOO ==> " ^ stringFromList (fun (path, expr) ->
                      stringFromInit_path path ^
                      " := " ^ Pp.stringFromAil_expression expr
                    ) xs
  ) in
  let () = Debug.print_debug 0 [] (fun () ->
    "EXPR: " ^ Pp.stringFromAil_expression expr
  ) in

let () = error "DONE" in
*)


  (* YUCK + TODO: move somewhere *)
  let is_string_literal_init = function
    | Init_expr (CabsExpression _ (CabsEstring _)) ->
        true
    | Init_list [(Nothing, Init_expr (CabsExpression _ (CabsEstring _)))] ->
        true
    | _ ->
        false
  end in

  if AilTypesAux.is_scalar current_ty then
    match init with
      | Init_expr e ->
          E.return e
      | Init_list [(Nothing, Init_expr e)] ->
          (* NOTE: scalar can be initialised with optional enclosing braces *)
          E.return e
      | _ ->
          (* STD §6.7.9#11, sentence 1 *)
          (* NOTE: the STD says "shall" and this is not a 'Constraints' section,
             so this is undefined behaviour... *)
          E.fail loc (Errors.Desugar_UndefinedBehaviour Undefined.UB081_scalar_initializer_not_single_expression)
    end >>= fun e ->
    desugar_expression e >>= fun d_e ->
    (* STD §6.7.9#4 *)
    if dur = ATypes.Static || dur = ATypes.Thread then
      is_initializer_constant_expression d_e >>= function
        | false ->
            E.fail (Loc.locOf d_e) (Errors.Desugar_ConstraintViolation "§6.7.9#4")
        | true ->
            if AilTypesAux.is_integer current_ty then
(* TODO: bring back the evaluation if possible. But the following code is wrong
   because the setting the suffix to Nothing regardless of the value of n is wrong. *)
              E.return (current_ty, d_e)
(*
              evaluate_integer_constant_expression loc (Just current_ty) d_e >>= fun n ->
              E.return begin
                (current_ty, AnnotatedExpression () [] loc (AilEconst (ConstantInteger (IConstant n Decimal Nothing))))
              end
*)
            else
              (* TODO: floating and pointer *)
              E.return (current_ty, d_e)
      end
    else
      E.return (current_ty, d_e)
  
  else if AilTypesAux.is_array_of_character current_ty && is_string_literal_init init then
    translate_cabs_string_literal <$> match init with
      | Init_expr (CabsExpression _ (CabsEstring lit)) ->
          E.return lit
      | Init_list [(Nothing, Init_expr (CabsExpression _ (CabsEstring lit)))] ->
          E.return lit
      | _ ->
          E.fail loc (Errors.Desugar_UndefinedBehaviour Undefined.UB083)
    end >>= fun (pref_opt, char_strs) ->
    
    let (elem_ty, mk_ty, current_size_opt) = match current_ty with
      | AilTypes.Atomic (AilTypes.Array elem_ty sz) ->
          (elem_ty, fun z -> AilTypes.Atomic (AilTypes.Array elem_ty z), sz)
      | AilTypes.Array elem_ty sz ->
          (elem_ty, fun z -> AilTypes.Array elem_ty z, sz)
      | _ -> error "TODO(msg): assert false, array_of_character init, no size opt"
    end in
    
    let do_wrap xs =
      List.map (fun z ->
        Just (
          AnnotatedExpression () [] loc (
            AilEconst (ConstantCharacter (Nothing, z))
          )
        )
      ) xs in
    let (new_ty, chars_array) =
      let chars_n = List.length char_strs in
      match current_size_opt with
        | Just _current_n ->
            let current_n = natFromInteger _current_n in
            (current_ty, match compare current_n (chars_n + 1) with
              | EQ ->
                  do_wrap char_strs ++ [Just zeroAil]
              | LT ->
                  do_wrap (List.take current_n char_strs)
              | GT ->
                  do_wrap char_strs ++
                  List.replicate (current_n - chars_n) (Just zeroAil)
            end)
        | Nothing ->
            (mk_ty (Just (integerFromNat chars_n + 1)), do_wrap char_strs ++ [Just zeroAil])
      end in
    let conved_chars_array =
      List.map (function
        | Nothing ->
            Nothing
        | Just z ->
            Just (
              AnnotatedExpression () [] loc (AilEcast AilTypes.no_qualifiers elem_ty z)
            )
      end) chars_array in
    (* TODO: check *)
    E.return
      ( new_ty
      , AnnotatedExpression () [] loc (AilEarray true elem_ty conved_chars_array))
  
  else if (*TODO: An array with element type compatible with a qualified or unqualified version of wchar_t, char16_t, or char32_t *) false then
    error "TODO: wip_desugar_initializer_, An array with element type compatible with a qualified or unqualified version of wchar_t, char16_t, or char32_t"

  else
    let () = Debug.print_debug 1 [] (fun () ->
      "TODO[wip_desugar_initializer_]: in the remaining cases (object that has aggregate or union type), init must Init_list, otherwise this UNDEFINED BEHAVIOUR..." 
    ) in
(*
  if AilTypesAux.is_scalar current_ty then
    (* STD §6.7.9#11 *)
    match init with
      | Init_expr e ->
          E.return e
      | Init_list [(Nothing, Init_expr e)] ->
          E.return e
      | _ ->
          (* STD §6.7.9#11, sentence 1 *)
          (* TODO: that's an undefined behaviour *)
          E.fail loc (Errors.Desugar_ConstraintViolation "§6.7.9#11, sentence 1")
    end >>= fun e ->
    desugar_expression e >>= fun d_e ->
    E.return (current_ty, d_e)
  
  let desugar_struct_union_initializer_ tag =
    match init with
      | Init_expr e ->
          sugar_expression e >>= d_e ->
          E.return (current_ty, d_e)
      | Init_list desigs_opt_inits ->
          
    end
  in
  
  
  match current_ty with
    | ATypes.Struct tag ->
        desugar_struct_initializer_ tag
    | ATypes.Union tag ->
        desugar_union_initializer_ tag
  end
  
  
  
  else *)
    match (AilTypesAux.unatomic current_ty, init) with
      | (ATypes.Struct _, Init_expr e) ->
          (* TODO: hack *)
          desugar_expression e >>= fun d_e ->
          E.return (current_ty, d_e)
      | _ ->
          E.get_tag_definitions >>= fun tagDefs ->
          foo current_ty init >>= fun (current_ty', xs) ->
          
          let () = Debug.print_debug 1 [] (fun () ->
            "current_ty': " ^ Pp.stringFromAil_ctype ATypes.no_qualifiers current_ty' ^
            ", FOO ==> " ^ stringFromList (fun (path, expr) ->
              stringFromInit_path path ^
              " := " ^ Pp.stringFromAil_expression expr
            ) xs
          ) in
          E.return (current_ty', constructValue tagDefs xs current_ty')
    end


  


(* KKKK: new init

 match init with
  | Init_expr e ->
      (* we ignore the type here because the type checking will catch
         errors later *)
      let update_literal_type n =
        match current_ty with
          | ATypes.Array elem_ty Nothing ->
              ATypes.Array elem_ty (Just n)
          | _ ->
              current_ty
      end in
      match dur with
        | ATypes.Automatic ->
            (* TODO: what if the string it too short/long for current_ty *)
            desugar_expression e >>= function
              | (AnnotatedExpression () _ _ (AilEstr (Nothing, str)) as d_e) ->

(* TODO: regarding the twos following commented regions:
         
         first §6.7.9#14 is not a constraint, second the text allows something instead of forbidding something *)
(*
                  if not (AilTypesAux.is_array_of_character current_ty) then
                    E.fail loc (Errors.Desugar_ConstraintViolation "§6.7.9#14")
                  else
*)
                    E.return (update_literal_type (integerFromNat (List.length str + 1)), d_e)
              | (AnnotatedExpression () _ _ (AilEstr (Just Enc_u8, str)) as d_e) ->
(*
                  if not (AilTypesAux.is_array_of_character current_ty) then
                    E.fail loc (Errors.Desugar_ConstraintViolation "§6.7.9#14")
                  else
*)
                    E.return (update_literal_type (integerFromNat (List.length str + 1)), d_e)
              | (AnnotatedExpression () _ _ (AilEstr (Just _, str)) as d_e) ->
                  E.fail loc (Errors.Desugar_NotyetSupported "string litteral initialisation with encoding prefix")
              | d_e ->
                  E.return (current_ty, d_e)
            end
            
        | ATypes.Allocated ->
            error "not possible"
        (* Static | Thread *)
        | _ ->
            let () = Debug.print_debug 1 [] (fun () -> "HELLO Init_expr") in
            desugar_expression e                   >>= fun d_e ->
            is_initializer_constant_expression d_e >>= function
              | true ->
                  match d_e with
                    | AnnotatedExpression () _ _ (AilEstr (Nothing, str)) ->
                        if not (AilTypesAux.is_array_of_character current_ty) then
                          E.fail loc (Errors.Desugar_ConstraintViolation "§6.7.9#14")
                        else
                          E.return (update_literal_type (integerFromNat (List.length str + 1)), d_e)
                    | AnnotatedExpression () _ _ (AilEstr (Just Enc_u8, str)) ->
                        if not (AilTypesAux.is_array_of_character current_ty) then
                          E.fail loc (Errors.Desugar_ConstraintViolation "§6.7.9#14")
                        else
                          E.return (update_literal_type (integerFromNat (List.length str + 1)), d_e)
                    | AnnotatedExpression () _ _ (AilEstr (Just _, str)) ->
                        E.fail loc (Errors.Desugar_NotyetSupported "string litteral initialisation with encoding prefix")
                    | _ ->
                        E.return (current_ty, d_e)
                  end
              | false ->
                  (* NOTE: we don't to check whether d_e is a string literal because the 
                     predicate would have been true. *)
                  E.fail (Loc.locOf e) (Errors.Desugar_ConstraintViolation "§6.7.9#4")
            end
      end
  
  | Init_list desigs_opt_inits ->
      (* NOTE: I know it would be more efficient to factorize these checks, but
         these is more readable *)
      if List.any (function
           | (Just (Desig_array _ :: _), _) -> true
           | _                              -> false
         end) desigs_opt_inits && not (AilTypesAux.is_array current_ty) then
        (* STD §6.7.9#6 *)
        E.fail loc (Errors.Desugar_ConstraintViolation "§6.7.9#6")
      else
      E.get_tag_definitions >>= fun tagDefs ->
      (* TODO: atomic *)
      match current_ty with
        | ATypes.Array elem_ty n_opt ->
            let n = match n_opt with
              | Just z ->
                  z
              | Nothing ->
                  integerFromNat (List.length desigs_opt_inits)
            end in
            let implicit = AnnotatedExpression () [] Loc.unknown (* TODO *) $ AilEconst match dur with
              | ATypes.Automatic ->
                  (* STD §6.7.9#10, first sentence *)
                  ConstantIndeterminate elem_ty
              | ATypes.Allocated ->
                  error "not possible"
              (* Static | Thread *)
              | _ ->
                  static_thread_implicit_initializer tagDefs elem_ty
            end in
            
            E.foldlM (fun (i, acc) (desigs_opt, init) ->
              match desigs_opt with
                | Just (Desig_member _ :: _) ->
                    E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "§6.7.9#7")
                | Just [Desig_array desig_e] ->
                    desugar_expression desig_e               >>= fun d_desig_e ->
                    is_integer_constant_expression d_desig_e >>= function
                      | true ->
                          evaluate_integer_constant_expression (Loc.locOf desig_e) Nothing d_desig_e >>= fun j                  ->
                          wip_desugar_initializer_ loc dur elem_ty init                      >>= fun (elem_ty', d_init) ->
                          (* TODO: use elem_ty' *)
                          (* comparing the specified index with the
                             expected current index *)
                          match compare j i with
                            | LT ->
                                E.fail (Loc.locOf desig_e) (Errors.Desugar_ConstraintViolation "TODO: find the STD text")
                            | EQ ->
                                E.return (i+1, Just d_init :: acc)
                            | GT ->
                                (*  *)
                                E.return (j+1, Just d_init :: (Utils.replicate_list (Just implicit) (natFromInteger $ j-i)) ++ acc)
                          end
                      | false ->
                          E.fail (Loc.locOf desig_e) (Errors.Desugar_ConstraintViolation "§6.7.9#6")
                    end
                | Nothing ->
                    wip_desugar_initializer_ loc dur elem_ty init >>= fun (elem_ty', d_init) ->
                    (* TODO: use elem_ty' *)
                    E.return (i+1, Just d_init :: acc)
                | _ ->
                    (* Multi-array designator *)
                    E.fail Loc.unknown (Errors.Desugar_NotyetSupported "sucks to be you")
              end
            ) (0, []) desigs_opt_inits >>= fun (_, xs_rev) ->
            
            let conved_elems =
              List.map (function
                | Nothing ->
                    Nothing
                | Just z ->
                    Just (
                      AnnotatedExpression () [] loc (AilEcast AilTypes.no_qualifiers elem_ty z)
                    )
              end) (List.reverse (Utils.replicate_list (Just implicit) (natFromInteger n - List.length xs_rev) ++ xs_rev)) in
            E.return
              ( ATypes.Array elem_ty (Just n)
              , AnnotatedExpression () [] Loc.unknown(* TODO *)
                  (* TODO: should use ConstantArray when possible *)
                  (AilEarray false elem_ty conved_elems) )
        
        | ATypes.Struct tag ->
            (* TODO: check the STD!!!!! *)
            E.resolve_tag_definition tag >>= function
              | Just (Struct_definition isAnonymous ident_tys) ->
                  (* TODO: (for now) only allowing explicit and complete initializer *)
                  if List.all (function
                       | (Just [Desig_member _], Init_expr _) -> true
                       | _                                    -> false
                     end) desigs_opt_inits then
                    E.foldlM (fun acc desigs_opt_init ->
                      match desigs_opt_init with
                        | (Just [Desig_member ident], Init_expr e) ->
                            desugar_expression e >>= fun d_e ->
                            E.return $ (ident, d_e) :: acc
                        | _ ->
                            error "TODO: Cabs_to_ail.wip_desugar_initializer_, Struct, Struct_definition, not Desig_member vs Init_expr"
                      end
                    ) [] desigs_opt_inits >>= fun xs_rev ->
                    E.return
                      ( current_ty
                      , AnnotatedExpression () [] Loc.unknown(* TODO *) (
                          AilEstruct tag (List.map (fun (ident, _) -> (ident, List.lookup ident xs_rev)) ident_tys)
                        ) )
                  
                  (* TODO: OR a flat implicit initializer *)
(*                else if List.all (function
                            | (Nothing, Init_expr _) -> true
                            | _                      -> false
                          end) desigs_opt_inits then
                    E.foldlM (fun desigs_opt_init acc ->
                      match desigs_opt_init with
                        | ((ident, _), (Nothing, Init_expr e)) ->
                            desugar_expression e >>= fun d_e ->
                            E.return $ (ident, Just d_e) :: acc
                        | _ ->
                            error "WIP: Cabs_to_ail.wip_desugar_initializer_, Struct, Struct_definition, else"
                      end
                    ) (List.zip ident_tys desigs_opt_inits) [] >>= fun xs_rev ->
                    
                    E.return $
                      AnnotatedExpression () Loc.unknown(* TODO *) (
                        AilEstruct tag (List.reverse xs_rev)
                      )
*)
                  else if is_fully_non_designated desigs_opt_inits then
                    E.foldlM (fun acc desigs_opt_init ->
                      match desigs_opt_init with
                        | ((ident, (_, _)), (Nothing, Init_expr e)) ->
                            desugar_expression e >>= fun d_e ->
                            E.return $ (ident, Just d_e) :: acc
                        | ((ident, (_, membr_ty)), (Nothing, init)) ->
                            (* we ignore the qualifiers, initialisers don't care about them *)
                            wip_desugar_initializer_ loc dur membr_ty init >>= fun (membr_ty', d_e) ->
                            (* TODO: use membr_ty' *)
                            E.return $ (ident, Just d_e) :: acc
(*                      | ((ident, membr_ty), (Nothing, Init_list non_designated_inits)) ->
                            E.mapM (fun (Nothing, init) ->
                              wip_desugar_initializer_ loc dur membr_ty init
                            ) non_designated_inits >>= fun d_es ->
                            E.return (ident,
                              match membr_ty with
                                | Array elem_ty _ ->
                                    AilEarray elem_ty d_es
                                | Struct tag_sym ->
                                    AilEstruct 
                              end    *)
                        | _ ->
                            error "TODO: Cabs_to_ail.wip_desugar_initializer_, Struct, Struct_definition, else"
                      end
                    ) [] (List.zip ident_tys desigs_opt_inits) >>= fun xs_rev ->
                    E.return
                      ( current_ty
                      , AnnotatedExpression () [] Loc.unknown(* TODO *) (
                          AilEstruct tag (List.reverse xs_rev)
                        ) )
                  
                  else
                    (* TODO: crazy stuff we don't deal with yet *)
                    E.fail loc (Errors.Desugar_NotyetSupported "crazy struct initializers")

              | _ ->
                  E.fail loc (Errors.Desugar_OtherViolation "[TODO msg], Struct init thing")
            end

        | ATypes.Union tag ->
            (* TODO: check the STD, the following is mostly improvised... *)
            E.resolve_tag_definition tag >>= function
              | Just (Union_definition isAnonymous ident_tys) ->
                  match desigs_opt_inits with
                    | [(Nothing, init')] ->
                        let (first_ident, (_, first_ty)) = match ident_tys with
                          | [] ->
                              (* NOTE: I don't the parser can produce an empty Union_definition *)
                              error "Cabs_to_ail.wip_desugar_initializer_ ==> empty Union_definition"
                          | z :: _ ->
                              z
                        end in
                        (* we ignore the qualifiers, initialisers don't care about them *)
                        wip_desugar_initializer_ loc dur first_ty init' >>= fun (first_ty', d_e) ->
                        (* TODO: use first_ty' *)
                        E.return
                          ( current_ty
                          , AnnotatedExpression () [] loc (
                              AilEunion tag first_ident (Just d_e)
                            )
                          )
                    | [(Just [Desig_member memb_ident], init')] ->
                        match List.lookup memb_ident ident_tys with
                          | Just (_, ty) ->
                              (* we ignore the qualifiers, initialisers don't care about them *)
                              E.return ty
                          | Nothing ->
                              E.fail loc (Errors.Desugar_InvalidMember memb_ident current_ty)
                        end >>= fun memb_ty ->
                        wip_desugar_initializer_ loc dur memb_ty init' >>= fun (membr_ty', d_e) ->
                        (* TODO: use membr_ty' *)
                        E.return
                          ( current_ty
                          , AnnotatedExpression () [] loc (
                              AilEunion tag memb_ident (Just d_e)
                            )
                          )
                    | _ ->
                        (* NOTE: finding a Desig_array here should be impossible
                           before of an earlier check *)
                        error "TODO: Cabs_to_ail.wip_desugar_initializer_, not a singleton list"
                  end
(*  list (maybe (list designator) * initializer_)  *)
(*                let () = Debug.print_debug 1
                      ("UNION INIT ==> " ^ stringFromList (stringFromPair show Pp.stringFromAil_ctype) ident_tys)in
                  E.fail loc (Errors.Desugar_OtherViolation "TODO union init") *)
              | _ ->
                  E.fail loc (Errors.Desugar_OtherViolation "[TODO msg], Union init thing")
            end

(*
        | ATypes.Array elem_ty Nothing ->
            let _ = desigs_opt_inits in
            E.fail loc (Errors.Desugar_NotyetSupported "not allowing array with no size for now")
*)

        (* NOTE: should be a scalar type *)
        | _ ->
            (* STD §6.7.9#11, sentence 1 *)
            match desigs_opt_inits with
              (* this the "optionaly enclosed in braces" case from (§6.7.9#11, sentence 1) *)
              | [(Nothing, init)] ->
                  wip_desugar_initializer_ loc dur current_ty init
              | _ ->
                  (* TODO: this (at leat) possible with something like:
                       int a = {1, 2}; *)
                  error "TODO: error message. is that even a possible case? (11)"
            end

      end
end
*)



and desugar_and_register_static_assert_declaration sa_decl =
  match sa_decl with
   | Static_assert e lit ->
       desugar_expression e >>= fun d_e ->
       is_integer_constant_expression d_e >>= function
         | false ->
             E.fail Loc.unknown (Errors.Desugar_UndefinedBehaviour Undefined.UB204_illtyped_Static_assert)
         | true ->
             evaluate_integer_constant_expression Loc.unknown Nothing d_e >>= fun n ->
             if n = 0 then
               E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "§6.7.10#3 Static_assert(The constant expression shall compare unequal to 0.)")
             else
               E.return ()
         end
  end


(* TODO: this is broken *)
val desugar_declaration_base: specifiers -> list init_declarator -> E.desugM (list (identifier * expression unit))
let desugar_declaration_base specifs idecltors =
  let () = Debug.print_debug 1 [] (fun () ->
    "BROKEN: desugar_declaration_base"
  ) in
          desugar_type_specifiers specifs.type_specifiers >>= fun (specs_qs, base_ty) ->
          (* for each [init_declarator] *)
          E.foldlM (fun acc init ->
            (* NOTE: the wf of the storage classes is checked later (see the
               pattern match on [ty]) *)
            let (isAtomic, tquals_qs) = translate_type_qualifiers specifs.type_qualifiers in
            let base_qs = AilTypesAux.combine_qualifiers specs_qs tquals_qs in
            desugar_init_declarator_BROKEN base_qs base_ty specifs.storage_classes init >>= fun (ident, is_tentative, (qs, _ty), mk_desug_init) ->
            let ty = if isAtomic then ATypes.Atomic _ty else _ty in
            
            if is_tentative then
              (* NOTE: this shouldn't be possible since tentative definition are file scoped *)
              error "Cabs_to_ail.desugar_declaration_base found a positive is_tentative"
            
            else if specifs.storage_classes = [SC_typedef] then
              (* Case of a typedef *)
              E.register_typedef ident (qs, ty) >>
              E.return acc
              
            else match ty with
              | ATypes.Function _ return_qs_ty params is_variadic ->
                  check_storage_class_specifiers Function_decl_context specifs.storage_classes >>= fun () ->
                  E.register_ordinary_identifier ident
                    E.OK_function specifs.storage_classes >>= fun (_, sym) ->
                  E.register_function_declaration (Loc.locOf ident) sym true (
                    return_qs_ty,
                    Just params, (* TODO: KKKK !!!! *)
                    is_variadic,
                    List.elem FS_inline   specifs.function_specifiers,
                    List.elem FS_Noreturn specifs.function_specifiers
                  ) >>
                  E.return acc
              | _ ->
                  check_storage_class_specifiers Object_decl_context specifs.storage_classes >>= fun () ->
                  E.register_ordinary_identifier ident
                    (E.OK_object false) specifs.storage_classes >>= fun (link, sym) ->
                  let ident_loc = Loc.locOf ident in
                  
                  (* TODO: STD check+quote *)
                  E.get_tag_definitions >>= fun ident_tagDefs ->
                  let (fake_ail_sigma : sigma unit) = <|
                    declarations= [];
                    object_definitions= [];
                    function_definitions= [];
                    static_assertions= [];
                    tag_definitions=
                      List.foldl (fun acc (ident, tagDef) ->
                        match tagDef with
                          | Struct_definition _ xs ->
                              (ident, StructDef xs) :: acc
                          | Union_definition _ xs ->
                              (ident, UnionDef xs) :: acc
                          | Enum_definition _ ->
                              acc
                        end
                      ) [] (Map_extra.toList ident_tagDefs);
                  |> in
                  let dur = determinate_storage_duration link specifs.storage_classes in
                  E.register_internal_object_declaration ident_loc sym
                    (dur, List.elem SC_register specifs.storage_classes, qs, ty) >>
                  mk_desug_init () >>= function
                    | Just (ty', d_e) ->
                        let () = Debug.print_debug 1 [] (fun () ->
                          "Hello, ty' = " ^ Pp.stringFromAil_ctype ATypes.no_qualifiers ty'
                        ) in
                        begin if ty <> ty' then
                          let () = Debug.print_debug 1 [] (fun () ->
                            "ty' is new"
                          ) in
                          (* TODO: tentative *)
                          E.update_internal_object_type sym ty'
(*
                          E.register_internal_object_declaration ident_loc sym
                            (dur, List.elem SC_register specifs.storage_classes, qs, ty')
*)
                        else
                          E.return ()
                        end >>
                        E.return (ty', (sym, d_e) :: acc)
                    | Nothing ->
                        E.return (ty, acc)
                  end >>= fun (ty', ret) ->
                  if link = Linkage_none && AilTypesAux.is_incomplete fake_ail_sigma ty' then
                    E.fail (*TODO*)(Loc.locOf ident) (Errors.Desugar_ConstraintViolation "§6.7#7 (desugar_declaration_base)")
                  else
                    E.return ret
            end
          ) [] idecltors >>= (List.reverse |- E.return)



type stmt_context = <|
  switch_depth: nat;
  cont_ident_opt: maybe cabs_identifier; (* Just ..., if inside a loop *)
|>

let rec desugar_statement_aux ctx (CabsStatement loc stmt_) =
  let self = desugar_statement_aux ctx in
  AnnotatedStatement loc <$>
    match stmt_ with
      | CabsSlabel ident s ->
	  AilSlabel <$> E.resolve_label ident
                    <*> self s
      
      | CabsScase e s ->
          if ctx.switch_depth > 0 then
            AilScase <$> (desugar_expression e >>=
                          evaluate_integer_constant_expression (Loc.locOf e) Nothing >>= fun n ->
                          E.return (IConstant n Decimal Nothing))
                     <*> self s
          else
            E.fail loc (Errors.Desugar_ConstraintViolation "§6.8.1#2")
      
      | CabsSdefault s ->
          if ctx.switch_depth > 0 then
            AilSdefault <$> self s
          else
            E.fail loc (Errors.Desugar_ConstraintViolation "§6.8.1#2")
      
      | CabsSblock ss ->
          (* TODO: STD check + annot *)
          E.fresh_block_scope >>= fun scope ->
          E.with_scope scope (
            E.mapM self ss
          ) >>= fun (bs, d_ss) ->
          
          (* this is removing unnecessary blocks introduced by the desugared.
             TODO: check carefully that we don't remove source blocks *)
          let d_ss' =
            List.foldr (fun z acc ->
              match z with
                | (CabsStatement _ (CabsSblock _), AnnotatedStatement _ (AilSblock _ _)) ->
                    (* this is the case of a block already present in the Cabs code. *)
                    snd z :: acc
                | (_, AnnotatedStatement _ (AilSblock [] xs)) ->
                    (* here a block with no local variables was introduced by the desugaring *)
                    xs ++ acc
                | _ ->
                    snd z :: acc
              end
            ) [] (List.zip ss d_ss) in
          
          E.return (AilSblock bs d_ss')
      
      | CabsSdecl (Declaration_base specifs idecltors) ->
          function
            | [] ->
                AilSskip
            | xs ->
                AilSdeclaration xs
          end <$> desugar_declaration_base specifs idecltors
      
      | CabsSdecl (Declaration_static_assert sa_decl) ->
          desugar_and_register_static_assert_declaration sa_decl >>
          (* TODO: hackish *)
          E.return AilSskip
      
      | CabsSnull ->
          E.return AilSskip
      
      | CabsSexpr e ->
          AilSexpr <$> desugar_expression e
      
      | CabsSif e s1 s2_opt ->
          (* TODO: check *)
          AilSif <$> desugar_expression e
                 <*> self s1
                 <*> maybe (E.return $ AnnotatedStatement Loc.unknown AilSskip) self s2_opt
      
      | CabsSswitch e s ->
          let ctx' = <| ctx with switch_depth= ctx.switch_depth + 1 |> in
          (* TODO: check *)
          AilSswitch <$> desugar_expression e
                     <*> desugar_statement_aux ctx' s
      
      | CabsSwhile e s ->
          E.freshify (CabsIdentifier loc "continue") >>= fun cont_ident ->
          E.register_label cont_ident >>
          E.resolve_label cont_ident >>= fun cont_sym ->
          let ctx' =
            <| ctx with cont_ident_opt= Just cont_ident |> in
          desugar_expression e         >>= fun d_e ->
          desugar_statement_aux ctx' s >>= fun d_s ->
          E.return begin
              AilSwhile d_e begin
                AnnotatedStatement loc begin
                  AilSblock [] [d_s; AnnotatedStatement loc (AilSlabel cont_sym (AnnotatedStatement loc AilSskip))]
                end
              end
          end
      
      | CabsSdo e s ->
          E.freshify (CabsIdentifier loc "continue") >>= fun cont_ident ->
          E.register_label cont_ident >>
          E.resolve_label cont_ident >>= fun cont_sym ->
          let ctx' =
            <| ctx with cont_ident_opt= Just cont_ident |> in
          desugar_expression e         >>= fun d_e ->
          desugar_statement_aux ctx' s >>= fun d_s ->
          E.return begin
              AilSdo begin
                AnnotatedStatement loc begin
                  AilSblock [] [d_s; AnnotatedStatement loc (AilSlabel cont_sym (AnnotatedStatement loc AilSskip))]
                end
              end d_e
          end
      
      | CabsSfor (Just (FC_decl ((Declaration_base specifs idecltors)))) e2_opt e3_opt s ->
          E.freshify (CabsIdentifier loc "continue") >>= fun cont_ident ->
          E.register_label cont_ident >>
          E.resolve_label cont_ident >>= fun cont_sym ->
          let ctx' =
            <| ctx with cont_ident_opt= Just cont_ident |> in
          
          (* TODO: this is not really a block scope (...) *)
          E.fresh_block_scope >>= fun scope ->
          E.with_scope scope (
            desugar_type_specifiers specifs.type_specifiers >>= fun (specs_qs, base_ty) ->
            let (isAtomic, tquals_qs) = translate_type_qualifiers specifs.type_qualifiers in
            let base_qs = AilTypesAux.combine_qualifiers specs_qs tquals_qs in
            E.mapM (fun init ->
              check_storage_class_specifiers Object_decl_context specifs.storage_classes >>= fun () ->
              desugar_init_declarator isAtomic base_qs base_ty specifs.storage_classes init
            ) idecltors  >>= fun xs ->
            (* for each [init_declarator] *)
            E.foldrM (fun opt (acc1, acc2) ->
              match opt with
                | Nothing ->
                    (* Case of a typedef *)
                    E.fail loc (Errors.Desugar_ConstraintViolation "§6.8.5#3")
                
                | Just (ident_loc, link, sym, is_tentative, (qs, ty), mk_desug_init) ->
                    if is_tentative then
                      (* NOTE: this shouldn't be possible since tentative definition are file scoped *)
                      error "Cabs_to_ail.desugar_statement, CabsSfor found a positive is_tentative"
                    
                    else if not (specifs.storage_classes = []        ||
                                 specifs.storage_classes = [SC_auto] ||
                                 specifs.storage_classes = [SC_register]) then
                      (* NOTE: amusingly, as it is written, the STD doesn't allow the absence of storage-class ... *)
                      E.fail loc (Errors.Desugar_ConstraintViolation "§6.8.5#3")
                    
                    else match ty with
                      | ATypes.Function _ _ _ _ ->
                          E.fail loc (Errors.Desugar_ConstraintViolation "§6.8.5#3")
                      | _ ->
                          mk_desug_init () >>= function
                            | Just (ty', d_e) ->
                                let dur = determinate_storage_duration link specifs.storage_classes in
                                let () = Debug.print_debug 1 [] (fun () ->
                                  "Hello, ty' = " ^ Pp.stringFromAil_ctype ATypes.no_qualifiers ty'
                                ) in
                                begin if ty <> ty' then
                                  let () = Debug.print_debug 1 [] (fun () ->
                                    "ty' is new"
                                  ) in
                                  (* TODO: tentative *)
                                  E.register_internal_object_declaration ident_loc sym
                                    (dur, List.elem SC_register specifs.storage_classes, qs, ty')
                                else
                                  E.register_internal_object_declaration ident_loc sym
                                    (dur, List.elem SC_register specifs.storage_classes, qs, ty)
                                end >>= fun () ->
                                E.return ( (sym, d_e) :: acc1
                                         , (sym, ((dur, List.elem SC_register specifs.storage_classes), qs, ty)) :: acc2 )
                            | Nothing ->
                                let dur = determinate_storage_duration link specifs.storage_classes in
                                E.register_internal_object_declaration ident_loc sym
                                  (dur, List.elem SC_register specifs.storage_classes, qs, ty) >>= fun () ->
                                E.return ( acc1
                                         , (sym, ((dur, List.elem SC_register specifs.storage_classes), qs, ty)) :: acc2 )
                          end
                    end
              end) ([], []) (List.reverse xs) >>= fun (sym_d_es, bindings) ->
              (* see (§6.8.5.3#2, second sentence) for the Nothing case *)
              maybe (E.return oneAil) desugar_expression e2_opt >>= fun d_e2 ->
              desugar_statement_aux ctx' s                      >>= fun d_s  ->
              match e3_opt with
                | Just e3 ->
                    desugar_expression e3 >>= fun d_e3 ->
                    let d_s_e3 = AnnotatedStatement Loc.unknown $ AilSexpr d_e3 in
                    E.return match d_s with
                      | AnnotatedStatement loc' (AilSblock bindings d_ss) ->
                          AnnotatedStatement loc' (
                            AilSblock bindings (d_ss ++ [AnnotatedStatement loc (AilSlabel cont_sym d_s_e3)])
                          )
                      | _ ->
                          AnnotatedStatement loc (
                            AilSblock [] [d_s; AnnotatedStatement loc (AilSlabel cont_sym d_s_e3)]
                          )
                    end
                | Nothing ->
                    E.return begin
                      AnnotatedStatement loc (
                        AilSblock [] [ d_s
                                     ; AnnotatedStatement loc (AilSlabel cont_sym (AnnotatedStatement loc AilSskip)) ]
                      )
                    end
              end >>= fun d_s_body ->
              E.return $
                AilSblock bindings [
                  AnnotatedStatement loc (AilSdeclaration sym_d_es);
                  AnnotatedStatement loc (AilSwhile d_e2 d_s_body)
                ]
          ) >>= fun (_, ret) ->
          E.return ret
      
      | CabsSfor fc_opt e2_opt e3_opt s ->
          E.freshify (CabsIdentifier loc "continue") >>= fun cont_ident ->
          E.register_label cont_ident >>
          E.resolve_label cont_ident >>= fun cont_sym ->
          let ctx' =
            <| ctx with cont_ident_opt= Just cont_ident |> in
          
          (* see (§6.8.5.3#2, second sentence) for the Nothing case *)
          (* for (...; ; ...) ...   ==> { ...; while(1) ... } *)
          maybe (E.return oneAil) desugar_expression e2_opt >>= fun d_e2 ->
          desugar_statement_aux ctx' s                      >>= fun d_s  ->
          match e3_opt with
            | Nothing ->
                E.return begin
                  AnnotatedStatement loc (
                    AilSlabel cont_sym (AnnotatedStatement loc AilSskip)
                  )
                end
            | Just e3 ->
                desugar_expression e3 >>= fun d_e3 ->
                E.return begin
                  AnnotatedStatement loc (
                    AilSlabel cont_sym (AnnotatedStatement (Loc.locOf e3) (AilSexpr d_e3))
                  )
                end
          end >>= fun d_s_e3 ->
          match (fc_opt, e3_opt) with
            | (Just (FC_expr e1), e3_opt) ->
                (* for (E1; E2; E3) S ==> { E1; while(E2) { S'; cont: E3   } }  *)
                (* for (E1; E2; ) S   ==> { E1; while(E2) { S'; cont: skip } }  *)
                desugar_expression e1 >>= fun d_e1 ->
                let d_s_e1 =
                  AnnotatedStatement (Loc.locOf e1) (AilSexpr d_e1) in
                let d_s_body = match d_s with
                  | AnnotatedStatement loc (AilSblock bs d_ss) ->
                      AnnotatedStatement loc (AilSblock bs (d_ss ++ [d_s_e3]))
                  | _ ->
                      AnnotatedStatement loc (AilSblock [] [d_s; d_s_e3])
                end in
                E.return begin
                  AilSblock [] [ d_s_e1
                               ; AnnotatedStatement loc (AilSwhile d_e2 d_s_body) ]
                end
            | (Just (FC_decl (Declaration_base _ _)), _) ->
                E.fail loc Errors.Desugar_impossible
            | (Just (FC_decl (Declaration_static_assert sa_decl)), e3_opt) ->
                (* for (_Static_assert(...); E2; E3) S ==> while(E2) { S'; cont: E3 } *)
                (* for (_Static_assert(...); E2; ) S ==> while(E2) { S'; cont: skip } *)
                desugar_and_register_static_assert_declaration sa_decl >>
                let d_s_body = match d_s with
                  | AnnotatedStatement loc (AilSblock bs d_ss) ->
                      AnnotatedStatement loc (AilSblock bs (d_ss ++ [d_s_e3]))
                  | _ ->
                      AnnotatedStatement Loc.unknown $
                        AilSblock [] [d_s; d_s_e3]
                end in
                E.return (AilSwhile d_e2 d_s_body)
            | (Nothing, e3_opt) ->
                (* for (; E2; E3) S ==> while(E2) { S'; cont: E3 } *)
                (* for (; E2; ) S ==> while(E2) { S'; cont: skip } *)
                let d_s_body = match d_s with
                  | AnnotatedStatement loc (AilSblock bs d_ss) ->
                      AnnotatedStatement loc (AilSblock bs (d_ss ++ [d_s_e3]))
                  | _ ->
                      AnnotatedStatement Loc.unknown $
                        AilSblock [] [d_s; d_s_e3]
                end in
                E.return (AilSwhile d_e2 d_s_body)
          end
      
      | CabsSgoto ident ->
          AilSgoto <$> E.resolve_label ident
      
      | CabsScontinue ->
          match ctx.cont_ident_opt with
            | Nothing ->
                E.fail loc (Errors.Desugar_ConstraintViolation "§6.8.6.2#1")
            | Just cont_ident ->
                self (CabsStatement loc (CabsSgoto cont_ident)) >>= fun (AnnotatedStatement _ stmt_) ->
                E.return stmt_
          end
      
      | CabsSbreak ->
          if ctx.switch_depth > 0 then
            E.return AilSbreak
          else match ctx.cont_ident_opt with
            | Just _ ->
                E.return AilSbreak
            | Nothing ->
                E.fail loc (Errors.Desugar_ConstraintViolation "§6.8.6.3#1")
          end
      
      | CabsSreturn Nothing ->
          E.get_current_return_type >>= function
            | ATypes.Void ->
                E.return AilSreturnVoid
            | _ ->
                E.fail loc Errors.Desugar_NonvoidReturn
          end
      
      | CabsSreturn (Just e) ->
          E.get_current_return_type >>= function
            | ATypes.Void ->
                E.fail loc (Errors.Desugar_ConstraintViolation "§6.8.6.4#1, 1st sentence")
            | _ ->
                AilSreturn <$> desugar_expression e
          end
      
      | CabsSpar ss ->
          AilSpar <$> E.mapM self ss
    end

val desugar_statement: cabs_statement -> E.desugM (statement unit)
let desugar_statement stmt =
  desugar_statement_aux <| switch_depth= 0; cont_ident_opt= Nothing |> stmt


val     register_labels: cabs_statement -> E.desugM unit
let rec register_labels (CabsStatement _ stmt_) =
  match stmt_ with
    | CabsSlabel ident s ->
        E.register_label ident >>
        register_labels s
    | CabsScase _ s ->
        register_labels s
    | CabsSdefault s ->
        register_labels s
    | CabsSblock ss ->
        E.mapM_ register_labels ss
    | CabsSdecl _ ->
        E.return ()
    | CabsSnull ->
        E.return ()
    | CabsSexpr _ ->
        E.return ()
    | CabsSif _ s1 s2_opt ->
        register_labels s1 >>
        maybe (E.return ()) register_labels s2_opt
    | CabsSswitch _ s ->
        register_labels s
    | CabsSwhile _ s ->
        register_labels s
    | CabsSdo _ s ->
        register_labels s
    | CabsSfor _ _ _ s ->
        register_labels s
    | CabsSgoto _ ->
        E.return ()
    | CabsScontinue ->
        E.return ()
    | CabsSbreak ->
        E.return ()
    | CabsSreturn _ ->
        E.return ()
    | CabsSpar _ ->
        (* TODO: temporary *)
        E.return ()
  end


(* TODO: check + annotate with STD *)
val desugar_and_register_function_definition: function_definition -> E.desugM unit
let desugar_and_register_function_definition (FunDef fundef_loc specifs (Declarator ptr_decltor_opt ddecltor as decltor) stmt) =
  if List.any (fun sc -> SC_extern <> sc && SC_static <> sc) specifs.storage_classes then
    E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "§6.9.1#4")
  else
    (* NOTE: §6.9.1#5 is enforces inside the following call to
       'desugar_declarator' (see 'desugar_direct_declarator') *)

    E.with_scope2 E.Scope_prototype (*TODO: make it a block*) begin
      desugar_declarator IsFunDef decltor
    end >>= fun (idents_map, (fun_ident, mk_qs_ctype)) ->
    
    E.register_ordinary_identifier fun_ident E.OK_function specifs.storage_classes >>= fun (_, fun_sym) ->
    
    (E.void -| E.with_scope E.Scope_function) begin
      register_labels stmt >>
      
      E.fresh_block_scope >>= fun funblock_scope ->
      E.with_scope funblock_scope begin
          (* TODO: this is a horrible hack, DO BETTER *)
          E.hack_inject_idents_map idents_map >>


(*        desugar_declarator (IsFunDef specifs) decltor >>= fun (fun_ident, mk_qs_ctype) -> *)
        desugar_type_specifiers specifs.type_specifiers >>= fun (specs_qs, specs_ty)  ->
        let (isAtomic, tquals_qs) = translate_type_qualifiers specifs.type_qualifiers in
        let base_ty = if isAtomic then ATypes.Atomic specs_ty else specs_ty in
        let base_qs = AilTypesAux.combine_qualifiers specs_qs tquals_qs     in
        
        let (qs, ty) = mk_qs_ctype base_qs base_ty in
        match ty with
          | ATypes.Function has_proto (return_qs, return_ty) params isVariadic ->
              (* NOTE: the constraint in §6.9.1#3 is enforced later in the Ail
                 typechecker *)
              let () = Debug.print_debug 4 [] (fun () ->
                show fun_ident ^ " ===> " ^ Pp.stringFromAil_ctype qs ty
              ) in
              
              E.function_is_defined fun_sym >>= function
                | true  -> E.fail Loc.unknown (Errors.Desugar_FunctionRedefinition fun_sym)
                | false -> E.return ()
              end >>
              
              E.register_function_declaration (Loc.locOf fun_ident) fun_sym false (
                (return_qs, return_ty),
                Just params, (* TODO: KKKK !!!! *)
                isVariadic,
                List.elem FS_inline   specifs.function_specifiers,
                List.elem FS_Noreturn specifs.function_specifiers
               ) >>
              
              E.set_current_return_type return_ty >>
              desugar_statement stmt >>= fun d_stmt ->
              E.return (Loc.locOf fun_ident, fun_sym, d_stmt)
        | _ ->
            (* STD §6.9.1#2 *)
            E.fail fundef_loc (Errors.Desugar_ConstraintViolation "§6.9.1#2")
        end
      end >>= fun (_, (loc, fun_sym, d_stmt)) ->
      E.bindings_of_idents_map idents_map >>= fun bindings ->
      E.register_function_definition fun_sym
      (* NOTE: the Cabs parser can't easily find the location of the
         function identifier, so add it here *)
      (Loc.with_cursor_from fundef_loc loc, List.map fst bindings, d_stmt)
    end


val desugar_and_register_external_declaration: external_declaration -> E.desugM unit
let desugar_and_register_external_declaration edecl =
  let storage_classes =
    maybe [] (fun z -> z.storage_classes) (specifiers_of_external_declaration edecl) in
  
  (* STD §6.9#2 *)
  if List.any (fun z -> z = SC_auto || z = SC_register) storage_classes then
    E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "§6.9#2")
  
  else match edecl with
    | EDecl_func fdef ->
        desugar_and_register_function_definition fdef
    
    (* struct-or-union identifier ; *)
    | EDecl_decl (Declaration_base <|
        storage_classes= [];
        type_specifiers= [TSpec_struct (Just ident) Nothing];
        type_qualifiers= [];
        function_specifiers= [];
        alignment_specifiers= [];
      |> []) ->
        (* TODO: check *)
        (* STD §6.7.2.3#7 *)
        E.void (E.register_tag E.Kind_struct (Just ident))
(*        error "TODO: §6.7.2.3#7" *)
    
    (* TODO: check *)
    | EDecl_decl (Declaration_base specifs idecltors) ->
        desugar_type_specifiers specifs.type_specifiers >>= fun (specs_qs, base_ty)  ->
        let (isAtomic, tquals_qs) = translate_type_qualifiers specifs.type_qualifiers in
        let base_qs = AilTypesAux.combine_qualifiers specs_qs tquals_qs in
        (* TODO: why the two maps? *)
        (* NOTE: this is (at least) needed to got the scope of typedefs right
           (see suite/parsing/declarator_visibility.c) *)
        (* NOTE: `desugar_init_declarator' does register the identifier it finds *)
        E.mapM (fun init ->
          desugar_init_declarator isAtomic base_qs base_ty specifs.storage_classes init
        ) idecltors >>= fun xs ->
        
        (* for each [init_declarator] *)
        E.mapM_ (function
          | Nothing ->
              (* Case of a typedef *)
              E.return ()
          | Just (ident_loc, link, sym, isTentative, (qs, ty), mk_desug_init) ->
              (* NOTE: `desugar_init_declarator' takes care of isAtomic *)
              match ty with
                | ATypes.Function _ return_ty params is_variadic ->
                    E.register_function_declaration ident_loc sym true (
                      return_ty,
                      Just params, (* TODO: KKKK !!!! *)
                      is_variadic,
                      List.elem FS_inline   specifs.function_specifiers,
                      List.elem FS_Noreturn specifs.function_specifiers
                    )
                | ty ->
                    let dur = determinate_storage_duration link specifs.storage_classes in
                    E.register_external_object_declaration ident_loc sym
                      (isTentative, dur, List.elem SC_register specifs.storage_classes, qs, ty) >>
                    
                    (* TODO: STD check+quote *)
                    E.get_tag_definitions >>= fun ident_tagDefs ->
                    let (fake_ail_sigma : sigma unit) = <|
                      declarations= [];
                      object_definitions= [];
                      function_definitions= [];
                      static_assertions= [];
                      tag_definitions=
                        List.reverse begin
                          List.foldl (fun acc (ident, tagDef) ->
                            match tagDef with
                              | Struct_definition _ xs ->
                                  (ident, StructDef xs) :: acc
                              | Union_definition _ xs ->
                                  (ident, UnionDef xs) :: acc
                              | Enum_definition _ ->
                                  acc
                            end
                          ) [] (Map_extra.toList ident_tagDefs)
                        end;
                    |> in
                    
                    mk_desug_init () >>= function
                      | Just (ty', d_e) ->
                          let () = Debug.print_debug 1 [] (fun () ->
                            "Hello, ty' = " ^ Pp.stringFromAil_ctype ATypes.no_qualifiers ty'
                          ) in
                          begin if ty <> ty' then
                            let () = Debug.print_debug 1 [] (fun () ->
                              "ty' is new"
                            ) in
                            (* TODO: tentative *)
                            E.update_external_object_type sym ty'
                          else
                            E.return ()
                          end >>
                          (* NOTE: it is the type after the initialisation which must be complete *)
                          if link = Linkage_none && AilTypesAux.is_incomplete fake_ail_sigma ty' then
                            E.fail (*TODO*)Loc.unknown (Errors.Desugar_ConstraintViolation "§6.7#7 (desugar_and_register_external_declaration), with init")
                          else
                            (* TODO: use ty' *)
                            (* STD §6.9#3, first sentence *)
                            E.external_object_is_defined sym >>= function
                              | true ->
                                  E.fail (*TODO*)Loc.unknown (Errors.Desugar_ExternalObjectRedefinition sym)
                              | false ->
                                  E.register_external_object_definition sym d_e
                            end
                      | Nothing ->
                          if link = Linkage_internal && AilTypesAux.is_incomplete fake_ail_sigma ty then
                            (* TODO: this is wrong (see tentative definition in the STD) *)
                            E.fail (*TODO*)Loc.unknown (Errors.Desugar_ConstraintViolation "§6.9.2#3")
                          else if link = Linkage_none && AilTypesAux.is_incomplete fake_ail_sigma ty then
                            E.fail (*TODO*)Loc.unknown (Errors.Desugar_ConstraintViolation "§6.7#7 (desugar_and_register_external_declaration), no init")
                          else
                            E.return ()
                    end
              end
        end) xs
  
    | EDecl_decl (Declaration_static_assert sa_decl) ->
        desugar_and_register_static_assert_declaration sa_decl
  end


import Core
val desugar: nat -> (map string Symbol.sym) * Core.fun_map unit * Core.impl -> string -> translation_unit ->
  Exception.exceptM (UniqueId.supply Symbol.sym * ail_program unit) Errors.error
let desugar sym_counter core_eval_stuff startup_str (TUnit edecls) =
(*
  E.eval sym_counter core_eval_stuff (
    E.with_scope E.Scope_file (
      let (base_qs1, base_ty1, ptr_decltor1) =
        ( ATypes.make_qualifiers true false false
        , ATypes.Basic (ATypes.Integer (ATypes.Signed ATypes.Int_))
        , PDecl [] (Just (PDecl [] Nothing)) ) in (* int const **ptrToPtrToConstInt *)
      
      let (base_qs2, base_ty2, ptr_decltor2) =
        ( ATypes.no_qualifiers
        , ATypes.Basic (ATypes.Integer (ATypes.Signed ATypes.Int_))
        , PDecl [Q_const] (Just (PDecl [] Nothing)) ) in (* int * const *ptrToConstPtrToInt *)
      
      let (base_qs3, base_ty3, ptr_decltor3) =
        ( ATypes.no_qualifiers
        , ATypes.Basic (ATypes.Integer (ATypes.Signed ATypes.Int_))
        , PDecl [] (Just (PDecl [Q_const] Nothing)) ) in (* int ** const constPtrToPtrToInt *)
      
      desugar_pointer_declarator ptr_decltor1 >>= fun mk_type1 ->
      let (qs1, ty1) = mk_type1 base_qs1 base_ty1 in
      let () = Debug.print_debug 2 [] (fun () -> "int const **ptrToPtrToConstInt") in
      let () = Debug.print_debug 2 [] (fun () -> (Pp.stringFromAil_ctype qs1 ty1)) in
      
      desugar_pointer_declarator ptr_decltor2 >>= fun mk_type2 ->
      let (qs2, ty2) = mk_type2 base_qs2 base_ty2 in
      let () = Debug.print_debug 2 [] (fun () -> "int * const *ptrToConstPtrToInt") in
      let () = Debug.print_debug 2 [] (fun () -> (Pp.stringFromAil_ctype qs2 ty2)) in
      
      desugar_pointer_declarator ptr_decltor3 >>= fun mk_type3 ->
      let (qs3, ty3) = mk_type3 base_qs3 base_ty3 in
      let () = Debug.print_debug 2 [] (fun () -> "int ** const constPtrToPtrToInt") in
      let () = Debug.print_debug 2 [] (fun () -> (Pp.stringFromAil_ctype qs3 ty3)) in
      
      (* ----- *)
      
      let decltor1 =
        Declarator (Just ptr_decltor1) (DDecl_identifier (CabsIdentifier Loc.unknown "ptrToPtrToConstInt")) in
      let specifs1 = <|
        storage_classes= [];
        type_specifiers= [TSpec_int];
        type_qualifiers= [Q_const];
        function_specifiers= [];
        alignment_specifiers= [];
      |> in
      let edecl1 =
        EDecl_decl (Declaration_base specifs1
          [InitDecl Loc.unknown decltor1 Nothing]) in
      
      desugar_declarator decltor1 >>= fun (_, mk_qs_type1) ->
      desugar_type_specifiers specifs1.type_specifiers >>= fun (specs_qs, base_ty) ->
      let (qs, ty) =
        let (_, tquals_qs) = translate_type_qualifiers specifs1.type_qualifiers in
        mk_qs_type1 (AilTypesAux.combine_qualifiers specs_qs tquals_qs) base_ty in
      
      let () = Debug.print_debug 2 [] (fun () -> "DECLTOR1:") in
      let () = Debug.print_debug 2 [] (fun () -> (Pp.stringFromAil_ctype qs ty)) in
      
      (* ----- *)
      
      let (_, tquals_qs) = translate_type_qualifiers specifs1.type_qualifiers in
      desugar_init_declarator (AilTypesAux.combine_qualifiers specs_qs tquals_qs) base_ty specifs1.storage_classes
        (InitDecl Loc.unknown decltor1 Nothing) >>= fun (ident, (qs, ty), mk_desug_init) ->
      
      let () = Debug.print_debug 2 [] (fun () -> "INIT DECLARATOR:") in
      let () = Debug.print_debug 2 [] (fun () -> (Pp.stringFromAil_ctype qs ty)) in
      
      
      
      
      E.mapM_ desugar_and_register_external_declaration edecls >>
      E.extract_program startup_str
    ) >>= fun (_, ret) ->
    E.return ret
  ) 
*)
  E.eval sym_counter core_eval_stuff (
    E.with_scope E.Scope_file (
      E.mapM_ desugar_and_register_external_declaration edecls >>
      E.extract_program startup_str
    ) >>= fun (_, ret) ->
    E.return ret
  )
