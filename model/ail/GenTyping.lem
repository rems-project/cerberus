open import Pervasives Common Utils AilSyntax AilTypes AilSyntaxAux AilWf TypingError
open import GenTypes GenTypesAux Constraint
open import Std Loc

import Constraint Undefined
import Builtins Debug Pp Cmm_csem

import Global

open import {hol} `utilTheory`

module AAux = AilTypesAux
module GAux = GenTypesAux

import ErrorMonad
module E = ErrorMonad

let inline (>>=) m f = E.bind m f
let inline (>>) m f = m >>= (fun _ -> f)
let inline (<$>) = E.fmap


val lookup_tag_definition: forall 'a. sigma 'a -> identifier -> maybe tag_definition
let lookup_tag_definition s sym =
  Context.lookup (=) s.tag_definitions sym


val gen_typing_type_of_constant: integerConstant -> genIntegerType
let gen_typing_type_of_constant iCst =
  let () = Debug.warn [] (fun () ->
    "GenTyping.type_of_constant is BROKEN, using min ranges is wrong"
  ) in
  match iCst with
    | IConstant n Decimal Nothing ->
        if AAux.in_min_integer_range n (Signed Int_) then
          Concrete (Signed Int_)
(*
        else if AAux.in_min_integer_range n (Signed Long) then
          Concrete (Signed Long)
        else if AAux.in_min_integer_range n (Signed LongLong) then
          Concrete (Signed LongLong)
*)
        else
          Unknown iCst
    | IConstant n _ Nothing ->
        (* Octal or Hexadecimal *)
        if AAux.in_min_integer_range n (Signed Int_) then
          Concrete (Signed Int_)
(*
        else if AAux.in_min_integer_range n (Unsigned Int_) then
          Concrete (Unsigned Int_)
        else if AAux.in_min_integer_range n (Unsigned Long) then
          Concrete (Unsigned Long)
        else if AAux.in_min_integer_range n (Signed LongLong) then
          Concrete (Signed LongLong)
        else if AAux.in_min_integer_range n (Unsigned LongLong) then
          Concrete (Unsigned LongLong)
*)
        else
          Unknown iCst
    
    | IConstant n _ (Just U) ->
        (* Decimal, Octal or Hexadecimal *)
        if AAux.in_min_integer_range n (Unsigned Int_) then
          Concrete (Unsigned Int_)
(*
        else if AAux.in_min_integer_range n (Unsigned Long) then
          Concrete (Unsigned Long)
        else if AAux.in_min_integer_range n (Unsigned LongLong) then
          Concrete (Unsigned LongLong)
*)
        else
          Unknown iCst
    
    | IConstant n Decimal (Just L) ->
        if AAux.in_min_integer_range n (Signed Long) then
          Concrete (Signed Long)
(*
        else if AAux.in_min_integer_range n (Signed LongLong) then
          Concrete (Signed LongLong)
*)
        else
          Unknown iCst
    | IConstant n _ (Just L) ->
        (* Octal or Hexadecimal *)
        if AAux.in_min_integer_range n (Signed Long) then
          Concrete (Signed Long)
(*
        else if AAux.in_min_integer_range n (Unsigned Long) then
          Concrete (Unsigned Long)
        else if AAux.in_min_integer_range n (Signed LongLong) then
          Concrete (Signed LongLong)
        else if AAux.in_min_integer_range n (Unsigned LongLong) then
          Concrete (Unsigned LongLong)
*)
        else
          Unknown iCst
    
    | IConstant n _ (Just UL) ->
        (* Decimal, Octal or Hexadecimal *)
        if AAux.in_min_integer_range n (Unsigned Long) then
          Concrete (Unsigned Long)
(*
        else if AAux.in_min_integer_range n (Unsigned LongLong) then
          Concrete (Unsigned LongLong)
*)
        else
          Unknown iCst
    
    | IConstant n Decimal (Just LL) ->
        if AAux.in_min_integer_range n (Signed LongLong) then
          Concrete (Signed LongLong)
        else
          Unknown iCst
    | IConstant n _ (Just LL) ->
        (* Octal or Hexadecimal *)
        if AAux.in_min_integer_range n (Signed LongLong) then
          Concrete (Signed LongLong)
(*
        else if AAux.in_min_integer_range n (Unsigned LongLong) then
          Concrete (Unsigned LongLong)
*)
        else
          Unknown iCst
    
    | IConstant n _ (Just ULL) ->
        (* Decimal, Octal or Hexadecimal *)
        if AAux.in_min_integer_range n (Unsigned LongLong) then
          Concrete (Unsigned LongLong)
        else
          Unknown iCst
    
    | IConstantMax ity ->
        Concrete ity
    
    | IConstantMin ity ->
        Concrete ity
end

(* STD §6.5.16.1#1 *)
val well_typed_assignment: sigma unit -> assignment_violation -> Loc.t -> ctype -> genType -> expression genTypeCategory -> E.errorM unit
let well_typed_assignment s f loc ty1 gty2 e2 =
  let throw err =
    E.constraint_violation (with_cursor_from (locOf e2) loc) (f err ty1 gty2)
  in
  if AAux.atomic_qualified_unqualified AAux.is_arithmetic ty1 && GAux.is_arithmetic gty2 then
    let () = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] OK: bullet 1") in
    E.add "§6.5.16.1#1, bullet 1"
  
  else if AAux.atomic_qualified_unqualified AAux.is_struct_or_union ty1 then
    E.add "§6.5.16.1#1, bullet 2" >>
    match (proj_ctype_ ty1, gty2) with
      | (Struct tag_sym1, GenStruct tag_sym2) ->
          (* TODO: this is maybe too conservative *)
          let () = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () ->
            "[well_typed_assignment] exiting with bullet 2 ==> " ^
            Pp.stringFromAil_ctype no_qualifiers ty1 ^ " -- " ^ Pp.stringFromAil_genType gty2) in
          if tag_sym1 = tag_sym2 then
            E.return ()
          else
            throw IncompatibleType
      | (Union tag_sym1, GenUnion tag_sym2) ->
          (* TODO: this is maybe too conservative *)
          let () = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () ->
            "[well_typed_assignment] exiting with bullet 2 ==> " ^
            Pp.stringFromAil_ctype no_qualifiers ty1 ^ " -- " ^ Pp.stringFromAil_genType gty2) in
          if tag_sym1 = tag_sym2 then
            E.return ()
          else
            throw IncompatibleType
      | _ ->
          throw IncompatibleType
    end
  
  else if AAux.atomic_qualified_unqualified AAux.is_pointer ty1 then
    let () = Debug.print_debug 2 [] (fun () ->
      "TODO: check the use of AAux.lvalue_conversion"
    ) in
    AAux.lvalue_conversion s ty1 >>= fun conv_ty1 ->
    let () = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () ->
      "[well_typed_assignment] before bullet 3: conv_ty1= " ^Pp.stringFromAil_ctype no_qualifiers conv_ty1  ^
      " -- gty2= " ^ Pp.stringFromAil_genType gty2) in
    match (proj_ctype_ ty1, proj_ctype_ conv_ty1, gty2) with
      | (Pointer ref_qs1 _, Pointer _ conv_ref_ty1, GenPointer ref_qs2 ref_ty2) ->
          (* doing the "qualified or unqualified versions of" by checking the compatibility of
             the unqualified referenced type with no qualifiers *)
          (* NOTE: for the left operand, we are looking at the qualifiers before
             conversion (since the lvalue conversion removes the qualifiers) *)
          if    AAux.are_compatible (no_qualifiers, conv_ref_ty1) (no_qualifiers, ref_ty2)
             && AAux.sub_qualifiers ref_qs2 ref_qs1 then
            let _ = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] OK: bullet 3") in (* DEBUG *)
            let () = Debug.print_debug 1 [] (fun () ->
              (* TODO !!!! *)
              "FIXME: sub_qualifiers sees the wrong qualifiers (GenTypeCategory RValue seems to be at fault) !!!!"
            ) in
            E.add "§6.5.16.1#1, bullet 3"
          
          else if (   (AAux.is_object conv_ref_ty1 && AAux.is_void   ref_ty2)
                   || (AAux.is_void   conv_ref_ty1 && AAux.is_object ref_ty2) ) &&
                  AAux.sub_qualifiers ref_qs2 ref_qs1 then
            let _ = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] OK: bullet 4") in (* DEBUG *)
            E.add "§6.5.16.1#1, bullet 4"
          
          else if is_null_pointer_constant e2 then
            let _ = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] OK: bullet 5") in (* DEBUG *)
            E.add "§6.5.16.1#1, bullet 5"
          
          else
            let () = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () ->
              "[well_typed_assignment] KO: is_pointer ty1 && gty2 ==> (ref_qs1, conv_ref_ty1)= " ^
              Pp.stringFromAil_human_ctype ref_qs1 conv_ref_ty1 ^ ", (ref_qs2, ref_ty2)= " ^
              Pp.stringFromAil_human_ctype ref_qs2 ref_ty2
            ) in (* DEBUG *)
            if AAux.are_compatible (no_qualifiers, conv_ref_ty1) (no_qualifiers, ref_ty2) then
              throw DiscardsQualifiers
            else
              throw IncompatiblePointerType
      | _ ->
          if is_null_pointer_constant e2 then
            E.add "§6.5.16.1#1, bullet 5"
          else
            throw IncompatibleType
    end
  
  else if AAux.atomic_qualified_unqualified AAux.is_Bool ty1 && GAux.is_pointer gty2 then
    let _ = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] OK: bullet 6") in (* DEBUG *)
    E.add "§6.5.16.1#1, bullet 6"
  
  else
    let _ = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] KO: the end") in (* DEBUG *)
    throw IncompatibleType


(* STD §6.5.9#2 *)
val well_typed_equality: genType -> genType -> bool -> bool -> bool
let well_typed_equality gty1 gty2 is_null1 is_null2 =
     (* STD §6.5.9#2, item 1 *)
     is_arithmetic gty1 && is_arithmetic gty2
     (* STD §6.5.9#2, item 2 *)
  || are_pointers_to_qualifiedOrUnqualified_compatible_types gty1 gty2
     (* Defacto extension. TODO: make it a specific flag *)
  || (Global.isDefacto () && is_pointer_to_object gty1 && is_pointer_to_object gty2)
     (* STD §6.5.9#2, item 3 *)
  || is_pointer_to_void gty1 && is_pointer_to_object gty2
     (* STD §6.5.9#2, item 3 *)
  || is_pointer_to_object gty1 && is_pointer_to_void gty2
     (* STD §6.5.9#2, item 4 *)
  || is_pointer gty1 && is_null2
     (* STD §6.5.9#2, item 4 *)
  || is_null1 && is_pointer gty2

let guard_violation loc viol b =
  E.guard loc (TError_ConstraintViolation viol) b

let well_typed_binary_arithmetic viol loc_e1 loc_op loc_e2 gt1 aop gt2 =
  let guard bop = guard_violation (with_regions_and_cursor [loc_e1; loc_e2] (Just loc_op)) (viol bop gt1 gt2) in
  match aop with
    | Mul  -> guard MultiplicativeInvalidOperandsType (is_arithmetic gt1 && is_arithmetic gt2)
    | Div  -> guard MultiplicativeInvalidOperandsType (is_arithmetic gt1 && is_arithmetic gt2)
    | Mod  -> guard ModInvalidOperandsType            (is_integer    gt1 && is_integer    gt2)
    | Add  -> guard AdditiveOperandsArithmeticType    (is_arithmetic gt1 && is_arithmetic gt2)
    | Sub  -> guard AdditiveOperandsArithmeticType    (is_arithmetic gt1 && is_arithmetic gt2)
    | Shl  -> guard BitwiseShiftInvalidOperandsType   (is_integer    gt1 && is_integer    gt2)
    | Shr  -> guard BitwiseShiftInvalidOperandsType   (is_integer    gt1 && is_integer    gt2)
    | Band -> guard BitwiseAndInvalidOperandsType     (is_integer    gt1 && is_integer    gt2)
    | Bxor -> guard BitwiseXorInvalidOperandsType     (is_integer    gt1 && is_integer    gt2)
    | Bor  -> guard BitwiseOrInvalidOperandsType      (is_integer    gt1 && is_integer    gt2)
  end


val combine_qualifiers_left: genType -> genType -> genType
let combine_qualifiers_left gty1 gty2 =
  match (gty1, gty2) with
    | (GenPointer qs1 ty1, GenPointer qs2 _) ->
        GenPointer (AAux.combine_qualifiers qs1 qs2) ty1
    | (GenPointer _  _ , _) ->
        gty1
    | _ ->
        gty1
  end


val combine_qualifiers_right: genType -> genType -> genType
let combine_qualifiers_right gty1 gty2 =
  match (gty1, gty2) with
    | (GenPointer qs1 _, GenPointer qs2 ty2) ->
        GenPointer (AAux.combine_qualifiers qs1 qs2) ty2
    | (_, GenPointer _ _) ->
        gty2
    | _ ->
        gty2
  end

val well_typed_conditional:
    (Loc.t * Loc.t * Loc.t * Loc.t) ->
    genType -> genType -> genType -> bool -> bool -> E.errorM genTypeCategory
let well_typed_conditional (loc_cond, loc_e1, loc_e2, loc_e3) gty1 gty2 gty3 is_null2 is_null3 =
  if is_scalar gty1 then
    E.add "§6.5.15#2" >>
    if is_arithmetic gty2 && is_arithmetic gty3 then
      E.add "§6.5.15#3, bullet 1" >>
      E.add "§6.5.15#5, sentence 1" >>
      E.return (GenRValueType (usual_arithmetic gty2 gty3))
    
    else if GAux.is_struct_or_union gty2 && gty2 = gty3 then
      E.add "§6.5.15#3, bullet 2" >>
      E.add "§6.5.15#5, sentence 2" >>
      E.return (GenRValueType gty2)
    
    else if GAux.void gty2 && GAux.void gty3 then
      E.add "§6.5.15#3, bullet 3" >>
      E.add "§6.5.15#5, sentence 3" >>
      E.return (GenRValueType GenVoid)
    
    else match composite_pointer gty2 gty3 with
      | Just gty ->
          E.add "§6.5.15#3, bullet 4" >>
            E.add "§6.5.15#6" >>
          E.return (GenRValueType gty)
      | Nothing ->
          if is_pointer gty2 && is_null3 then
            E.add "§6.5.15#3, bullet 5" >>
            E.add "§6.5.15#6" >>
            E.return (GenRValueType (combine_qualifiers_left gty2 gty3))
          else if is_pointer gty3 && is_null2 then
            E.add "§6.5.15#3, bullet 5" >>
            E.add "§6.5.15#6" >>
            E.return (GenRValueType (combine_qualifiers_right gty2 gty3))
          else if is_pointer_to_object gty2 && is_pointer_to_void gty3 then
            E.add "§6.5.15#3, bullet 6" >>
            E.add "§6.5.15#6" >>
            E.return (GenRValueType (combine_qualifiers_right gty2 gty3))
          else if is_pointer_to_object gty3 && is_pointer_to_void gty2 then
            E.add "§6.5.15#3, bullet 6" >>
            E.add "§6.5.15#6" >>
            E.return (GenRValueType (combine_qualifiers_left gty2 gty3))
          else
            E.constraint_violation (with_regions_and_cursor [loc_e2; loc_e3] (Just loc_cond))
                                   (ConditionalOperatorInvalidOperandTypes gty2 gty3)
    end
  else
    E.constraint_violation (with_cursor_from loc_e1 loc_cond) (ConditionalOperatorControlType gty1)


val annotate_stringLiteral: stringLiteral -> E.errorM (expression_ genTypeCategory * genTypeCategory)
let annotate_stringLiteral (pref_opt, strs) =
  let elem_ty = match pref_opt with
                  | Nothing     -> AAux.mk_ctype_integer Char                 (* STD §6.4.5#6 sentence 3 *)
                  | Just Enc_u8 -> AAux.mk_ctype_integer Char                 (* STD §6.4.5#6 sentence 4 *)
                  | Just Enc_u  -> char16_t                                   (* STD §6.4.5#6 sentence 6 *)
                  | Just Enc_U  -> char32_t                                   (* STD §6.4.5#6 sentence 6 *)
                  | Just Enc_L  -> AAux.mk_ctype_integer (IBuiltin "wchar_t") (* STD §6.4.5#6 sentence 5 *)
                end in

  (* TODO: check the type *)
  E.return
    ( AilEstr (pref_opt, strs)
    , GenLValueType no_qualifiers (Ctype [] (Array elem_ty (Just $ integerFromNatural (naturalFromNat (List.length strs + 1))))) false )


val     typecheck_constant: constant -> E.errorM genType
let rec typecheck_constant cst =
  match cst with
    | ConstantInteger iCst ->
        E.return (GenBasic (GenInteger (gen_typing_type_of_constant iCst)))
    | ConstantFloating ((_, suff_opt)) ->
        E.add "§6.4.4.2#4" >>
        let rfty = match suff_opt with
          | Nothing ->
              Double
          | Just Fsuf_F ->
              Float
          | Just Fsuf_L ->
              LongDouble
        end in
        E.return (GenBasic (GenFloating (RealFloating rfty)))
    | ConstantCharacter cc ->
        (* TODO: §6.4.4.4#9 *)
        match fst cc with
          | Nothing ->
              E.add "§6.4.4.4#10" >>
              E.return (GenBasic (GenInteger (Concrete (Signed Int_))))
          | Just Pref_L ->
              E.add "§6.4.4.4#11" >>
              E.return (GenBasic (GenInteger (Concrete (IBuiltin "wchar_t"))))
          | Just Pref_u ->
              E.add "§6.4.4.4#11" >>
              E.return genChar16_t
          | Just Pref_U ->
              E.add "§6.4.4.4#11" >>
              E.return genChar32_t
        end
    | ConstantArray elem_ty csts ->
        (* TODO: this is probably too strong *)
        E.mapM typecheck_constant csts >>= function
          | [] ->
              error "typecheck_constant: empty array constant"
          | gtys ->
              (* TODO !!!! *)
              E.return (GenArray elem_ty (Just $ integerFromNat (List.length csts)))
        end
    | ConstantIndeterminate ty ->
        E.return (GenTypes.inject_type ty)
    | ConstantNull ->
        (* TODO: check *)
        E.return (GenPointer no_qualifiers (Ctype [] Void))
    | ConstantStruct tag_sym xs ->
        E.mapM (fun (memb_ident, cst) ->
          (* TODO: need to check that the members type match ... *)
          typecheck_constant cst >>= fun gty ->
          E.return (memb_ident, gty)
        ) xs >>= fun xs_gtys ->
        E.return (GenTypes.GenStruct tag_sym)
    | ConstantUnion tag_sym memb_ident cst ->
          (* TODO: need to check that the members type match ... *)
        typecheck_constant cst >>= fun membr_gty ->
        E.return (GenTypes.GenUnion tag_sym)
  end

val annotate_rvalue: sigma unit -> gamma -> expression unit -> E.errorM (expression genTypeCategory * genType)
val annotate_assignee: sigma unit -> gamma -> assignment_violation -> Loc.t -> ctype -> expression unit -> E.errorM (expression genTypeCategory)
val annotate_arguments:
  sigma unit -> gamma -> Loc.t -> bool -> bool -> list (expression unit) -> list (qualifiers * ctype * bool) ->
  E.errorM (list (expression genTypeCategory))

(* context given to [annotate_expression] to inform it on the what the current
   expression is: *)
type annotation_context =
    (* operand of AilEsizeof_expr *)
  | CTXsizeof
    (* operand of AilEunary Address *)
  | CTXaddr
    (* operand of AilEunary PostfixIncr *)
  | CTXincr
    (* operand of AilEunary PostfixDecr *)
  | CTXdecr
    (* left operand of AilEmemberof *)
  | CTXmemberof
    (* left operand of AilEassign or AilEcompoundAssign *)
  | CTXassign
    (* array initialiser (used by AilEstr) *)
  | CTXarray_init
    (* otherwise *)
  | CTXother

val     annotate_expression: sigma unit -> gamma -> annotation_context -> expression unit -> E.errorM (expression genTypeCategory)
let rec annotate_expression sigm gamm ctx (AnnotatedExpression () std_annots loc expr_) =
  let annotate_expression = annotate_expression sigm gamm in
  let annotate_rvalue     = annotate_rvalue sigm gamm     in
  let annotate_assignee   = annotate_assignee sigm gamm   in
  let annotate_arguments  = annotate_arguments sigm gamm  in
  match expr_ with
    | AilEunary (Plus as uop) e ->
        (* STD §6.5.3.3#1, sentence 1 *)
        E.add "§6.5.3.3#1, sentence 1" >>
        annotate_rvalue e >>= fun (a_e, gty) ->
        if is_arithmetic gty then
          let mk_conversion =
            if is_integer gty then integer_promote else (fun z -> z) in
          E.return (AilEunary uop a_e, GenRValueType (mk_conversion gty))
        else
          E.constraint_violation (with_cursor_from (locOf e) loc) (InvalidArgumentTypeUnaryExpression gty)
    
    | AilEunary (Minus as uop) e ->
        (* STD §6.5.3.3#1, sentence 1 *)
        E.add "§6.5.3.3#1, sentence 1" >>
        annotate_rvalue e >>= fun (a_e, gty) ->
        if is_arithmetic gty then
          let mk_conversion =
            if is_integer gty then integer_promote else (fun z -> z) in
          E.return (AilEunary uop a_e, GenRValueType (mk_conversion gty))
        else
          E.constraint_violation (with_cursor_from (locOf e) loc) (InvalidArgumentTypeUnaryExpression gty)
    
    | AilEunary (Bnot as uop) e ->
        (* STD §6.5#4, sentence 1 *)
        (* STD §6.5.3.3#1, sentence 2 *)
        E.add "STD §6.5#4, sentence 1" >>
        E.add "STD §6.5.3.3#1, sentence 2" >>
        annotate_rvalue e >>= fun (a_e, gty) ->
        if is_integer gty then
          E.return (AilEunary uop a_e, GenRValueType (integer_promote gty))
        else
          E.constraint_violation (with_cursor_from (locOf e) loc) (InvalidArgumentTypeUnaryExpression gty)
    
    | AilEunary Address e ->
        (* STD §6.5.3.2#1 *)
        E.add "§6.5.3.2#1" >>
        annotate_expression CTXaddr e >>= fun a_e ->
        match GenTypes.genTypeCategoryOf a_e with
          | GenRValueType (GenFunction hasProto ty params isVariadic) ->
              (* e is a 'function designator' *)
              let gty' = GenPointer no_qualifiers (Ctype [] (Function hasProto ty params isVariadic)) in
              E.return (AilEunary Address a_e, GenRValueType gty')
          | GenRValueType gty ->
              E.constraint_violation (with_cursor_from (locOf e) loc) (UnaryAddressNotRvalue gty)
          | GenLValueType qs ty isRegister ->
              (* e is an 'lvalue' *)
              let () = Debug.warn [Debug.DB_ail_typing]
                 (fun () -> "(TODO) GenTyping.annotate_expression AilEunary Address, not checking for bit-field member") in
              if isRegister then
                E.constraint_violation (with_cursor_from (locOf e) loc) UnaryAddressRegisterLvalue
              else
                E.add "§6.5.3.2#3, 2nd sentence" >>
                E.return (AilEunary Address a_e, GenRValueType (GenPointer qs ty))
        end
    
    | AilEunary Indirection e ->
        annotate_rvalue e >>= fun (e', gty) ->
        match gty with
          | GenPointer ref_qs ref_ty ->
              E.add "§6.5.3.2#4, sentence 2" >>
              E.add "§6.5.3.2#4, sentence 3" >>
              if AAux.is_object ref_ty then
                (* *)
                E.return (AilEunary Indirection e', GenLValueType ref_qs ref_ty false)
              else
                (* TODO: check that it's ok to drop the qualifiers *)
                E.return (AilEunary Indirection e', GenRValueType (inject_type ref_ty))
          | _ ->
              E.constraint_violation (with_cursor_from (locOf e) loc) IndirectionNotPointer
        end
    
    | AilEunary (PostfixIncr as uop) e ->
        annotate_expression CTXincr e >>= fun e' ->
        match GenTypes.genTypeCategoryOf e' with
          | GenLValueType qs' ty' _ ->
              AAux.lvalue_coercion sigm ty' >>= fun ty' ->
              if AAux.modifiable sigm qs' ty' && (AAux.is_real ty' || AAux.is_pointer ty') then
                E.return (AilEunary uop e', GenRValueType (inject_type ty'))
              else
                E.constraint_violation (with_cursor_from (locOf e) loc) (InvalidArgumentTypeUnaryIncrement ty')
          | _ ->
            E.constraint_violation (with_cursor_from (locOf e) loc) UnaryExpressionNotLvalue
        end
    
    | AilEunary (PostfixDecr as uop) e ->
        annotate_expression CTXdecr e >>= fun e' ->
        match GenTypes.genTypeCategoryOf e' with
          | GenLValueType qs' ty' _ ->
              AAux.lvalue_coercion sigm ty' >>= fun ty' ->
              if AAux.modifiable sigm qs' ty' && (AAux.is_real ty' || AAux.is_pointer ty') then
                E.return (AilEunary uop e', GenRValueType (inject_type ty'))
              else
                E.constraint_violation (with_cursor_from (locOf e) loc) (InvalidArgumentTypeUnaryDecrement ty')
          | _ ->
            E.constraint_violation (with_cursor_from (locOf e) loc) UnaryExpressionNotLvalue
        end
    
    | AilEarray is_str elem_ty e_opts ->
        (* TODO: think about it *)
        E.mapM (maybe (E.return Nothing) (fun e ->
          if AilTypesAux.is_array elem_ty then
            annotate_rvalue e >>= fun (e', gty) ->
            let () = Debug.warn [] (fun () ->
              "TODO!!! Ail's typing is not properly checking AilEarray when elem_ty is an array type"
            ) in
            E.return (Just e')
          else
            E.add "§6.7.9#11" >>
            (* TODO: unqualify elem_ty? *)
            (Just <$> annotate_assignee InitializationAsSimpleAssignment loc elem_ty e)
(*
          annotate_rvalue e >>= fun (e', gty) ->
          (* TODO: maybe this is too strict and we want to relax to only having
             the types compatibles? *)
          if inject_type elem_ty <> gty then
            let () = Debug.print_debug 1 [] (fun () ->
              "elem_ty: " ^ Pp.stringFromAil_ctype no_qualifiers elem_ty
            ) in
            let () = Debug.print_debug 1 [] (fun () ->
              "gty: " ^ Pp.stringFromAil_genType gty
            ) in
            let () = Debug.print_debug 1 [] (fun () ->
              "expr: " ^ Pp.stringFromAil_expression expr
            ) in
            E.fail loc (TError "illtyped element of an AilEarray")
          else
            E.return (Just e')
*)
        )) e_opts >>= fun xs ->
        (* TODO: checking that the types in [xs] match ty *)
        E.return ( AilEarray is_str elem_ty xs
                 , GenRValueType (GenArray elem_ty (Just (integerFromNat $ List.length xs))) )
    
    | AilEstruct tag_sym xs ->
        E.mapM (fun (ident, e_opt) ->
          maybe (E.return Nothing) (fun e -> Just <$> annotate_rvalue e) e_opt >>= fun a_e_opt ->
          E.return (ident, Maybe.map fst a_e_opt)
        ) xs >>= fun xs' ->
        (* TODO: the actual type checking of the members ... *)
        let () = Debug.warn [Debug.DB_ail_typing] (fun () -> "typing of struct constant doesn't check the members are valid for the tag") in
        E.return (AilEstruct tag_sym xs', GenRValueType (GenStruct tag_sym))
    
    | AilEunion tag_sym memb_ident e_opt ->
        maybe (E.return Nothing) (fun e -> (Just -| fst) <$> annotate_rvalue e) e_opt >>= fun a_e_opt ->
        let () = Debug.warn [Debug.DB_ail_typing] (fun () -> "typing of union constant doesn't check the member is valid for the tag") in
        E.return (AilEunion tag_sym memb_ident a_e_opt, GenRValueType (GenUnion tag_sym))
    
    | AilEcompound qs ty e ->
        (* STD §6.5.2.5#1 *)
        E.add "§6.5.2.5#1" >>
        if    (AAux.is_complete sigm ty && AAux.is_object ty)
           || (AAux.is_array_unknown_size ty && not (AAux.is_vla ty)) then
          (* TODO: check that *)
          annotate_definition_aux sigm gamm (ty, e) >>= fun a_e ->
          E.add "§6.5.2.5#4" >>
          E.return (AilEcompound qs ty a_e, GenLValueType qs ty false)
        else
          E.constraint_violation loc InvalidTypeCompoundLiteral

    | AilEbuiltin str ->
        match str with
        | "atomic_store_explicit" ->
          E.misc (Loc.with_cursor loc) GenericFunctionMustBeDirectlyCalled
        | "atomic_load_explicit" ->
          E.misc (Loc.with_cursor loc) GenericFunctionMustBeDirectlyCalled
        | "atomic_exchange_explicit" ->
          E.misc (Loc.with_cursor loc) GenericFunctionMustBeDirectlyCalled
        | "atomic_compare_exchange_strong_explicit" ->
          E.misc (Loc.with_cursor loc) GenericFunctionMustBeDirectlyCalled
        | "atomic_compare_exchange_weak_explicit" ->
          E.misc (Loc.with_cursor loc) GenericFunctionMustBeDirectlyCalled
        | "atomic_fetch_key_explicit" ->
          E.misc (Loc.with_cursor loc) GenericFunctionMustBeDirectlyCalled
        | _ ->
          match Builtins.ctype_of_builtin_varname str with
            | Just ty ->
                E.return (AilEbuiltin str, GenRValueType (inject_type ty))
            | Nothing ->
                error ("WIP typing, AilEbuiltin: " ^ str)
          end
        end
(*

(GenBasic (GenInteger (Concrete ity))))


        (* TODO: check *)
        let ity = match str with
          | "INT8_MIN" ->
              Signed Int_
          | "INT16_MIN" ->
              Signed Int_
          | "INT32_MIN" ->
              Signed Int_ (* TODO: this might not fit in a signed int ... *)
          | "INT64_MIN" ->
              Signed Long
          | "INT8_MAX" ->
              Signed Int_
          | "INT16_MAX" ->
              Signed Int_
          | "INT32_MAX" ->
              Signed Int_ (* TODO: this might not fit in a signed int ... *)
          | "INT64_MAX" ->
              Signed Long
          | "UINT8_MAX" ->
              Unsigned Int_
          | "UINT16_MAX" ->
              Unsigned Int_
          | "UINT32_MAX" ->
              Unsigned Int_ (* TODO: this might not fit in a signed int ... *)
          | "UINT64_MAX" ->
              Unsigned Long
          | _ ->
              error ("WIP typing, AilEbuiltin: " ^ str)
        end in
        E.return (AilEbuiltin str, GenRValueType (GenBasic (GenInteger (Concrete ity))))
*)
    
    | AilEident sym ->
        match (Context.lookup identifierEqual gamm sym, Context.lookup identifierEqual sigm.declarations sym) with
          | (Just ((_, _, isRegister), qs, ty), Nothing) ->
              let () = Debug.print_debug 1 [Debug.DB_ail_typing] (fun () ->
                "[AilEident (gamma)] " ^ show sym ^ " -- " ^ Pp.stringFromAil_ctype qs ty
              ) in
              E.return (AilEident sym, GenLValueType qs ty isRegister)
          | (Nothing, Just (_, Decl_object (_, isRegister) qs ty)) ->
              let () = Debug.print_debug 1 [Debug.DB_ail_typing] (fun () ->
                "[AilEident (sigma)] " ^ show sym ^ " -- " ^ Pp.stringFromAil_ctype qs ty
              ) in
              E.return (AilEident sym, GenLValueType qs ty isRegister)
          | (Nothing, Just (_, Decl_function has_proto (ret_qs, ret_ty) params is_variadic _ (* is_inline *) _ (* is_Noreturn *))) ->
              (* TODO: is_inline, is_Noreturn *)
              (* NOTE: here sym is a 'function designator', hence it has function type. BUT
                 other part of the typechecker MUST perform the 'function_coercion' as described in
                 (§6.3.2.1#4). *)
              E.return (AilEident sym, GenRValueType (inject_type (Ctype [Annot.Aloc loc] (Function has_proto (ret_qs, ret_ty) params is_variadic))))
          | _ ->
              error "gentpying.annotate_expression: AilEident symbol couldn't be resolved"
        end
    
    | AilEbinary e1 Comma e2 ->
        E.add "§6.5.17#3, sentence 3" >>
        annotate_rvalue e1 >>= fun (e1', _  ) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        E.return (AilEbinary e1' Comma e2', GenRValueType gty2)
    
    | AilEcall (AnnotatedExpression _ annots' loc' (AilEbuiltin builtin_function)) args ->
        let loc_cursor = Loc.with_cursor loc' in
        let memorder_ty = Ctype [] $ Basic (Integer (Signed (Int_))) (* TODO: actually memory_order enum *) in
        match (builtin_function, args) with
        | ("atomic_store_explicit", object_e :: desired_e :: order_e :: args) ->
            annotate_rvalue object_e >>= fun (object_e',  object_gty)  ->
            match object_gty with
              | GenPointer qs object_ty ->
                  let params_wo_ptr = [(qs, Ctype [] $ AAux.unatomic object_ty, false); (no_qualifiers, memorder_ty, false)] in
                  let gen_fun_ty = GenRValueType (GenFunction false (qs, Ctype [] Void) ((qs, Ctype [] $ Pointer qs object_ty, false) :: params_wo_ptr) false) in
                  guard_violation loc_cursor (AtomicAddressArgumentMustBeAtomic AtomicStore object_ty) (AAux.is_atomic object_ty) >>= fun () ->
                  annotate_arguments loc_cursor false false (desired_e :: order_e :: args) params_wo_ptr >>= fun es' ->
                  match memory_order_of_expr order_e with
                  | Just Cmm_csem.Acquire ->
                    E.undef loc_cursor Undefined.UB205_atomic_store_memorder
                  | Just Cmm_csem.Consume ->
                    E.undef loc_cursor Undefined.UB205_atomic_store_memorder
                  | Just Cmm_csem.Acq_rel ->
                    E.undef loc_cursor Undefined.UB205_atomic_store_memorder
                  | _ ->
                    E.return (AilEcall (AnnotatedExpression gen_fun_ty annots' loc' $ AilEbuiltin builtin_function) (object_e' :: es')
                             , GenRValueType GenVoid)
                  end
              | gty ->
                  E.constraint_violation loc_cursor $ AtomicAddressArgumentMustBePointer AtomicStore gty
            end
        
        | ("atomic_load_explicit", object_e :: order_e :: args) ->
            annotate_rvalue object_e >>= fun (object_e', object_gty) ->
            match object_gty with
              | GenPointer qs object_ty ->
                  let ret_ty = Ctype [] (AAux.unatomic object_ty) in
                  let params_wo_ptr = [(no_qualifiers, memorder_ty, false)] in
                  let gen_fun_ty = GenRValueType (GenFunction false (qs, ret_ty) ((qs, Ctype [] $ Pointer qs object_ty, false) :: params_wo_ptr) false) in
                  guard_violation loc_cursor (AtomicAddressArgumentMustBeAtomic AtomicLoad object_ty) (AAux.is_atomic object_ty) >>= fun () ->
                  annotate_arguments loc_cursor false false (order_e :: args) params_wo_ptr >>= fun es' ->
                  match memory_order_of_expr order_e with
                  | Just Cmm_csem.Release ->
                    E.undef loc_cursor Undefined.UB206_atomic_load_memorder
                  | Just Cmm_csem.Acq_rel ->
                    E.undef loc_cursor Undefined.UB206_atomic_load_memorder
                  | _ ->
                    E.return (AilEcall (AnnotatedExpression gen_fun_ty annots' loc' $ AilEbuiltin builtin_function) (object_e' :: es')
                             , GenRValueType (inject_type ret_ty))
                  end
              | gty ->
                  E.constraint_violation loc_cursor $ AtomicAddressArgumentMustBePointer AtomicLoad gty
            end
        
        | ("atomic_exchange_explicit", object_e :: args) ->
            annotate_rvalue object_e >>= fun (object_e', object_gty) ->
            match object_gty with
              | GenPointer qs object_ty ->
                  let ret_ty = Ctype [] (AAux.unatomic object_ty) in
                  let params_wo_ptr = [(qs, ret_ty, false); (no_qualifiers, memorder_ty, false)] in
                  let gen_fun_ty = GenRValueType (GenFunction false (qs, ret_ty) ((qs, Ctype [] $ Pointer qs object_ty, false) :: params_wo_ptr) false) in
                  guard_violation loc_cursor (AtomicAddressArgumentMustBeAtomic AtomicExchange object_ty) (AAux.is_atomic object_ty) >>= fun () ->
                  annotate_arguments loc_cursor false false args params_wo_ptr >>= fun es' ->
                  E.return (AilEcall (AnnotatedExpression gen_fun_ty annots' loc' $ AilEbuiltin builtin_function) (object_e' :: es')
                           , GenRValueType (inject_type ret_ty))
              | gty ->
                  E.constraint_violation loc_cursor $ AtomicAddressArgumentMustBePointer AtomicExchange gty
            end
        
        | ("atomic_compare_exchange_strong_explicit", object_e :: expected_e :: desired_e :: order_success_e :: order_failure_e :: args) ->
            annotate_rvalue object_e  >>= fun (object_e', object_gty) ->
            match object_gty with
              | GenPointer qs object_ty ->
                  let ty = Ctype [] $ AAux.unatomic object_ty in
                  let params_wo_ptr = [(qs, Ctype [] $ Pointer qs ty, false); (qs, ty, false);
                                       (no_qualifiers, memorder_ty, false); (no_qualifiers, memorder_ty, false)] in
                  let gen_fun_ty = GenRValueType $GenFunction false (no_qualifiers, Ctype [] $ Basic (Integer Bool))
                                       ((qs, Ctype [] $ Pointer qs object_ty, false) :: params_wo_ptr) false in
                  guard_violation loc_cursor (AtomicAddressArgumentMustBeAtomic AtomicCompareExchange object_ty) (AAux.is_atomic object_ty) >>= fun () ->
                  annotate_arguments loc_cursor false false (expected_e :: desired_e :: order_success_e :: order_failure_e :: args) params_wo_ptr >>= fun es' ->
                  (* TODO: The failure argument shall be no stronger than the success argument. *)
                  match memory_order_of_expr order_failure_e with
                  | Just Cmm_csem.Release ->
                    E.undef loc_cursor Undefined.UB207_atomic_compare_exchange_memorder
                  | Just Cmm_csem.Acq_rel ->
                    E.undef loc_cursor Undefined.UB207_atomic_compare_exchange_memorder
                  | _ ->
                    E.return (AilEcall (AnnotatedExpression gen_fun_ty annots' loc' $ AilEbuiltin builtin_function) (object_e' :: es')
                             , GenRValueType (GenBasic (GenInteger (Concrete (AilTypes.Bool)))))
                  end
              | gty ->
                  E.constraint_violation loc_cursor $ AtomicAddressArgumentMustBePointer AtomicCompareExchange gty
            end
        
        | ("atomic_compare_exchange_weak_explicit", object_e :: expected_e :: desired_e :: order_success_e :: order_failure_e :: args) ->
            annotate_rvalue object_e  >>= fun (object_e', object_gty) ->
            match object_gty with
              | GenPointer qs object_ty ->
                  let ty = Ctype [] $ AAux.unatomic object_ty in
                  let params_wo_ptr = [(qs, Ctype [] $ Pointer qs ty, false); (qs, ty, false);
                                       (no_qualifiers, memorder_ty, false); (no_qualifiers, memorder_ty, false)] in
                  let gen_fun_ty = GenRValueType $GenFunction false (no_qualifiers, Ctype [] $ Basic (Integer Bool))
                                       ((qs, Ctype [] $ Pointer qs object_ty, false) :: params_wo_ptr) false in
                  guard_violation loc_cursor (AtomicAddressArgumentMustBeAtomic AtomicCompareExchange object_ty) (AAux.is_atomic object_ty) >>= fun () ->
                  annotate_arguments loc_cursor false false (expected_e :: desired_e :: order_success_e :: order_failure_e :: args) params_wo_ptr >>= fun es' ->
                  (* TODO: The failure argument shall be no stronger than the success argument. *)
                  match memory_order_of_expr order_failure_e with
                  | Just Cmm_csem.Release ->
                    E.undef loc_cursor Undefined.UB207_atomic_compare_exchange_memorder
                  | Just Cmm_csem.Acq_rel ->
                    E.undef loc_cursor Undefined.UB207_atomic_compare_exchange_memorder
                  | _ ->
                    E.return (AilEcall (AnnotatedExpression gen_fun_ty annots' loc' $ AilEbuiltin builtin_function) (object_e' :: es')
                             , GenRValueType (GenBasic (GenInteger (Concrete (AilTypes.Bool)))))
                  end
              | gty ->
                  E.constraint_violation loc_cursor $ AtomicAddressArgumentMustBePointer AtomicCompareExchange gty
            end
        
        | ("linux_fence", [order_e]) ->
           annotate_rvalue order_e  >>= fun (order_e' , order_gty) ->
           E.return (AilEcall (AnnotatedExpression (GenRValueType GenVoid) annots' loc' (AilEbuiltin "linux_fence")) [order_e'], GenRValueType GenVoid)
        
        | ("linux_read", [object_e; order_e]) ->
           annotate_rvalue object_e >>= fun (object_e', object_gty) ->
           annotate_rvalue order_e  >>= fun (order_e' , order_gty ) ->
           match (object_gty) with
             | (GenPointer qs object_ty) ->
                 E.return ( AilEcall (AnnotatedExpression ((* TODO: HACK *)GenRValueType GenVoid) annots' loc' (AilEbuiltin "linux_read")) [object_e';order_e']
                          , GenRValueType (inject_type $ Ctype [] (AAux.unatomic object_ty)) )
             | _ ->
                 error "WIP: typing of linux_read"
           end
        
       | ("linux_write", [object_e; desired_e; order_e]) ->
           annotate_rvalue object_e  >>= fun (object_e',  object_gty)  ->
           annotate_rvalue desired_e >>= fun (desired_e', desired_gty) ->
           annotate_rvalue order_e   >>= fun (order_e' , order_gty )   ->
           E.return (AilEcall (AnnotatedExpression (GenRValueType GenVoid) annots' loc' (AilEbuiltin "linux_write")) [object_e'; desired_e'; order_e'],
                     GenRValueType GenVoid)
        
       | ("linux_rmw", [object_e; desired_e; order_e]) ->
           annotate_rvalue object_e  >>= fun (object_e',  object_gty)  ->
           annotate_rvalue desired_e >>= fun (desired_e', desired_gty) ->
           annotate_rvalue order_e   >>= fun (order_e' , order_gty )   ->
           match (object_gty) with
             | (GenPointer qs object_ty) ->
                 E.return (AilEcall (AnnotatedExpression ((* TODO: HACK *)
   GenRValueType GenVoid) annots' loc' (AilEbuiltin "linux_rmw"))
   [object_e'; desired_e'; order_e'], GenRValueType (inject_type $ Ctype [] (AAux.unatomic object_ty)))
             | _ ->
                 error "WIP: typing of linux_rmw"
           end
        | (str, _) ->
          error $ "translate builtin function : " ^ str
    end
    
    (* TODO: this is wrong in so many ways!! *)
    | AilEcall (AnnotatedExpression _ annots' loc' (AilEident (Symbol.Symbol digest s (Just "atomic_thread_fence")))) [order_e] ->
        (* TODO: do typechecking *)
        annotate_rvalue order_e >>= fun (order_e', order_gty) ->
        E.return (AilEcall (AnnotatedExpression (GenRValueType GenVoid) annots' loc' (AilEident (Symbol.Symbol digest s (Just "atomic_thread_fence")))) [order_e'], GenRValueType GenVoid)
    
    | AilEcall e es ->
        E.add "§6.5.2.2#1" >>
        annotate_rvalue e >>= function
          | (e', GenPointer qs (Ctype _ (Function has_proto (ret_qs, ret_ty) params is_variadic))) ->
              (* TODO: qualifiers *)
              let () = Debug.warn [] (fun () ->
                "(unsure) the typing of AilEcall doesn't look at [ret_qs]"
              ) in
              if not (AAux.is_void ret_ty || AAux.is_complete_object sigm ret_ty) then
                if AAux.is_array ret_ty then
                  E.constraint_violation loc (FunctionCallArrayReturnType ret_ty)
                else
                  E.constraint_violation loc (FunctionCallIncompleteReturnType ret_ty)
              (* TODO: do we need to check if qs is unqualified? *)
              else if AAux.is_unqualified qs then
                annotate_arguments (locOf e) has_proto is_variadic es params >>= fun es' ->
                E.return (AilEcall e' es', GenRValueType (inject_type ret_ty))
              else
                error "annotate_expression(AilEcall): function decay pointer should not be qualified"
          | (_, gty) ->
              E.constraint_violation loc FunctionCallIncorrectType
        end
    
    | AilEassert e ->
        annotate_rvalue e >>= fun (e', gty) ->
        if is_scalar gty then
          E.add "§7.2.1.1#2" >>
          E.return (AilEassert e', GenRValueType GenVoid)
        else
          E.constraint_violation loc AssertMacroExpressionScalarType
    
    | AilEoffsetof ty ident ->
        E.return (AilEoffsetof ty ident, GenRValueType (GenBasic (GenInteger SizeT)))
    
    | AilEgeneric (* e gas *) _ _ ->
        E.fail loc (TError_NotYetSupported "C11 generic selection")
    
    | AilEmemberof e memb_ident ->
        (* TODO: factorise *)
        (* TODO: Atomic types *)
        annotate_expression CTXmemberof e >>= fun a_e ->
        (* the value of the AilEmemberof operator is an lvalue if [e] is an lvalue *)
        match GenTypes.genTypeCategoryOf a_e with
          | GenLValueType qs ty _ ->
              (* NOTE: the member his not a "register" regardless of whether the
                 struct/union was *)
              (* NOTE: the qualifiers of the value are the combination of the ones
                of the left operand [e] and the ones in the declaration of the
                 member type (see §6.5.2.3#3 and #8) *)
              match ty with
                | Ctype _ (Struct tag_sym) ->
                    match lookup_tag_definition sigm tag_sym with
                      | Just (StructDef membersDefs) ->
                          match List.lookup memb_ident membersDefs with
                            | Just (memb_qs, memb_ty) ->
                                E.return ( AilEmemberof a_e memb_ident
                                         , GenLValueType (AAux.combine_qualifiers qs memb_qs) memb_ty false )
                            | Nothing ->
                                E.constraint_violation (Loc.with_cursor_from (Loc.locOf e) (Loc.locOf memb_ident))
                                                       (MemberofNoMemberLvalue memb_ident qs ty)
                          end
                      | _ ->
                          error "annotate_expression(AilEmemberof struct): failed to find a valid tag definition"
                    end
                | Ctype _ (Union tag_sym) ->
                    match lookup_tag_definition sigm tag_sym with
                      | Just (UnionDef membersDefs) ->
                          match List.lookup memb_ident membersDefs with
                            | Just (memb_qs, memb_ty) ->
                                E.return ( AilEmemberof a_e memb_ident
                                         , GenLValueType (AAux.combine_qualifiers qs memb_qs) memb_ty false )
                            | Nothing ->
                                E.constraint_violation (with_cursor_from (locOf e) (locOf memb_ident))
                                                       (MemberofNoMemberLvalue memb_ident qs ty)
                          end
                      | _ ->
                          error "annotate_expression(AilEmemberof union): failed to find a valid tag definition"
                    end
                | _ ->
                    E.constraint_violation (with_cursor_from (locOf e) loc) (MemberofReferenceBaseTypeLvalue qs ty)
              end
          | GenRValueType gty ->
              match gty with
                | GenStruct tag_sym ->
                    match lookup_tag_definition sigm tag_sym with
                      | Just (StructDef membersDefs) ->
                          match List.lookup memb_ident membersDefs with
                            | Just (_, memb_ty) ->
                                E.return (AilEmemberof a_e memb_ident, GenRValueType (GenTypes.inject_type memb_ty))
                            | Nothing ->
                                E.constraint_violation (Loc.with_cursor_from (Loc.locOf e) (Loc.locOf memb_ident) )
                                                       (MemberofNoMemberRvalue memb_ident gty)
                          end
                      | _ ->
                          error "annotate_expression(AilEmemberof struct): failed to find a valid tag definition"
                    end
                | GenUnion tag_sym ->
                    match lookup_tag_definition sigm tag_sym with
                      | Just (UnionDef membersDefs) ->
                          match List.lookup memb_ident membersDefs with
                            | Just (_, memb_ty) ->
                                E.return (AilEmemberof a_e memb_ident, GenRValueType (GenTypes.inject_type memb_ty))
                            | Nothing ->
                                E.constraint_violation (with_cursor_from (locOf e) (locOf memb_ident))
                                                       (MemberofNoMemberRvalue memb_ident gty)
                          end
                      | _ ->
                          error "annotate_expression(AilEmemberof union): failed to find a valid tag definition"
                    end
                | _ ->
                    E.constraint_violation (with_cursor_from (locOf e) loc) (MemberofReferenceBaseTypeRvalue gty)
              end
        end
    
    | AilEmemberofptr e memb_ident ->
      (* TODO: factorize *)
      (* TODO: Atomic types *)
      (* NOTE: the qualifiers of the value are the combination of the ones
         of the referenced type of left operand [e] and the ones in the
         declaration of the member type (see §6.5.2.3#4) *)
        annotate_rvalue e >>= function
          | (e', GenPointer ref_qs (Ctype _ (Struct tag_sym) as ref_ty)) ->
              match lookup_tag_definition sigm tag_sym with
                | Just (StructDef membersDefs) ->
                    match List.lookup memb_ident membersDefs with
                      | Just (memb_qs, memb_ty) ->
                          E.return ( AilEmemberofptr e' memb_ident
                                   , GenLValueType (AAux.combine_qualifiers ref_qs memb_qs) memb_ty false )
                      | Nothing ->
                          E.constraint_violation (with_cursor_from (locOf e) (locOf memb_ident))
                                                 (MemberofptrNoMember memb_ident ref_qs ref_ty)
                    end
                | _ ->
                    error "annotate_expression(AilEmemberofptr struct): failed to find a valid tag definition"
              end
          | (e', GenPointer ref_qs (Ctype _ (Union tag_sym) as ref_ty)) ->
              match lookup_tag_definition sigm tag_sym with
                | Just (UnionDef membersDefs) ->
                    match List.lookup memb_ident membersDefs with
                      | Just (memb_qs, memb_ty) ->
                          E.return ( AilEmemberofptr e' memb_ident
                                   , GenLValueType (AAux.combine_qualifiers ref_qs memb_qs) memb_ty false )
                      | Nothing ->
                          E.constraint_violation (with_cursor_from (locOf e) (locOf memb_ident))
                                                 (MemberofptrNoMember memb_ident ref_qs ref_ty)
                    end
                | _ ->
                    error "annotate_expression(AilEmemberofptr union): failed to find a valid tag definition"
              end
          | (_, GenPointer ref_qs ref_ty) ->
              E.constraint_violation (with_cursor_from (locOf e) loc) (MemberofptrReferenceBaseType ref_qs ref_ty)
          | (_, gty) ->
              E.constraint_violation (with_cursor_from (locOf e) loc) (MemberofptrReferenceTypeNotPointer gty)
        end
    
    | AilEassign e1 e2 ->
        annotate_expression CTXassign e1 >>= fun e1' ->
        match GenTypes.genTypeCategoryOf e1' with
          | GenLValueType qs1 ty1 _ ->
              if AAux.modifiable sigm qs1 ty1 then
                let assign_ty = AAux.rvalue_coercion ty1 in
                E.add "§6.5.16#3, sentence 3" >>
                annotate_assignee SimpleAssignmentViolation loc assign_ty e2 >>= fun e2' -> 
                E.return (AilEassign e1' e2', GenRValueType (inject_type assign_ty))
              else
                E.constraint_violation (with_cursor_from (locOf e1) loc) AssignmentModifiableLvalue (* lvalue was not modifiable *)
          | _ ->
              E.constraint_violation (with_cursor_from (locOf e1) loc) AssignmentModifiableLvalue (* was not a lvalue *)
        end
    
    | AilEbinary e1 (Arithmetic (Mul  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 aop gty2 >>
        E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
    
    | AilEbinary e1 (Arithmetic (Div  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 aop gty2 >>
        E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
    
    | AilEbinary e1 (Arithmetic (Mod  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 aop gty2 >>
        E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
    
    | AilEbinary e1 (Arithmetic (Band as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 aop gty2 >>
        E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
    
    | AilEbinary e1 (Arithmetic (Bxor  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 aop gty2 >>
        E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
    
    | AilEbinary e1 (Arithmetic (Bor  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 aop gty2 >>
        E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
    
    | AilEbinary e1 (Arithmetic (Shl  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 aop gty2 >>
        E.return (AilEbinary e1' bop e2', GenRValueType (integer_promote gty1))
    
    | AilEbinary e1 (Arithmetic (Shr  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 aop gty2 >>
        E.return (AilEbinary e1' bop e2', GenRValueType (integer_promote gty1))
    
    | AilEbinary e1 (Arithmetic Add as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        (* NOTE: TODO: this is also relates to §6.5.2.1#1 *)
        (* STD §6.5.6#2 *)
        if is_pointer_to_complete_object sigm gty1 && is_integer gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType gty1)
        else if is_pointer_to_complete_object sigm gty2 && is_integer gty1 then
          E.return (AilEbinary e1' bop e2', GenRValueType gty2)
        else
          well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 Add gty2 >>
          E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
    
    | AilEbinary e1 (Arithmetic Sub as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if are_pointers_to_compatible_complete_objects sigm gty1 gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger PtrdiffT)))
        else if is_pointer_to_complete_object sigm gty1 && is_integer gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType gty1)
        else
          well_typed_binary_arithmetic ArithBinopOperandsType (locOf e1) loc (locOf e2) gty1 Sub gty2 >>
          E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
    
    | AilEbinary e1 (And as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if is_scalar gty1 && is_scalar gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc)) (AndInvalidOperandsType gty1 gty2)
    
    | AilEbinary e1 (Or  as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if is_scalar gty1 && is_scalar gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc)) (OrInvalidOperandsType gty1 gty2)
    
    | AilEbinary e1 (Lt as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if are_pointers_to_qualifiedOrUnqualified_compatible_types gty1 gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else if is_real gty1 && is_real gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc)) (RelationalInvalidOperandsType gty1 gty2)
    
    | AilEbinary e1 (Gt as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if are_pointers_to_qualifiedOrUnqualified_compatible_types gty1 gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else if is_real gty1 && is_real gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc)) (RelationalInvalidOperandsType gty1 gty2)
    
    | AilEbinary e1 (Le as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if are_pointers_to_qualifiedOrUnqualified_compatible_types gty1 gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else if is_real gty1 && is_real gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc)) (RelationalInvalidOperandsType gty1 gty2)
    
    | AilEbinary e1 (Ge as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if are_pointers_to_qualifiedOrUnqualified_compatible_types gty1 gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else if is_real gty1 && is_real gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc)) (RelationalInvalidOperandsType gty1 gty2)
    
    | AilEbinary e1 (Eq as bop) e2 ->
        (* STD §6.5.9#2 *)
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if well_typed_equality gty1 gty2 (is_null_pointer_constant e1') (is_null_pointer_constant e2') then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc)) (EqualityInvalidOperandsType gty1 gty2)
    
    | AilEbinary e1 (Ne as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if well_typed_equality gty1 gty2 (is_null_pointer_constant e1') (is_null_pointer_constant e2') then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          let () = Debug.print_debug 1 [] (fun () ->
            "gty1: " ^ Pp.stringFromAil_genType gty1 ^
            " <--> gty2: " ^ Pp.stringFromAil_genType gty2 ^
            " , are_pointers_to_compatible_types: " ^
            if are_pointers_to_compatible_types gty1 gty2 then "true" else "false"
          ) in
          E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc)) (EqualityInvalidOperandsType gty1 gty2)
    
    | AilEsizeof qs ty ->
        wf_lvalue sigm qs ty >>
        E.add "§6.5.3.4#1, sentence 1" >>
        if AAux.is_function ty || AAux.is_incomplete sigm ty then
          E.constraint_violation (with_cursor_from (locOf ty) loc) (SizeofInvalidApplication (inject_type ty))
        else
          E.add "§6.5.3.4#5" >>
          E.return (AilEsizeof qs ty, GenRValueType (GenBasic (GenInteger SizeT)))
    
    | AilEsizeof_expr e ->
        let () = Debug.warn [Debug.DB_ail_typing]
          (fun () -> "(TODO) GenTyping.annotate_expression AilEsizeof_expr, not checking for bit-field member") in
        (* because we are dealing with the operand of sizeof(), we do not call
           any of the conversion/decay functions (see §6.3.2.1#2-4) *)
        annotate_expression CTXsizeof e >>= fun a_e ->
        let gty = match GenTypes.genTypeCategoryOf a_e with
          | GenRValueType gty ->
              gty
          | GenLValueType _ ty _ ->
              inject_type ty
        end in
        E.add "§6.5.3.4#1, sentence 1" >>
        if GAux.is_function gty || GAux.is_incomplete sigm gty then
          E.constraint_violation (with_cursor_from (locOf e) loc) (SizeofInvalidApplication gty)
        else
          E.add "§6.5.3.4#5" >>
          E.return (AilEsizeof_expr a_e, GenRValueType (GenBasic (GenInteger SizeT)))
    
    | AilEalignof qs ty ->
        wf_lvalue sigm qs ty >>
        E.add "§6.5.3.4#1, sentence 1" >>
        if AAux.is_function ty || AAux.is_incomplete sigm ty then
          E.constraint_violation (with_cursor_from (locOf ty) loc) (AlignofInvalidApplication qs ty)
        else
          E.add "§6.5.3.4#5" >>
          E.return (AilEalignof qs ty, GenRValueType (GenBasic (GenInteger SizeT)))
    
    | AilEcast qs (Ctype _ Void as cty) e ->
        wf_lvalue sigm qs cty >>
        annotate_rvalue e >>= fun (e', _) ->
        E.return (AilEcast qs cty e', GenRValueType GenVoid)
    
    | AilEcast qs ty e ->
        wf_lvalue sigm qs ty >>
        annotate_rvalue e >>= fun (e', gty) ->
        if not (is_scalar gty && AAux.is_scalar ty) then
          E.constraint_violation (with_cursor_from (locOf e) loc) (CastInvalidType qs ty)
        else if is_pointer gty && AAux.is_floating ty then
          E.constraint_violation (with_cursor_from (locOf e) loc) CastPointerToFloat
        else if is_floating gty && AAux.is_pointer ty then
          E.constraint_violation (with_cursor_from (locOf e) loc) CastFloatToPointer
        else
          E.return (AilEcast qs ty e', GenRValueType (inject_type ty))
    
    | AilEcond e1 e2 e3 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        annotate_rvalue e3 >>= fun (e3', gty3) ->
        well_typed_conditional (loc, locOf e1, locOf e2, locOf e3)
            gty1 gty2 gty3 (is_null_pointer_constant e2') (is_null_pointer_constant e3') >>= fun genCat ->
        E.return (AilEcond e1' e2' e3', genCat)
    
    | AilEcompoundAssign e1 (Add as aop) e2 ->
        annotate_expression CTXassign e1 >>= fun e1'         ->
        annotate_rvalue e2     >>= fun (e2', gty2) ->
        match GenTypes.genTypeCategoryOf e1' with
          | GenLValueType qs ty _ -> 
              AAux.lvalue_coercion sigm ty >>= fun ty1 ->
                if    AAux.modifiable sigm qs ty
                   && (AAux.is_arithmetic ty1 && is_arithmetic gty2 || AAux.is_pointer_to_complete_object sigm ty && is_integer gty2) then
                  E.return (AilEcompoundAssign e1' aop e2', GenRValueType (inject_type ty1))
                else
                  E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc))
                                         (CompoundAssignmentAddSubOperandTypes (inject_type ty1) gty2)
          | _ ->
              E.constraint_violation (with_cursor_from (locOf e1) loc) AssignmentModifiableLvalue
        end
    
    | AilEcompoundAssign e1 (Sub as aop) e2 ->
        annotate_expression CTXassign e1 >>= fun e1'         ->
        annotate_rvalue e2     >>= fun (e2', gty2) ->
        match GenTypes.genTypeCategoryOf e1' with
          | GenLValueType qs ty _ -> 
              AAux.lvalue_coercion sigm ty >>= fun ty1 ->
                if    AAux.modifiable sigm qs ty
                   && (AAux.is_arithmetic ty1 && is_arithmetic gty2 || AAux.is_pointer_to_complete_object sigm ty && is_integer gty2) then
                  E.return (AilEcompoundAssign e1' aop e2', GenRValueType (inject_type ty1))
                else
                  E.constraint_violation (with_regions_and_cursor [locOf e1; locOf e2] (Just loc))
                                         (CompoundAssignmentAddSubOperandTypes (inject_type ty1) gty2)
          | _ ->
              E.constraint_violation (with_cursor_from (locOf e1) loc) AssignmentModifiableLvalue
        end
    
    | AilEcompoundAssign e1 aop e2 ->
        annotate_expression CTXassign e1 >>= fun e1'         ->
        annotate_rvalue e2     >>= fun (e2', gty2) ->
        match GenTypes.genTypeCategoryOf e1' with
          | GenLValueType qs ty _ ->
              inject_type <$> AAux.lvalue_coercion sigm ty >>= fun gty1 ->
              if AAux.modifiable sigm qs ty then
                well_typed_binary_arithmetic CompoundAssignmentOthersOperandTypes (locOf e1) loc (locOf e2) gty1 aop gty2 >>
                E.return (AilEcompoundAssign e1' aop e2', GenRValueType gty1)
              else
                E.constraint_violation (with_cursor_from (locOf e1) loc) AssignmentModifiableLvalue
          | _ ->
              E.constraint_violation (with_cursor_from (locOf e1) loc) AssignmentModifiableLvalue
        end
    
    | AilEconst cst ->
        (* STD §6.5.1#3 *)
        E.add "§6.5.1#3" >>
(*
        annotate_constant cst >>= fun (cst', gty) ->
        E.return (AilEconst cst', gty)
*)
        typecheck_constant cst >>= fun gty ->
        E.return (AilEconst cst, GenRValueType gty)
    
    (* TODO: check *)
    | AilEstr lit ->
        (* STD §6.5.1#4 *)
        E.add "§6.5.1#4" >>
        annotate_stringLiteral lit
    
    (* TODO: maybe look at the type of inside? *)
    | AilEannot ty e ->
        annotate_expression ctx e >>= function
          | AnnotatedExpression (GenLValueType qs _ isRegister) _ _ e' ->
              E.return (e', GenLValueType qs ty isRegister)
          | AnnotatedExpression (GenRValueType _) annots loc e' ->
              E.return (e', GenRValueType (inject_type ty))
        end
    
    | AilEva_start e sym ->
        annotate_rvalue e >>= fun (e', _) ->
        E.return (AilEva_start e' sym, GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        (* TODO: add this check later
        annotate_rvalue e >>= function
          | (e', GenBuiltin "va_list") ->
              E.return (AilEva_start e' sym, GenRValueType GenVoid)
          | _ ->
              E.misc (locOf e) VaStartArgumentType
        end
        *)
    
    | AilEva_copy e1 e2 ->
        annotate_rvalue e1 >>= fun (e1', _) ->
        annotate_rvalue e2 >>= fun (e2', _) ->
        E.return (AilEva_copy e1' e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
    
    | AilEva_arg e ty ->
        annotate_rvalue e >>= fun (e', _) ->
        E.return (AilEva_arg e' ty, GenRValueType (inject_type ty))
        (* TODO: add this check later
        annotate_rvalue e >>= function
          | (e', GenBuiltin "va_list") ->
              E.return (AilEva_arg e' ty, GenRValueType (inject_type ty))
          | _ ->
              E.misc (locOf e) VaArgArgumentType
        end
        *)

    | AilEva_end e ->
        annotate_rvalue e >>= fun (e', _) ->
        E.return (AilEva_end e', GenRValueType GenVoid)
    
    | AilEprint_type e ->
        annotate_expression ctx e >>= fun a_e ->
        E.return (AilEprint_type a_e, genTypeCategoryOf a_e)
    | AilEbmc_assume e ->
        annotate_rvalue e >>= fun (e', gty) ->
        E.return (AilEbmc_assume e', GenRValueType GenVoid)
    | AilEreg_load r ->
        E.return (AilEreg_load r, GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_))))) (* NOTE: assuming registers are always of type int *)
    | AilErvalue _ ->
        (* This should be impossible because the desugaring doesn't emit any AilErvalue *)
        error "annotate_expression(AilErvalue)"
    | AilEarray_decay _ ->
        (* This should be impossible because the Desugaring doesn't emit any AilEarray_decay *)
        error "annotate_expression(AilEarray_decay)"
    | AilEfunction_decay _ ->
        (* This should be impossible because the Desugaring doesn't emit any AilEfunction_decay *)
        error "annotate_expression(AilEfunction_decay)"
  end
  >>= fun (expr_', gtc) ->
  E.unpack >>= fun annots ->
  perform_decays sigm ctx (AnnotatedExpression gtc annots loc expr_')






(*
(* Must NOT BE CALLED for:
     - the operand of the AilEsizeof_expr
     - the operand of the AilEunary Address
     - the operand of the AilEunary PostIncr
     - the operand of the AilEunary PostDecr
     - the left operand of AilEmemberof
     - the left operand of AilEassign and AilEcompoundAssign *)
(* STD §6.3.2.1#2 *)
(* TYPE: sigma unit -> expression genTypeCategory -> E.errorM (expression genTypeCategory) *)
and nonarray_lvalue_conversion sigm a_expr =
  match genTypeCategoryOf a_expr with
    | GenLValueType qs ty isRegister ->
        if not (AAux.is_array ty) then
          let rvalue_ty = AAux.unatomic (AAux.unqualify ty) in
          if AAux.is_incomplete sigm ty then
            error "TODO: nonarray_lvalue_conversion ==> undefined behaviour"
          else
            E.return (
              AnnotatedExpression (GenRValueType (inject_type rvalue_ty))
                (Loc.locOf a_expr) (AilErvalue a_expr)
            )
        else
          E.return a_expr
    | GenRValueType gty ->
        error "WIP: nonarray_lvalue_conversion, GenRValueType"
  end

(* Must NOT BE CALLED for:
     - the operand of AilEsizeof_expr
     - the operand of AilEunary Address
     - a AilEstr used to initialize an array *)
(* STD §6.3.2.1#3 *)
(* TYPE: sigma unit -> expression genTypeCategory -> E.errorM (expression genTypeCategory) *)
and array_decay sigm a_expr =
  (* TODO: DEAD CODE *)
  match genTypeCategoryOf a_expr with
    | GenLValueType qs ty isRegister ->
        if AAux.is_array ty then
          if isRegister then
            error "TODO: array_decay ==> undefined behaviour"
          else
            (* TODO: qualifiers?? *)
            let () = begin
              if not (AAux.is_unqualified qs) then
                Debug.warn [Debug.DB_ail_typing] (fun () -> "(UNSURE) GenTyping.array_decay, qs <> {}")
              else
              ()
            end in
            E.return (
              AnnotatedExpression (GenRValueType (inject_type (AAux.array_coercion ty)))
                (Loc.locOf a_expr) (AilEarray_decay a_expr)
            )
        else
          E.return a_expr
    | GenRValueType gty ->
        error "WIP: array_decay, GenRValueType"
  end

(* Must NOT BE CALLED for:
     - the operand of AilEsizeof_expr
     - the operand of AilEunary Address *)
(* STD §6.3.2.1#4 *)
(* TYPE: sigma unit -> expression genTypeCategory -> E.errorM (expression genTypeCategory) *)
and function_decay sigm a_expr =
  (* TODO: DEAD CODE *)
  error "WIP: function_decay"
*)

and perform_decays sigm ctx a_expr =
  let is_literal = match a_expr with
    | AnnotatedExpression _ _ _ (AilEarray true _ _) ->
        true
    | AnnotatedExpression _ _ _ (AilEconst (ConstantArray _ _)) ->
        true
    | AnnotatedExpression _ _ _ (AilEstr _) -> (* TODO: this is probably dead now *)
        true
    | _ ->
        false
  end in
  match annotations a_expr with
    | (std_annots, GenLValueType qs ty isRegister) ->
        let () = Debug.print_debug 1 [] (fun () ->
          "GenLValueType ==>" ^ Pp.stringFromAil_ctype qs ty
        ) in
        if    not (AAux.is_array ty)
           && not (List.elem ctx [CTXsizeof; CTXaddr; CTXincr; CTXdecr; CTXmemberof; CTXassign]) then
          (* STD §6.3.2.1#2 *)
          (* performing the lvalue conversion *)
          let rvalue_ty = Ctype [] (AAux.unatomic ty) in
          if AAux.is_incomplete sigm ty then
            (* STD §6.3.2.1#2, sentence 3 *)
            E.undef (Loc.locOf ty) Undefined.UB020_nonarray_incomplete_lvalue_conversion
          else
            E.return (
              AnnotatedExpression (GenRValueType (inject_type rvalue_ty))
                std_annots (Loc.locOf a_expr) (AilErvalue a_expr)
            )
        else if    AAux.is_array ty
                && not (List.elem ctx [CTXsizeof; CTXaddr])
                && not (List.elem ctx [CTXarray_init] && is_literal) then
          (* STD §6.3.2.1#3 *)
          (* performing the array decay *)
          if isRegister then
            E.undef Loc.unknown Undefined.UB022_register_array_decay
          else
            (* TODO: qualifiers?? *)
            let () = begin
              if not (AAux.is_unqualified qs) then
                Debug.warn [Debug.DB_ail_typing] (fun () -> "(UNSURE) GenTyping.array_decay, qs <> {}")
              else
                ()
            end in
            E.return (
              AnnotatedExpression (GenRValueType (inject_type (AAux.array_coercion ty)))
                std_annots (Loc.locOf a_expr) (AilEarray_decay a_expr)
            )
        else
          E.return a_expr
    | (std_annots, GenRValueType gty) ->
        if not (List.elem ctx [CTXsizeof; CTXaddr]) then
          (* STD §6.3.2.1#4 *)
          (* performing the function decay *)
          E.return match gty with
            | GenFunction hasProto ty params isVariadic ->
                AnnotatedExpression
                  (GenRValueType (GenPointer no_qualifiers (Ctype [] (Function hasProto ty params isVariadic))))
                  std_annots (Loc.locOf a_expr) (AilEfunction_decay a_expr)
            | GenArray elem_ty sz_opt ->
              match a_expr with
                | AnnotatedExpression _ _ _ (AilEarray false _ _) ->
                    (* NOTE: this case doesn't syntactically exist in C, since
                       array values don't exist *)
                    a_expr
                | _ ->
                    if not (List.elem ctx [CTXarray_init] && is_literal) then
                      let ty = Ctype [] (Array elem_ty sz_opt) in
                      (* STD §6.3.2.1#3 *)
                      (* performing the array decay *)
                      AnnotatedExpression (GenRValueType (inject_type (AAux.array_coercion ty)))
                        std_annots (Loc.locOf a_expr) (AilEarray_decay a_expr)
                    else
                      a_expr
              end
            | _ ->
                a_expr
          end
        else
          E.return a_expr
  end













and annotate_rvalue sigm gamm expr =
  annotate_expression sigm gamm CTXother expr >>= fun (AnnotatedExpression gtc std_annots loc expr_) ->
   E.return match gtc with
     | GenRValueType gty ->
         (AnnotatedExpression (GenRValueType gty) std_annots loc expr_, gty)
     | GenLValueType qs ty isRegister ->
         (AnnotatedExpression (GenLValueType qs ty isRegister) std_annots loc expr_, inject_type ty)
   end


and annotate_assignee sigm gamm a_ctxt loc ty1 e2 =
  annotate_rvalue sigm gamm e2 >>= fun (e2, gty2) ->
  well_typed_assignment sigm a_ctxt loc ty1 gty2 e2 >>
  E.return e2


and annotate_arguments_aux sigm gamm n_args n_params loc has_proto is_variadic args params =
  let annotate_expression = annotate_expression sigm gamm CTXother in
  let annotate_assignee   = annotate_assignee sigm gamm FunctionParameterAsSimpleAssignment in
  let annotate_arguments_aux = annotate_arguments_aux sigm gamm n_args n_params loc has_proto is_variadic in
  match (args, params) with
    | ([], []) ->
        E.return []
    | ([], [(_, Ctype _ Void, _)]) ->
        (* TODO: document this case *)
        E.return []
    | (arg_e :: args', (_, param_ty1, isRegister) :: params') ->

(*
        if has_proto then
*)
          (* TODO: add location *)
          annotate_assignee Loc.unknown (AAux.rvalue_coercion param_ty1) arg_e          >>= fun a_arg_e ->
          annotate_arguments_aux args' params' >>= fun a_args' ->
          E.return (a_arg_e :: a_args')
(*
        else
          (* the called function has a type that does not include a prototype *)
          (* STD §6.5.2.2#6 *)
          let ty1' = KKKK
*)


    | (_, []) ->
        (* This case must correspond to a call to a variadic function *)
        if not is_variadic then
          E.constraint_violation loc (FunctionCallTooManyArguments n_params n_args)
        else
          (* following (§6.5.2.2#7) *)
          (* TODO: default argument promotion + checks (at least that there are no void-expression, though this might already be done by the promotion) *)
          E.mapM annotate_expression args
(*
          E.mapM annotate_expression args >>= fun a_args ->
          if List.any (fun z -> type_of annot z = Void) a_args then
            E.fail Loc.unknown (TError "called a variadic function with a void expression")
          else
            E.return a_args
*)
    | (_, _) ->
        E.constraint_violation loc (FunctionCallTooFewArguments n_params n_args)
  end

and annotate_arguments sigm gamm loc has_proto is_variadic args params =
  annotate_arguments_aux sigm gamm (List.length args) (List.length params) loc has_proto is_variadic args params












(*
(* returns both the annotated intializer and the infered type (used for arrays) *)
and annotate_initialization sigm gamm ty e =
  (* §6.7.9#3 *)
  E.guard (TError "failed §6.7.9#3")
    (   AAux.is_array_unknown_size ty
     || AAux.is_complete_object sigm ty && not (AAux.is_vla ty)) >>
  
  if AAux.is_scalar ty then
    (* STD §6.7.9#11, sentence 3 *)
    annotate_assignee sigm gamm (AAux.unqualify ty) e >>= fun a_e ->
    E.return (a_e, ty)
  
  (* TODO: "(...) that has automatic storage duration" *)
  (* STD §6.7.9#13 *)
  else if AAux.is_struct_or_union ty then
    (* TODO: check *)
    annotate_rvalue sigm gamm e >>= fun (a_e, gty) ->
    (* TODO: need to make sure that gty is compatible with ty *)
    E.return (a_e, ty)
  
  (* STD §6.7.9#14 *)
  else if AAux.is_array_of_character ty then
    error ("WIP: annotate_initialization, is_array_of_character ty ==> " ^ Pp.stringFromAil_ctype ty)
  
  (* STD §6.7.9#15 *)
  else if AAux.compatibleWithQualifiedUnqualifiedVersionOf ty [Builtin "wchar_t"; char16_t; char32_t] then
    error "WIP: annotate_initialization, compatibleWithQualifiedUnqualifiedVersionOf ty [Builtin \"wchar_t\"; char16_t; char32_t]"
  
  (* STD §6.7.9#16 *)
(*          else if  then *) (* KKK *)
  (* TODO: at this point we should now have a non character array *)
  else if AAux.is_array ty then
    (* TODO: check the std. (not that it says anything useful here ...) *)
    annotate_expression sigm gamm e >>= fun a_e ->
    match (ty, GenTypes.genTypeCategoryOf a_e) with
      | (Array elem_qs1 elem_ty1 Nothing, GenRValueType (GenArray _ elem_ty2 (Just n2))) ->
          (* TODO: check, but I don't think we need to do anything regarding qualifiers here *)
          if AAux.compatible elem_ty1 elem_ty2 then
            E.return (a_e, Array elem_ty1 (Just n2))
          else
            error ("TODO(annotate_initialisation, 1): error message: array object definition, types didn't match ==> " ^
                   Pp.stringFromAil_ctype elem_ty1 ^ " <-> " ^ Pp.stringFromAil_ctype elem_ty2)
     | (Array _ elem_ty1 (Just n1), GenRValueType (GenArray _ elem_ty2 (Just n2))) ->
          (* TODO: check, but I don't think we need to do anything regarding qualifiers here *)
         if AAux.compatible elem_ty1 elem_ty2 && n1 = n2 then
           E.return (a_e, Array elem_ty1 (Just n1))
         else
            error ("TODO(annotate_initialisation, 2): error message: array object definition, types didn't match ==> " ^
                   Pp.stringFromAil_ctype elem_ty1 ^ " <-> " ^ Pp.stringFromAil_ctype elem_ty2)
     | _ ->
         error "WIP: annotate_initialization, not(is_scalar ty), not array (or had no size)"
    end
  else
    error "WIP: annotate_initialization, final case"

*)














and annotate_definition_aux sigm gamm (ty, e) =
  if    (AAux.is_array ty --> AAux.has_unknown_size ty)
     || (AAux.is_complete_object sigm ty --> not (AAux.is_vla ty)) then
    if AAux.is_scalar ty then
      E.add "§6.7.9#11, sentence 3" >>
      (* NOTE: since we are not passing a `qs' with `ty' to annotate_assignee,
         we are indeed unqualifying the scalar type *)
      (* TODO: add location *)
      annotate_assignee sigm gamm InitializationAsSimpleAssignment Loc.unknown ty e
      
      (* TODO: "(...) that has automatic storage duration" *)
      else if AAux.is_struct_or_union ty then
        (* TODO: check *)
        E.add "§6.7.9#13" >>
        annotate_rvalue sigm gamm e >>= fun (a_e, gty) ->
        (* TODO: need to make sure that gty is compatible with ty *)
        E.return a_e
      
      (* STD §6.7.9#15 *)
      else if AAux.compatibleWithQualifiedUnqualifiedVersionOf ty [AAux.mk_ctype_builtin "wchar_t"; char16_t; char32_t] then
        error "WIP: annotate_definition_aux, compatibleWithQualifiedUnqualifiedVersionOf ty [Builtin \"wchar_t\"; char16_t; char32_t]"
      
          (* STD §6.7.9#16 *)
(*          else if  then *) (* KKK *)

      (* TODO: at this point we should now have a non character array *)
      else if AAux.is_array ty then
        (* TODO: check the std. (not that it says anything useful here ...) *)
        let ctx =
(*          if AAux.is_array_of_character ty then *)
          if AAux.is_array ty then
            CTXarray_init
          else
            CTXother in
        annotate_expression sigm gamm ctx e >>= fun a_e ->
          let () = Debug.warn [Debug.DB_ail_typing]
            (fun () -> "(UNSURE) for the definition of arrays the compatilibity of types is checked for they unqualified versions and ignoring the elem_qs") in
        match (ty, GenTypes.genTypeCategoryOf a_e) with
          | (Ctype _ (Array elem_ty1 Nothing), GenRValueType (GenArray elem_ty2 (Just n))) ->
              if AAux.are_compatible (no_qualifiers, elem_ty1) (no_qualifiers, elem_ty2) then
                E.return a_e (* (e', GenArray elem_ty1 (Just n)) *)
              else
                error ("TODO(annotate_definition_aux, 1): error message: array object definition, types didn't match ==> " ^
                       Pp.stringFromAil_ctype no_qualifiers elem_ty1 ^ " <-> " ^ Pp.stringFromAil_ctype no_qualifiers elem_ty2)
         | (Ctype _ (Array elem_ty1 (Just n1)), GenRValueType (GenArray elem_ty2 (Just n2))) ->
              if AAux.are_compatible (no_qualifiers, elem_ty1) (no_qualifiers, elem_ty2) && n1 = n2 then
                E.return a_e (* (e', GenArray elem_ty1 (Just n1)) *)
              else
                error ("TODO(annotate_definition_aux, 2): error message: array object definition, types didn't match ==> " ^
                       Pp.stringFromAil_ctype no_qualifiers elem_ty1 ^ " <-> " ^ Pp.stringFromAil_ctype no_qualifiers elem_ty2)

         | (Ctype _ (Array elem_ty1 (Just n1)), GenLValueType qs2 (Ctype _ (Array elem_ty2 (Just n2))) _) ->
             (* TODO: isRegister? *)
             (* TODO: what if n1 < n2? *)
             (* TODO: check std *)
             if AAux.are_compatible (no_qualifiers, elem_ty1) (no_qualifiers, elem_ty2) && n1 >= n2 then
               E.return a_e
             else
                error ("TODO(annotate_definition_aux, 3): error message: array object definition, types didn't match ==> " ^
                       Pp.stringFromAil_ctype no_qualifiers elem_ty1 ^ "[" ^ show n1 ^ "] <-> " ^
                       Pp.stringFromAil_ctype no_qualifiers elem_ty2 ^ "[" ^ show n2 ^ "]")
         | _ ->
             (* STD §6.7.9#14 *)
             if AAux.is_array_of_character ty then
               error ("WIP: annotate_definition_aux, is_array_of_character ty ==> " ^
                      Pp.stringFromAil_ctype no_qualifiers ty ^ " <===> " ^ Pp.stringFromAil_expression a_e)
             else
               let () = Debug.print_debug 1 [] (fun () ->
                 "ty: " ^ Pp.stringFromAil_ctype no_qualifiers ty ^ " <--> gty: " ^
                 match GenTypes.genTypeCategoryOf a_e with
                   | GenLValueType qs' ty' _ ->
                       "lvalue " ^ Pp.stringFromAil_ctype qs' ty'
                   | GenRValueType gty ->
                       "rvalue " ^ Pp.stringFromAil_genType gty
                 end
               ) in
               error "WIP: annotate_definition, not(is_scalar ty), not array (or had no size)"
        end
      else
        error "WIP: annotate_definition_aux, final case"
  else
    (* STD §6.7.9#3 *)
    E.constraint_violation (Loc.locOf e) IllegalInitializer

val annotate_definition: sigma unit -> gamma -> (Symbol.sym * expression unit) -> E.errorM (Symbol.sym * expression genTypeCategory)
let annotate_definition sigm gamm (sym, e) =
  match Context.lookup identifierEqual gamm sym with
    | Just (_, sym_qs, sym_ty) ->
        annotate_definition_aux sigm gamm (sym_ty, e) >>= fun a_e ->
        E.return (sym, a_e)
    | Nothing ->
        error "annotate_definition: symbol not found in the context"
  end


val annotate_definitions:
  sigma unit -> gamma -> list (Symbol.sym * expression unit) -> E.errorM (list (Symbol.sym * expression genTypeCategory))
let rec annotate_definitions sigm gamm = function
  | [] ->
      E.return []
  | d :: ds ->
      annotate_definition  sigm gamm d  >>= fun d  ->
      annotate_definitions sigm gamm ds >>= fun ds ->
      E.return (d :: ds)
end


val     annotate_statement_: Loc.t -> sigma unit -> gamma -> ctype -> statement_ unit -> E.errorM (statement_ genTypeCategory)
let rec annotate_statement_ loc sigm gamm ty stmt =
  let annotate_expression = annotate_expression sigm gamm CTXother   in
  let annotate_rvalue     = annotate_rvalue sigm gamm       in
  let annotate_block bindings =
    (* WIP *)
    E.mapM (annotate_statement sigm (Context.add_bindings bindings gamm) ty) in
  let annotate_statement  = annotate_statement sigm gamm ty in
  
  match stmt with
    | AilSskip ->
        E.return AilSskip
    | AilSexpr e ->
        annotate_expression e >>= fun e' ->
        E.return (AilSexpr e')
    | AilSblock bindings ss ->
        AilTyping.well_formed_bindings loc sigm bindings >>
        if sigma_fresh_bindings bindings sigm then
          annotate_block bindings ss >>= fun ss' ->
          E.return (AilSblock bindings ss')
        else
          error "annotate_statement: sigma_fresh bindings failed in a AilSblock"
    | AilSif e s1 s2 ->
        annotate_rvalue e >>= fun (e', gty) ->
        E.add "§6.8.4.1#1" >>
        if is_scalar gty then
          annotate_statement s1 >>= fun s1' ->
          annotate_statement s2 >>= fun s2' ->
          E.return (AilSif e' s1' s2')
        else
          E.constraint_violation (Loc.locOf e) IfStatementControllingExpressionNotScalar
    | AilSwhile e s ->
        annotate_rvalue e >>= fun (e', gty) ->
        E.add "§6.8.5#2" >>
        if is_scalar gty then
          annotate_statement s >>= fun s' ->
          E.return (AilSwhile e' s')
        else
          E.constraint_violation (Loc.locOf e) IterationStatementControllingExpressionNotScalar
    | AilSdo s e ->
        annotate_rvalue e >>= fun (e', gty) ->
        E.add "§6.8.5#2" >>
        if is_scalar gty then
          annotate_statement s >>= fun s' ->
          E.return (AilSdo s' e')
        else
          E.constraint_violation (Loc.locOf e) IterationStatementControllingExpressionNotScalar
    | AilSbreak ->
        E.return AilSbreak
    | AilScontinue ->
        E.return AilScontinue
    | AilSreturnVoid ->
        if AAux.is_void ty then
          E.return AilSreturnVoid
        else
          E.constraint_violation loc NonVoidReturnVoidFunction
    | AilSreturn e ->
        annotate_assignee sigm gamm ReturnAsSimpleAssignment (with_cursor_from (locOf e) loc) ty e >>= fun e' ->
        E.return (AilSreturn e')
    | AilSswitch e s ->
        annotate_rvalue e >>= fun (e', gty) ->
        E.add "§6.8.4.2#1" >>
        if is_integer gty then
          annotate_statement s >>= fun s' ->
          E.return (AilSswitch e' s')
        else
          E.constraint_violation (Loc.locOf e) SwitchStatementControllingExpressionNotInteger
    | AilScase ic s ->
        annotate_statement s >>= fun s' ->
        E.return (AilScase ic s')
    | AilSdefault s ->
        annotate_statement s >>= fun s' ->
        E.return (AilSdefault s')
    | AilSlabel sym s ->
        annotate_statement s >>= fun s' ->
        E.return (AilSlabel sym s')
    | AilSgoto sym ->
        E.return (AilSgoto sym)
    | AilSdeclaration sym_es ->
        annotate_definitions sigm gamm sym_es >>= fun sym_es' ->
        E.return (AilSdeclaration sym_es')
    | AilSpar ss ->
        E.mapM annotate_statement ss >>= fun ss' ->
        E.return (AilSpar ss')
    | AilSreg_store r e ->
        annotate_rvalue e >>= fun (e', _) ->
        E.return (AilSreg_store r e')
  end

and annotate_statement sigm gamm ty (AnnotatedStatement loc stmt) =
  annotate_statement_ loc sigm gamm ty stmt >>= fun stmt' ->
  E.return (AnnotatedStatement loc stmt')


val annotate_block:
      sigma unit -> gamma -> ctype -> list (statement unit) -> E.errorM (list (statement genTypeCategory))
let annotate_block sigm gamm ty stmts =
  E.mapM (annotate_statement sigm gamm ty) stmts

val annotate_sigma: sigma unit -> E.errorM (sigma genTypeCategory)
let annotate_sigma sigm =
  (* TODO: morally we want a "mapP_" here *)
  (* Checking that declarations are well-formed *)
  E.mapM (fun (ident, decl) ->
    match decl with
    | (_, (Decl_object dur_opt qs ty as decl)) ->
        wf_lvalue sigm qs ty >>
        E.return (ident, decl)
    | (_, (Decl_function hasProto ret_ty params isVariadic _ (* isInline *) _ (* isNoreturn *) as decl)) ->
        (* TODO?   ==> AilTyping.well_formed_bindings bs && *)
        wf_type sigm (Ctype [] (Function hasProto ret_ty params isVariadic)) >>
        E.return (ident, decl)
    end
  ) sigm.declarations >>
  
  (* Typechecking of external objects that have a definition *)
  E.mapM (fun (ident, e) ->
    match Context.lookup identifierEqual sigm.declarations ident with
      | Just (loc, Decl_object _ _ (* qs *) ty) ->
          (* TODO: qualifiers?; storage duration? *)
          annotate_definition_aux sigm Context.empty (ty, e) >>= fun def ->
          E.return (ident, def)
      | _ ->
          error "annotate_sigma: object definition must have a declaration"
    end
  ) sigm.object_definitions >>= fun object_defs' ->
  
  (* Typechecking of functions that have a definition *)
  E.mapM (fun (ident, (loc, param_idents, s)) ->
    match Context.lookup identifierEqual sigm.declarations ident with
      | Just (_, Decl_function hasProto (ret_qs, ret_ty) params _ (* isVariadic *) _ (* isInline *) _ (* isNoreturn *)) ->
          (* TODO: qualifiers *)
          let () = Debug.warn [] (fun () ->
            "(unsure) annotate_sigma doesn't look at [ret_qs]"
           ) in
          let bindings = List.map (fun (ident, (qs, ty, isRegister)) ->
            (* STD §6.9.1#9, first sentence *)
            (ident, ((loc, Automatic, isRegister), qs, ty))
          ) (List.zip param_idents params) in
          if sigma_fresh_bindings bindings sigm then
            annotate_statement sigm (Context.add_bindings bindings Context.empty) ret_ty s >>= fun s' ->
              E.return (ident, (loc, param_idents, s'))
          else
            error "annotate_sigma: parameter identifiers are not fresh"
      | _ ->
          error "annotate_sigma: function definition must have a declaration"
    end
  ) sigm.function_definitions >>= fun function_defs' ->
  
  E.mapM (fun tag ->
    let check_member sigm (ident, (qs, ty)) =
      E.add "§6.7.2.1#3" >>
      if AilTypesAux.has_flexible_array_member sigm ty then
        E.constraint_violation (Loc.locOf ident) StructMemberFlexibleArray
      else if AilTypesAux.is_function ty then
        E.constraint_violation (Loc.locOf ident) (StructMemberFunctionType ident)
      else if AilTypesAux.is_incomplete sigm ty then
        E.constraint_violation (Loc.locOf ident) (StructMemberIncompleteType qs ty)
      else
        E.return ()
    in match tag with
    | (_, StructDef xs) ->
        (* STD §6.7.2.1#3 *)
        match List.dest_init xs with
          | Nothing ->
              (* NOTE: this should be dead code because of the C syntax *)
              error "GenTyping.annotate_sigma, StructDef, empty sdecls_opt"
          | Just ([], memb) ->
              check_member sigm memb
          | Just (xs', (last_ident, (last_qs, last_ty))) ->
              E.mapM_ (check_member sigm) xs' >>
              (* This allows flexible array members *)
              if AilTypesAux.has_flexible_array_member sigm last_ty then
                E.constraint_violation (Loc.locOf last_ident) StructMemberFlexibleArray
              else if AilTypesAux.is_function last_ty then
                E.constraint_violation (Loc.locOf last_ident) (StructMemberFunctionType last_ident)
              else if AilTypesAux.is_incomplete sigm last_ty && not (AilTypesAux.is_array_unknown_size last_ty) then
                E.constraint_violation (Loc.locOf last_ident) (StructMemberIncompleteType last_qs last_ty)
              else
                E.return ()
        end >>
        E.mapM_ (fun (_, (qs, ty)) ->
          (* TODO: check that it is ok to use wf_lvalue (instead of just wf_type) *)
          wf_lvalue sigm qs ty
        ) xs
    | (_, UnionDef xs) ->
        E.mapM (check_member sigm) xs >>
        E.mapM_ (fun (_, (qs, ty)) ->
          (* TODO: check that it is ok to use wf_lvalue (instead of just wf_type) *)
          wf_lvalue sigm qs ty
        ) xs
  end) sigm.tag_definitions >>
  
  E.return <|
    declarations=         sigm.declarations;
    object_definitions=   object_defs';
    function_definitions= function_defs';
    (* TODO: hack *)
    static_assertions= [];
    tag_definitions= sigm.tag_definitions;
    extern_idmap= sigm.extern_idmap;
  |>


(* NOTE: this is the only thing this module exports *)
val annotate_program: ail_program unit -> E.errorM (ail_program genTypeCategory)
let annotate_program (startup_opt, sigm) =
  match startup_opt with
    | Nothing ->
        annotate_sigma sigm >>= fun sigm' ->
        E.return (startup_opt, sigm')
    | Just startup ->
        match Context.lookup identifierEqual sigm.declarations startup with
          | Just (loc, Decl_function hasProto (ret_qs, ret_ty) params (* bs *) _ (* isVariadic *) _ (* isInline *) _ (* isNoreturn *)) ->
              (* STD §5.1.2.2.1 *)
              (* TODO: "... or equivalent;10) or in some other implementation-defined manner." *)
              match params with
                | [] ->
                    (* TODO: not sure if really allowed by the std, clearly used a lot *)
                    E.return ()
                | [(<| const= false; restrict= false; volatile= false(*; atomic= false*) |>, Ctype _ Void, _)] ->
                    E.return ()
                | [(<| const= false; restrict= false; volatile= false(*; atomic= false*) |>, Ctype _ (Basic (Integer (Signed Int_))), _);
                   (<| const= false; restrict= false; volatile= false(*; atomic= false*) |>,
                    Ctype _ (Pointer <| const= false; restrict= false; volatile= false(*; atomic= false*) |>
                      (Ctype _ (Pointer <| const= false; restrict= false; volatile= false(*; atomic= false*) |> (Ctype _ (Basic (Integer Char)))))), _)] ->
                    E.return ()
                    (* TODO: can the parameters be qualified with const or volatile? *)
                | ((<| const= false; restrict= false; volatile= false(*; atomic= false*) |>, Ctype _ (Basic (Integer (Signed Int_))), _)::
                  (_, aty2, _)::_) ->
                    E.undef (Loc.with_cursor_from (Loc.locOf aty2) loc) Undefined.UB004c_incorrect_main_argument2
                | ((_, aty1, _)::_) ->
                    E.undef (Loc.with_cursor_from (Loc.locOf aty1) loc) Undefined.UB004b_incorrect_main_argument1
              end >>
              (* TODO: check arguments *)
              if ret_qs = no_qualifiers && proj_ctype_ ret_ty = Basic (Integer (Signed Int_)) then
                annotate_sigma sigm >>= fun sigm' ->
                E.return (startup_opt, sigm')
              else
                E.undef (Loc.with_cursor_from (Loc.locOf ret_ty) loc) Undefined.UB004a_incorrect_main_return_type
          | Just (loc, _) ->
              E.undef loc Undefined.UB004d_main_not_function
          | Nothing ->
              error ("Startup function " ^ show startup ^ " not found in AIL declarations.")
        end
  end
