open import Pervasives Common Utils AilSyntax AilTypes ErrorMonad TypingError Annot
import Implementation_
import Loc Debug

import Implementation


(* NOTE: a well-formed ctype cannot have an Atomic inside another one *)
let unatomic (Ctype _ ty) =
match ty with
  | Atomic (Ctype _ ty) ->
      ty
  | ty ->
      ty
end



(* == Function on qualifiers ==================================================================== *)
val is_unqualified: qualifiers -> bool
let is_unqualified = function
  | <|
      const    = false;
      restrict = false;
      volatile = false;
(*      atomic   = false *)
    |> ->
      true
  | _ ->
      false
end

val combine_qualifiers: qualifiers -> qualifiers -> qualifiers
let combine_qualifiers qs1 qs2 = <|
  const    = qs1.const    || qs2.const   ;
  restrict = qs1.restrict || qs2.restrict;
  volatile = qs1.volatile || qs2.volatile;
(*  atomic   = qs1.atomic   || qs2.atomic  ; *)
|>

val sub_qualifiers: qualifiers -> qualifiers -> bool
let sub_qualifiers qs1 qs2 =
     (qs1.const    --> qs2.const)
  && (qs1.restrict --> qs2.restrict)
  && (qs1.volatile --> qs2.volatile)
(*  && (qs1.atomic   --> qs2.atomic) *)


(* == predicates on integerTypes ================================================================= *)
(* TODO: factorise is_signed_ity and is_unsigned_ity *)
val     is_signed_ity: integerType -> bool
let rec is_signed_ity ity =
  match ity with
    | Char ->
        Implementation_.char_is_signed
    | Bool ->
        false
    | Signed _ ->
        true
    | Unsigned _ ->
        false
    | IBuiltin _ ->
        error "TODO: AilTypesAux.is_signed_ity, IBuiltin"
    | Enum tag_sym ->
        is_signed_ity (Implementation_.typeof_enum tag_sym)
    | Size_t ->
        (* STD §7.19#2 *)
        false
    | Ptrdiff_t ->
        (* STD §7.19#2 *)
        true
  end

(* STD §6.2.5#6, sentence 4 *)
val     is_unsigned_ity: integerType -> bool
let rec is_unsigned_ity ity =
  match ity with
    | Char ->
        not (Implementation_.char_is_signed)
    | Bool ->
        true
    | Signed _ ->
        false
    | Unsigned _ ->
        true
    | IBuiltin _ ->
        error "TODO: AilTypesAux.is_unsigned_ity, IBuiltin"
    | Enum tag_sym ->
        is_unsigned_ity (Implementation_.typeof_enum tag_sym)
    | Size_t ->
        (* STD §7.19#2 *)
        true
    | Ptrdiff_t ->
        (* STD §7.19#2 *)
        false
  end



(* == constructor predicates on ctypes =========================================================== *)
val is_integer: ctype -> bool
let is_integer ty =
  (* TODO: check atomic *)
  match unatomic ty with
  | Basic (Integer _) ->
      true
  | _ ->
      false
end


val is_floating: ctype -> bool
let is_floating ty =
  match unatomic ty with
    | Basic (Floating _) ->
        true
    | _ ->
        false
  end

val is_void: ctype -> bool
let is_void ty =
  (* TODO: check atomic *)
  match unatomic ty with
  | Void ->
      true
  | _ ->
      false
end

val is_pointer: ctype -> bool
let is_pointer ty =
     (* STD §6.2.5#22, sentence 3-4 *)
  (* TODO: check atomic *)
  match unatomic ty with
  | Pointer _ _ ->
      true
  | _ ->
      false
end

val is_atomic: ctype -> bool
let is_atomic = function
  | Ctype _ (Atomic _) ->
      (* STD §6.2.5#20, bullet 6 *)
      true
(*
  | Pointer qs _ ->
      qs.atomic
*)
  | _ ->
      false
end

(* TODO: I don't like that, in particular if pred = is_atomic this doesn't work... *)
val atomic_qualified_unqualified: (ctype -> bool) -> ctype -> bool
let atomic_qualified_unqualified pred = function
  | Ctype _ (Atomic ty) ->
      pred ty
  | ty ->
      pred ty
end


(* STD §6.2.5#15, sentence 1 *)
val is_character: ctype -> bool
let is_character ty =
  (* TODO: check atomic *)
  match unatomic ty with
  | Basic (Integer Char) ->
      true
  | Basic (Integer (Signed Ichar)) ->
      true
  | Basic (Integer (Unsigned Ichar)) ->
      true
  | _ ->
      false
end

val is_Bool: ctype -> bool
let is_Bool ty =
  (* TODO: check atomic *)
  match unatomic ty with
  | Basic (Integer Bool) ->
      true
  | _ ->
      false
end

(* TODO: STD doc *)
val     is_array: ctype -> bool
let is_array ty =
  (* TODO: check atomic *)
  match unatomic ty with
  | Array _ _ ->
      true
  | Builtin "jmp_buf" ->
      true
  | Builtin "fpos_t" ->
      false
  | _ ->
      false
end

val is_array_unknown_size: ctype -> bool
let is_array_unknown_size ty =
  (* TODO: check atomic *)
  match unatomic ty with
    | Array _ Nothing ->
        true
    | _ ->
        (* TODO: check builtins *)
        false
  end


val is_array_of_character: ctype -> bool
let is_array_of_character ty =
  (* TODO: check atomic *)
  match unatomic ty with
  | Array elem_ty _ ->
      is_character elem_ty
  | _ ->
      false
end

(* STD §6.2.5#1, sentence 3 *)
val is_function: ctype -> bool
let is_function ty =
  (* TODO: check atomic *)
  match unatomic ty with
  | Function _ _ _ _ ->
      true
  | _ ->
      false
end

val is_struct: ctype -> bool
let is_struct ty =
  (* TODO: check atomic *)
  match unatomic ty with
  | Struct _ ->
      true
  | _ ->
      false
end

val is_union: ctype -> bool
let is_union ty =
  (* TODO: check atomic *)
  match unatomic ty with
  | Union _ ->
      true
  | _ ->
      false
end

val is_struct_or_union: ctype -> bool
let is_struct_or_union ty =
  is_struct ty || is_union ty


val has_flexible_array_member: forall 'a. sigma 'a -> ctype -> bool
let has_flexible_array_member sigm ty =
  (* TODO: check atomic *)
  match unatomic ty with
    | Struct tag_sym ->
        match List.lookup tag_sym sigm.tag_definitions with
          | Just (StructDef membersDefs) ->
              match List.dest_init membersDefs with
                | Just (_, (_, (_, last_ty))) ->
                    (* NOTE: this assumes membersDefs is wf (i.e. it has more than one element) *)
                    is_array_unknown_size last_ty
                | Nothing ->
                    false
              end
          | _ ->
              error "AilTypesAux.has_flexible_array_member: Struct, UnionDef or Nothing"
        end
    | _ ->
        false
end



(* == generic predicates on ctypes ============================================================== *)
(* STD §6.2.5#1, sentence 3 *)
val is_object: ctype -> bool
let is_object ty =
  (* TODO: check atomic *)
  match unatomic ty with
  | Builtin "FILE" ->
      true
  | Builtin "cnd_t" ->
      true
  | Builtin "fpos_t" ->
      true
  | Builtin "mtx_t" ->
      true
  | Builtin "once_flag" ->
      true
  | Builtin "thrd_t" ->
      true
  | Builtin "tss_t" ->
      true
  | Builtin "va_list" ->
      true
  | _ ->
      not (is_function ty)
end

(* STD §6.2.5#18, sentence 1 *)
val is_arithmetic: ctype -> bool
let is_arithmetic ty =
  is_integer ty || is_floating ty

(* STD §6.2.5#21, sentence 1 *)
val is_scalar: ctype -> bool
let is_scalar ty =
  is_pointer ty || is_arithmetic ty

(* STD §6.2.5#21, sentence 2 *)
val is_aggregate: ctype -> bool
let is_aggregate ty =
  is_array ty || is_struct ty

(* STD §6.2.5#20 *)
(* NOTE: dead code *)
val is_derived: ctype -> bool
let is_derived (Ctype _ ty) =
  match ty with
  | Array _ _ -> true
  | Struct _ -> true
  | Union _ -> true
  | Function _ _ _ _ -> true
  | Pointer _ _ -> true
  | Atomic _ -> true
  | _ -> false
  end

(* STD §6.2.5#24 *)
(* NOTE: dead code *)
val is_derived_declarator: ctype -> bool
let is_derived_declarator ty =
  match unatomic ty with
  | Array _ _ -> true
  | Function _ _ _ _ -> true
  | Pointer _ _ -> true
  | _ -> false
  end

(* TODO *)
(* STD §6.2.5#1, sentence 4 *)
val is_complete: forall 'a. sigma 'a -> ctype -> bool
let is_complete sigm ty =
  (* TODO: check atomic *)
  match unatomic ty with
  | Void ->
      (* STD §6.2.5#19 *)
      false
  | Basic _ ->
      (* STD §6.2.5#14, sentece 2 *)
      true
  | Pointer _ _ ->
      true
  | Array _ n_opt ->
      (* STD §6.2.5#22, sentence 1-2 *)
      (* STD §6.7.6.2#4, sentence 1 *)
      isJust n_opt
  | Builtin "cnd_t" ->
      true
  | Builtin "fpos_t" ->
      true
  | Builtin "mtx_t" ->
      true
  | Builtin "once_flag" ->
      true
  | Builtin "thrd_t" ->
      true
  | Builtin "tss_t" ->
      true
  | Builtin "va_list" ->
      true
    (* STD §6.2.5#22, sentence 3-4 *)
  | Struct sym ->
      match Context.lookup (=) sigm.tag_definitions sym with
        | Just (StructDef _) ->
            true
        | _ ->
            let _ = Debug.print_debug 5 [Debug.DB_ail_typing]
                (fun () -> "is_complete failed on struct tag: " ^ show sym ^ " with env: " ^ show sigm.tag_definitions) in
            false
      end
    (* STD §6.2.5#22, sentence 3-4 *)
  | Union sym ->
      match Context.lookup (=) sigm.tag_definitions sym with
        | Just (UnionDef _) ->
            true
        | _ ->
            false
      end
  | Builtin str ->
      true (* FIXME: error ("TODO: AilTypesAux.is_complete, Builtin ==> " ^ str) *)
  | _ ->
      false
end

(* TODO *)
(* STD §6.2.5#1, sentence 4 *)
val is_incomplete: forall 'a. sigma 'a -> ctype -> bool
let is_incomplete sigm ty =
  not (is_complete sigm ty)




(* ============================================================================================== *)
val in_integer_range: Implementation.implementation -> integer -> integerType -> bool
let in_integer_range impl n ity =
  Range.mem n (Implementation.integer_range impl ity)

val in_min_integer_range: integer -> integerType -> bool
let in_min_integer_range n ity =
  Range.mem n (Implementation.min_integer_range ity)


val le_integer_range: Implementation.implementation -> integerType -> integerType -> bool
let le_integer_range impl ity1 ity2 =
  if ity1 = ity2 then
    (* reflexive cases *)
    true
  else match (ity1, ity2) with
    | (Char, Signed Ichar) ->
        Implementation_.char_is_signed
    | (Char, Signed ibty) ->
        Implementation_.char_is_signed || (Implementation_.precision_ity Char) < (Implementation_.precision_ity (Signed ibty))
    | (Signed Ichar, Char) ->
        Implementation_.char_is_signed
    | (Signed ibty, Char) ->
        Implementation_.char_is_signed && Implementation_.precision_ity (Signed ibty) = Implementation_.precision_ity Char
    | (Unsigned Ichar, Char) ->
        not Implementation_.char_is_signed
    | (Unsigned ibty, Char) ->
        not Implementation_.char_is_signed && Implementation_.precision_ity (Unsigned ibty) = Implementation_.precision_ity Char
    | (Char, Unsigned _) ->
        not Implementation_.char_is_signed
    | (Char, Bool) ->
        not Implementation_.char_is_signed && Implementation_.precision_ity Char = Implementation_.precision_ity Bool
    | (Bool, Char) ->
        not Implementation_.char_is_signed || (Implementation_.precision_ity Bool) < (Implementation_.precision_ity Char)

    | (Signed Ichar, Signed _) ->
        true
    | (Signed Short, Signed Int_) ->
        true
    | (Signed Short, Signed Long) ->
        true
    | (Signed Short, Signed LongLong) ->
        true
    | (Signed Int_, Signed Long) ->
        true
    | (Signed Int_, Signed LongLong) ->
        true
    | (Signed Long, Signed LongLong) ->
        true
    | (Signed ibty1, Signed ibty2) ->
        Implementation_.precision_ity (Signed ibty1) = Implementation_.precision_ity (Signed ibty2)
    | (Signed _, Bool) ->
        false
    | (Bool, Signed ibty2) ->
        (Implementation_.precision_ity Bool) < (Implementation_.precision_ity (Signed ibty2))
    
    | (Bool, Unsigned _) ->
        true
    | (Unsigned Ichar, Unsigned _) ->
        true
    | (Unsigned Short, Unsigned Int_) ->
        true
    | (Unsigned Short, Unsigned Long) ->
        true
    | (Unsigned Short, Unsigned LongLong) ->
        true
    | (Unsigned Int_, Unsigned Long) ->
        true
    | (Unsigned Int_, Unsigned LongLong) ->
        true
    | (Unsigned Long, Unsigned LongLong) ->
        true
    | (Unsigned ibty, Bool) ->
        Implementation_.precision_ity (Unsigned ibty) = Implementation_.precision_ity Bool
    | (Unsigned ibty1, Unsigned ibty2) ->
        Implementation_.precision_ity (Unsigned ibty1) = Implementation_.precision_ity (Unsigned ibty2)
    
    | (Signed _, Unsigned _) ->
        false
    
    | (Unsigned _, Signed Ichar) ->
        false
    | (Unsigned Short, Signed Short) ->
        false
    | (Unsigned Int_, Signed Int_) ->
        false
    | (Unsigned Long, Signed Long) ->
        false
    | (Unsigned LongLong, Signed LongLong) ->
        false
    | (Unsigned ibty1, Signed ibty2) ->
        (Implementation_.precision_ity (Unsigned ibty1)) < (Implementation_.precision_ity (Signed ibty2))
      
    (* TODO: check *)
    | (IBuiltin str1, IBuiltin str2) ->
        str1 = str2
  
 
  | (IBuiltin str, _) -> error ("WIP le_integer_range (left): " ^ str)
  | (_, IBuiltin str) -> error ("WIP le_integer_range (right): " ^ str)

  | (Char, Char) -> true
  | (Bool, Bool) -> true
  | (Size_t, Size_t) -> true
  | (Ptrdiff_t, Ptrdiff_t) -> true
  | (Enum _, Enum _) ->
      error "WIP le_integer_range: Enum, Enum"
  
  | (Char, Size_t) ->
      error "WIP le_integer_range: Char, Size_t"
  | (Char, Ptrdiff_t) ->
      error "WIP le_integer_range: Char, Ptrdiff_t"
  | (Char, Enum _) ->
      error "WIP le_integer_range: Char, Enum"
  
  | (Bool, Size_t) ->
      error "WIP le_integer_range: Bool, Size_t"
  | (Bool, Ptrdiff_t) ->
      error "WIP le_integer_range: Bool, Ptrdiff_t"
  | (Bool, Enum _) ->
      error "WIP le_integer_range: Bool, Enum"
  
  | (Signed _, Size_t) ->
      error "WIP le_integer_range: Signed, Size_t"
  | (Signed _, Ptrdiff_t) ->
      error "WIP le_integer_range: Signed, Ptrdiff_t"
  | (Signed _, Enum _) ->
      error "WIP le_integer_range: Signed, Enum"
  
  | (Unsigned _, Size_t) ->
      error "WIP le_integer_range: Unsigned, Size_t"
  | (Unsigned _, Ptrdiff_t) ->
      error "WIP le_integer_range: Unsigned, Ptrdiff_t"
  | (Unsigned _, Enum _) ->
      error "WIP le_integer_range: Unsigned, Enum"
  
  | (Ptrdiff_t, Char) ->
      error "WIP le_integer_range: Ptrdiff_t, Char"
  | (Ptrdiff_t, Bool) ->
      error "WIP le_integer_range: Ptrdiff_t, Bool"
  | (Ptrdiff_t, Signed _) ->
      error "WIP le_integer_range: Ptrdiff_t, Signed"
  | (Ptrdiff_t, Unsigned _) ->
      error "WIP le_integer_range: Ptrdiff_t, Unsigned"
  | (Ptrdiff_t, Enum _) ->
      error "WIP le_integer_range: Ptrdiff_t, Enum"
  | (Ptrdiff_t, Size_t) ->
      error "WIP le_integer_range: Ptrdiff_t, Size_t"
  
  | (Size_t, Char) ->
      error "WIP le_integer_range: Size_t, Char"
  | (Size_t, Bool) ->
      error "WIP le_integer_range: Size_t, Bool"
  | (Size_t, Signed _) ->
      error "WIP le_integer_range: Size_t, Signed"
  | (Size_t, Unsigned _) ->
      error "WIP le_integer_range: Size_t, Unsigned"
  | (Size_t, Enum _) ->
      error "WIP le_integer_range: Size_t, Enum"
  | (Size_t, Ptrdiff_t) ->
      error "WIP le_integer_range: Size_t, Ptrdiff_t"
  
  | (Enum _, Char) ->
      error "WIP le_integer_range: Enum, Char"
  | (Enum _, Bool) ->
      error "WIP le_integer_range: Enum, Bool"
  | (Enum _, Signed _) ->
      error "WIP le_integer_range: Enum, Signed"
  | (Enum _, Unsigned _) ->
      error "WIP le_integer_range: Enum, Unsigned"
  | (Enum _, Size_t) ->
      error "WIP le_integer_range: Enum, Size_t"
  | (Enum _, Ptrdiff_t) ->
      error "WIP le_integer_range: Enum, Ptrdiff_t"
  end


val eq_integer_rank_base: integerType -> integerType -> bool
let eq_integer_rank_base ity1 ity2 =
  match (ity1, ity2) with
  (* STD §6.3.1.1#1, bullet 4 *)
  | (Signed ibty1, Unsigned ibty2) ->
      ibty1 = ibty2
  | (Unsigned ibty1, Signed ibty2) ->
      ibty1 = ibty2
  (* STD §6.3.1.1#1, bullet 6 *)
  | (Char, Unsigned Ichar) ->
      true
  | (Char, Signed Ichar) ->
      true
  | (Unsigned Ichar, Char) ->
      true
  | (Signed Ichar, Char) ->
      true
  | _ ->
      false
  end


(* TODO: K this looks wrong, in particular the STD says "No two signed integer types shall have the same rank" *)
val eq_integer_rank: integerType -> integerType -> bool
let eq_integer_rank ity1 ity2 =
  ity1 = ity2 || eq_integer_rank_base ity1 ity2

(*
val lt_integer_rank_base: Implementation.implementation -> integerType -> integerType -> bool
let lt_integer_rank_base impl ity1 ity2 =
  match (ity1, ity2) with
    (* STD §6.3.1.1#1, bullet 7 *)
    | (Bool, _) ->
        not (Bool = ity2)
    (* STD §6.3.1.1#1, bullet 3 *)
    | (Signed Long, Signed LongLong) ->
        true
    | (Signed Int_, Signed Long) ->
        true
    | (Signed Short, Signed Int_) ->
        true
    | (Signed Ichar, Signed Short) ->
        true
    (* STD §6.3.1.1#1, bullet 2 *)
    | (Signed ibty1, Signed ibty2) ->
        (Implementation_.precision_ity (Signed ibty1)) < (Implementation_.precision_ity (Signed ibty2))
    | _ ->
        false
  end

val lt_integer_rank_congruence: Implementation.implementation -> integerType -> integerType -> bool
let lt_integer_rank_congruence impl ity1 ity2 =
  match (ity1, ity2) with
    | (_, Bool) ->
        false
    | (Bool, _) ->
        true
    | (_, Char) ->
        false
    | (Char, Unsigned ibty2) ->
        lt_integer_rank_base impl (Signed Ichar) (Signed ibty2)
    | (Char, Signed ibty2) ->
        lt_integer_rank_base impl (Signed Ichar) (Signed ibty2)
    | (Signed ibty1, Signed ibty2) ->
        lt_integer_rank_base impl (Signed  ibty1) (Signed ibty2)
    | (Unsigned ibty1, Unsigned ibty2) ->
        lt_integer_rank_base impl (Signed  ibty1) (Signed ibty2)
    | (Unsigned ibty1, ity2) ->
        lt_integer_rank_base impl (Signed  ibty1) ity2
    | (ity1, Unsigned ibty2) ->
        lt_integer_rank_base impl ity1 (Signed ibty2)
    | _ ->
        error "WIP lt_integer_rank_congruence"
  end
*)

val lt_integer_rank: integerType -> integerType -> bool
let lt_integer_rank ity1 ity2 =
  match (ity1, ity2) with
    | (_, Bool) ->
        false
    | (Bool, _) ->
        true
    
    | (_, Char) ->
        false
    | (_, Signed Ichar) ->
        false
    | (_, Unsigned Ichar) ->
        false
    | (Char, Signed _) ->
        true
    | (Char, Unsigned _) ->
        true
    | (Signed Ichar, Signed _) ->
        true
    | (Signed Ichar, Unsigned _) ->
        true
    | (Unsigned Ichar, Signed _) ->
        true
    | (Unsigned Ichar, Unsigned _) ->
        true
    
    | (_, Signed Short) ->
        false
    | (_, Unsigned Short) ->
        false
    | (Signed Short, Signed _) ->
        true
    | (Signed Short, Unsigned _) ->
        true
    | (Unsigned Short, Signed _) ->
        true
    | (Unsigned Short, Unsigned _) ->
        true
    
    | (_, Signed Int_) ->
        false
    | (_, Unsigned Int_) ->
        false
    | (Signed Int_, Signed _) ->
        true
    | (Signed Int_, Unsigned _) ->
        true
    | (Unsigned Int_, Signed _) ->
        true
    | (Unsigned Int_, Unsigned _) ->
        true
    
    | (_, Signed Long) ->
        false
    | (_, Unsigned Long) ->
        false
    | (Signed Long, Signed _) ->
        true
    | (Signed Long, Unsigned _) ->
        true
    | (Unsigned Long, Signed _) ->
        true
    | (Unsigned Long, Unsigned _) ->
        true
    
    | _ ->
        (* TODO: this is probably wrong for macro types *)
        false
  end

val le_integer_rank: integerType -> integerType -> bool
let le_integer_rank ity1 ity2 =
  eq_integer_rank ity1 ity2 || lt_integer_rank ity1 ity2

val ge_integer_rank: integerType -> integerType -> bool
let ge_integer_rank ity1 ity2 =
  le_integer_rank ity2 ity1

(* STD §6.2.5#10 *)
val le_real_floating_range : realFloatingType -> realFloatingType -> bool
let le_real_floating_range fty1 fty2 =
  match (fty1, fty2) with
  | (Float, _) -> true
  | (Double, Double) -> true
  | (_, LongDouble) -> true
  | _ -> false
  end

val is_corresponding_unsigned: integerType -> integerType -> bool
let is_corresponding_unsigned ity1 ity2 =
  match (ity1, ity2) with
    | (Signed ibty1, Unsigned ibty2) ->
        ibty1 = ibty2
    | (_, _) ->
        false
  end

val corresponding_unsigned: integerType -> maybe integerType
let corresponding_unsigned = function
  | Signed ibty ->
      Just (Unsigned ibty)
  | _ ->
      Nothing
end

val make_corresponding_unsigned: integerType -> integerType
let make_corresponding_unsigned = function
  | Signed ibty ->
      Unsigned ibty
  | ity ->
      ity
end


val integer_promotion: Implementation.implementation -> integerType -> integerType
let integer_promotion impl = function
  | Signed   Int_ ->
      Signed   Int_
  | Unsigned Int_ ->
      Unsigned Int_
  | Size_t ->
      (* TODO: this is not standard, but in cerberus we don't treat size_t as an aliased type *)
      Size_t
  | Signed Intptr_t ->
      (* TODO: this is not standard, but in cerberus we don't treat intptr_t as aliased types *)
      Signed Intptr_t
  | Unsigned Intptr_t ->
      (* TODO: this is not standard, but in cerberus we don't treat uintptr_t as aliased types *)
      Unsigned Intptr_t
  | ity ->
      if le_integer_rank ity (Signed Int_) then
        if le_integer_range impl ity (Signed Int_) then
          Signed Int_
        else
          Unsigned Int_
      else
        ity
  end


val promotion: Implementation.implementation -> ctype -> maybe ctype
let promotion impl = function
  | Ctype annots (Basic (Integer ity)) ->
      Just (Ctype annots (Basic (Integer (integer_promotion impl ity))))
  | _ ->
      Nothing
end


val usual_arithmetic_integer: Implementation.implementation -> integerType -> integerType -> integerType
let usual_arithmetic_integer impl ity1 ity2 =
  (* TODO: this is not standard, but in cerberus we don't treat (u)intptr_t and size_t as an aliased types *)
  let () = Debug.warn [] (fun () ->
    "NON STD: usual_arithmetic_integer ==> if any operand is of type size_t, then the common type is size_t"
  ) in
  match (ity1, ity2) with
    | (Size_t, _) ->
        Size_t
    | (_, Size_t) ->
        Size_t
    
    | (Signed Intptr_t, Unsigned Intptr_t) ->
        Unsigned Intptr_t
    | (Signed Intptr_t, _) ->
        Signed Intptr_t
    | (Unsigned Intptr_t, Signed Intptr_t) ->
        Unsigned Intptr_t
    | (_, Signed Intptr_t) ->
        Signed Intptr_t
    | (Unsigned Intptr_t, _) ->
        Unsigned Intptr_t
    | (_, Unsigned Intptr_t) ->
        Unsigned Intptr_t

    | _ ->
        let promoted_ity1 = integer_promotion impl ity1 in
        let promoted_ity2 = integer_promotion impl ity2 in
        if    (is_signed_ity promoted_ity1 && is_signed_ity promoted_ity2)
           || (is_unsigned_ity promoted_ity1 && is_unsigned_ity promoted_ity2) then
          if lt_integer_rank promoted_ity1 promoted_ity2 then
            promoted_ity2
          else
            promoted_ity1
        
        else if is_unsigned_ity promoted_ity1 && ge_integer_rank promoted_ity1 promoted_ity2 then
          promoted_ity1
        else if is_unsigned_ity promoted_ity2 && ge_integer_rank promoted_ity2 promoted_ity1 then
          promoted_ity2
        
        else if is_signed_ity promoted_ity1 then
          if le_integer_range impl promoted_ity2 promoted_ity1 then
            promoted_ity1
          else
            make_corresponding_unsigned promoted_ity1
        
        else (* if is_signed_ity promoted_ity2 then *)
          if le_integer_range impl promoted_ity1 promoted_ity2 then
            promoted_ity2
          else
            make_corresponding_unsigned promoted_ity2

(*
        let promoted_ity1 = integer_promotion impl ity1 in
        let promoted_ity2 = integer_promotion impl ity2 in
        if is_signed_ity promoted_ity1 then
          if is_signed_ity promoted_ity2 then
            if lt_integer_rank promoted_ity2 promoted_ity1 then
              promoted_ity1
            else
              promoted_ity2
          else
            if le_integer_rank promoted_ity1 promoted_ity2 then
              promoted_ity2
            else
              if le_integer_range impl promoted_ity2 promoted_ity1 then
                promoted_ity1
              else
                make_corresponding_unsigned promoted_ity1
        else
          if is_unsigned_ity promoted_ity2 then
            if lt_integer_rank promoted_ity2 promoted_ity1 then
              promoted_ity1
            else
              promoted_ity2
          else
            if le_integer_rank promoted_ity2 promoted_ity1 then
              promoted_ity1
            else if le_integer_range impl promoted_ity1 promoted_ity2 then
              promoted_ity2
            else
              make_corresponding_unsigned promoted_ity2
*)
  end


(* TODO *)
val usual_arithmetic_floating: Implementation.implementation -> floatingType -> floatingType -> floatingType
let usual_arithmetic_floating impl ty1 ty2 = ty1


(* STD §6.2.5#12 *)
val corresponding_real_type: ctype -> maybe realFloatingType
let corresponding_real_type (Ctype _ ty as cty) =
  if is_floating cty then
    match ty with
    | Basic (Floating (RealFloating rfty)) ->
        Just rfty
(*
    | Basic (Floating (Complex fty))
        Basic (Floating fty)
*)
    | _ ->
        error "AilTypesAux.corresponding_real_type"
    end
  else
    Nothing


(* assuming [ty] is an lvalue type, [modifiable ty] is true iff
   [ty] is modifiable lvalue type (see §6.3.2.1#1, sentence 3) *)

(*
A modifiable lvalue is an lvalue that does not have array type, does not have an incomplete type, does not have a const- qualified type, and if it is a structure or union, does not have any member (including, recursively, any member or element of all contained aggregates or unions) with a const- qualified type.
*)
val modifiable: forall 'a. sigma 'a -> qualifiers -> ctype -> bool
let modifiable sigm qs ty =
  not (is_array ty) &&
  not (qs.const) &&
  is_object ty &&
  not (is_incomplete sigm ty)

val is_real: ctype -> bool
let is_real (Ctype _ ty) =
  match ty with
    | Basic (Integer _) ->
        true
    | Basic (Floating (RealFloating _)) ->
        true
    | _ ->
        false
  end





(* (§6.2.7) Compatible type *)
val            are_compatible: (qualifiers * ctype) -> (qualifiers * ctype) -> bool
let rec ~{coq} are_compatible (qs1, Ctype _ ty1) (qs2, Ctype _ ty2) =
  (* qualifiers need to be equal (see §6.7.3#10) *)
  qs1 = qs2 && match (ty1, ty2) with
    | (Void, Void) ->
        true
    | (Basic bty1, Basic bty2) ->
        let (bty1', bty2') = match (bty1, bty2) with
          | (Integer (Enum tag_sym1), Integer (Enum tag_sym2)) ->
              (Integer (Implementation_.typeof_enum tag_sym1), Integer (Implementation_.typeof_enum tag_sym2))
          | (Integer (Enum tag_sym1), _) ->
              (Integer (Implementation_.typeof_enum tag_sym1), bty2)
          | (_, Integer (Enum tag_sym2)) ->
              (bty1, Integer (Implementation_.typeof_enum tag_sym2))
          | _ ->
              (bty1, bty2)
        end in
        bty1' = bty2'
    | (Array elem_ty1 n1_opt, Array elem_ty2 n2_opt) ->
        (* STD §6.7.6.2#6 *)
           are_compatible (no_qualifiers, elem_ty1) (no_qualifiers, elem_ty2)
        && match (n1_opt, n1_opt) with
             | (Just n1, Just n2) -> n1 = n2
             | (Just _ , Nothing) -> true
             | (Nothing, Just _ ) -> true
             | (Nothing, Nothing) -> true
           end
    | (Function _ (ret_qs1, ret_ty1) params1 isVariadic1, Function _ (ret_qs2, ret_ty2) params2 isVariadic2) ->
        (* STD §6.7.6.3#15 *)
        (* TODO: when the two types do not both have a param list *)
           are_compatible (ret_qs1, ret_ty1) (ret_qs2, ret_ty2)
        && are_compatible_params params1 params2
        && isVariadic1 = isVariadic2
    | (Pointer ref_qs1 ref_ty1, Pointer ref_qs2 ref_ty2) ->
        (* STD §6.7.6.1#2 *)
        are_compatible (ref_qs1, ref_ty1) (ref_qs2, ref_ty2)
    | (Struct tag1, Struct tag2) ->
        (* STD §6.2.7#1 *)
        (* TODO: being conservative here (aka STD compliant) *)
        tag1 = tag2 (* TODO/NOTE: just looking at the tag should be enough since we only have one translation unit (?) *)
    | (Union tag1, Union tag2) ->
        (* STD §6.2.7#1 *)
        (* TODO: being conservative here (aka STD compliant) *)
        tag1 = tag2 (* TODO/NOTE: just looking at the tag should be enough since we only have one translation unit (?) *)
    | (Builtin str1, Builtin str2) ->
        str1 = str2
    | (Atomic atom_ty1, Atomic atom_ty2) ->
        are_compatible (no_qualifiers, atom_ty1) (no_qualifiers, atom_ty2)
    | _ ->
        (* TODO: we can't see Enum types here and there is some impl-def stuff *)
        false
  end

(* TYP: bool -> (list (qualifiers * ctype * bool) * list (qualifiers * ctype * bool)) -> bool *)
and are_compatible_params_aux acc = function
  | ([], []) ->
      acc
  | (((qs1, ty1, _) :: params1), ((qs2, ty2, _) :: params2)) ->
      are_compatible_params_aux (
        (* NOTE(unsure): but as far as I can tell the twos parameters can differ
           on whether they have the register storage-class *)
        acc && are_compatible (qs1, ty1) (qs2, ty2)
      ) (params1, params2)
  | _ ->
      (* the list of params must have the same length to be compatible *)
      false
end

and are_compatible_params params1 params2 =
  are_compatible_params_aux true (params1, params2)











val            is_composite_params_aux: (ctype -> ctype -> ctype -> bool) -> 
                                        list (qualifiers * ctype * bool) -> list (qualifiers * ctype * bool) -> list (qualifiers * ctype * bool) -> bool
let rec ~{coq} is_composite_params_aux is_composite p1 p2 p3 =
  match (p1, p2, p3) with
    | ([], [], []) ->
        true
    | ((_, ty1, _) :: p1, (_, ty2, _) :: p2, (qs3, ty3, _) :: p3) ->
        is_unqualified qs3 && is_composite ty1 ty2 ty3 &&
        is_composite_params_aux is_composite p1 p2 p3
    | _ ->
      false
  end

val            is_composite: ctype -> ctype -> ctype -> bool
let rec ~{coq} is_composite (Ctype _ ty1) (Ctype _ ty2) (Ctype _ ty3) =
  let is_composite_params = is_composite_params_aux is_composite in
  (* TODO: check the qualifiers *)
  match (ty1, ty2, ty3) with
    | (Void, Void, Void) ->
        true
    | (Basic bty1, Basic bty2, Basic bty3) ->
        bty1 = bty2 && bty1 = bty3
    | (Array ty1 n1_opt, Array ty2 n2_opt, Array ty3 n3_opt) ->
        (* TODO: this is probably wrong regarding the sizes *)
        is_composite ty1 ty2 ty3 && n1_opt = n2_opt && n1_opt = n3_opt
    | (Function _ (qs1, ty1) p1 _, Function _ (qs2, ty2) p2 _, Function _ (qs3, ty3) p3 _) ->
        (* TODO: return qualifiers? *)
        is_composite ty1 ty2 ty3 && is_composite_params p1 p2 p3
    | (Pointer qs1 ty1, Pointer qs2 ty2, Pointer qs3 ty3) ->
        is_composite ty1 ty2 ty3 && qs1 = qs2 && qs1 = qs3
    | _ ->
        false
  end

val        is_composite_params: list (qualifiers * ctype * bool) -> list (qualifiers * ctype * bool) -> list (qualifiers * ctype * bool) -> bool
let ~{coq} is_composite_params params1 params2 params3 =
  is_composite_params_aux is_composite params1 params2 params3

val make_composite_params_aux:
  (ctype -> ctype -> maybe ctype) ->
  (list (qualifiers * ctype * bool) * list (qualifiers * ctype * bool)) ->
  maybe (list (qualifiers * ctype * bool))
let rec ~{coq} make_composite_params_aux make_composite = function
  | ([], []) ->
      Just []
  | ((_, ty1, _) :: params1, (_, ty2, _) :: params2) ->
      match (make_composite ty1 ty2, make_composite_params_aux make_composite (params1, params2)) with
        | (Just ty, Just p) ->
            Just ((no_qualifiers, ty, false) :: p)
        | _ ->
            Nothing
      end
  | _ ->
      Nothing
end

(* (§6.2.7#3) composite type *)
(* TODO: this function is defined over Ail types, so function types
   are simpler than what the desugaring can see (functions have parameters). So
   this function SHOULD NOT be used by the desugaring *)
val            make_composite: ctype -> ctype -> maybe ctype
let rec ~{coq} make_composite (Ctype a1 ty1 as cty1) (Ctype a2 ty2 as cty2) =
  let make_composite_params params1 params2 = make_composite_params_aux make_composite (params1, params2) in
  
  (* a composite type can only be made from two compatible types *)
  if not (are_compatible (no_qualifiers, cty1) (no_qualifiers, cty2)) then
    Nothing
  else match (ty1, ty2) with
    | (Void, Void) ->
        Just (Ctype (a1++a2) Void)
    | (Basic bty1, Basic bty2) ->
        (* thanks to the compatibility test we know bty1 = bty2  *)
        Just (Ctype (a1++a2) (Basic bty1))
    | (Array elem_ty1 n1_opt, Array elem_ty2 n2_opt) ->
        (* STD §6.2.7#3, first bullet *)
        (* TODO(vla): more would be needed if we want to support VLAs *)
        let n_opt = match (n1_opt, n2_opt) with
          | (Just n1, Just n2) ->
              (* thanks to the compatibility test we know that n1 = n2  *)
              Just n1
          | (Just n1, Nothing) ->
              Just n1
          | (Nothing, Just n2) ->
              Just n2
          | (Nothing, Nothing) ->
              Nothing
        end in
          Maybe.map (fun ty -> Ctype (a1++a2) (Array ty n_opt)) (make_composite elem_ty1 elem_ty2)
    | (Function hasProto1 (ret_qs1, ret_ty1) params1 isVariadic1, Function hasProto2 (ret_qs2, ret_ty2) params2 isVariadic2) ->
        (* TODO: return qualifiers? *)
        (* TODO: like the preceding comment said, there is quite a bit of
           simplication here *)
        if isVariadic1 <> isVariadic2 then
          Nothing
        else match (make_composite ret_ty1 ret_ty2, make_composite_params params1 params2) with
          | (Just ret_ty, Just params) ->
              (* TODO: check the prototype thing *)
              Just (Ctype (a1++a2) (Function (hasProto1 || hasProto2) (ret_qs1, ret_ty) params isVariadic1))
          | _ ->
              Nothing
        end
    | (Pointer ref_qs1 ref_ty1, Pointer ref_qs2 ref_ty2) ->
        (* thanks to the compatibility test we know ref_qs1 = ref_qs2  *)
        Maybe.map (fun ref_ty -> Ctype (a1++a2) (Pointer ref_qs1 ref_ty)) (make_composite ref_ty1 ref_ty2)
    | (Builtin str1, Builtin str2) ->
        (* NOTE: We're conservative here. *)
        if str1 = str2 then
          Just (Ctype (a1++a2) (Builtin str1))
        else
          Nothing
    | _ ->
        Nothing
  end

val        make_composite_params: list (qualifiers * ctype * bool) -> list (qualifiers * ctype * bool) -> maybe (list (qualifiers * ctype * bool))
let ~{coq} make_composite_params params1 params2 =
  make_composite_params_aux make_composite (params1, params2)


(* following (§6.3.2.1)#3 *)
val array_coercion: ctype -> ctype
let array_coercion (Ctype loc ty) =
Ctype loc $ match ty with
  | Array elem_ty _ ->
      Pointer no_qualifiers elem_ty
  | ty ->
      ty
end

(* following (§6.3.2.1)#4 *)
val function_coercion: ctype -> ctype
let function_coercion (Ctype loc ty) =
Ctype loc $ match ty with
  | Function hasProto ret_qs_ty params isVariadic ->
      Pointer no_qualifiers (Ctype [] (Function hasProto ret_qs_ty params isVariadic))
  | ty ->
      ty
end

(* following (§6.3.2.1)#2 *)
val lvalue_convertible: forall 'a. sigma 'a -> ctype -> bool
let lvalue_convertible S ty =
  not (is_array ty) && is_complete S ty

(* following (§6.3.2.1)#2 and #3 *)
val lvalue_coercion: forall 'a. sigma 'a -> ctype -> errorM ctype
let lvalue_coercion S ty =
  if lvalue_convertible S ty then
    return ty
  else if is_array ty then
    return (array_coercion ty)
  else
    undef (Loc.locOf ty) Undefined.UB020_nonarray_incomplete_lvalue_conversion

(* following (§6.3.2.1)#3 and #4 *)
val rvalue_coercion: ctype -> ctype
let rvalue_coercion ty =
  if is_array ty then
    array_coercion ty
  else if is_function ty then
    function_coercion ty
  else
    ty








val is_pointer_to_complete_object: forall 'a. sigma 'a -> ctype -> bool
let is_pointer_to_complete_object S = function
  | Ctype _ (Pointer _ ty) ->
      is_complete S ty
  | _ ->
      false
  end

val        are_pointers_to_compatible_complete_objects: forall 'a. sigma 'a -> ctype -> ctype -> bool
let ~{coq} are_pointers_to_compatible_complete_objects sigm (Ctype _ ty1) (Ctype _ ty2) =
  match (ty1, ty2) with
    | (Pointer ref_qs1 ref_ty1, Pointer ref_qs2 ref_ty2) ->
           is_complete sigm ref_ty1 && is_complete sigm ref_ty2
        && are_compatible (ref_qs1, ref_ty1) (ref_qs1, ref_ty2)
    | _ ->
        false
  end  

val        are_pointers_to_compatible_objects: ctype -> ctype -> bool
let ~{coq} are_pointers_to_compatible_objects (Ctype _ ty1) (Ctype _ ty2) =
  match (ty1, ty2) with
    | (Pointer ref_qs1 ref_ty1, Pointer ref_qs2 ref_ty2) ->
           is_object ref_ty1 && is_object ref_ty2
        && are_compatible (ref_qs1, ref_ty1) (ref_qs1, ref_ty2)
    | _ ->
        false
  end  

val is_pointer_to_object: ctype -> bool
let is_pointer_to_object (Ctype _ ty) =
match ty with
  | Pointer _ ref_ty ->
      is_object ref_ty
  | _ ->
      false
end

val is_pointer_to_void: ctype -> bool
let is_pointer_to_void (Ctype _ ty) =
match ty with
  | Pointer _ (Ctype _ Void) ->
      true
  | _ ->
      false
end

val is_pointer_to_function: ctype -> bool
let is_pointer_to_function (Ctype _ ty) =
match ty with
  | Pointer _ ref_ty ->
      is_function ref_ty
  | _ ->
      false
end


val        pointers_to_compatible_types: ctype -> ctype -> bool
let ~{coq} pointers_to_compatible_types (Ctype _ ty1) (Ctype _ ty2) =
  match (ty1, ty2) with
  | (Pointer ref_qs1 ref_ty1, Pointer ref_qs2 ref_ty2) ->
      are_compatible (ref_qs1, ref_ty1) (ref_qs1, ref_ty2)
  | _ ->
      false
  end  


(* STD §6.2.5#4, sentence 1 *)
val is_standard_signed_integer_type: ctype -> bool
let is_standard_signed_integer_type (Ctype _ ty) =
match ty with
(*
  | Basic (Integer (Signed Ichar)) ->
      true
  | Basic (Integer (Signed Short)) ->
      true
  | Basic (Integer (Signed Int_)) ->
      true
  | Basic (Integer (Signed Long)) ->
      true
  | Basic (Integer (Signed LongLong)) ->
      true
*)
  | Basic (Integer ity) ->
      is_signed_ity ity
  | _ ->
      false
end

(* TODO: no extended types for now *)
(* STD §6.2.5#4, sentence 3 *)
val is_extended_signed_integer_type: ctype -> bool
let is_extended_signed_integer_type _ =
  false

(* STD §6.2.5#4, sentence 4 *)
val is_signed_integer_type: ctype -> bool
let is_signed_integer_type ty =
  is_standard_signed_integer_type ty || is_extended_signed_integer_type ty


(* STD §6.2.5#6, sentences 1-2 *)
val is_standard_unsigned_integer_type: ctype -> bool
let is_standard_unsigned_integer_type (Ctype _ ty) =
match ty with
(*
  | Basic (Integer Bool) ->
      true
  | Basic (Integer (Unsigned Ichar)) ->
      true
  | Basic (Integer (Unsigned Short)) ->
      true
  | Basic (Integer (Unsigned Int_)) ->
      true
  | Basic (Integer (Unsigned Long)) ->
      true
  | Basic (Integer (Unsigned LongLong)) ->
      true
*)
  | Basic (Integer ity) ->
      is_unsigned_ity ity
  | _ ->
       false
end

(* TODO: no extended types for now *)
(* STD §6.2.5#6, sentence 3 *)
val is_extended_unsigned_integer_type: ctype -> bool
let is_extended_unsigned_integer_type _ =
  false


val is_unsigned_integer_type: ctype -> bool
let is_unsigned_integer_type (Ctype _ ty) =
match ty with
  | Basic (Integer ity) ->
      is_unsigned_ity ity
  | _ ->
      false
end








val variably_modified: ctype -> bool
let variably_modified _ =
  let () = Debug.warn [] (fun () -> "AilTypesAux.variably_modified is BOGUS") in
  (* TODO *)
  false



val had_unknown_size: ctype -> bool
let has_unknown_size = function
  | _ ->
      false (* TODO !!!!!!! *)
end

val is_vla: ctype -> bool
let is_vla = function
  | _ ->
      false (* TODO !!!!!!! *)
end

val is_complete_object: forall 'a. sigma 'a -> ctype -> bool
let is_complete_object S ty =
  is_complete S ty && is_object ty


(* Adjustment for function parameter types *)
val adjust: qualifiers -> ctype -> (qualifiers * ctype)
let adjust qs (Ctype a ty) =
match ty with
  | Array elem_ty _ ->
      (* STD §6.7.6.3#7 *)
      (* TODO: now that I removed qualifiers from Array, this function doesn't
         doesn't do the right thing. Cabs_to_ail should not use it anymore
         (at least not for Array) *)
      (no_qualifiers, Ctype a (Pointer qs elem_ty))
 | Function hasProto ret_qs_ty params isVariadic ->
      (* STD §6.7.6.3#8 *)
     let () = Debug.warn [] (fun () ->
       "(unsure) AilTypesAux.Function, qualifiers"
     ) in
     (no_qualifiers, Ctype a (Pointer qs (Ctype [] (Function hasProto ret_qs_ty params isVariadic))))
 | ty ->
     (qs, Ctype a ty)
end



(* STD §6.3.2.1#2 *)
val lvalue_conversion: forall 'a. sigma 'a -> ctype -> errorM ctype
let lvalue_conversion S cty =
  if is_array cty then
    error "trying to do a lvalue conversion on an array type"
  
  else if is_incomplete S cty && not (is_array cty) then
    undef (Loc.locOf cty) Undefined.UB020_nonarray_incomplete_lvalue_conversion
  
  (* STD §6.3.2.1#2, sentence 2 *)
  else match cty with
    | Ctype _ (Atomic cty') ->
        return cty'
    | _ ->
        (* NOTE: since the qualifiers of ty are not passed to this function, we
           have already "unqualified" the type *)
        return cty
  end

val compatibleWithQualifiedUnqualifiedVersionOf: ctype -> list ctype -> bool
let compatibleWithQualifiedUnqualifiedVersionOf ty tys =
  List.any (fun ty' ->
    are_compatible (no_qualifiers, ty) (no_qualifiers, ty')
  ) tys


val referenced_type: ctype -> maybe ctype
let referenced_type ty =
  (* TODO: check atomic *)
  match unatomic ty with
  | Pointer _ ty' ->
      Just ty'
  | _ ->
      Nothing
end






(* TODO: this is such a bad name ... *)
val     has_pointer_at_leafs: ctype -> bool
let rec has_pointer_at_leafs (Ctype _ ty) =
  match ty with
    | Void ->
        false
    | Basic _ ->
        false
    | Array elem_ty _ ->
        has_pointer_at_leafs elem_ty
    | Function _ _ _ _ ->
        false
    | Pointer _ _ ->
        true
    | Atomic ty ->
        has_pointer_at_leafs ty
    | Struct _ ->
        false
    | Union _ ->
        false
    | Builtin _ ->
        (* TODO *)
        false
  end

let mk_ctype_integer ity =
  Ctype [] (Basic (Integer ity))

let mk_ctype_builtin str =
  Ctype [] (Builtin str)

let mk_ctype_atomic cty =
  Ctype [] (Atomic cty)
