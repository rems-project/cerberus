open import Pervasives
import Map_extra

open import Utils Errors Loc
import Exception Pp

open import Core Core_aux
import Mem_common Core_ctype Core_ctype_aux Implementation_

open import Core_typing_aux

module I = Implementation_

module Cty = struct
  include Core_ctype
  include Core_ctype_aux
end

import Core_typing_effect
module E = Core_typing_effect

let inline (>>=)      = E.bind
let inline (>>) m1 m2 = m1 >>= fun _ -> m2
let inline (<$>)      = E.fmap
let inline (<*>)      = E.app


val     infer_pattern: pattern -> E.eff (typing_env * inferred * inferred_pattern)
let rec infer_pattern (Pattern annots pat) =
  let loc = Annot.get_loc_ annots in
  match pat with
  | CaseBase (Nothing, bTy) ->
      E.return (empty_env, toInferred bTy, Pattern annots (CaseBase (Nothing, bTy)))
  | CaseBase (Just sym, bTy) ->
      E.return (singleton_tdecl_env (Sym sym) (TDsym bTy), toInferred bTy, Pattern annots (CaseBase (Just sym, bTy)))
  | CaseCtor ctor pats ->
      match (ctor, pats) with
        | (Cnil (), []) ->
            let infer = InferredType_list InferredUnknown in
            E.return (empty_env, infer, Pattern annots (CaseCtor (Cnil infer) []))
        | (Cnil (), _) ->
            error "infer_pattern: Cnil: wrong number of arguments"
        | (Ccons, [pat1; pat2]) ->
            infer_pattern pat1 >>= fun (env1, infer1, tpat1) ->
            match toCoreBaseType infer1 with
              | Just bTy ->
                  typecheck_pattern (BTy_list bTy) pat2 >>= fun (env2, tpat2) ->
                  E.return (env_union env1 env2, InferredType_list infer1, Pattern annots (CaseCtor Ccons [tpat1; tpat2]))
              | Nothing ->
                  E.fail (locOf pat1) TooGeneral
            end
        | (Ccons, _) ->
            error "infer_pattern: Ccons: wrong number of arguments"
        | (Ctuple, _) ->
            unzip3 <$> E.mapM (infer_pattern) pats >>= fun (envs, infers, pats') ->
            E.return (env_unions envs,
                      InferredType_tuple infers,
                      Pattern annots (CaseCtor Ctuple pats'))
        | (Carray, _) ->
            error "Core_typing.Carray: WIP, Carray"
        | (Civmax, [pat']) ->
            typecheck_pattern BTy_ctype pat' >>= fun (env, tpat') ->
            E.return (env, InferredType_object OTy_integer, Pattern annots (CaseCtor Civmax [tpat']))
        | (Civmax, _) ->
            error "infer_pattern: Civmax: wrong number of arguments"
        | (Civmin, [pat']) ->
            typecheck_pattern BTy_ctype pat' >>= fun (env, tpat') ->
            E.return (env, InferredType_object OTy_integer, Pattern annots (CaseCtor Civmin [tpat']))
        | (Civmin, _) ->
            error "infer_pattern: Civmin: wrong number of arguments"
        | (Civsizeof, [pat']) ->
            typecheck_pattern BTy_ctype pat' >>= fun (env, tpat') ->
            E.return (env, InferredType_object OTy_integer, Pattern annots (CaseCtor Civsizeof [tpat']))
        | (Civsizeof, _) ->
            error "infer_pattern: Civsizeof: wrong number of arguments"
        | (Civalignof, [pat']) ->
            typecheck_pattern BTy_ctype pat' >>= fun (env, tpat') ->
            E.return (env, InferredType_object OTy_integer, Pattern annots (CaseCtor Civalignof [tpat']))
        | (Civalignof, _) ->
            error "infer_pattern: Civalignof: wrong number of arguments"
        | (CivCOMPL, [pat1; pat2]) ->
            typecheck_pattern BTy_ctype pat1                >>= fun (env1, tpat1) ->
            typecheck_pattern (BTy_object OTy_integer) pat2 >>= fun (env2, tpat2) ->
            E.return ( env_union env1 env2
                     , InferredType_object OTy_integer
                     , Pattern annots (CaseCtor CivCOMPL [tpat1; tpat2]))
        | (CivCOMPL, _) ->
            error "infer_pattern: CivCOMPL: wrong number of arguments"
        | (CivAND, [pat1; pat2; pat3]) ->
            typecheck_pattern BTy_ctype pat1                >>= fun (env1, tpat1) ->
            typecheck_pattern (BTy_object OTy_integer) pat2 >>= fun (env2, tpat2) ->
            typecheck_pattern (BTy_object OTy_integer) pat3 >>= fun (env3, tpat3) ->
            E.return ( env_unions [env1; env2; env3]
                     , InferredType_object OTy_integer
                     , Pattern annots (CaseCtor CivAND [tpat1; tpat2; tpat3]))
        | (CivAND, _) ->
            error "infer_pattern: CivAND: wrong number of arguments"
        | (CivOR, [pat1; pat2; pat3]) ->
            typecheck_pattern BTy_ctype pat1                >>= fun (env1, tpat1) ->
            typecheck_pattern (BTy_object OTy_integer) pat2 >>= fun (env2, tpat2) ->
            typecheck_pattern (BTy_object OTy_integer) pat3 >>= fun (env3, tpat3) ->
            E.return ( env_unions [env1; env2; env3]
                     , InferredType_object OTy_integer
                     , Pattern annots (CaseCtor CivOR [tpat1; tpat2; tpat3]))
        | (CivOR, _) ->
            error "infer_pattern: CivOR: wrong number of arguments"
        | (CivXOR, [pat1; pat2; pat3]) ->
            typecheck_pattern BTy_ctype pat1                >>= fun (env1, tpat1) ->
            typecheck_pattern (BTy_object OTy_integer) pat2 >>= fun (env2, tpat2) ->
            typecheck_pattern (BTy_object OTy_integer) pat3 >>= fun (env3, tpat3) ->
            E.return ( env_unions [env1; env2; env3]
                     , InferredType_object OTy_integer
                     , Pattern annots (CaseCtor CivXOR [tpat1; tpat2; tpat3]))
        | (CivXOR, _) ->
            error "infer_pattern: CivXOR: wrong number of arguments"
        | (Cspecified, [pat']) ->
            infer_pattern pat' >>= fun (env, infer', tpat') ->
            match infer' with
              | InferredType_object oTy ->
                  E.return (env, InferredType_loaded oTy, Pattern annots (CaseCtor Cspecified [tpat']))
              | _ ->
                  E.fail (locOf pat') (MismatchFound "Cspecified" "object" (toCoreBaseType infer'))
            end
        | (Cspecified, _) ->
            error "infer_pattern: Cspecified: wrong number of arguments"
        | (Cunspecified, [_]) ->
            E.fail loc TooGeneral
        | (Cunspecified, _) ->
            error "infer_pattern: Cunspecified: wrong number of arguments"
        | (Cfvfromint, [pat]) ->
            typecheck_pattern (BTy_object OTy_integer) pat >>= fun (env, tpat) ->
            E.return (env, InferredType_object OTy_floating, Pattern annots (CaseCtor Cfvfromint [tpat]))
        | (Cfvfromint, _) ->
            error "infer_pattern: Cfvfromint: wrong number of arguments"
        | (Civfromfloat, [pat1; pat2]) ->
            typecheck_pattern BTy_ctype                 pat1 >>= fun (env1, tpat1) ->
            typecheck_pattern (BTy_object OTy_floating) pat2 >>= fun (env2, tpat2) ->
            E.return ( env_union env1 env2
                     , InferredType_object OTy_integer
                     , Pattern annots (CaseCtor Civfromfloat [tpat1; tpat2]))
        | (Civfromfloat, _) ->
            error "infer_pattern: Cfvfromfloat: wrong number of arguments"
      end
end


(* val     typecheck_pattern: core_base_type -> pattern -> E.eff (typing_env * inferred_pattern) *)
and typecheck_pattern expected_bTy (Pattern annots pat) =
  let loc = Annot.get_loc_ annots in
  match pat with
  | CaseBase (Nothing, bTy) ->
      guard_match loc "empty pattern" expected_bTy bTy >>
      E.return (empty_env, Pattern annots (CaseBase (Nothing, bTy)))
  | CaseBase (Just sym, bTy) ->
      guard_match loc ("pattern symbol " ^ show sym) expected_bTy bTy >>
      E.return (singleton_tdecl_env (Sym sym) (TDsym bTy), Pattern annots (CaseBase (Just sym, bTy)))
  | CaseCtor ctor pats ->
      match (ctor, expected_bTy, pats) with
        | (Cnil (), BTy_list elem_bTy, []) ->
            E.return (empty_env, Pattern annots (CaseCtor (Cnil (toInferred elem_bTy)) []))
        | (Cnil (), _, []) ->
            E.fail loc (MismatchExpected "Cnil" expected_bTy "list")
        | (Cnil (), _, _) ->
            error "typecheck_pattern: Cnil: wrong number of arguments"

        | (Ccons, BTy_list elem_bTy, [pat1; pat2]) ->
            typecheck_pattern elem_bTy     pat1 >>= fun (env1, tpat1) ->
            typecheck_pattern expected_bTy pat2 >>= fun (env2, tpat2) ->
            E.return (env_union env1 env2, Pattern annots (CaseCtor Ccons [tpat1; tpat2]))
        | (Ccons, _, []) ->
            E.fail loc (MismatchExpected "Ccons" expected_bTy "list")
        | (Ccons, _, _) ->
            error "typecheck_pattern: Ccons: wrong number of arguments"

        | (Ctuple, BTy_tuple bTys, _) ->
            List.unzip <$> E.mapM (fun (bTy, pat) ->
              typecheck_pattern bTy pat
            ) (List.zip bTys pats) >>= fun (envs, tpats) ->
            E.return (env_unions envs, Pattern annots (CaseCtor Ctuple tpats))
        | (Ctuple, _, _) ->
            E.fail loc (MismatchExpected "Ctuple" expected_bTy "tuple")

        | (Carray, _, _) ->
            (* TODO: *)
            error "Core_typing.Carray: WIP, Carray"

        | (Civmax, BTy_object OTy_integer, [pat']) ->
            typecheck_pattern (BTy_ctype) pat' >>= fun (env, tpat') ->
            E.return (env, Pattern annots (CaseCtor Civmax [tpat']))
        | (Civmax, _, [_]) ->
            E.fail loc (Mismatch "Civmax" expected_bTy (BTy_object OTy_integer))
        | (Civmax, _, _) ->
            error "typecheck_pattern: Civmax: wrong number of arguments"

        | (Civmin, BTy_object OTy_integer, [pat']) ->
            typecheck_pattern (BTy_ctype) pat' >>= fun (env, tpat') ->
            E.return (env, Pattern annots (CaseCtor Civmin [tpat']))
        | (Civmin, _, [_]) ->
            E.fail loc (Mismatch "Civmin" expected_bTy (BTy_object OTy_integer))
        | (Civmin, _, _) ->
            error "typecheck_pattern: Civmin: wrong number of arguments"

        | (Civsizeof, BTy_object OTy_integer, [pat']) ->
            typecheck_pattern (BTy_ctype) pat' >>= fun (env, tpat') ->
            E.return (env, Pattern annots (CaseCtor Civsizeof [tpat']))
        | (Civsizeof, _, [_]) ->
            E.fail loc (Mismatch "Civsizeof" expected_bTy (BTy_object OTy_integer))
        | (Civsizeof, _, _) ->
            error "typecheck_pattern: Civsizeof: wrong number of arguments"

        | (Civalignof, BTy_object OTy_integer, [pat']) ->
            typecheck_pattern (BTy_ctype) pat' >>= fun (env, tpat') ->
            E.return (env, Pattern annots (CaseCtor Civalignof [tpat']))
        | (Civalignof, _, [_]) ->
            E.fail loc (Mismatch "Civalignof" expected_bTy (BTy_object OTy_integer))
        | (Civalignof, _, _) ->
            error "typecheck_pattern: Civalignof: wrong number of arguments"

        | (CivCOMPL, BTy_object OTy_integer, [pat1; pat2]) ->
            typecheck_pattern BTy_ctype pat1                >>= fun (env, tpat1) ->
            typecheck_pattern (BTy_object OTy_integer) pat2 >>= fun (env, tpat2) ->
            E.return (env, Pattern annots (CaseCtor CivCOMPL [tpat1; tpat2]))
        | (CivCOMPL, _, [_]) ->
            E.fail loc (Mismatch "CivCOMPL" expected_bTy (BTy_object OTy_integer))
        | (CivCOMPL, _, _) ->
            error "typecheck_pattern: CivCOMPL: wrong number of arguments"

        | (CivAND, BTy_object OTy_integer, [pat1; pat2; pat3]) ->
            typecheck_pattern BTy_ctype pat1                >>= fun (env, tpat1) ->
            typecheck_pattern (BTy_object OTy_integer) pat2 >>= fun (env, tpat2) ->
            typecheck_pattern (BTy_object OTy_integer) pat3 >>= fun (env, tpat3) ->
            E.return (env, Pattern annots (CaseCtor CivAND [tpat1; tpat2; tpat3]))
        | (CivAND, _, [_]) ->
            E.fail loc (Mismatch "CivAND" expected_bTy (BTy_object OTy_integer))
        | (CivAND, _, _) ->
            error "typecheck_pattern: CivAND: wrong number of arguments"

        | (CivOR, BTy_object OTy_integer, [pat1; pat2; pat3]) ->
            typecheck_pattern BTy_ctype pat1                >>= fun (env, tpat1) ->
            typecheck_pattern (BTy_object OTy_integer) pat2 >>= fun (env, tpat2) ->
            typecheck_pattern (BTy_object OTy_integer) pat3 >>= fun (env, tpat3) ->
            E.return (env, Pattern annots (CaseCtor CivOR [tpat1; tpat2; tpat3]))
        | (CivOR, _, [_]) ->
            E.fail loc (Mismatch "CivOR" expected_bTy (BTy_object OTy_integer))
        | (CivOR, _, _) ->
            error "typecheck_pattern: CivOR: wrong number of arguments"

        | (CivXOR, BTy_object OTy_integer, [pat1; pat2; pat3]) ->
            typecheck_pattern BTy_ctype pat1                >>= fun (env, tpat1) ->
            typecheck_pattern (BTy_object OTy_integer) pat2 >>= fun (env, tpat2) ->
            typecheck_pattern (BTy_object OTy_integer) pat3 >>= fun (env, tpat3) ->
            E.return (env, Pattern annots (CaseCtor CivXOR [tpat1; tpat2; tpat3]))
        | (CivXOR, _, [_]) ->
            E.fail loc (Mismatch "CivXOR" expected_bTy (BTy_object OTy_integer))
        | (CivXOR, _, _) ->
            error "typecheck_pattern: CivXOR: wrong number of arguments"

        | (Cspecified, BTy_loaded oTy, [pat']) ->
            typecheck_pattern (BTy_object oTy) pat' >>= fun (env, tpat') ->
            E.return (env, Pattern annots (CaseCtor Cspecified [tpat']))
        | (Cspecified, _, [_]) ->
            E.fail loc (MismatchExpected "Civspecified" expected_bTy "loaded object")
        | (Cspecified, _, _) ->
            error "typecheck_pattern: Cspecified: wrong number of arguments"

        | (Cunspecified, BTy_loaded oTy, [pat']) ->
            (* TODO: dependent types here .... *)
            typecheck_pattern BTy_ctype pat' >>= fun (env, tpat') ->
            E.return (env, Pattern annots (CaseCtor Cunspecified [tpat']))
        | (Cunspecified, _, [_]) ->
            E.fail loc (MismatchExpected "Civunspecified" expected_bTy "loaded object")
        | (Cunspecified, _, _) ->
            error "typecheck_pattern: Cunspecified: wrong number of arguments"

        | (Cfvfromint, BTy_object OTy_floating, [pat]) ->
            typecheck_pattern (BTy_object OTy_integer) pat >>= fun (env, tpat) ->
            E.return (env, Pattern annots (CaseCtor Cfvfromint [tpat]))
        | (Cfvfromint, _, [_]) ->
            E.fail loc (Mismatch "Civfromint" expected_bTy (BTy_object OTy_floating))
        | (Cfvfromint, _, _) ->
            error "typecheck_pattern: Civfromint: wrong number of arguments"

        | (Civfromfloat, BTy_object OTy_integer, [pat1; pat2]) ->
            typecheck_pattern BTy_ctype                pat1  >>= fun (env1, tpat1) ->
            typecheck_pattern (BTy_object OTy_floating) pat2 >>= fun (env2, tpat2) ->
            E.return ( env_union env1 env2
                     , Pattern annots (CaseCtor Civfromfloat [tpat1; tpat2] ))
        | (Civfromfloat, _, [_; _]) ->
            E.fail loc (Mismatch "Civfromfloat" expected_bTy (BTy_object OTy_integer))
        | (Civfromfloat, _, _) ->
            error "typecheck_pattern: Civfromfloat: wrong number of arguments"
      end
end


val     typeof_object_value: Loc.t -> typing_env -> object_value -> E.eff core_object_type
let rec typeof_object_value loc env oval =
  match oval with
   | OVinteger _ ->
       E.return OTy_integer
   | OVfloating _ ->
       E.return OTy_floating
   | OVpointer _ ->
       E.return OTy_pointer
   | OVarray [] ->
       (* TODO(V): impossible to write an example *)
       error "TODO: EmptyArray"
   | OVarray (lval'::lvals') ->
       typeof_loaded_value loc env lval' >>= fun oTy ->
       E.mapM (fun lval ->
         typeof_loaded_value loc env lval >>= fun oTy' ->
         if oTy <> oTy' then
           (* TODO(V): impossible to write an example *)
           error "TODO HeterogenousArray oTy oTy'"
         else
           E.return ()
       ) lvals' >>
       E.return (OTy_array oTy)
   | OVstruct tag_sym _ ->
       let () = Debug.warn [Debug.DB_core_typing] (fun () ->
         "Core typing, OVstruct doesn't check the validity of the member"
       ) in
       E.return (OTy_struct tag_sym)
   | OVunion tag_sym _ _ ->
       E.return (OTy_union tag_sym)
   | OVcomposite _ _ _ ->
       E.return OTy_integer
  end

(* val     typeof_loaded_value: Loc.t -> typing_env -> loaded_value -> E.eff core_object_type *)
and typeof_loaded_value loc env (lval: loaded_value) : E.eff core_object_type =
  match lval with
    | LVspecified oval ->
        typeof_object_value loc env oval
    | LVunspecified ty ->
       (* TODO(V): impossible to write an example *)
        error "TODO: typeof_loaded_value, LVunspecified"
  end



val     typeof_value: Loc.t -> typing_env -> Core.value -> E.eff core_base_type
let rec typeof_value loc env cval =
  match cval with
    | Vobject oval ->
        BTy_object <$> typeof_object_value loc env oval
    | Vloaded (LVspecified oval) ->
        BTy_loaded <$> typeof_object_value loc env oval
    | Vloaded (LVunspecified ty) ->
        match core_object_type_of_ctype ty with
          | Just oTy ->
              E.return (BTy_loaded oTy)
          | Nothing ->
             (* TODO(V): impossible to write an example *)
              error "TODO typeof_value, Vunspecified not oTy"
        end
    | Vunit ->
        E.return BTy_unit
    | Vtrue ->
        E.return BTy_boolean
    | Vfalse ->
        E.return BTy_boolean
    | Vctype _ ->
        E.return BTy_ctype
    | Vlist bTy cvals' ->
       E.mapM (fun cval ->
         typeof_value loc env cval >>= fun bTy' ->
         if bTy <> bTy' then
           E.fail loc (HeterogenousList bTy bTy')
         else
           E.return ()
       ) cvals' >>
       E.return (BTy_list bTy)
    | Vtuple cvals ->
        BTy_tuple <$> E.mapM (typeof_value loc env) cvals
  end


val     infer_pexpr: core_tag_definitions -> typing_env -> pexpr -> E.eff inferred_pexpr
let rec infer_pexpr tagDefs env (Pexpr annot () pexpr_) =
  let loc = Annot.get_loc_ annot in
  match pexpr_ with
    | PEsym sym ->
        match Map.lookup (Sym sym) env.decls with
          | Just (TDsym bTy) ->
              E.return (Pexpr annot (toInferred bTy) (PEsym sym))
          | Just _ ->
              E.fail loc (FunctionOrProcedureSymbol sym)
          | Nothing ->
              (* NOTE: this should have been detected by the parser.
               * We add it here just in case. *)
              E.fail loc (UnresolvedSymbol (Sym sym))
        end
    (* FIXME: match type for each impl constant??? *)
    | PEimpl impl ->
        error "E.return (Pexpr (BTy_object OTy_integer) (PEimpl impl))"
    | PEval cval ->
        typeof_value loc env cval >>= fun bTy ->
        E.return (Pexpr annot (toInferred bTy) (PEval cval))
    | PEconstrained cs ->
        (* FIXME *)
        error "WIP: Core_typing.infer_pexpr, PEconstrained"
    | PEundef loc ub ->
        E.return (Pexpr annot InferredUnknown (PEundef loc ub))
    | PEerror str pe ->
        infer_pexpr tagDefs env pe >>= fun tpe ->
        E.return (Pexpr annot InferredUnknown (PEerror str tpe))
    | PEctor ctor pes ->
        let ret_ctor bTy ctor pes = E.return (Pexpr annot bTy (PEctor ctor pes)) in
        match (ctor, pes) with
          | (Cnil (), []) ->
              E.return (Pexpr annot InferredUnknown (PEctor (Cnil InferredUnknown) []))
          | (Cnil _, _) ->
              error "infer_pexpr: Cnil: wrong number of arguments"
          | (Ccons, [pe1; pe2]) ->
              infer_pexpr tagDefs env pe1 >>= fun (Pexpr _ infer1 _ as pe1') ->
              match toCoreBaseType infer1 with
                | Just bTy1 ->
                    typecheck_pexpr tagDefs env (BTy_list bTy1) pe2 >>= fun pe2' ->
                    E.return (Pexpr annot (InferredType_list infer1) (PEctor Ccons [pe1'; pe2']))
                | Nothing ->
                    infer_pexpr tagDefs env pe2 >>= fun (Pexpr _ infer2 _ as pe2') ->
                    match toCoreBaseType infer2 with
                      | Just (BTy_list elem_bTy2) ->
                          typecheck_pexpr tagDefs env elem_bTy2 pe1 >>= fun pe1' ->
                            E.return (Pexpr annot infer2 (PEctor Ccons [pe1'; pe2']))
                      | Just _ ->
                          E.fail (locOf pe2) (MismatchFound "Ccons" "list" (toCoreBaseType infer2))
                      | Nothing ->
                          (* TODO: can maybe be improved (see Core_typing_aux.unify) *)
                          E.fail loc TooGeneral
                    end
              end
(*
              let str =
                let str1 = match toCoreBaseType infer1 with
                  | Just bTy ->
                      Pp.stringFromCore_core_base_type bTy
                  | Nothing ->
                      "?"
                end in
                let str2 = match toCoreBaseType infer2 with
                  | Just bTy ->
                      Pp.stringFromCore_core_base_type bTy
                  | Nothing ->
                      "?"
                end in
                str1 ^ " <- vs -> " ^ str2
              in
              E.guard (InferredType_list infer1 = infer2)
                loc (CoreTyping_TODO ("annotate Ccons: illtyped list ==> " ^ str)) >>
              E.return (Pexpr infer2 (PEctor Ccons [pe1'; pe2']))
*)
          | (Ccons, _) ->
              error "infer_pexpr: Ccons: wrong number of arguments"
          | (Ctuple, _) ->
            E.mapM (infer_pexpr tagDefs env) pes >>= fun pes' ->
            let (infers, pes') = List.unzip (
                List.map (fun (Pexpr _ infers _ as pe') -> (infers, pe')) pes'
            ) in E.return (Pexpr annot (InferredType_tuple infers) (PEctor Ctuple pes'))
          | (Civmax, [pe]) ->
              typecheck_pexpr tagDefs env BTy_ctype pe >>= fun pe' ->
              ret_ctor (InferredType_object OTy_integer) Civmax [pe']
          | (Civmax, _) ->
              error "infer_pexpr: Civmax: wrong number of arguments"
          | (Civmin, [pe]) ->
              typecheck_pexpr tagDefs env BTy_ctype pe >>= fun pe' ->
              ret_ctor (InferredType_object OTy_integer) Civmin [pe']
          | (Civmin, _) ->
              error "infer_pexpr: Civmin: wrong number of arguments"
          | (Civsizeof, [pe]) ->
              typecheck_pexpr tagDefs env BTy_ctype pe >>= fun pe' ->
              ret_ctor (InferredType_object OTy_integer) Civsizeof [pe']
          | (Civsizeof, _) ->
              error "infer_pexpr: Civsizeof: wrong number of arguments"
          | (Civalignof, [pe]) ->
              typecheck_pexpr tagDefs env BTy_ctype pe >>= fun pe' ->
              ret_ctor (InferredType_object OTy_integer) Civalignof [pe']
          | (Civalignof, _) ->
              error "infer_pexpr: Civalignof: wrong number of arguments"
          | (CivCOMPL, [pe1; pe2]) ->
              typecheck_pexpr tagDefs env BTy_ctype pe1                >>= fun pe1' ->
              typecheck_pexpr tagDefs env (BTy_object OTy_integer) pe2 >>= fun pe2' ->
              ret_ctor (InferredType_object OTy_integer) CivCOMPL [pe1'; pe2']
          | (CivCOMPL, _) ->
              error "infer_pexpr: CivCOMPL: wrong number of arguments"
          | (CivAND, [pe1; pe2; pe3]) ->
              typecheck_pexpr tagDefs env BTy_ctype pe1                >>= fun pe1' ->
              typecheck_pexpr tagDefs env (BTy_object OTy_integer) pe2 >>= fun pe2' ->
              typecheck_pexpr tagDefs env (BTy_object OTy_integer) pe3 >>= fun pe3' ->
              ret_ctor (InferredType_object OTy_integer) CivAND [pe1'; pe2']
          | (CivAND, _) ->
              error "infer_pexpr: CivAND: wrong number of arguments"
          | (CivOR, [pe1; pe2; pe3]) ->
              typecheck_pexpr tagDefs env BTy_ctype pe1                >>= fun pe1' ->
              typecheck_pexpr tagDefs env (BTy_object OTy_integer) pe2 >>= fun pe2' ->
              typecheck_pexpr tagDefs env (BTy_object OTy_integer) pe3 >>= fun pe3' ->
              ret_ctor (InferredType_object OTy_integer) CivOR [pe1'; pe2']
          | (CivOR, _) ->
              error "infer_pexpr: CivOR: wrong number of arguments"
          | (CivXOR, [pe1; pe2; pe3]) ->
              typecheck_pexpr tagDefs env BTy_ctype pe1                >>= fun pe1' ->
              typecheck_pexpr tagDefs env (BTy_object OTy_integer) pe2 >>= fun pe2' ->
              typecheck_pexpr tagDefs env (BTy_object OTy_integer) pe3 >>= fun pe3' ->
              ret_ctor (InferredType_object OTy_integer) CivXOR [pe1'; pe2']
          | (CivXOR, _) ->
              error "infer_pexpr: CivXOR: wrong number of arguments"
          
          | (Cspecified, [pe]) ->
              infer_pexpr tagDefs env pe >>= fun (Pexpr _ infer _ as pe') ->
              match infer with
                | InferredType_object oTy ->
                    ret_ctor (InferredType_loaded oTy) Cspecified [pe']
                | _ ->
                    E.fail loc TooGeneral
              end
          | (Cspecified, _) ->
              error "infer_pexpr: Cspecified: wrong number of arguments"
          | (Cunspecified, [Pexpr _ () (PEval (Vctype ty))]) ->
              let pe' = Pexpr annot InferredType_ctype (PEval (Vctype ty)) in
              match core_object_type_of_ctype ty with
                | Just oTy ->
                    ret_ctor (InferredType_loaded oTy) Cunspecified [pe']
                | Nothing ->
                    E.fail loc (CoreTyping_TODO "Cunspecified, not oTy")
              end
          | (Cunspecified, [pe]) ->
              error "Core_typing, Cunspecified non-trivial"
          | (Cunspecified, _) ->
              error "infer_pexpr: Cunspecified: wrong number of arguments"
          | _ ->
              error ("WIP: infer_pexpr, " ^ Pp.stringFromCore_pexpr (Pexpr annot () pexpr_))
        end
    | PEcase pe cases ->
        infer_pexpr tagDefs env pe >>= fun (Pexpr _ infer _ as pe') ->
        match toCoreBaseType infer with
          | Nothing ->
              E.fail loc TooGeneral
          | Just case_bTy ->
              E.mapM (fun (pat, pe) ->
                typecheck_pattern case_bTy pat              >>= fun (env', pat') ->
                infer_pexpr tagDefs (env_union env env') pe >>= fun pe'          ->
                E.return (pat', pe')
              ) cases >>= fun cases' ->
              match List.foldr (fun (_, Pexpr _ infer _) acc ->
                (* NOTE: the eta expansion around Just is because of Lem *)
                maybe (toCoreBaseType infer) (fun z -> Just z) acc
              ) Nothing cases' with
                | Just bTy ->
                    E.mapM (fun (pat, pe) ->
                      typecheck_pattern case_bTy pat                      >>= fun (env', pat') ->
                      typecheck_pexpr tagDefs (env_union env env') bTy pe >>= fun pe'          ->
                      E.return (pat', pe')
                    ) cases >>= fun cases' ->
                    E.return (Pexpr annot (toInferred bTy) (PEcase pe' cases'))
                | Nothing ->
                    E.fail loc TooGeneral
              end
        end
    | PEarray_shift pe1 cty pe2 ->
        typecheck_pexpr tagDefs env (BTy_object OTy_pointer) pe1 >>= fun pe1' ->
        typecheck_pexpr tagDefs env (BTy_object OTy_integer) pe2 >>= fun pe2' ->
        E.return (Pexpr annot (InferredType_object OTy_pointer) (PEarray_shift pe1' cty pe2'))
    | PEmember_shift pe tag_sym memb_ident ->
        let xs = match fromJust "Core_typing.infer_pexpr, PEmember_shift" (Map.lookup tag_sym tagDefs) with
          | Core_ctype.StructDef z -> z
          | Core_ctype.UnionDef  z -> z
        end in
        typecheck_pexpr tagDefs env (BTy_object OTy_pointer) pe >>= fun pe' ->
          match List.lookup memb_ident xs with
            | Nothing ->
                E.fail loc (CoreTyping_TODO ("PEmember_shift, no member '" ^ show memb_ident ^ "' defined for the tag '" ^ show tag_sym ^ "'"))
            | _ ->
                E.return (Pexpr annot (InferredType_object OTy_pointer) (PEmember_shift pe' tag_sym memb_ident))
          end
    | PEnot pe ->
        Pexpr annot InferredType_boolean <$> (PEnot <$> typecheck_pexpr tagDefs env BTy_boolean pe)
    | PEop bop pe1 pe2 ->
        E.trysM_ (with_regions_and_cursor [locOf pe1; locOf pe2] (Just loc)) (MismatchBinaryOperator bop)
        (fun (bTy, bTy1, bTy2) ->
          Pexpr annot (toInferred bTy) <$> (PEop bop <$> typecheck_pexpr tagDefs env bTy1 pe1
                                                     <*> typecheck_pexpr tagDefs env bTy2 pe2)
        ) match bop with
          | OpAdd ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpSub ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpMul ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpDiv ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpRem_t ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer) ]
          | OpRem_f ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer) ]
          | OpExp ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer) ]
          | OpEq ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating)
              ; (BTy_boolean, BTy_ctype, BTy_ctype) ]
          | OpGt ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpLt ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpGe ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpLe ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpAnd ->
              [ (BTy_boolean, BTy_boolean, BTy_boolean) ]
          | OpOr ->
              [ (BTy_boolean, BTy_boolean, BTy_boolean) ]
        end
    | PEstruct tag_sym fields ->
        match fromJust "Core_typing.infer_pexpr, PEstruct" (Map.lookup tag_sym tagDefs) with
          | Core_ctype.UnionDef _ ->
              E.fail loc (InvalidTag tag_sym)
          | Core_ctype.StructDef xs ->
              E.mapM (fun (ident, pe) ->
                match List.lookup ident xs with
                  | Nothing ->
                      E.fail loc (InvalidMember tag_sym ident)
                  | Just ty ->
                      match core_object_type_of_ctype ty with
                        | Nothing ->
                            E.fail loc (CoreTyping_TODO ("in PEstruct, failed to convert '" ^
                                        Pp.stringFromCore_ctype ty ^ "' to a Core object type"))
                        | Just oTy ->
                            typecheck_pexpr tagDefs env (BTy_loaded oTy) pe >>= fun pe' ->
                            E.return (ident, pe')
                      end
                end
              ) fields
        end >>= fun fields' ->
        E.return begin
          Pexpr annot (InferredType_object (OTy_struct tag_sym))
            (PEstruct tag_sym fields')
        end
    | PEunion tag_sym ident pe ->
        match fromJust "Core_typing.infer_pexpr, PEunion" (Map.lookup tag_sym tagDefs) with
          | Core_ctype.StructDef _ ->
              E.fail loc (InvalidTag tag_sym)
          | Core_ctype.UnionDef xs ->
              match List.lookup ident xs with
                | Nothing ->
                    E.fail loc (InvalidMember tag_sym ident)
                | Just ty ->
                    match core_object_type_of_ctype ty with
                      | Nothing ->
                          E.fail loc (CoreTyping_TODO ("in PEunion, failed to convert '" ^
                                                       Pp.stringFromCore_ctype ty ^ "' to a Core object type"))
                      | Just oTy ->
                          typecheck_pexpr tagDefs env (BTy_loaded oTy) pe >>= fun pe' ->
                            Pexpr annot (InferredType_object (OTy_union tag_sym)) <$>
                              (PEunion tag_sym ident <$> typecheck_pexpr tagDefs env (BTy_loaded oTy) pe)
                    end
              end
        end
    | PEcfunction pe ->
        typecheck_pexpr tagDefs env (BTy_loaded OTy_pointer) pe >>= fun pe' ->
        E.return $ Pexpr annot (InferredType_tuple [InferredType_ctype; InferredType_list InferredType_ctype;
                                         InferredType_boolean; InferredType_boolean]) (PEcfunction pe')
    | PEmemberof tag_sym memb_ident pe ->
        let xs = match fromJust "Core_typing.infer_pexpr, PEmemberof" (Map.lookup tag_sym tagDefs) with
          | Core_ctype.StructDef xs ->
              xs
          | Core_ctype.UnionDef xs ->
              xs
        end in
        match List.lookup memb_ident xs with
          | Nothing ->
              E.fail loc (InvalidMember tag_sym memb_ident)
          | Just ty ->
              match core_object_type_of_ctype ty with
                | Nothing ->
                    E.fail loc (CoreTyping_TODO ("in PEmemberof, failed to convert '" ^
                                                 Pp.stringFromCore_ctype ty ^ "' to a Core object type"))
                | Just oTy ->
                    Pexpr annot (InferredType_loaded oTy) <$>
                       (PEmemberof tag_sym memb_ident <$>
                         typecheck_pexpr tagDefs env (BTy_object (OTy_struct tag_sym)) pe)
              end
        end
    | PEcall nm pes ->
        match Map.lookup nm env.decls with
          | Just (TDfun ret_bTy bTys) ->
              Pexpr annot (toInferred ret_bTy) <$> (PEcall nm <$> E.mapM (fun (bTy, pe) ->
                typecheck_pexpr tagDefs env bTy pe) (List.zip bTys pes))
          | Just _ ->
              E.fail loc (CoreTyping_TODO "PEcall, the name wasn't a function")
          | Nothing ->
              E.fail loc (CoreTyping_TODO ("PEcall, couldn't resolve the name: " ^ Pp.stringFromCore_pexpr (Pexpr annot () pexpr_)))
        end
    | PElet pat pe1 pe2 ->
        infer_pattern pat >>= fun (pat_env, pat_infer, pat') ->
        match toCoreBaseType pat_infer with
          (* if we can infer the type of the pattern, we use it to
             typecheck pe1 *)
          | Just pat_bTy ->
              typecheck_pexpr tagDefs env pat_bTy pe1         >>= fun pe1'                     ->
              infer_pexpr tagDefs (env_union env pat_env) pe2 >>= fun (Pexpr annot infer2 _ as pe2') ->
              E.return (Pexpr annot infer2 (PElet pat' pe1' pe2'))
          (* otherwise we need to infer the type of pe1 and use it to typecheck
             the pattern *)
          | Nothing ->
              infer_pexpr tagDefs env pe1 >>= fun (Pexpr _ pe1_infer _ as pe1') ->
              match toCoreBaseType pe1_infer with
                | Just pe1_bTy ->
                  typecheck_pattern pe1_bTy pat                   >>= fun (pat_env, pat')          ->
                  infer_pexpr tagDefs (env_union env pat_env) pe2 >>= fun (Pexpr _ infer2 _ as pe2') ->
                  E.return (Pexpr annot infer2 (PElet pat' pe1' pe2'))
                | Nothing ->
                    (* we couldn't infer the types of neither the pattern not pe1 *)
                    E.fail (locOf pat) TooGeneral
              end
        end
    | PEif pe1 pe2 pe3 ->
        infer_pexpr tagDefs env pe2 >>= fun (Pexpr _ infer2 _ as pe2') ->
        infer_pexpr tagDefs env pe3 >>= fun (Pexpr _ infer3 _ as pe3') ->
        match (toCoreBaseType infer2, toCoreBaseType infer3) with
          | (Nothing, Nothing) ->
              E.fail loc TooGeneral
          | (Just bTy2, Nothing) ->
              typecheck_pexpr tagDefs env bTy2 pe3 >>= fun pe3' ->
              E.return (toInferred bTy2, pe2', pe3')
          | (Nothing, Just bTy3) ->
              typecheck_pexpr tagDefs env bTy3 pe2 >>= fun pe2' ->
              E.return (toInferred bTy3, pe2', pe3')
          | (Just bTy2, Just bTy3) ->
              E.guard (bTy2 = bTy3) (with_regions_and_cursor [locOf pe2; locOf pe3] (Just loc)) (MismatchIf bTy2 bTy3) >>
              E.return (toInferred bTy2, pe2', pe3')
        end >>= fun (infer, pe2', pe3') ->
        Pexpr annot infer <$> (PEif <$> typecheck_pexpr tagDefs env BTy_boolean pe1
             <*> E.return pe2'
             <*> E.return pe3')
    | PEis_scalar pe ->
        Pexpr annot InferredType_boolean <$> (PEis_scalar <$> typecheck_pexpr tagDefs env BTy_ctype pe)
    | PEis_integer pe ->
        Pexpr annot InferredType_boolean <$> (PEis_integer <$> typecheck_pexpr tagDefs env BTy_ctype pe)
    | PEis_signed pe ->
        Pexpr annot InferredType_boolean <$> (PEis_signed <$> typecheck_pexpr tagDefs env BTy_ctype pe)
    | PEis_unsigned pe ->
        Pexpr annot InferredType_boolean <$> (PEis_unsigned <$> typecheck_pexpr tagDefs env BTy_ctype pe)
    | PEare_compatible pe1 pe2 ->
        Pexpr annot InferredType_boolean <$> (PEare_compatible <$> typecheck_pexpr tagDefs env BTy_ctype pe1 <*> typecheck_pexpr tagDefs env BTy_ctype pe2)
  end


(*
val     typecheck_pexpr: typing_env -> core_base_type -> pexpr -> E.eff
typed_pexpr*)
and typecheck_pexpr tagDefs (env: typing_env) (bTy: core_base_type) (Pexpr annot () pexpr_) : E.eff inferred_pexpr =
  let loc = Annot.get_loc_ annot in
  Pexpr annot (toInferred bTy) <$> match pexpr_ with
    | PEsym sym ->
        match Map.lookup (Sym sym) env.decls with
          | Just (TDsym bTy') ->
              guard_match loc ("symbol: " ^ show sym) bTy bTy' >>
              E.return (PEsym sym)
          | Just _ ->
              E.fail loc (CoreTyping_TODO "found a fun/proc symbolic in a PEsym")
          | Nothing ->
              E.fail loc (CoreTyping_TODO ("unresolved PEsym ==> " ^ show sym))
        end
    | PEimpl iCst ->
        match Map.lookup (Impl iCst) env.decls with
          | Just (TDsym bTy') ->
              guard_match loc "impl-name" bTy bTy' >>
              E.return (PEimpl iCst)
          | Just _ ->
              E.fail loc (CoreTyping_TODO "found a fun/proc symbolic in a PEimpl")
          | Nothing ->
              E.fail loc (CoreTyping_TODO "unresolved PEimpl")
        end
    | PEval cval ->
        typeof_value loc env cval >>= fun bTy' ->
        guard_match loc "value" bTy bTy' >>
        E.return (PEval cval)
    | PEconstrained cs ->
        (* list (list Mem.mem_constraint2 * (generic_pexpr 'ty 'sym)) (* constrained value *) *)
        error "WIP: Core_typing.typecheck_pexpr, PEconstrained"
    | PEundef loc ub ->
        E.return (PEundef loc ub)
    | PEerror str pe ->
        PEerror str <$> infer_pexpr tagDefs env pe
    | PEctor ctor pes ->
        let ret_ctor ctor pe = PEctor ctor [pe] in
        match (ctor, bTy, pes) with
          | (Cnil (), BTy_list elem_bTy, []) ->
              E.return (PEctor (Cnil (toInferred elem_bTy)) [])
          | (Cnil _, _, _) ->
              E.fail loc (MismatchExpected "Cnil" bTy "list")
          | (Ccons, BTy_list elem_bTy, [pe]) ->
              ret_ctor Ccons <$> typecheck_pexpr tagDefs env elem_bTy pe
          | (Ccons, BTy_list elem_bTy, [pe1; pe2]) ->
              typecheck_pexpr tagDefs env elem_bTy pe1 >>= fun pe1' ->
              typecheck_pexpr tagDefs env bTy pe2      >>= fun pe2' ->
              E.return (PEctor Ccons [pe1'; pe2'])
          | (Ccons, _, _) ->
              E.fail loc (MismatchExpected "Ccons" bTy "list")
          | (Ctuple, BTy_tuple bTys, _) ->
              E.mapM (fun (bTy, pe) -> typecheck_pexpr tagDefs env bTy pe)
                (List.zip bTys pes) >>=
              (fun pes' -> E.return (PEctor Ctuple pes'))
          | (Ctuple, _, _) ->
              E.fail loc (MismatchExpected "Ctuple" bTy "tuple")
          | (Carray, BTy_object (OTy_array oTy), pes) ->
              PEctor Carray <$> E.mapM (fun pe ->
                typecheck_pexpr tagDefs env (BTy_loaded oTy) pe
              ) pes
          | (Carray, _, _) ->
              E.fail loc (MismatchExpected "Carray" bTy "array")
          | (Civmax, BTy_object OTy_integer, [pe]) ->
              ret_ctor Civmax <$> typecheck_pexpr tagDefs env (BTy_ctype) pe
          | (Civmax, _, _) ->
              E.fail loc (Mismatch "Civmax" bTy (BTy_object OTy_integer))
          | (Civmin, BTy_object OTy_integer, [pe]) ->
              ret_ctor Civmin <$> typecheck_pexpr tagDefs env (BTy_ctype) pe
          | (Civmin, _, _) ->
              E.fail loc (Mismatch "Civmin" bTy (BTy_object OTy_integer))
          | (Civsizeof, BTy_object OTy_integer, [pe]) ->
              ret_ctor Civsizeof <$> typecheck_pexpr tagDefs env (BTy_ctype) pe
          | (Civsizeof, _, _) ->
              E.fail loc (Mismatch "Civsizeof" bTy (BTy_object OTy_integer))
          | (Civalignof, BTy_object OTy_integer, [pe]) ->
              ret_ctor Civalignof <$> typecheck_pexpr tagDefs env (BTy_ctype) pe
          | (Civalignof, _, _) ->
              E.fail loc (Mismatch "Civalignof" bTy (BTy_object OTy_integer))
          | (CivCOMPL, BTy_object OTy_integer, [pe1; pe2]) ->
              typecheck_pexpr tagDefs env BTy_ctype                pe1 >>= fun pe1' ->
              typecheck_pexpr tagDefs env (BTy_object OTy_integer) pe2 >>= fun pe2' ->
              E.return (PEctor CivCOMPL [pe1'; pe2'])
          | (CivCOMPL, _, _) ->
              E.fail loc (Mismatch "CivCOMPL" bTy (BTy_object OTy_integer))
          | (CivAND, BTy_object OTy_integer, [pe1; pe2; pe3]) ->
              typecheck_pexpr tagDefs env BTy_ctype                pe1 >>= fun pe1' ->
              typecheck_pexpr tagDefs env (BTy_object OTy_integer) pe2 >>= fun pe2' ->
              typecheck_pexpr tagDefs env (BTy_object OTy_integer) pe3 >>= fun pe3' ->
              E.return (PEctor CivAND [pe1'; pe2'; pe3'])
          | (CivAND, _, _) ->
              E.fail loc (Mismatch "CivAND" bTy (BTy_object OTy_integer))
          | (CivOR, BTy_object OTy_integer, [pe1; pe2; pe3]) ->
              typecheck_pexpr tagDefs env BTy_ctype                pe1 >>= fun pe1' ->
              typecheck_pexpr tagDefs env (BTy_object OTy_integer) pe2 >>= fun pe2' ->
              typecheck_pexpr tagDefs env (BTy_object OTy_integer) pe3 >>= fun pe3' ->
              E.return (PEctor CivOR [pe1'; pe2'; pe3'])
          | (CivOR, _, _) ->
              E.fail loc (Mismatch "CivOR" bTy (BTy_object OTy_integer))
          | (CivXOR, BTy_object OTy_integer, [pe1; pe2; pe3]) ->
              typecheck_pexpr tagDefs env BTy_ctype                pe1 >>= fun pe1' ->
              typecheck_pexpr tagDefs env (BTy_object OTy_integer) pe2 >>= fun pe2' ->
              typecheck_pexpr tagDefs env (BTy_object OTy_integer) pe3 >>= fun pe3' ->
              E.return (PEctor CivXOR [pe1'; pe2'; pe3'])
          | (CivXOR, _, _) ->
              E.fail loc (Mismatch "CivXOR" bTy (BTy_object OTy_integer))
          | (Cspecified, BTy_loaded oTy, [pe]) ->
              ret_ctor Cspecified <$> typecheck_pexpr tagDefs env (BTy_object oTy) pe
          | (Cspecified, _, _) ->
              E.fail loc (MismatchExpected "Cspecified" bTy "loaded object")
          | (Cunspecified, BTy_loaded _, [pe]) ->
              ret_ctor Cunspecified <$> typecheck_pexpr tagDefs env BTy_ctype pe
          | (Cunspecified, _, _) ->
              E.fail loc (MismatchExpected "Cunspecified" bTy "loaded object")
          | (Cfvfromint, BTy_object OTy_floating, [pe]) ->
              ret_ctor Cfvfromint <$> typecheck_pexpr tagDefs env (BTy_object OTy_integer) pe
          | (Cfvfromint, _, _) ->
              E.fail loc (Mismatch "Cfvfromint" bTy (BTy_object OTy_floating))
          | (Civfromfloat, BTy_object OTy_integer, [pe_ty; pe_fval]) ->
              typecheck_pexpr tagDefs env BTy_ctype                 pe_ty   >>= fun pe_ty'   ->
              typecheck_pexpr tagDefs env (BTy_object OTy_floating) pe_fval >>= fun pe_fval' ->
              E.return (PEctor Civfromfloat [pe_ty'; pe_fval'])
          | (Civfromfloat, _, _) ->
              E.fail loc (Mismatch "Civfromfloat" bTy (BTy_object OTy_integer))
        end
    | PEcase pe cases ->
        infer_pexpr tagDefs env pe >>= fun (Pexpr _ infer _ as pe') ->
        match toCoreBaseType infer with
          | Nothing ->
              E.fail loc TooGeneral
          | Just case_bTy ->
              E.mapM (fun (pat, pe) ->
                typecheck_pattern case_bTy pat                      >>= fun (env', pat') ->
                typecheck_pexpr tagDefs (env_union env env') bTy pe >>= fun pe'          ->
                E.return (pat', pe')
              ) cases >>= fun cases' ->
              E.return (PEcase pe' cases')
        end
    | PEarray_shift pe1 cTy pe2 ->
        guard_match loc "array_shift()" bTy (BTy_object OTy_pointer) >>
        (PEarray_shift <$> typecheck_pexpr tagDefs env (BTy_object OTy_pointer) pe1
                       <*> E.return cTy
                       <*> typecheck_pexpr tagDefs env (BTy_object OTy_integer) pe2)
    | PEmember_shift pe tag_sym memb_ident ->
          let xs = match fromJust "Core_typing.typecheck_pexpr, PEmember_shift 1" (Map.lookup tag_sym tagDefs) with
            | Core_ctype.StructDef z -> z
            | Core_ctype.UnionDef  z -> z
          end in
          match List.lookup memb_ident xs with
            | Nothing ->
                E.fail loc (CoreTyping_TODO ("PEmember_shift, no member '" ^ show memb_ident ^ "' defined for the tag '" ^ show tag_sym ^ "'"))
            | _ ->
                guard_match loc "member_shift()" bTy (BTy_object OTy_pointer) >>
                (PEmember_shift <$> typecheck_pexpr tagDefs env (BTy_object OTy_pointer) pe
                                <*> E.return tag_sym
                                <*> E.return memb_ident)
          end
    | PEnot pe ->
        guard_match loc "not()" bTy BTy_boolean >>
        (PEnot <$> typecheck_pexpr tagDefs env BTy_boolean pe)
    | PEop bop pe1 pe2 ->
        E.trysM_ (with_regions_and_cursor [locOf pe1; locOf pe2] (Just loc)) (MismatchBinaryOperator bop)
        (fun (bTy', bTy1, bTy2) ->
          (PEop bop <$> typecheck_pexpr tagDefs env bTy1 pe1
                    <*> typecheck_pexpr tagDefs env bTy2 pe2)
        ) match bop with
          | OpAdd ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpSub ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpMul ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpDiv ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpRem_t ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer) ]
          | OpRem_f ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer) ]
          | OpExp ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer) ]
          | OpEq ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating)
              ; (BTy_boolean, BTy_ctype, BTy_ctype) ]
          | OpGt ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpLt ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpGe ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpLe ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpAnd ->
              [ (BTy_boolean, BTy_boolean, BTy_boolean) ]
          | OpOr ->
              [ (BTy_boolean, BTy_boolean, BTy_boolean) ]
        end
    | PEstruct tag_sym fields ->
        guard_match loc "struct()" bTy (BTy_object (OTy_struct tag_sym)) >>
        match fromJust "Core_typing.typecheck_pexpr, PEstruct" (Map.lookup tag_sym tagDefs) with
          | Core_ctype.UnionDef _ ->
              E.fail loc (InvalidTag tag_sym)
          | Core_ctype.StructDef xs ->
              E.mapM (fun (ident, pe) ->
                match List.lookup ident xs with
                  | Nothing ->
                      E.fail loc (InvalidMember tag_sym ident)
                  | Just ty ->
                      match core_object_type_of_ctype ty with
                        | Nothing ->
                            E.fail loc (CoreTyping_TODO ("in PEstruct, failed to convert '" ^
                                        Pp.stringFromCore_ctype ty ^ "' to a Core object type"))
                        | Just oTy ->
                            typecheck_pexpr tagDefs env (BTy_loaded oTy) pe >>= fun pe' ->
                            E.return (ident, pe')
                      end
                end
              ) fields
        end >>= fun fields' ->
        E.return (PEstruct tag_sym fields')
    | PEunion tag_sym ident pe ->
        guard_match loc "union()" bTy (BTy_object (OTy_union tag_sym)) >>
        match fromJust "Core_typing.typecheck_pexpr, PEunion" (Map.lookup tag_sym tagDefs) with
          | Core_ctype.StructDef _ ->
              E.fail loc (InvalidTag tag_sym)
          | Core_ctype.UnionDef xs ->
              match List.lookup ident xs with
                | Nothing ->
                    E.fail loc (InvalidMember tag_sym ident)
                | Just ty ->
                    match core_object_type_of_ctype ty with
                      | Nothing ->
                          E.fail loc (CoreTyping_TODO ("in PEunion, failed to convert '" ^
                                                       Pp.stringFromCore_ctype ty ^ "' to a Core object type"))
                      | Just oTy ->
                          typecheck_pexpr tagDefs env (BTy_loaded oTy) pe >>= fun pe' ->
                          E.return (PEunion tag_sym ident pe')
                    end
              end
        end
    | PEcfunction pe ->
        guard_match loc "cfunction()" bTy (BTy_tuple [BTy_ctype; BTy_list BTy_ctype; BTy_boolean; BTy_boolean]) >>
        (PEcfunction <$> typecheck_pexpr tagDefs env (BTy_loaded OTy_pointer) pe)
    | PEmemberof tag_sym memb_ident pe ->
        let xs = match fromJust "Core_typing.typecheck_pexpr, PEmemberof" (Map.lookup tag_sym tagDefs) with
          | Core_ctype.StructDef xs ->
              xs
          | Core_ctype.UnionDef xs ->
              xs
        end in
        match List.lookup memb_ident xs with
          | Nothing ->
              E.fail loc (InvalidMember tag_sym memb_ident)
          | Just ty ->
              match core_object_type_of_ctype ty with
                | Nothing ->
                    E.fail loc (CoreTyping_TODO ("in PEmemberof, failed to convert '" ^
                                                 Pp.stringFromCore_ctype ty ^ "' to a Core object type"))
                | Just oTy ->
                    guard_match loc "memberof()" bTy (BTy_loaded oTy) >>= fun () ->
                    PEmemberof tag_sym memb_ident <$>
                      typecheck_pexpr tagDefs env (BTy_object (OTy_struct tag_sym)) pe
              end
        end
    | PEcall nm pes ->
        match Map.lookup nm env.decls with
          | Just (TDfun ret_bTy bTys) ->
            guard_match loc "function call" bTy ret_bTy >>
            (PEcall nm <$> E.mapM (fun (bTy, pe) ->
              typecheck_pexpr tagDefs env bTy pe) (List.zip bTys pes))
          | Just _ ->
              E.fail loc (CoreTyping_TODO ("illtyped a fun/proc symbolic ==> " ^ Pp.stringFromCore_pexpr (Pexpr [] () (PEcall nm pes))))
          | Nothing ->
              E.fail loc (CoreTyping_TODO ("unresolved PEcall ==> " ^ Pp.stringFromCore_pexpr (Pexpr [] () pexpr_)))
        end
    | PElet pat pe1 pe2 ->
        infer_pattern pat >>= fun (pat_env, pat_infer, pat') ->
        match toCoreBaseType pat_infer with
          | Just pat_bTy ->
              typecheck_pexpr tagDefs env pat_bTy pe1                 >>= fun pe1' ->
              typecheck_pexpr tagDefs (env_union env pat_env) bTy pe2 >>= fun pe2' ->
              E.return (PElet pat' pe1' pe2')
          | Nothing ->
              infer_pexpr tagDefs env pe1 >>= fun (Pexpr _ pe1_infer _ as pe1') ->
              match toCoreBaseType pe1_infer with
                | Just pe1_bTy ->
                    typecheck_pattern pe1_bTy pat                           >>= fun (pat_env, pat') ->
                    typecheck_pexpr tagDefs (env_union env pat_env) bTy pe2 >>= fun pe2'            ->
                    E.return (PElet pat' pe1' pe2')
                | Nothing ->
                    E.fail (locOf pat) TooGeneral
              end
        end
    | PEif pe1 pe2 pe3 ->
        PEif <$> typecheck_pexpr tagDefs env BTy_boolean pe1
             <*> typecheck_pexpr tagDefs env bTy pe2
             <*> typecheck_pexpr tagDefs env bTy pe3
    | PEis_scalar pe ->
        guard_match loc "is_scalar()" bTy BTy_boolean >>
        (PEis_scalar <$> typecheck_pexpr tagDefs env BTy_ctype pe)
    | PEis_integer pe ->
        guard_match loc "is_integer()" bTy BTy_boolean >>
        (PEis_integer <$> typecheck_pexpr tagDefs env BTy_ctype pe)
    | PEis_signed pe ->
        guard_match loc "is_signed()" bTy BTy_boolean >>
        (PEis_signed <$> typecheck_pexpr tagDefs env BTy_ctype pe)
    | PEis_unsigned pe ->
        guard_match loc "is_unsigned()" bTy BTy_boolean >>
        (PEis_unsigned <$> typecheck_pexpr tagDefs env BTy_ctype pe)
    | PEare_compatible pe1 pe2 ->
        guard_match loc "are_compatible()" bTy BTy_boolean >>
        (PEare_compatible <$> typecheck_pexpr tagDefs env BTy_ctype pe1 <*> typecheck_pexpr tagDefs env BTy_ctype pe2)
  end


val typecheck_export_pexpr: core_tag_definitions -> typing_env -> core_base_type -> Core.pexpr -> E.eff typed_pexpr
let typecheck_export_pexpr tagDefs env bTy pe =
  typecheck_pexpr tagDefs env bTy pe >>= export_pexpr


val infer_action: core_tag_definitions -> typing_env -> action unit -> E.eff (core_base_type * typed_action unit)
let rec infer_action tagDefs env (Action loc annot act_) =
  match act_ with
    | Create pe1 pe2 pref ->
        typecheck_export_pexpr tagDefs env (BTy_object OTy_integer) pe1 >>= fun tpe1 ->
        typecheck_export_pexpr tagDefs env BTy_ctype                pe2 >>= fun tpe2 ->
        E.return (BTy_object OTy_pointer, Create tpe1 tpe2 pref)
    | CreateReadOnly pe1 pe2 pe3 pref ->
        typecheck_export_pexpr tagDefs env (BTy_object OTy_integer) pe1 >>= fun tpe1 ->
        match pe2 with
          | Pexpr _ () (PEval (Vctype ty)) ->
              let tpe2 = Pexpr [] BTy_ctype (PEval (Vctype ty)) in
              match core_object_type_of_ctype ty with
                | Just lvalue_oTy ->
                    typecheck_export_pexpr tagDefs env (BTy_loaded lvalue_oTy)  pe3 >>= fun tpe3 ->
                    E.return (BTy_object OTy_pointer, CreateReadOnly tpe1 tpe2 tpe3 pref)
                | Nothing ->
                    E.fail loc (CoreTyping_TODO "CreateReadOnly, not oTy")
              end
          | _ ->
              E.fail loc (CoreTyping_TODO "CreateReadOnly, non-trivial ctype")
        end
    | Alloc pe1 pe2 pref ->
        typecheck_export_pexpr tagDefs env (BTy_object OTy_integer) pe1 >>= fun tpe1 ->
        typecheck_export_pexpr tagDefs env (BTy_object OTy_integer) pe2 >>= fun tpe2 ->
        E.return (BTy_object OTy_pointer, Alloc tpe1 tpe2 pref)
    | Kill b pe ->
        typecheck_export_pexpr tagDefs env (BTy_object OTy_pointer) pe >>= fun tpe ->
        E.return (BTy_unit, Kill b tpe)
    | Store b pe1 pe2 pe3 mo ->
        match pe1 with
          | Pexpr _ () (PEval (Vctype ty)) ->
              let tpe1 = Pexpr [] BTy_ctype (PEval (Vctype ty)) in
              match core_object_type_of_ctype ty with
                | Just lvalue_oTy ->
                    typecheck_export_pexpr tagDefs env (BTy_object OTy_pointer) pe2 >>= fun tpe2 ->
                    typecheck_export_pexpr tagDefs env (BTy_loaded lvalue_oTy)  pe3 >>= fun tpe3 ->
                    E.return (BTy_unit, Store b tpe1 tpe2 tpe3 mo)
                | Nothing ->
                    E.fail loc (CoreTyping_TODO "Store, not oTy")
              end
          | _ ->
              typecheck_export_pexpr tagDefs env BTy_ctype pe1 >>= fun tpe1 ->
              typecheck_export_pexpr tagDefs env (BTy_object OTy_pointer) pe2 >>= fun tpe2 ->
              infer_pexpr tagDefs env pe3 >>= fun (Pexpr _ pe3_infer _ as pe3') ->
              if is_inferred_storable pe3_infer then
                export_pexpr pe3' >>= fun tpe3 ->
                E.return (BTy_unit, Store b tpe1 tpe2 tpe3 mo)
              else
                E.fail loc (CoreTyping_TODO "Store, not storable")
        end
    | Load pe1 pe2 mo ->
        match pe1 with
          | Pexpr _ () (PEval (Vctype ty)) ->
              let tpe1 = Pexpr [] BTy_ctype (PEval (Vctype ty)) in
              match core_object_type_of_ctype ty with
                | Just lvalue_oTy ->
                    typecheck_export_pexpr tagDefs env (BTy_object OTy_pointer) pe2 >>= fun tpe2 ->
                    E.return (BTy_loaded lvalue_oTy, Load tpe1 tpe2 mo)
                | Nothing ->
                    E.fail loc (CoreTyping_TODO "Load, not oTy")
              end
          | _ ->
              E.fail loc (CoreTyping_TODO "Load, non-trivial ctype")
        end
    | RMW pe1 pe2 pe3 pe4 mo1 mo2 ->
        error "WIP infer_paction: RMW"
    | Fence mo ->
        E.return (BTy_unit, Fence mo)
  end >>= fun (bTy, act_') ->
  E.return (bTy, Action loc annot act_')


val typecheck_action: core_tag_definitions -> typing_env -> core_base_type -> action unit -> E.eff (typed_action unit)
let typecheck_action tagDefs env bTy (Action loc annot act_) =
  Action loc annot <$> match act_ with
  | Create pe1 pe2 pref ->
      guard_match loc "create()" bTy (BTy_object OTy_pointer) >>
      typecheck_export_pexpr tagDefs env (BTy_object OTy_integer) pe1 >>= fun tpe1 ->
      typecheck_export_pexpr tagDefs env BTy_ctype                pe2 >>= fun tpe2 ->
      E.return (Create tpe1 tpe2 pref)
  | CreateReadOnly pe1 pe2 pe3 pref ->
      guard_match loc "create_readonly()" bTy (BTy_object OTy_pointer) >>
      typecheck_export_pexpr tagDefs env (BTy_object OTy_integer) pe1 >>= fun tpe1 ->
      match pe2 with
        | Pexpr _ () (PEval (Vctype ty)) ->
            let tpe2 = Pexpr [] BTy_ctype (PEval (Vctype ty)) in
            match core_object_type_of_ctype ty with
              | Just lvalue_oTy ->
                  typecheck_export_pexpr tagDefs env (BTy_loaded lvalue_oTy)  pe3 >>= fun tpe3 ->
                  E.return (CreateReadOnly tpe1 tpe2 tpe3 pref)
              | Nothing ->
                  E.fail loc (CoreTyping_TODO "CreateReadOnly, not oTy")
            end
        | _ ->
            E.fail loc (CoreTyping_TODO "CreateReadOnly, non-trivial ctype")
      end
  | Alloc pe1 pe2 pref ->
      guard_match loc "alloc()" bTy (BTy_object OTy_pointer) >>
      typecheck_export_pexpr tagDefs env (BTy_object OTy_integer) pe1 >>= fun tpe1 ->
      typecheck_export_pexpr tagDefs env (BTy_object OTy_integer) pe2 >>= fun tpe2 ->
      E.return (Alloc tpe1 tpe2 pref)
  | Kill b pe ->
      guard_match loc "kill()" bTy BTy_unit >>
      typecheck_export_pexpr tagDefs env (BTy_object OTy_pointer) pe >>= fun tpe ->
      E.return (Kill b tpe)
  | Store b pe1 pe2 pe3 mo ->
      guard_match loc "store()" bTy BTy_unit >>
      match pe1 with
        | Pexpr _ () (PEval (Vctype ty)) ->
            let tpe1 = Pexpr [] BTy_ctype (PEval (Vctype ty)) in
            match core_object_type_of_ctype ty with
              | Just lvalue_oTy ->
                  typecheck_export_pexpr tagDefs env (BTy_object OTy_pointer) pe2 >>= fun tpe2 ->
                  typecheck_export_pexpr tagDefs env (BTy_loaded lvalue_oTy)  pe3 >>= fun tpe3 ->
                  E.return (Store b tpe1 tpe2 tpe3 mo)
              | Nothing ->
                  E.fail loc (CoreTyping_TODO "Store, not oTy")
            end
        | _ ->
            typecheck_export_pexpr tagDefs env BTy_ctype pe1 >>= fun tpe1 ->
            typecheck_export_pexpr tagDefs env (BTy_object OTy_pointer) pe2 >>= fun tpe2 ->
            infer_pexpr tagDefs env pe3 >>= fun (Pexpr _ pe3_infer _ as pe3') ->
            if is_inferred_storable pe3_infer then
              export_pexpr pe3' >>= fun tpe3 ->
              E.return (Store b tpe1 tpe2 tpe3 mo)
            else
              E.fail loc (CoreTyping_TODO "Store, not storable")
      end
  | Load pe1 pe2 mo ->
      match pe1 with
        | Pexpr _ () (PEval (Vctype ty)) ->
            let tpe1 = Pexpr [] BTy_ctype (PEval (Vctype ty)) in
            match core_object_type_of_ctype ty with
              | Just lvalue_oTy ->
                  typecheck_export_pexpr tagDefs env (BTy_object OTy_pointer) pe2 >>= fun tpe2 ->
                  guard_match loc "load()" bTy (BTy_loaded lvalue_oTy) >>
                  E.return (Load tpe1 tpe2 mo)
              | Nothing ->
                  E.fail loc (CoreTyping_TODO "Load, not oTy")
            end
        | _ ->
            E.fail loc (CoreTyping_TODO "Load, non-trivial ctype")
      end
  | RMW pe1 pe2 pe3 pe4 mo1 mo2 ->
      error "WIP: RMW"
  | Fence mo ->
      guard_match loc "fence()" bTy BTy_unit >>
      E.return (Fence mo)
  end



val memop_signature: Mem_common.memop -> core_base_type * list core_base_type
let memop_signature = function
  | Mem_common.PtrEq ->
      (BTy_boolean, [BTy_object OTy_pointer; BTy_object OTy_pointer])
  | Mem_common.PtrNe ->
      (BTy_boolean, [BTy_object OTy_pointer; BTy_object OTy_pointer])
  | Mem_common.PtrLt ->
      (BTy_boolean, [BTy_object OTy_pointer; BTy_object OTy_pointer])
  | Mem_common.PtrGt ->
      (BTy_boolean, [BTy_object OTy_pointer; BTy_object OTy_pointer])
  | Mem_common.PtrLe ->
      (BTy_boolean, [BTy_object OTy_pointer; BTy_object OTy_pointer])
  | Mem_common.PtrGe ->
      (BTy_boolean, [BTy_object OTy_pointer; BTy_object OTy_pointer])
  | Mem_common.Ptrdiff ->
      (BTy_object OTy_integer, [BTy_ctype; BTy_object OTy_pointer; BTy_object OTy_pointer])
  | Mem_common.IntFromPtr ->
      (BTy_object OTy_integer, [BTy_ctype; BTy_ctype; BTy_object OTy_pointer])
  | Mem_common.PtrFromInt ->
      (BTy_object OTy_pointer, [BTy_ctype; BTy_ctype; BTy_object OTy_integer])
  | Mem_common.PtrValidForDeref ->
      (BTy_boolean, [BTy_ctype; BTy_object OTy_pointer])
  | Mem_common.PtrWellAligned ->
      (BTy_boolean, [BTy_ctype; BTy_object OTy_pointer])
  | Mem_common.Memcpy ->
      (BTy_object OTy_pointer, [BTy_object OTy_pointer; BTy_object OTy_pointer; BTy_object OTy_integer])
  | Mem_common.Memcmp ->
      (BTy_object OTy_integer, [BTy_object OTy_pointer; BTy_object OTy_pointer; BTy_object OTy_integer])
  | Mem_common.Realloc ->
      (BTy_object OTy_pointer, [BTy_object OTy_integer; BTy_object OTy_pointer; BTy_object OTy_integer])
  | Mem_common.PtrArrayShift ->
      (BTy_object OTy_pointer, [BTy_object OTy_pointer; BTy_ctype; BTy_object OTy_integer])
end


val     collect_labels: typing_env -> expr unit -> E.eff typing_env
let rec collect_labels env (Expr _ expr_) =
  match expr_ with
    | Epure _ ->
        E.return env
    | Ememop _ _ ->
        E.return env
    | Eaction _ ->
        E.return env
    | Ecase _ pat_es ->
        E.foldlM (fun env' (_, e) ->
          collect_labels env' e
        ) env pat_es
    | Elet _ _ e ->
        collect_labels env e
    | Eif _ e1 e2 ->
        collect_labels env  e1 >>= fun env' ->
        collect_labels env' e2
    | Eskip ->
        E.return env
    | Eccall _ _ _ _ ->
        E.return env
    | Eproc _ _ _ ->
        E.return env
    | Eunseq es ->
        E.foldlM (fun env' e ->
          collect_labels env' e
        ) env es
    | Ewseq _ e1 e2 ->
        collect_labels env  e1 >>= fun env' ->
        collect_labels env' e2
    | Esseq _ e1 e2 ->
        collect_labels env  e1 >>= fun env' ->
        collect_labels env' e2
    | Easeq _ _ _ ->
        E.return env
    | Eindet _ e ->
        collect_labels env e
    | Ebound _ e ->
        collect_labels env e
    | End es ->
        E.foldlM (fun env' e ->
          collect_labels env' e
        ) env es
    | Esave (sym, bTy) sym_bTy_pes e ->
        collect_labels <| env with labs= Map.insert sym (bTy, List.map (fun (_, (z, _)) -> z) sym_bTy_pes) env.labs |> e
    | Erun _ _ _ ->
        E.return env
    | Epar es ->
        E.foldlM (fun env' e ->
          collect_labels env' e
        ) env es
    | Ewait _ ->
        E.return env
  end


(* val     typecheck_expr: Loc.t -> typing_env -> core_base_type -> Core.expr unit -> E.eff (typed_expr unit) *)
and typecheck_expr tagDefs (env: typing_env) expected_bTy (Expr annot expr_) =
  let loc = Annot.get_loc_ annot in
  Expr annot <$> match expr_ with
    | Epure pe ->
        Epure <$> typecheck_export_pexpr tagDefs env expected_bTy pe
    | Ememop memop pes ->
        let (ret_bTy, bTys) = memop_signature memop in
        E.mapM (fun (bTy, pe) ->
          typecheck_export_pexpr tagDefs env bTy pe
        ) (List.zip bTys pes) >>= fun pes' ->
        guard_match loc "memop()" expected_bTy ret_bTy >>
        E.return (Ememop memop pes')
    | (Eaction (Paction p act)) ->
        (Eaction -| Paction p)
          <$> typecheck_action tagDefs env expected_bTy act
    | Ecase pe cases ->
        infer_pexpr tagDefs env pe >>= fun (Pexpr _ infer _ as pe') ->
        match toCoreBaseType infer with
          | Nothing ->
              E.fail (locOf pe) TooGeneral
          | Just case_bTy ->
              export_pexpr pe' >>= fun pe' ->
              E.mapM (fun (pat, e) ->
                typecheck_pattern case_bTy pat                             >>= fun (env', pat') ->
                export_pattern loc pat'                                    >>= fun pat'         ->
                typecheck_expr tagDefs (env_union env env') expected_bTy e >>= fun e'           ->
                E.return (pat', e')
              ) cases >>= fun cases' ->
              E.return (Ecase pe' cases')
        end
    | Elet pat pe1 e2 ->
        infer_pattern pat >>= fun (pat_env, pat_infer, _pat') ->
        match toCoreBaseType pat_infer with
          | Nothing ->
              E.fail (locOf pat) TooGeneral
          | Just pat_bTy ->
              typecheck_pexpr tagDefs env pat_bTy pe1 >>= export_pexpr       >>= fun pe1' ->
              export_pattern loc _pat'                                       >>= fun pat' ->
              typecheck_expr tagDefs (env_union env pat_env) expected_bTy e2 >>= fun e2'  ->
              E.return (Elet pat' pe1' e2')
        end
    | Eif pe1 e2 e3 ->
        Eif <$> typecheck_export_pexpr tagDefs env BTy_boolean pe1
            <*> typecheck_expr tagDefs env expected_bTy e2
            <*> typecheck_expr tagDefs env expected_bTy e3
    | Eskip ->
        E.guard (expected_bTy = BTy_unit) loc (Mismatch "skip" expected_bTy BTy_unit) >>
        E.return Eskip
    | Eccall () pe_ty pe pes ->
        infer_pexpr tagDefs env pe_ty >>= export_pexpr >>= fun pe_ty' ->
        infer_pexpr tagDefs env pe    >>= export_pexpr >>= fun (Pexpr _ bTy _ as pe') ->
        match (pe_ty, bTy) with
          | (Pexpr _ _ (PEval (Vctype (Cty.Pointer _ (Cty.Function (qs, ty) nparams isVariadic))))
            , BTy_loaded OTy_pointer) ->
              begin
                if isVariadic then
                  match List.dest_init pes with
                    | Nothing ->
                        E.fail loc (CoreTyping_TODO "ccall to a variadic C procedure must at least have a list of pointers as last argument")
                    | Just (first_pes, last_pe) ->
                        E.mapM (fun pe ->
                          typecheck_export_pexpr tagDefs env (BTy_object OTy_pointer) pe
                        ) first_pes >>= fun first_pes' ->
                        typecheck_export_pexpr tagDefs env
                          (BTy_list (BTy_tuple [BTy_ctype; BTy_object OTy_pointer])) last_pe >>= fun last_pe' ->
                        E.return (first_pes' ++ [last_pe'])
                  end
                else
                  E.mapM (fun pe ->
                    typecheck_export_pexpr tagDefs env (BTy_object OTy_pointer) pe
                  ) pes
              end >>= fun pes' ->
              let ret_oTy_opt = Core_aux.core_object_type_of_ctype ty in
              guard_match loc "ccall" expected_bTy (maybe BTy_unit BTy_loaded ret_oTy_opt) >>
              E.return (Eccall () pe_ty' pe' pes')
          | (_, _) ->
              E.fail loc (CoreTyping_TODO "the first operand of ccall() should have a C function type")
        end
    | Eproc () nm pes ->
        match Map.lookup nm env.decls with
          | Just (TDproc ret_bTy bTys) ->
              E.mapM (fun (bTy, pe) ->
                typecheck_export_pexpr tagDefs env bTy pe
              ) (List.zip bTys pes) >>= fun pes' ->
              guard_match loc "proc" expected_bTy ret_bTy >>
              E.return (Eproc () nm pes')
          | Just _ ->
          (* TODO: clean *)
              E.fail loc (CoreTyping_TODO ("in Eproc(), found a def in a cfunction value: " (*^
                                           Pp.stringFromCore_value (Vobject (OVcfunction nm))*)))
          | Nothing ->
              E.fail loc (CoreTyping_TODO ("in Eproc(), unresolved sym in cfunction value: " (*^
                                           Pp.stringFromCore_value (Vobject (OVcfunction nm))*)))
        end
    | Eunseq []  ->
        E.fail loc (CoreTyping_TODO "UNSEQ must have at least two arguments (seen 0)")
    | Eunseq [e] ->
        E.fail loc (CoreTyping_TODO "UNSEQ must have at least two arguments (seen 1)")
    | Eunseq es ->
        (* TODO: forbid jumps, par(), ... *)
        match expected_bTy with
          | BTy_tuple bTys ->
              Eunseq <$> E.mapM (fun (bTy, e) -> typecheck_expr tagDefs env bTy e)
                          (List.zip bTys es)
          | _ -> E.fail loc (CoreTyping_TODO "UNSEQ illtyped")
        end
    | Ewseq pat e1 e2 ->
        infer_pattern pat >>= fun (env', infer, _pat') ->
        match toCoreBaseType infer with
          | Nothing ->
              E.fail loc TooGeneral
          | Just pat_bTy ->
              Ewseq <$> export_pattern loc _pat'
                    <*> typecheck_expr tagDefs env pat_bTy e1
                    <*> typecheck_expr tagDefs (env_union env env') expected_bTy e2
        end
    | Esseq pat e1 e2 ->
        infer_pattern pat >>= fun (env', infer, _pat') ->
        match toCoreBaseType infer with
          | Nothing ->
              E.fail loc TooGeneral
          | Just pat_bTy ->
              Esseq <$> export_pattern loc _pat'
                    <*> typecheck_expr tagDefs env pat_bTy e1
                    <*> typecheck_expr tagDefs (env_union env env') expected_bTy e2
        end
    | Easeq (sym, sym_bTy) act1 (Paction p act2) ->
        guard_match loc "atomic seq" expected_bTy sym_bTy >>
        let env' = insert_tdecl (Sym sym) (TDsym sym_bTy) env in
        typecheck_action tagDefs env  sym_bTy act1                   >>= fun act1' ->
        typecheck_action tagDefs env' BTy_unit (*expected_bTy*) act2 >>= fun act2' ->
        E.return (Easeq (sym, sym_bTy) act1' (Paction p act2'))
    | Eindet n e ->
        (* TODO *)
        Eindet n <$> typecheck_expr tagDefs env expected_bTy e
    | Ebound n e ->
        (* TODO *)
        Ebound n <$> typecheck_expr tagDefs env expected_bTy e
    | End es ->
        if List.length es < 2 then
          E.fail loc (CoreTyping_TODO "nd() should have at least 2 operand")
        else
          E.mapM (typecheck_expr tagDefs env expected_bTy) es >>= fun es' ->
          E.return (End es')
    | Esave sym_bTy sym_bTy_pes e ->
        (* TODO: check *)
        E.mapM (fun (sym, (bTy, pe)) ->
          typecheck_pexpr tagDefs env bTy pe
            >>= export_pexpr >>= fun pe' ->
           E.return (sym, (bTy, pe'))
        ) sym_bTy_pes >>= fun sym_bTy_pes' ->
        let env' = <| decls= Map.fromList (List.map (fun (sym, (bTy, _)) -> (Sym sym, TDsym bTy)) sym_bTy_pes'); labs= Map.empty |> in
        Esave sym_bTy sym_bTy_pes' <$> typecheck_expr tagDefs (env_union env env') expected_bTy e
    | Erun () sym pes ->
        match Map.lookup sym env.labs with
          | Just (bTy, bTys) ->
(*            guard_match loc "run" expected_bTy bTy >> *) (* TODO check *)
              begin
                Erun () sym <$> E.mapM (fun (bTy, pe) ->
                  typecheck_pexpr tagDefs env bTy pe
                    >>= export_pexpr >>= fun pe' ->
                  E.return pe'
                ) (List.zip bTys pes)
              end
          | Nothing ->
              E.fail loc (CoreTyping_TODO "Erun, undeclared label")
        end
    | Epar es ->
        if List.length es < 2 then
          E.fail loc (CoreTyping_TODO "Epar must have at least 2 operands")
        else match expected_bTy with
          | BTy_tuple bTys ->
              Epar <$> E.mapM (uncurry $ typecheck_expr tagDefs env) (List.zip bTys es)
          | _ ->
              E.fail loc (CoreTyping_TODO "Epar has as tuple type")
        end
    | Ewait id ->
        error "typecheck_expr, Ewait"
  end


(* TODO: add a check for the existence of main *)
val typecheck_program: Core.file unit -> Exception.exceptM (Core.typed_file unit) Errors.error
let typecheck_program file =
  let aux =
    (* The startup function/procedure must be defined *)
    match file.main with
      | Just sym ->
          E.guard (Map.member sym file.funs)
            Loc.unknown (UndefinedStartup sym)
      | Nothing ->
          E.return ()
    end >>
    
    (* Register the functions/procedures from the stdlib and the impl constants *)
    let env = Map_extra.fold (fun sym decl acc ->
      match decl with
        | Fun bTy sym_bTys _ ->
            insert_tdecl (Sym sym) (TDfun bTy (List.map snd sym_bTys)) acc
        | ProcDecl _ bTy bTys ->
            insert_tdecl (Sym sym) (TDproc bTy bTys) acc
        | Proc _ bTy sym_bTys _ ->
            insert_tdecl (Sym sym) (TDproc bTy (List.map snd sym_bTys)) acc
      end) file.stdlib $
    Map_extra.fold (fun iCst decl acc ->
      match decl with
        | Def bTy _ ->
            insert_tdecl (Impl iCst) (TDsym bTy) acc
        | IFun bTy sym_bTys _ ->
            insert_tdecl (Impl iCst) (TDfun bTy (List.map snd sym_bTys)) acc
        | BuiltinDecl _ bTy bTys ->
            insert_tdecl (Impl iCst) (TDproc bTy bTys) acc
      end) file.impl
    (* TODO: do this is a principled way *)
      (insert_tdecl (Impl (I.StdFunction "signal")) (TDproc (BTy_loaded OTy_pointer)
        [ BTy_object OTy_integer; BTy_object OTy_pointer ])
      (insert_tdecl (Impl (I.StdFunction "exit")) (TDproc BTy_unit [ BTy_loaded OTy_integer ])
      (insert_tdecl (Impl (I.StdFunction "_Exit")) (TDproc BTy_unit [ BTy_loaded OTy_integer ])
      (insert_tdecl (Impl (I.StdFunction "snprintf")) (TDproc (BTy_loaded OTy_integer)
        [ BTy_object OTy_pointer
        ; BTy_object OTy_integer
        ; BTy_list (BTy_object OTy_integer)
        ; BTy_list (BTy_tuple [BTy_ctype; BTy_object OTy_pointer]) ])
      (insert_tdecl (Impl (I.StdFunction "sprintf")) (TDproc (BTy_loaded OTy_integer)
        [ BTy_object OTy_pointer
        ; BTy_list (BTy_object OTy_integer)
        ; BTy_list (BTy_tuple [BTy_ctype; BTy_object OTy_pointer]) ])
      (insert_tdecl (Impl (I.StdFunction "printf")) (TDproc (BTy_loaded OTy_integer)
        [ BTy_list (BTy_object OTy_integer)
        ; BTy_list (BTy_tuple [BTy_ctype; BTy_object OTy_pointer]) ]) empty_env )))))) in
    
    (* Then typechecks them *)
    E.mapMapM (fun _ decl ->
      match decl with
        | Fun bTy sym_bTys pe ->
            let env' = List.foldr (fun (sym, bTy) acc -> insert_tdecl (Sym sym) (TDsym bTy) acc) env sym_bTys in
            Fun bTy sym_bTys <$> typecheck_export_pexpr file.tagDefs env' bTy pe
        | ProcDecl loc bTy bTys ->
            E.return (ProcDecl loc bTy bTys)
        | Proc loc bTy sym_bTys e ->
            let env' = List.foldr (fun (sym, bTy) acc -> insert_tdecl (Sym sym) (TDsym bTy) acc) env sym_bTys in
            collect_labels env' e >>= fun env' ->
            Proc loc bTy sym_bTys <$> typecheck_expr file.tagDefs env' bTy e
      end) file.stdlib >>= fun stdlib' ->
    
    (* Typechecking of the impl constants *)
    E.mapMapM (fun _ decl ->
      match decl with
        | Def bTy pe ->
            Def bTy <$> typecheck_export_pexpr file.tagDefs env bTy pe
        | IFun bTy sym_bTys pe ->
            let env' = List.foldr (fun (sym, bTy) acc -> insert_tdecl (Sym sym) (TDsym bTy) acc) env sym_bTys in
            IFun bTy sym_bTys <$> typecheck_export_pexpr file.tagDefs env' bTy pe
        | BuiltinDecl loc bTy bTys ->
            E.return (BuiltinDecl loc bTy bTys)
      end) file.impl >>= fun impl' ->
    
    (* Typechecking and registering of the globals *)
    E.foldlM (fun (env_acc, res_acc) (sym, bTy, e) ->
      collect_labels env_acc e >>= fun env_acc' ->
      typecheck_expr file.tagDefs env_acc' bTy e >>= fun te ->
      E.return (insert_tdecl (Sym sym) (TDsym bTy) env_acc', (sym, bTy, te) :: res_acc)
    ) (env, []) file.globs >>= fun (env, rev_globs') ->
    
    (* Registering the program functions *)
    let env = Map_extra.fold (fun sym decl acc ->
      match decl with
        | Fun bTy sym_bTys _ ->
            insert_tdecl (Sym sym) (TDfun bTy (List.map snd sym_bTys)) acc
        | ProcDecl _ bTy bTys ->
            insert_tdecl (Sym sym) (TDproc bTy bTys) acc
        | Proc _ bTy sym_bTys _ ->
            insert_tdecl (Sym sym) (TDproc bTy (List.map snd sym_bTys)) acc
      end) file.funs env in
    (* and typechecking them *)
    E.mapMapM (fun _ decl ->
      match decl with
        | Fun bTy sym_bTys pe ->
            let env' = List.foldr (fun (sym, bTy) acc -> insert_tdecl (Sym sym) (TDsym bTy) acc) env sym_bTys in
            Fun bTy sym_bTys <$> typecheck_export_pexpr file.tagDefs env' bTy pe
        | ProcDecl loc bTy bTys ->
            E.return (ProcDecl loc bTy bTys)
        | Proc loc bTy sym_bTys e ->
            let env' = List.foldr (fun (sym, bTy) acc -> insert_tdecl (Sym sym) (TDsym bTy) acc) env sym_bTys in
            collect_labels env' e >>= fun env' ->
            Proc loc bTy sym_bTys <$> typecheck_expr file.tagDefs env' bTy e
      end) file.funs >>= fun funs' ->
    
    E.return <| main= file.main; tagDefs= file.tagDefs; stdlib= stdlib'; impl= impl'; globs= List.reverse rev_globs'; funs= funs'; funinfo= file.funinfo; |>
  in
  match E.runM aux with
    | Exception.Result file' ->
        Exception.return file'
    | Exception.Exception err ->
        Exception.Exception err
  end
