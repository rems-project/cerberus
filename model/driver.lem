open import Pervasives

import Core Core_ctype Boot Decode Output Set_extra Map
import Core_aux Builtins Core_linking
module Caux = Core_aux

open import Utils Show Errors Trace_event
import Cmm_op Cmm_csem

import Core_eval Core_run


import Translation_aux
import Enum State_exception_undefined Exception Undefined Nondeterminism Dlist


import AilSyntax AilTypes

import Translation_aux

import Fs

module Mem = struct
  include import Mem Mem_aux
end

import Pp
(* import Driver_effect *)

module Cmm = Cmm_csem

(* The indirection is required because of a bug in Lem *)
module U = Undefined


module SEU = State_exception_undefined
module ND  = Nondeterminism

open import {hol} `ppTheory`


import Global



(* DEBUG *)
val stringFromCore_core_state: forall 'a. Core_run.core_state -> string
declare ocaml target_rep function stringFromCore_core_state = `String_core_run.string_of_core_state`


type driver_error =
  | DErr_core_run of core_run_cause
  | DErr_memory of Mem_common.mem_error
  | DErr_concurrency of string
  | DErr_other of string

type driver_state = <|
  core_file:         Core.file Core_run.core_run_annotation;
  core_extern:       map Symbol.sym Symbol.sym; (* declarations -> definitions *)
  core_state:        Core_run.core_state;       (* state of the core program *)
  core_run_state:    Core_run.core_run_state;   (* state of the core evaluator *)
  layout_state:      Mem.mem_state;         (* state of memory layout model *)
  concurrency_state: Cmm_op.symState;       (* state of the concurrency memmodel *)
  fs_state:          Fs.fs_state;           (* state of the file system *)
  trace:             list trace_event;
  
  symbolic_assoc: map Symbol.sym Core.object_value;
  
  blocked: bool; (* concurrency model ended by blocking *)
  (* DEBUG *)
  (*trace: list string;*)
  dr_step_counter: nat;
|>

let driver_state_eq dr_st1 dr_st2 =
     dr_st1.core_state = dr_st2.core_state
  && dr_st1.layout_state = dr_st2.layout_state
(*  && dr_st1.concurrency_state = dr_st2.concurrency_state *) (* TODO *)

instance (Eq driver_state)
  let (=) = driver_state_eq
  let (<>) = fun x y -> not (driver_state_eq x y)
end

(* NOTE: Used by the UI to distinguish runtime step kinds *)
type step_kind =
  | SK_action_request of string
  | SK_memop_request
  | SK_tau of string
  | SK_eval of string
  | SK_done
  | SK_misc of list string

instance (Show step_kind)
  let show kind =
    match kind with
    | SK_action_request str ->
      "action request: " ^ str
    | SK_memop_request ->
      "memop request"
    | SK_tau str ->
      "tau: " ^ str
    | SK_eval str ->
      "eval: " ^ str
    | SK_done ->
      "done"
    | SK_misc ss ->
      "misc: " ^ String.concat "," ss
    end
end

type driverM 'a = ND.ndM 'a step_kind driver_error Mem.mem_iv_constraint driver_state


val aid_to_string: Cmm.action -> string
let aid_to_string a =
  show (Cmm.aid_of a)



(* open ND.Operators *)
let inline (>>=)      = ND.bind
let inline (>>) m1 m2 = ND.bind m1 (fun _ -> m2)



(*
val liftMem: forall 'a. Mem.memM 'a -> driver_state -> driverM ('a * driver_state)
let liftMem m dr_st =
  ND.msum "liftMem" $ map (function
    | Left mem_err ->
        (* TODO: map memory error to something sensible ... *)
            ND.kill (ND.Other mem_err)
    | Right (z, layout_st') ->
        ND.return (z, <| dr_st with layout_state= layout_st' |>)
  end) (Mem.runMem m dr_st.layout_state)
*)
val liftMem: forall 'a. Mem.memM 'a -> driverM 'a
let liftMem m =
  ND.liftND (fun dr_st -> dr_st.layout_state)
    (fun dr_st mem_st -> <| dr_st with layout_state= mem_st |>)
    (fun err_str -> SK_misc ["memory"; err_str])
    (fun mem_err -> DErr_memory mem_err)
    m

val liftConc: forall 'a. Cmm_op.ndM 'a -> driverM 'a
let liftConc =
  ND.liftND (fun _ -> ())
    (fun dr_st () -> dr_st)
    (fun err_str -> SK_misc ["concurrency"; err_str])
    (fun str -> DErr_concurrency str)

val get_thread_states: driverM (list (Core_ctype.thread_id * (maybe Core_ctype.thread_id * Core_run.thread_state)))
let get_thread_states =
  ND.get >>= fun dr_st ->
  ND.return dr_st.core_state.Core_run.thread_states



let add_to_concur_sym_map sym oval concur_sym_map =
  match oval with
    | _ ->
        let () = Debug.print_debug 4 [Debug.DB_driver; Debug.DB_concurrency]
            (fun () -> "ADDING TO ASSOC ==> " ^ show sym ^ " := " ^ Pp.stringFromCore_value (Core.Vobject oval)) in
        Map.insert sym oval concur_sym_map
  end

val     print_eval_conv_aux: driver_state -> Core_run.thread_state -> Core.pexpr -> Mem.memM (either Errors.error (Undefined.t Core.value))
let rec print_eval_conv_aux dr_st th_st pe =
  match Core_eval.eval_pexpr_aux2 (Loc.other "Driver.print_eval_conv_aux") dr_st.core_extern th_st.Core_run.env (Just dr_st.layout_state) dr_st.core_file pe with
  | Exception.Result (Undefined.Defined (Right cval)) ->
      ND.return (Right (Undefined.Defined cval))
  | Exception.Result (Undefined.Defined (Left (Core.Pexpr [] () (Core.PEconstrained xs)))) ->
      ND.msum "printf_eval_conv" begin
        List.map (fun (cs, pe) ->
            ( "printf_eval_conv_pe_constrained"
            , ND.addConstraints "printf_eval_conv" cs >> print_eval_conv_aux dr_st th_st pe
            )) xs
        end
  | Exception.Result (Undefined.Defined _) ->
      error "print_eval_conv: should be a value or PEconstrained"
  | Exception.Result (Undefined.Undef loc undef) ->
      ND.return (Right (Undefined.Undef loc undef))
  | Exception.Result (Undefined.Error loc err) ->
      ND.return (Right (Undefined.Error loc err))
  | Exception.Exception err ->
      ND.return (Left (Loc.other "Driver.print_eval_conv_aux", Errors.CORE_RUN err))
end

val printf_eval_conv: driver_state -> Core_run.thread_state -> Core_ctype.ctype -> Mem.mem_value -> Mem.memM (either Errors.error (Undefined.t Core.value))
let printf_eval_conv dr_st th_st cty mval =
  let () = Debug.print_debug 4 [] (fun () -> "printf_eval_conv") in
  let (_, cval) = Core_aux.valueFromMemValue mval in
  print_eval_conv_aux dr_st th_st $
    Translation_aux.mk_stdcall dr_st.core_file.Core.stdlib "conv_loaded_int"
    [ Caux.mk_ctype_pe cty; Core.Pexpr [] () (Core.PEval cval)]

(* Perform a given number of successive steps of the concurrency model *)
val     stepConcurrency: nat -> driverM unit
let rec stepConcurrency n =
  let () = Debug.print_debug 10 [Debug.DB_driver] (fun () -> "Driver.stepConcurrency") in (* DEBUG *)
  if n = 0 then
    ND.return ()
  else begin
    ND.get >>= fun dr_st ->
    let conc_result = Cmm_op.symStep dr_st.concurrency_state in
    liftConc conc_result >>= function
      | Cmm_op.ConcurrencyTau performed_act concur_st' ->
          ND.log ("ConcurrencyTau with aid: " ^ show (Cmm.aid_of performed_act)) >> (* DEBUG *)
          ND.print_debug 4 [Debug.DB_driver; Debug.DB_concurrency]
            (fun () -> "ConcurrencyTau with aid: " ^ show (Cmm.aid_of performed_act) ^ "\n") >> (* DEBUG *)
          ND.update (fun dr_st -> <| dr_st with concurrency_state= concur_st' |>)
      
      (* TODO: the variables names seems completely messed up here *)
      | Cmm_op.ReadsFrom (new_concrete_mval: Mem.mem_value) (previous_symbolic_mval: Mem.mem_value) performed_act concur_st' ->
          error "WIP: Driver.stepConcurrency, ReadsFrom"
(*
          ND.log ("ReadsFrom with aid: " ^ show (Cmm.aid_of performed_act) ^ " with concrete: " ^ (* DEBUG *)
                  Pp.pretty_stringFromMem_mem_value new_concrete_mval ^ " and previous: " ^       (* DEBUG *)
                  Pp.pretty_stringFromMem_mem_value previous_symbolic_mval) >>                    (* DEBUG *)
          ND.print_debug 2 [Debug.DB_driver; Debug.DB_concurrency]
            (fun () -> "ReadsFrom with aid: " ^ aid_to_string performed_act ^ "\n") >>       (* DEBUG *)
          ND.print_debug 2 [Debug.DB_driver; Debug.DB_concurrency]
            (fun () -> "CONCRETE MVAL = " ^ Pp.stringFromCore_value        (* DEBUG *)
            (Core.Vobject (snd $ Core_aux.objectValueFromMemValue new_concrete_mval))) >>         (* DEBUG *)
          
          let new_concrete_cst =
            let other = Symbolic.SYMBconst (snd $ Core_aux.objectValueFromMemValue new_concrete_mval) in
            Mem.case_mem_value new_concrete_mval
              (fun _ -> other)
              (fun _ sym -> Symbolic.SYMBsym Symbolic.SYMBint sym)
              (fun _ _ -> other)
              (fun _ _ -> other)
              (fun _ _ -> other)
              (fun _ -> other)
              (fun _ _ -> other)
              (fun _ _ _ -> other) in
          
          let previous_sym =
            let fail = error "[Driver] previous_symbolic_mval was not a concurrency read" in
            Mem.case_mem_value new_concrete_mval
              (fun _ -> fail)
              (fun _ sym -> sym)
              (fun _ _ -> fail)
              (fun _ _ -> fail)
              (fun _ _ -> fail)
              (fun _ -> fail)
              (fun _ _ -> fail)
              (fun _ _ _ -> fail) in
          let previous_symb = Symbolic.SYMBsym Symbolic.SYMBint previous_sym in
          
          ND.log ("ADDING READ CONSTRAINT: EQ " ^ Pp.pretty_stringFromMem_mem_value previous_symbolic_mval ^ " <--> " ^ (* DEBUG *)
                  Pp.pretty_stringFromMem_mem_value new_concrete_mval) >>                                               (* DEBUG *)
          ND.add_constraint (Constraints.assert_eq previous_symb new_concrete_cst) >>
          ND.print_debug 2 [Debug.DB_driver; Debug.DB_concurrency]
            (fun () -> "ReadsFrom: " ^ show previous_sym ^ " = " ^ Pp.pretty_stringFromMem_mem_value new_concrete_mval) >> (* DEBUG *)
          ND.return <| dr_st with
            concurrency_state= concur_st';
            core_state= (* resolve_read previous_sym new_concrete_cst *) dr_st.core_state;
            symbolic_assoc= add_to_concur_sym_map previous_sym (snd (Core_aux.objectValueFromMemValue new_concrete_mval)) dr_st.symbolic_assoc;
          |>
*)
    end
  end >>
  stepConcurrency (n-1)

val liftCore_run: forall 'a. Core_run.core_runM 'a -> driverM 'a
let liftCore_run m =
  ND.get >>= fun dr_st ->
  match SEU.run m dr_st.core_run_state with
    | Exception.Result (res, run_st') ->
        ND.update (fun dr_st -> <| dr_st with core_run_state= run_st' |>) >>
        match res with
          | U.Defined z ->
              ND.return z
          | U.Undef loc ubs ->
              ND.kill (ND.Undef loc ubs)
          | U.Error loc str ->
              ND.kill (ND.Error loc str)
        end
    | Exception.Exception err ->
        ND.kill (ND.Other (DErr_core_run err))
  end

(*
val runCore: forall 'a. core_runM 'a -> driver_state -> driverM ('a * driver_state)
let runCore m dr_st =
  match SEU.run m dr_st.core_run_state with
    | Exception.Result (U.Defined z, run_st') ->
        ND.return (z, <| dr_st with core_run_state= run_st' |>)
    
    | Exception.Result (U.Undef loc ubs, _) ->
        ND.kill (ND.Undef loc ubs)
    
    | Exception.Result (U.Error loc str, _) ->
        ND.kill (ND.Error loc str)
    
    | Exception.Exception err ->
        ND.kill (ND.Other (DErr_core_run err))
  end
*)


(* Returns the number of uncommitted action in the concurency memory model state *)
val number_of_uncommitted: Cmm_op.symState -> nat
let number_of_uncommitted concur_st =
  Set.size concur_st.Cmm_op.symPre.Cmm.actions - List.length concur_st.Cmm_op.symCommitted


(*
let symbolicFromIntegerValue ((Defacto_memory_types2.IV _ ival_) as ival) =
  match ival_ with
  | Defacto_memory_types2.IVconcurRead _ sym ->
      Symbolic.SYMBsym Symbolic.SYMBint sym
  | _ ->
      Symbolic.SYMBconst (Core.OVinteger ival)
  end
*)

val drive_fs_step: Core_ctype.thread_id -> Core_run.thread_state -> driver_state -> Core_run.fs_oper -> driverM unit
let drive_fs_step tid th_st dr_st fs_oper =
  let th_st_from_int n =
    let (Core.Expr arena_annots _) = th_st.Core_run.arena in
    <| th_st with Core_run.arena= Core.Expr arena_annots (Core.Epure (Caux.mk_specified_pe (Caux.mk_integer_pe n))) |>
  in
  let th_st_from_ptr p =
    let (Core.Expr arena_annots _) = th_st.Core_run.arena in
    <| th_st with Core_run.arena= Core.Expr arena_annots (Core.Epure (Caux.mk_specified_pe (Caux.mk_value_pe (Core.Vobject (Core.OVpointer p))))) |>
  in
  let th_st_from_void () =
    let (Core.Expr arena_annots _) = th_st.Core_run.arena in
    <| th_st with Core_run.arena= Core.Expr arena_annots (Core.Epure (Caux.mk_value_pe Core.Vunit)) |>
  in
  let update fs_st th_st =
    ND.update $ fun dr_st ->
      let core_st' = Core_run.update_thread_state tid th_st dr_st.core_state in
      <| dr_st with
        fs_state= fs_st;
        core_state= core_st';
        dr_step_counter= dr_st.dr_step_counter + 1;
      |>
  in
  let store_error e =
    let errname = Fs.fs_string_of_error e in
    let err = Builtins.translate_errno ("__cerbvar_" ^ errname) in
    let err_mval = Mem.integer_value_mval (AilTypes.Signed AilTypes.Int_) (Mem.integer_ival err) in
    liftMem $ Mem.store (Loc.other "update errno") Core_ctype.signed_int false th_st.Core_run.errno err_mval
  in
  let return (fs_st, res) =
    match res with
      | Left e ->
        store_error e >>
        update fs_st (th_st_from_int (0 - 1))
      | Right n ->
        update fs_st $ th_st_from_int (integerFromNat n)
    end
  in
  let store_buffer ptr (fs_st, res) =
    match res with
      | Left e ->
        store_error e >>
        update fs_st (th_st_from_int (0 - 1))
      | Right buf ->
        let n = integerFromNat $ List.length buf in
        (* TODO: store chars is wrong here!! it adds a \0 in the end of the array *)
        liftMem (Output.store_chars_in_array false ptr buf) >>
        update fs_st (th_st_from_int n)
    end
  in
  let store_buffer_trunc ptr max (fs_st, res) =
    match res with
      | Left e ->
        store_error e >>
        update fs_st (th_st_from_int (0 - 1))
      | Right buf ->
        let buf_trunc = List.take (natFromInteger max) buf in
        let n = integerFromNat $ List.length buf_trunc in
        liftMem (Output.store_chars_in_array false ptr buf_trunc) >>
        update fs_st (th_st_from_int n)
    end
  in
  let update_stdout out_chars =
    ND.update (fun dr_st ->
      let core_st' = Core_run.update_thread_state tid (th_st_from_int (integerFromNat (List.length out_chars))) dr_st.core_state in
      <| dr_st with
        core_state= <| core_st' with
          Core_run.io= <| dr_st.core_state.Core_run.io with Core_run.stdout=
                Dlist.append (Dlist.singleton (String.toString out_chars)) dr_st.core_state.Core_run.io.Core_run.stdout
              |>
        |>;
        dr_step_counter= dr_st.dr_step_counter + 1;
      |>
    )
  in
  let update_stderr out_chars =
    ND.update (fun dr_st ->
      let core_st' = Core_run.update_thread_state tid (th_st_from_int (integerFromNat (List.length out_chars))) dr_st.core_state in
      <| dr_st with
        core_state= <| core_st' with
          Core_run.io= <| dr_st.core_state.Core_run.io with Core_run.stderr=
                Dlist.append (Dlist.singleton (String.toString out_chars)) dr_st.core_state.Core_run.io.Core_run.stderr
              |>
        |>;
        dr_step_counter= dr_st.dr_step_counter + 1;
      |>
    )
  in
  let struct_sym name =
    let dom = Map.domain dr_st.core_file.Core.tagDefs in
    let res = Set.filter (fun sym ->
      match sym with
      | Symbol.Symbol _ _ (Just n) -> n = name
      | _ -> error ("symbol struct " ^ name ^ " not in tagDefs")
      end) dom
    in
    match Set_extra.toList res with
    | [] -> error ("no symbols for struct " ^ name ^ " in tagDefs")
    | [sym] -> sym
    | sym::_ -> sym
    end
  in
  let store_dir (fs_st, res) =
    let sym = struct_sym "dirent" in
    let loc = Loc.other "store struct dirent" in
    let dirent_cty = Core_ctype.Struct sym in
    let update_mem dir_name =
      Mem.bind (Mem.allocate_static tid (Symbol.PrefOther "dirent") (Mem.alignof_ival dirent_cty) dirent_cty Nothing) (fun dirent_ptr ->
        let d_name_ptr = Mem.member_shift_ptrval dirent_ptr sym (Cabs.CabsIdentifier loc "d_name") in
        Mem.bind (Output.store_chars_in_array true d_name_ptr dir_name) (fun _ ->
          (Mem.return dirent_ptr)))
    in
    match res with
    | Left e ->
      store_error e >>
      update fs_st (th_st_from_ptr (Mem.null_ptrval dirent_cty))
    | Right [] ->
      update fs_st (th_st_from_ptr (Mem.null_ptrval dirent_cty))
    | Right dir_name ->
      liftMem (update_mem dir_name) >>= fun dirent_ptr ->
      update fs_st (th_st_from_ptr dirent_ptr)
    end
  in
  let store_stat stat_ptr (fs_st, res) =
    let sym = struct_sym "stat" in
    let update_mem stat =
      let loc = Loc.other "store struct stat" in
      let store iTy memb f =
        let ptr = Mem.member_shift_ptrval stat_ptr sym (Cabs.CabsIdentifier loc memb) in
        let mval = Mem.integer_value_mval iTy (Mem.integer_ival (f stat)) in
        Mem.store loc (Core_ctype.Basic (AilTypes.Integer iTy)) false ptr mval
      in
      let sint = AilTypes.Unsigned AilTypes.Int_ in
      let uint = AilTypes.Signed AilTypes.Int_ in
      let ushort = AilTypes.Unsigned AilTypes.Short in
      let slonglong = AilTypes.Signed AilTypes.LongLong in
      let ulonglong = AilTypes.Unsigned AilTypes.LongLong in
      Mem.bind (store sint "st_dev" Fs.fs_dev) (fun _ ->
      Mem.bind (store ulonglong "st_ino" Fs.fs_ino) (fun _ ->
      Mem.bind (store ushort "st_mode" Fs.fs_mode) (fun _ ->
      Mem.bind (store ushort "st_nlink" Fs.fs_nlink) (fun _ ->
      Mem.bind (store uint "st_uid" Fs.fs_uid) (fun _ ->
      Mem.bind (store uint "st_gid" Fs.fs_gid) (fun _ ->
      Mem.bind (store sint "st_rdev" Fs.fs_rdev) (fun _ ->
               (store slonglong "st_size" Fs.fs_size) )))))))
    in
    match res with
    | Left e ->
      store_error e >>
      update fs_st (th_st_from_int (0 - 1))
    | Right stat ->
      liftMem (update_mem stat) >>
      update fs_st (th_st_from_int 0)
    end
  in
  match fs_oper with
    | Core_run.FS_MKDIR path mode ->
      return $ Fs.fs_mkdir dr_st.fs_state path mode
    | Core_run.FS_OPEN path oflag mode_opt ->
      return $ Fs.fs_open dr_st.fs_state path oflag mode_opt
    | Core_run.FS_CLOSE fd ->
      return $ Fs.fs_close dr_st.fs_state fd
    | Core_run.FS_WRITE fd buf size ->
      match natFromInteger fd with
      | 0 ->
        error "driver_fs_step: stdin not supported yet."
      | 1 ->
        update_stdout (List.take (natFromInteger size) buf)
      | 2 ->
        update_stderr (List.take (natFromInteger size) buf)
      | _ ->
        return $ Fs.fs_write dr_st.fs_state fd buf size
      end
    | Core_run.FS_READ fd ptr size ->
      store_buffer ptr $ Fs.fs_read dr_st.fs_state fd size
    | Core_run.FS_PWRITE fd buf size off ->
      return $ Fs.fs_pwrite dr_st.fs_state fd buf size off
    | Core_run.FS_PREAD fd ptr size off ->
      store_buffer ptr $ Fs.fs_pread dr_st.fs_state fd size off
    | Core_run.FS_UMASK mode ->
      return $ Fs.fs_umask dr_st.fs_state mode
    | Core_run.FS_CHMOD path mode ->
      return $ Fs.fs_chmod dr_st.fs_state path mode
    | Core_run.FS_CHDIR path ->
      return $ Fs.fs_chdir dr_st.fs_state path
    | Core_run.FS_CHOWN path uid gid ->
      return $ Fs.fs_chown dr_st.fs_state path uid gid
    | Core_run.FS_LINK oldpath newpath ->
      return $ Fs.fs_link dr_st.fs_state oldpath newpath
    | Core_run.FS_READLINK path ptr max ->
      store_buffer_trunc ptr max $ Fs.fs_readlink dr_st.fs_state path
    | Core_run.FS_STAT path ptr ->
      store_stat ptr $ Fs.fs_stat dr_st.fs_state path
    | Core_run.FS_LSTAT path ptr ->
      store_stat ptr $ Fs.fs_lstat dr_st.fs_state path
    | Core_run.FS_SYMLINK target lpath ->
      return $ Fs.fs_symlink dr_st.fs_state target lpath
    | Core_run.FS_RMDIR path ->
      return $ Fs.fs_rmdir dr_st.fs_state path
    | Core_run.FS_TRUNCATE path len ->
      return $ Fs.fs_truncate dr_st.fs_state path len
    | Core_run.FS_UNLINK path ->
      return $ Fs.fs_unlink dr_st.fs_state path
    | Core_run.FS_LSEEK fd off whence ->
      return $ Fs.fs_lseek dr_st.fs_state fd off whence
    | Core_run.FS_RENAME oldpath newpath ->
      return $ Fs.fs_rename dr_st.fs_state oldpath newpath
    | Core_run.FS_OPENDIR path ->
      return $ Fs.fs_opendir dr_st.fs_state path
    | Core_run.FS_READDIR dir ->
      store_dir $ Fs.fs_readdir dr_st.fs_state dir
    | Core_run.FS_REWINDDIR dir ->
      update (Fs.fs_rewinddir dr_st.fs_state dir) (th_st_from_void ())
    | Core_run.FS_CLOSEDIR dir ->
      return $ Fs.fs_closedir dr_st.fs_state dir
    | Core_run.FS_PRINTF fmt args ->
      liftMem (Output.printf (printf_eval_conv dr_st th_st) fmt args) >>= function
        | Left err ->
          error "TODO: printf error"
        | Right (Undefined.Defined buf) ->
          update_stdout buf
        | Right (Undefined.Error loc str) ->
          ND.kill (ND.Error loc str)
        | Right (Undefined.Undef loc ubs) ->
          ND.kill (ND.Undef loc ubs)
      end
    | Core_run.FS_VPRINTF fd fmt ap ->
      liftMem (Output.vprintf (printf_eval_conv dr_st th_st) fmt ap) >>= function
        | Left err ->
          error "TODO: vprintf error"
        | Right (Undefined.Defined buf) ->
          let size = integerFromNat $ List.length buf in
          match natFromInteger fd with
          | 0 ->
            error "vprintf trying to output in the stdin"
          | 1 ->
            update_stdout buf
          | 2 ->
            update_stderr buf
          | _ ->
            return $ Fs.fs_write dr_st.fs_state fd buf size
          end
        | Right (Undefined.Error loc str) ->
          ND.kill (ND.Error loc str)
        | Right (Undefined.Undef loc ubs) ->
          ND.kill (ND.Undef loc ubs)
      end
    | Core_run.FS_VSNPRINTF ptr size fmt ap ->
      liftMem (Output.vsnprintf (printf_eval_conv dr_st th_st) ptr size fmt ap) >>= function
        | Left err ->
          error "TODO: vprintf error"
        | Right (Undefined.Defined n) ->
          update dr_st.fs_state $ th_st_from_int n
        | Right (Undefined.Error loc str) ->
          ND.kill (ND.Error loc str)
        | Right (Undefined.Undef loc ubs) ->
          ND.kill (ND.Undef loc ubs)
      end
  end


(* For a given thread, perform all possible step that are not action requests *)
val     drive_core_thread: Core_ctype.thread_id -> driverM unit
let rec drive_core_thread tid =
  ND.get >>= fun dr_st ->
  let th_info = match List.lookup tid dr_st.core_state.Core_run.thread_states with
    | Just z ->
        z (* (tid, z) *)
    | _ ->
        error "drive_core_thread, wrong tid"
  end in
  ND.mk_step (SK_misc ["drive_core_thread"]) $ List.map (function
    | Core_run.Step_constrained debug_str xs ->
        ( SK_misc ["constrained"; debug_str]
        , (* DEBUG *) ND.print_debug 4 [Debug.DB_driver_step] (fun () -> ">> STEP_CONSTRAINED, |xs| = " ^ show (List.length xs)) >>
          ND.msum (SK_misc ["constrained"]) (
            List.map (fun (cs, step_m) ->
              ( SK_misc [Pp.stringFromMem_iv_mem_constraint cs]
              , let () = Debug.print_debug 4 [] (fun () ->
                  "ADDING CONSTRAINTS (driver) ===> " ^ Pp.stringFromMem_iv_mem_constraint cs
                ) in
                ND.addConstraints (SK_misc ["driver"; debug_str]) cs >>
                liftCore_run step_m >>= fun th_st' ->
                ND.update (fun dr_st -> <| dr_st with
                  core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
                  dr_step_counter= dr_st.dr_step_counter + 1
                |>) >>
                drive_core_thread tid )
            ) xs
          ) )
    
    | Core_run.Step_action_request str _ ->
        ( SK_action_request str
        , ND.return () )
    | Core_run.Step_memop_request _ _ _ _ ->
        ( SK_memop_request
        , ND.return () )
    | Core_run.Step_tau debug_str tsk step_m ->
        ( SK_tau debug_str
        , let () = Debug.print_debug 4 [] (fun () -> "Step_tau(" ^ debug_str ^ ")") in
          let () = Boot.begin_timing ("tau: " ^ debug_str) in (* DEBUG, PROFILING *)
          match tsk with
            | Core_run.TSK_Ccall sym mvals ->
                ND.update $ fun dr_st ->
                <| dr_st with
                  trace= ME_function_call sym mvals :: dr_st.trace
                |>
            | Core_run.TSK_Return sym mval_opt ->
                ND.update $ fun dr_st ->
                <| dr_st with
                  trace= ME_function_return sym mval_opt :: dr_st.trace
                |>
            | Core_run.TSK_Misc ->
                ND.return ()
          end >>
          let pre_th_st = (* DEBUG *)
            snd $ fromJust "Driver.drive_core_thread" (List.lookup tid dr_st.core_state.Core_run.thread_states) in
          begin
            if debug_str <> "Eloc" then
            (* DEBUG *) ND.print_debug 6 [Debug.DB_driver_step] (fun () -> "tau(tid_" ^ show tid ^ "): " ^ debug_str ^ " with arena= " ^
            (* DEBUG *)                   Pp.stringFromCore_expr pre_th_st.Core_run.arena ^ ";\nstack= " ^
            (* DEBUG *)                   Pp.stringFromCore_stack pre_th_st.Core_run.stack)
            else
              ND.return ()
          end >>
          (* case where the Core program does a non pure but non memory-related
             step (typically ordering related stuff) *)
          liftCore_run step_m >>= fun th_st' ->
          let () = Boot.end_timing () in (* DEBUG, PROFILING *)
          ND.update (fun dr_st -> <| dr_st with
            core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
            dr_step_counter= dr_st.dr_step_counter + 1
          |>) >>
          drive_core_thread tid )
    | Core_run.Step_eval debug_str step_m ->
        ( SK_eval debug_str
        , let () = Debug.print_debug 4 [] (fun () -> "Step_eval(" ^ debug_str ^ ")") in
          let () = Boot.begin_timing ("eval: " ^ debug_str) in (* DEBUG, PROFILING *)
          let pre_th_st = (* DEBUG *)
            snd $ fromJust "Driver.drive_core_thread" (List.lookup tid dr_st.core_state.Core_run.thread_states) in
          (* DEBUG *) ND.print_debug 6 [Debug.DB_driver_step] (fun () -> "eval(tid_" ^ show tid ^ "): " ^ debug_str ^ " with arena= " ^
          (* DEBUG *)                   Pp.stringFromCore_expr pre_th_st.Core_run.arena ^ ";\nstack= " ^
          (* DEBUG *)                   Pp.stringFromCore_stack pre_th_st.Core_run.stack) >>
          (* case where the Core program does a pure step *)
          liftCore_run step_m >>= fun th_st' ->
          let () = Boot.end_timing () in (* DEBUG, PROFILING *)
          ND.update (fun dr_st -> <| dr_st with
            core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
            dr_step_counter= dr_st.dr_step_counter + 1
          |>) >>
          drive_core_thread tid )
    
    | Core_run.Step_thread_done parent_tid cval ->
        ( SK_misc ["thread_done"]
        , (* DEBUG *) ND.print_debug 6 [Debug.DB_driver_step] (fun () -> "thread " ^ show tid ^ " is done") >>
          let actions_of_current_thread: set Cmm.action =
            Set.filter (fun act -> Cmm.tid_of act = tid) $ dr_st.concurrency_state.Cmm_op.symPre.Cmm.actions in
          let last_actions_of_current_thread: set Cmm.action =
            Set.filter (fun act ->
              not (Set.any (fun (act', _) -> act = act') dr_st.concurrency_state.Cmm_op.symPre.Cmm.sb)
            ) actions_of_current_thread in
          ND.update (fun dr_st -> <| dr_st with
            core_state= Core_run.kill_thread tid parent_tid (Set.map Cmm.aid_of last_actions_of_current_thread) cval dr_st.core_state;
            dr_step_counter= dr_st.dr_step_counter + 1;
          |>) >>
          drive_core_thread parent_tid )
    
    | Core_run.Step_blocked ->
        (SK_misc ["blocked"], ND.return ())
    | Core_run.Step_error debug_str ->
        error ("WIP: Step_error --> " ^ debug_str)
    (* NOTE: it clears the stack and add the value to the arena *)
    | Core_run.Step_done cval ->
        ( SK_done
        , get_thread_states >>= fun th_sts ->
          let th_st = match lookup tid th_sts with
            | Just (_, th_st) -> th_st
            | Nothing -> error "WIP: Step_done"
          end in
          ND.update (fun dr_st ->
            let core_st' = Core_run.update_thread_state tid
              <| Core_run_aux.arena= Core.Expr [] (Core.Epure (Core_aux.mk_value_pe cval));
                 Core_run_aux.stack= Core.Stack_empty;
                 Core_run_aux.errno= Mem.null_ptrval Core_ctype.signed_int;
                 Core_run_aux.env= th_st.Core_run_aux.env;
                (* Dummy locations *)
                 Core_run_aux.exec_loc= Core_run_aux.ELoc_globals;
                 Core_run_aux.current_loc= Loc.unknown;
              |> dr_st.core_state
            in
            <| dr_st with
              core_state= core_st';
              dr_step_counter= dr_st.dr_step_counter + 1;
            |>))

    | Core_run.Step_spawn_threads mk_th_st th_sts ->
        ( SK_misc ["spawn_threads"]
        , ND.print_debug 6 [Debug.DB_driver_step] (fun () -> "Step_spawn_threads") >>
          let ((th_tids, core_st'), run_st') = State.runStateM (
            State.foldlM (fun (th_tids_, core_st_) th_st ->
              State.bind (Core_run.spawn_thread (Just tid) th_st core_st_)
                (fun (tid, core_st_') -> State.return (tid :: th_tids_, core_st_'))
            ) ([], dr_st.core_state) th_sts
          ) dr_st.core_run_state in
          ND.update (fun dr_st -> <| dr_st with
            core_run_state= run_st';
            core_state= Core_run.update_thread_state tid
                          (mk_th_st (Core.Expr [] (Core.Eunseq $ List.reverse (List.map (fun z -> Core.Expr [] (Core.Ewait z)) th_tids))))
                          core_st';
          |>) >>
          ND.mapM_ drive_core_thread th_tids >>
          drive_core_thread tid )
    
    | Core_run.Step_fs th_st fs_step ->
        (SK_misc ["fs_step"], drive_fs_step tid th_st dr_st fs_step >> drive_core_thread tid)
    
    | Core_run.Step_bound step_m ->
        ( SK_misc ["bound"]
        , liftCore_run step_m >>= fun th_st' ->
          ND.update (fun dr_st -> <| dr_st with
            core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
            dr_step_counter= dr_st.dr_step_counter + 1
          |>) >>
          drive_core_thread tid )

  end) (Core_run.core_thread_step2 dr_st.layout_state dr_st.core_file dr_st.core_extern dr_st.symbolic_assoc tid th_info)
















(* perform drive_core_thread for all the core threads *)
val     drive_core_threads: unit -> driverM unit
let rec drive_core_threads () =
  ND.get >>= fun dr_st ->
  ND.mapM_ (fun (tid, _) ->
    ND.print_debug 9 [Debug.DB_driver] (fun () -> "BEFORE drive_core_thread, in drive_core_threads") >>
    drive_core_thread tid
  ) dr_st.core_state.Core_run.thread_states




let repair_pre_execution dr_st =
  let repair preEx =
    <| preEx with Cmm.asw=
      Set.filter (fun (a,c) ->
        not (
          Set.any (fun b -> a <> b && Relation.inRel a b preEx.Cmm.sb

&& Relation.inRel b c preEx.Cmm.asw

) preEx.Cmm.actions
        )
      ) preEx.Cmm.asw


|>
  in
  <| dr_st with concurrency_state=
    <| dr_st.concurrency_state with Cmm_op.symPre= repair dr_st.concurrency_state.Cmm_op.symPre |>
  |>



val update_core_state: Core_run.core_state -> driver_state -> driver_state
let update_core_state core_st dr_st =
  <| dr_st with core_state= core_st |>

val update_core_run_state: Core_run.core_run_state -> driver_state -> driver_state
let update_core_run_state run_st dr_st =
  <| dr_st with core_run_state= run_st |>




(* ========================================================================== *)


val action_request_concurrency: Core_run.action_request -> driverM unit
let action_request_concurrency = function
  | Core_run.AllocRequest loc sb_edges dd_edges asw_edges aid tid pref align_ival size_ival mk_th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST ALLOC") in (* DEBUG *)
      (* TODO: hack, hack, hack *)
      ND.log ("ALLOC REQUEST (aid: " ^ show aid ^ ")") >> (* DEBUG *)
      liftMem (Mem.allocate_dynamic tid pref align_ival size_ival) >>= fun ptrval ->
      ND.update (fun dr_st ->
        update_core_state (Core_run.update_thread_state tid (mk_th_st' ptrval) dr_st.core_state) dr_st
      )
  
  | Core_run.CreateRequest loc sb_edges dd_edges asw_edges aid tid pref align_ival lvalue_ty init_opt mk_th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST CREATE") in (* DEBUG *)
      (* TODO: hack, hack, hack *)
      ND.log ("CREATE REQUEST (aid: " ^ show aid ^ ")") >> (* DEBUG *)
      liftMem (Mem.allocate_static tid pref align_ival lvalue_ty init_opt) >>= fun ptrval ->
      ND.update (fun dr_st ->
        update_core_state (Core_run.update_thread_state tid (mk_th_st' ptrval) dr_st.core_state) dr_st
      )
  
  | Core_run.StoreRequest loc sb_edges dd_edges asw_edges aid tid mo lvalue_ty is_locking ptr_val mem_val th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "CONCUR REQUEST STORE") in (* DEBUG *)
      let preEx_step = <|
          Cmm_op.newAction=    Cmm.Store aid tid mo ptr_val mem_val;
          Cmm_op.sbBefore=     sb_edges;
          Cmm_op.ddBefore=     dd_edges;
          Cmm_op.aswBefore=    asw_edges;
          Cmm_op.locationKind= Just (if Core_ctype.is_atomic lvalue_ty then Cmm.Atomic else Cmm.Non_Atomic);
      |> in
      
      ND.log ("STORE REQUEST (aid: " ^ show aid ^ ")") >> (* DEBUG *)
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
          concurrency_state= Cmm_op.symUpdatePreEx dr_st.concurrency_state preEx_step;
          (*trace= "store" :: dr_st.trace*)
        |>
      )
  
  | Core_run.LoadRequest loc sb_edges dd_edges asw_edges aid tid mo lvalue_ty ptr_val sym mk_th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "CONCUR REQUEST LOAD") in (* DEBUG *)
(*      let mval = Mem.symbolic_mval (Symbolic.SYMBsym Symbolic.SYMBint sym) in *)
      let ity = match lvalue_ty with
        | Core_ctype.Basic (AilTypes.Integer ity) ->
            ity
        | _ ->
            AilTypes.Signed (AilTypes.Int_) (* TODO DUMMY *)
      end in
      let mval = Mem.integer_value_mval ity (Mem.concurRead_ival ity sym) in
      let preEx_step = <|
          Cmm_op.newAction=    Cmm.Load aid tid mo ptr_val mval;
          Cmm_op.sbBefore=     sb_edges;
          Cmm_op.ddBefore=     dd_edges;
          Cmm_op.aswBefore=    asw_edges;
          Cmm_op.locationKind= Just (if Core_ctype.is_atomic lvalue_ty then Cmm.Atomic else Cmm.Non_Atomic);
      |> in
      
      ND.log ("LOAD REQUEST (aid: " ^ show aid ^ ")") >> (* DEBUG *)
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid (mk_th_st' mval) dr_st.core_state;
          concurrency_state= Cmm_op.symUpdatePreEx dr_st.concurrency_state preEx_step;
          (*trace= "store" :: dr_st.trace*)
        |>
      )
  
  | Core_run.FenceRequest loc sb_edges dd_edges asw_edges aid tid mo th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "CONCUR REQUEST FENCE") in (* DEBUG *)
      let preEx_step = <|
          Cmm_op.newAction=    Cmm.Fence aid tid mo;
          Cmm_op.sbBefore=     sb_edges;
          Cmm_op.ddBefore=     dd_edges;
          Cmm_op.aswBefore=    asw_edges;
          Cmm_op.locationKind= Nothing;
      |> in
      ND.log ("FENCE REQUEST (aid: " ^ show aid ^ ")") >> (* DEBUG *)
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
          concurrency_state= Cmm_op.symUpdatePreEx dr_st.concurrency_state preEx_step;
          (*trace=             "fence" :: dr_st.trace*)
        |>
      )
  
  | Core_run.RMWRequest loc sb_edges dd_edges asw_edges aid tid mo1 mo2 lvalue_ty ptr_val mval_expected mval_actual th_st' ->
(*
      let preEx_step = <|
          Cmm_op.newAction=    Cmm.RMW aid tid mo ptr_val mval;
          Cmm_op.sbBefore=     sb_edges;
          Cmm_op.ddBefore=     dd_edges;
          Cmm_op.aswBefore=    asw_edges;
          Cmm_op.locationKind= Just (if Core_ctype.is_atomic lvalue_ty then Cmm.Atomic else Cmm.Non_Atomic);
      |> in
      
      ND.return <| dr_st with
        core_state= update_thread_state tid (mk_th_st' mval) dr_st.core_state;
        concurrency_state= Cmm_op.symUpdatePreEx dr_st.concurrency_state preEx_step;
        trace= "rmw" :: dr_st.trace
      |>
*)
      error "WIP: Driver ==> RMWRequest"

  | Core_run.KillRequest loc sb_edges dd_edges asw_edges aid tid is_dynamic ptr_val th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST KILL") in (* DEBUG *)
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
          (* TODO: the kill ... *)
        |>
      )
end




(* This version only uses the memory layout model (note that is deterministic) *)
val action_request_sequential: Core_run.action_request -> driverM unit
let action_request_sequential = function
  | Core_run.AllocRequest loc sb_edges dd_edges asw_edges aid tid pref align_ival size_ival mk_th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST ALLOC") in (* DEBUG *)
      liftMem (Mem.allocate_dynamic tid pref align_ival size_ival) >>= fun ptrval ->
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid (mk_th_st' ptrval) dr_st.core_state;
          trace= ME_allocate_dynamic tid pref align_ival size_ival ptrval :: dr_st.trace
        |>
      )
  
  | Core_run.CreateRequest loc sb_edges dd_edges asw_edges aid tid pref align_ival lvalue_ty init_opt mk_th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST CREATE") in (* DEBUG *)
      liftMem (Mem.allocate_static tid pref align_ival lvalue_ty init_opt) >>= fun ptrval ->
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid (mk_th_st' ptrval) dr_st.core_state;
          trace= ME_allocate_static tid pref align_ival lvalue_ty init_opt ptrval :: dr_st.trace
        |>
      )
  
  | Core_run.LoadRequest loc sb_edges dd_edges asw_edges aid tid mo lvalue_ty ptr_val _ mk_th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST LOAD") in (* DEBUG *)
      liftMem (Mem.load loc lvalue_ty ptr_val) >>= fun (fp, mval) ->
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid (mk_th_st' mval) dr_st.core_state;
          trace= ME_load loc lvalue_ty ptr_val mval :: dr_st.trace
        |>
      )
  
  | Core_run.StoreRequest loc sb_edges dd_edges asw_edges aid tid mo lvalue_ty is_locking ptr_val mem_val th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST STORE") in (* DEBUG *)
      (* TODO: need to make memory layout detect unsequenced races (use to make
         the concurency to the check even in the sequential mode) *)
      liftMem (Mem.store loc lvalue_ty is_locking ptr_val mem_val) >>= fun fp ->
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
          trace= ME_store loc lvalue_ty is_locking ptr_val mem_val :: dr_st.trace
        |>
      )
  
  | Core_run.RMWRequest loc sb_edges dd_edges asw_edges aid tid mo1 mo2 lvalue_ty ptr_val mval_expected mval_actual th_st' ->
      error "WIP: Driver.seq ==> RMWRequest"
  
  | Core_run.FenceRequest loc sb_edges dd_edges asw_edges aid tid mo th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST FENCE") in (* DEBUG *)
      ND.update (fun dr_st ->
        update_core_state (Core_run.update_thread_state tid th_st' dr_st.core_state) dr_st
      )
  
  | Core_run.KillRequest loc sb_edges dd_edges asw_edges aid tid is_dynamic ptr_val th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST KILL") in (* DEBUG *)
      liftMem (Mem.kill loc is_dynamic ptr_val) >>
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
          trace= ME_kill loc is_dynamic ptr_val :: dr_st.trace
        |>
      )
end




val perform_action_request: bool -> Core_run.core_runM Core_run.action_request -> driverM unit
let perform_action_request with_concurrency request_m =
  (* DEBUG *) ND.print_debug 9 [Debug.DB_driver] (fun () -> "Step_action_request") >>
  liftCore_run request_m >>= fun request ->
  
  let execution_mode_is_random = match Global.current_execution_mode () with
    | Nothing   -> false
    | Just mode -> mode = Global.Random
  end in
  
  begin
    if with_concurrency then
      action_request_concurrency request >>
      if execution_mode_is_random then
        ND.get >>= fun dr_st ->
        let total = number_of_uncommitted dr_st.concurrency_state in
        let choices = Enum.enumFromTo 0 total in
        
        (* DEBUG *)
        let _ = if choices = [] then error "BOOM" else () in
        
        ND.pick (SK_misc ["driver 1"]) choices >>= fun n ->
        ND.warns_if_no_active_ex (stepConcurrency n)
      else
        ND.return ()
    else
      action_request_sequential request
  end 


val     driver: bool -> driverM unit
let rec driver with_concurrency =
  let process_core_step2 = function
  | Core_run.Step_action_request _ request_m ->
      perform_action_request with_concurrency request_m >>
      driver with_concurrency
  | Core_run.Step_memop_request memop cvals tid mk_th_st ->
      match (memop, cvals) with
        | (Mem_common.Ptrdiff, [Core.Vctype ty; Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
            liftMem (Mem.diff_ptrval ty ptr_val1 ptr_val2) >>= fun ival ->
            ND.return (mk_th_st (Core.Vobject (Core.OVinteger ival)))
        
        | (Mem_common.IntFromPtr, [Core.Vctype ref_ty; Core.Vctype (Core_ctype.Basic (AilTypes.Integer ity)); Core.Vobject (Core.OVpointer ptr_val)]) ->
            liftMem (Mem.intcast_ptrval ref_ty ity ptr_val) >>= fun ival ->
            ND.return (mk_th_st (Core.Vobject (Core.OVinteger ival)))
        
        | (Mem_common.PtrFromInt, [Core.Vctype ty; Core.Vctype ref_ty; Core.Vobject (Core.OVinteger ival)]) ->
            liftMem (Mem.ptrcast_ival ty ref_ty ival) >>= fun ptrval ->
            ND.return (mk_th_st (Core.Vobject (Core.OVpointer ptrval)))
        
        | (Mem_common.PtrValidForDeref, [Core.Vctype ref_ty; Core.Vobject (Core.OVpointer ptr_val)]) ->
            liftMem (Mem.validForDeref_ptrval ref_ty ptr_val) >>= fun is_valid ->
            ND.return (mk_th_st (if is_valid then Core.Vtrue else Core.Vfalse))
        
        | (Mem_common.PtrEq, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
            ND.print_debug 2 [Debug.DB_driver] (fun () -> "PtrEq") >> (* DEBUG *)
            liftMem (Mem.eq_ptrval ptr_val1 ptr_val2) >>= fun is_eq ->
            ND.return (mk_th_st (if is_eq then Core.Vtrue else Core.Vfalse))
        
        | (Mem_common.PtrNe, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
            liftMem (Mem.ne_ptrval ptr_val1 ptr_val2) >>= fun is_ne ->
            ND.return (mk_th_st (if is_ne then Core.Vtrue else Core.Vfalse))
        
        | (Mem_common.PtrLt, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
            liftMem (Mem.lt_ptrval ptr_val1 ptr_val2) >>= fun is_lt ->
            ND.return (mk_th_st (if is_lt then Core.Vtrue else Core.Vfalse))
        
        | (Mem_common.PtrGt, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
            liftMem (Mem.gt_ptrval ptr_val1 ptr_val2) >>= fun is_gt ->
            ND.return (mk_th_st (if is_gt then Core.Vtrue else Core.Vfalse))
        
        | (Mem_common.PtrLe, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
            liftMem (Mem.le_ptrval ptr_val1 ptr_val2) >>= fun is_le ->
            ND.return (mk_th_st (if is_le then Core.Vtrue else Core.Vfalse))
        
        | (Mem_common.PtrGe, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
            liftMem (Mem.ge_ptrval ptr_val1 ptr_val2) >>= fun is_ge ->
            ND.return (mk_th_st (if is_ge then Core.Vtrue else Core.Vfalse))
        
        | (Mem_common.Memcpy, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2);
                               Core.Vobject (Core.OVinteger size_ival)]) ->
            liftMem (Mem.memcpy ptr_val1 ptr_val2 size_ival) >>= fun res ->
            ND.return (mk_th_st (Core.Vobject (Core.OVpointer res)))
        
        | (Mem_common.Memcmp, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2);
                               Core.Vobject (Core.OVinteger size_ival)]) ->
            liftMem (Mem.memcmp ptr_val1 ptr_val2 size_ival) >>= fun res ->
            ND.return (mk_th_st (Core.Vobject (Core.OVinteger res)))
        
        | (Mem_common.PtrWellAligned, [Core.Vctype ref_ty; Core.Vobject (Core.OVpointer ptrval)]) ->
            liftMem (Mem.isWellAligned_ptrval ref_ty ptrval) >>= fun b ->
            ND.return (mk_th_st (if b then Core.Vtrue else Core.Vfalse))
        
        | (Mem_common.Realloc, [Core.Vobject (Core.OVinteger align_ival); Core.Vobject (Core.OVpointer old_ptr);
                               Core.Vobject (Core.OVinteger size_ival)]) ->
            liftMem (Mem.realloc tid align_ival old_ptr size_ival) >>= fun res ->
            ND.return (mk_th_st (Core.Vobject (Core.OVpointer res)))

        | (Mem_common.PtrArrayShift, [Core.Vobject (Core.OVpointer ptrval); Core.Vctype ty; Core.Vobject (Core.OVinteger n_ival)]) ->
            liftMem (Mem.eff_array_shift_ptrval ptrval ty n_ival) >>= fun res ->
            ND.update (fun dr_st ->
              <| dr_st with
                trace= ME_eff_array_shift_ptrval ptrval ty n_ival res :: dr_st.trace
              |>
            ) >>
            ND.return (mk_th_st (Core.Vobject (Core.OVpointer res)))

        | (Mem_common.Va_start, [Core.Vlist _ ty_cvals]) ->
            let ty_ptrs =
              List.map (function
                | Core.Vtuple [Core.Vctype ty; Core.Vobject (Core.OVpointer ptr)] -> (ty, ptr)
                | _ -> error "va_start"
              end) ty_cvals in
            liftMem (Mem.va_start ty_ptrs) >>= fun res ->
            ND.return (mk_th_st (Core.Vobject (Core.OVinteger res)))

        | (Mem_common.Va_copy, [Core.Vobject (Core.OVinteger va)]) ->
            liftMem (Mem.va_copy va) >>= fun res ->
            ND.return (mk_th_st (Core.Vobject (Core.OVinteger res)))

        | (Mem_common.Va_arg, [Core.Vobject (Core.OVinteger va); Core.Vctype ty]) ->
            liftMem (Mem.va_arg va ty) >>= fun res ->
            ND.return (mk_th_st (Core.Vobject (Core.OVpointer res)))

        | (Mem_common.Va_end, [Core.Vobject (Core.OVinteger va)]) ->
            liftMem (Mem.va_end va) >>
            ND.return (mk_th_st Core.Vunit)

        | _ ->
            error ("WIP memop request: " ^ show memop ^ " ==> " ^ Pp.stringFromCore_value (Core.Vtuple cvals) )
      end >>= fun th_st' ->
      ND.update (fun dr_st ->
        update_core_state (Core_run.update_thread_state tid th_st' dr_st.core_state) dr_st
      ) >>
      driver with_concurrency

  | Core_run.Step_tau d_info _ _ ->
      error ("FOUND A TAU: '" ^ show d_info ^ "'")
  | Core_run.Step_eval d_info _ ->
      error ("FOUND AN EVAL: '" ^ show d_info ^ "'")

(*
  | Step_thread_done of thread_id * Core.value
  | Step_blocked
  | Step_error of string
  | Step_branch of (* DEBUG *) string * (Constraints.t -> Constraints.t) * (Constraints.t -> Constraints.t) * core_runM thread_state * core_runM thread_state
*)
  | Core_run.Step_done cval ->
      ND.print_debug 3 [Debug.DB_driver] (fun () -> "driver.process_core_step ==> Step_done with value: " ^ Pp.stringFromCore_value cval) >> (* DEBUG *)
      ND.return ()
(*
  | Step_spawn_threads of list thread_state (* initial states for the children *)
*)
  | _ ->
      error "Driver.driver, wrong Step_"
  end in

(*  ND.collapse $ *) (* TODO: need to write lots of Eq instances for this to work ... *)
  drive_core_threads () >>
  ND.get >>= fun post_core_dr_st ->
  
    (* TODO: hackish *)
    let non_blocked_th_sts = List.filter (fun (tid, th_info) ->
      List.any (fun step -> step <> Core_run.Step_blocked) $ Core_run.core_thread_step2 post_core_dr_st.layout_state post_core_dr_st.core_file post_core_dr_st.core_extern post_core_dr_st.symbolic_assoc tid th_info
    ) post_core_dr_st.core_state.Core_run.thread_states in
  
  (if Global.current_execution_mode () = Just Global.Random then
    (* HACK The problem is that some threads are blocked (they wait
       for other threads to finish. If we randomly pick that thread to
       execute, there will not be any steps to execute, and the whole
       execution comes to a halt. To properly solve this, we need to
       implement back tracking. Since we haven't, we temporarily
       switch to exhaustive mode and also compute the steps of the
       other threads. *)
    
    ND.print_debug 6 [Debug.DB_driver] (fun () -> "FIRST: " ^ show (List.length post_core_dr_st.core_state.Core_run.thread_states) ^ " vs " ^ show (List.length non_blocked_th_sts)) >>
    ND.bindExhaustive (ND.pick (SK_misc ["driver 2"]) (* post_core_dr_st.core_state.thread_states *) non_blocked_th_sts)
                      (fun (tid, th_info) ->
(* OLD                       ND.return $ core_thread_step post_core_dr_st.core_file th_info post_core_dr_st.core_state) *)
                       ND.pick (SK_misc ["driver 3"]) $ Core_run.core_thread_step2 post_core_dr_st.layout_state post_core_dr_st.core_file post_core_dr_st.core_extern post_core_dr_st.symbolic_assoc tid th_info)
    

   else
    ND.print_debug 6 [Debug.DB_driver] (fun () -> "SECOND") >>
(*
     ND.pick (* post_core_dr_st.core_state.thread_states *) non_blocked_th_sts >>= fun th_info ->
     ND.return (core_thread_step post_core_dr_st.core_file th_info post_core_dr_st.core_state)
*)
    ND.pick (SK_misc ["driver 4"]) non_blocked_th_sts >>= fun (tid, th_info) ->
    ND.pick (SK_misc ["driver 5"]) (Core_run.core_thread_step2 post_core_dr_st.layout_state post_core_dr_st.core_file post_core_dr_st.core_extern post_core_dr_st.symbolic_assoc tid th_info)
  ) >>=
      process_core_step2 (*post_core_dr_st*)







val     hack: map Symbol.sym Symbol.sym -> list (map Symbol.sym Core.value) -> Mem.mem_state -> Core.file Core_run.core_run_annotation -> map Symbol.sym Core.object_value -> Core.pexpr -> Core.value
let rec hack core_extern env mem_st core_file concur_sym_map pexpr =
  let () = Debug.print_debug 1 [] (fun () -> "XX 25") in
  match Core_eval.step_eval_pexpr 0 (Loc.other "Driver.hack") core_extern env (Just mem_st) core_file false pexpr with
    | Exception.Result (Undefined.Defined pexpr') ->
        match Core_aux.valueFromPexpr pexpr' with
          | Just cval ->
              cval
          | Nothing ->
              hack core_extern env mem_st core_file concur_sym_map pexpr'
        end
    | _ ->
        error ("Driver.hack, UNDEF/ERROR:" ^ Pp.stringFromCore_pexpr pexpr)
(*
    | _ ->
        (* TODO: this is wrong *)
        expr
*)
end

(*

let finalize_constraints mem_st core_file concur_sym_map (Constraints.Constraints symbs) =
  Constraints.Constraints $ List.map (function
    | Symbolic.SYMBop op symb1 symb2 ->
        error "WIP Driver.finalize_constraints"
*)
(*

(*
        let Just symb1' = match hack core_file (Core.PEval (Core.Vinteger (Mem.symbolic_ival symb1))) with
                            | Core.Vinteger ival ->
                                Mem_aux.symbolicFromIntegerValue ival
                          end in
        let Just symb2' = match hack core_file (Core.PEval (Core.Vinteger (Mem.symbolic_ival symb2))) with
                            | Core.Vinteger ival ->
                                Mem_aux.symbolicFromIntegerValue ival
                          end in
*)
        match (hack mem_st core_file concur_sym_map (Core.PEval (Core.Vobject (Core.OVsymbolic symb1))),
               hack mem_st core_file concur_sym_map (Core.PEval (Core.Vobject (Core.OVsymbolic symb2)))) with
          | (Core.Vobject (Core.OVsymbolic symb1'), Core.Vobject (Core.OVsymbolic symb2')) ->
   let _ = Boot.print_debug 2 ("finalize_constr ==> " ^ stringFromSymbolic symb1 ^ " <-> " ^ stringFromSymbolic symb2) in
              Symbolic.SYMBop op symb1' symb2'
          | (Core.Vobject (Core.OVsymbolic symb1'), Core.Vobject oval2') ->
              Symbolic.SYMBop op symb1' (Symbolic.SYMBconst oval2')
          | (cval1, cval2) ->
              error ("Driver.finalize_constraints ==> " ^ stringFromValue cval1 ^ " <-> " ^ stringFromValue cval2)
        end
    | symb ->
        symb
  end) symbs
*)


type driver_result = <|
  dres_blocked: bool;
  dres_concurrency_state: Cmm_op.symState;
  dres_driver_steps: nat;
  dres_core_value: Core.value;
  dres_stdout: string;
  dres_stderr: string;
|>


val finalize: string -> driver_state -> driver_result (* (string * (bool * Cmm_op.symState * Core.value) * (nat * nat)) *)
let finalize debug_str dr_st =
  match dr_st.core_state.Core_run.thread_states with
    | [(tid, (_, th_st))] ->
        let cval = hack dr_st.core_extern th_st.Core_run.env dr_st.layout_state dr_st.core_file dr_st.symbolic_assoc
            match Core_aux.to_pure th_st.Core_run.arena with
(*
              | Just (Core.PEval (Core.Vinteger ival)) ->
                  let Just symb = Mem_aux.symbolicFromIntegerValue ival in
                  Core_aux.unsymbolify symb
*)
              | Just pe ->
                  pe
              | Nothing ->
                  error ("Driver.finalize: the arena wasn't pure ==> " ^ Pp.stringFromCore_expr th_st.Core_run.arena)
            end in
        <|
          dres_blocked= dr_st.blocked;
          dres_concurrency_state= dr_st.concurrency_state;
          dres_driver_steps= dr_st.dr_step_counter;
          dres_core_value= cval;
          dres_stdout= List.foldr String.stringAppend "" (Dlist.toList dr_st.core_state.Core_run.io.Core_run.stdout);
          dres_stderr= List.foldr String.stringAppend "" (Dlist.toList dr_st.core_state.Core_run.io.Core_run.stderr);
        |>
    | xs ->
        let () = Debug.print_debug 3 [Debug.DB_driver] (fun () -> "ERROR (end of the Driver)\n" ^ stringFromCore_core_state dr_st.core_state) in (* DEBUG *)
        error ("BOOM finalize [" ^ debug_str ^ "]")
  end







(* TODO: it is problematic for proofy backend that this function may diverge *)
(* TODO: HACK *)
let initial_driver_state file fs_state =
(*
  let mk_dr_st core_st run_st = <|
    symbol_supply=     UniqueId.new_supply;
    core_file=         file;
    core_state=        initial_core_state;
    core_run_state=    initial_core_run_state;
    concurrency_state= initialExeState emptyPreEx;
    
    (* TODO: uber hack *)
    sequential_state= Map.empty;
    blocked= false;
    trace= [];
  |> in
  let (core_st, run_st) =
    match SEU.run (init file) initial_core_run_state with
      | Exception.Result (U.Defined core_st, run_st) ->
          (core_st, run_st)
      | _ ->
          error "failed to build initial driver state"
    end in
  mk_dr_st core_st run_st
*)
  <|
    core_file=         file;
    core_extern=       Core_linking.create_extern_symmap file;
    core_state=        Core_run.initial_core_state;
    core_run_state=    Core_run.initial_core_run_state (Caux.collect_labeled_continuations_NEW file);
    layout_state=      Mem.initial_mem_state;
    concurrency_state= Cmm_op.symInitialState Cmm_op.symInitialPre;
    fs_state=          fs_state;
    trace=             [];


  symbolic_assoc= Map.empty;
    (* TODO: uber hack *)
(*    sequential_state= Map.empty; *)
    blocked= false;
    
    dr_step_counter= 0;
  |>




val spawn_thread: maybe Core_ctype.thread_id -> Core_run.thread_state -> driverM Core_ctype.thread_id
let driver_spawn_thread parent_tid_opt th_st =
  ND.get >>= fun dr_st ->
  let ((tid, core_st'), run_st') = State.runStateM (
    Core_run.spawn_thread parent_tid_opt th_st dr_st.core_state
  ) dr_st.core_run_state in
  ND.update (fun dr_st -> <| dr_st with
    core_state= core_st';
    core_run_state= run_st';
  |>) >>
  ND.return tid
let inline spawn_thread = driver_spawn_thread

val update_thread_state: Core_ctype.thread_id -> Core_run.thread_state -> driverM unit
let driver_update_thread_state tid th_st =
  ND.update (fun dr_st ->
    <| dr_st with core_state= Core_run.update_thread_state tid th_st dr_st.core_state |>
  )
let inline update_thread_state = driver_update_thread_state

val driver_globals: bool -> Core.file Core_run.core_run_annotation -> driverM Core_ctype.thread_id
let driver_globals with_concurrency file =
  (* spawning a thread for the initialisation of globals, and later the execution of main *)
  spawn_thread Nothing <|
    (* NOTE: the Eskip is just a placeholder, the thread is given its actual state later *)
    Core_run.arena=  Core.Expr [] Core.Eskip;
    Core_run.stack=  Core_aux.push_empty_continuation Nothing Core_aux.empty_stack;
    Core_run.errno=  Mem.null_ptrval Core_ctype.signed_int;
    Core_run.env= [Map.empty];
    Core_run.current_loc= Loc.unknown;
    Core_run.exec_loc= Core_run.ELoc_globals;
  |> >>= fun tid0 ->
  
  ND.read (fun dr_st ->
    dr_st.core_file.Core.globs
  ) >>= fun globs ->
  let glob_defs = List.reverse $ List.foldl (fun acc (sym, glb) ->
    match glb with
    | Core.GlobalDef bTy e -> (sym, bTy, e) :: acc
    | Core.GlobalDecl _ -> acc
    end) [] globs
  in
  ND.mapM_ (fun (glob_sym, glob_bTy, expr) ->
    let () = Debug.print_debug 6 [Debug.DB_driver] (fun () ->      (* DEBUG *)
      "Starting the evaluation of global `" ^ show glob_sym ^ "'"  (* DEBUG *)
    ) in                                                           (* DEBUG *)
    (* setting up the initialisation of the current global in thread 0 *)
    get_thread_states >>= function
      | [(_, (_, th_st))] ->
        update_thread_state tid0 <|
          (* the previously evaluated globals are substituted in the body of the
             global we are about to evaluate *)
          Core_run.arena= expr;
          Core_run.stack= Core_aux.push_empty_continuation Nothing Core_aux.empty_stack;
          Core_run.env= th_st.Core_run.env;
    (*      Core_run.labels= Map.empty; *)
          Core_run.errno=  Mem.null_ptrval Core_ctype.signed_int;
          Core_run.current_loc= Loc.other ("global(" ^ show glob_sym ^ ")"); (* TODO: preserve locations in Core.globs *)
          Core_run.exec_loc= Core_run.ELoc_globals;
        |>
      | _ ->
          error "ERROR (in Driver, global init didn't evaluate to value)"
    end >>= fun () ->
    
    (* evaluation of the initialisation *)
    driver with_concurrency >>= fun () ->
    
    get_thread_states >>= function
      | [(_, (_, th_st))] ->
          (* TODO: technically the arena should always be a value at this point *)
          match Core_aux.to_pure th_st.Core_run.arena with
            | Just pe ->
                match Core_aux.valueFromPexpr pe with
                  | Nothing ->
                      error "WIP: driver_globals"
                  | Just cval ->
                      update_thread_state tid0
                        <| th_st with
                            Core_run.env = Core_aux.update_env (Core.Pattern [] (Core.CaseBase (Just (glob_sym), glob_bTy))) cval th_st.Core_run.env
                        |>
                        (*

                      ND.update (fun dr_st ->
                        <| dr_st with
                          core_run_state=
                            <| dr_st.core_run_state with Core_run.env= Core_aux.update_env (Core.Pattern [] (Core.CaseBase (Just (glob_sym), glob_bTy))) cval dr_st.core_run_state.Core_run.env |>
                        |>
                     ) *)
                end
            | Nothing ->
                error "TODO(msg): Driver.driver_globals, the end of the evaluation of a glob didn't produce a value"
          end
      | _ ->
          error "ERROR (in Driver, global init didn't evaluate to value)"
    end
  ) glob_defs >>
  ND.return tid0



val pp_exeState: Cmm_op.symState -> string
declare ocaml target_rep function pp_exeState = `Pp_cmm.pp_execState`

(*
let rec process_integer_value_base sym_assoc = function
  | (IVconcurRead _ sym as ival_) ->
      match Map.lookup sym sym_assoc with
        | Just (Core.OVinteger (IV _ ival_)) ->
            process_integer_value_base sym_assoc ival_
        | Nothing ->
            ival_
      end
  | IVop iop ivals_ ->
      IVop iop (List.map (process_integer_value_base sym_assoc) ivals_)
  | ival_ ->
      (* WIP *)
      ival_
end


(* TODO: move somewhere else, and do it nicer *)
let rec process_objet_value sym_assoc = function
  | (Core.Vobject (Core.OVinteger (IV prov ival_)) as cval) ->
      let ival_' =
        Defacto_memory_aux2.lifted_simplify_integer_value_base (process_integer_value_base sym_assoc ival_) in
      Core.Vobject (Core.OVinteger (IV prov ival_'))
  | (Core.Vloaded (Core.LVspecified (Core.OVinteger (IV prov ival_))) as cval) ->
      let ival_' =
        Defacto_memory_aux2.lifted_simplify_integer_value_base (process_integer_value_base sym_assoc ival_) in
      Core.Vloaded (Core.LVspecified (Core.OVinteger (IV prov ival_')))
(*
  | (Core.Vobject (Core.OVinteger (Defacto_memory_types.IV _ (Defacto_memory_types.IVconcurRead _ sym))) as cval) ->
      match Map.lookup sym sym_assoc with
        | Just oval ->
            process_objet_value sym_assoc (Core.Vobject oval)
        | Nothing ->
            cval
      end
  | (Core.Vspecified (Core.OVinteger (Defacto_memory_types.IV _ (Defacto_memory_types.IVconcurRead _ sym))) as cval) ->
      match Map.lookup sym sym_assoc with
        | Just oval ->
            process_objet_value sym_assoc (Core.Vspecified oval)
        | Nothing ->
            cval
      end
*)
  | cval ->
      cval
end
*)



val drive: bool -> bool -> Core.file Core_run.core_run_annotation -> list string -> driverM driver_result
let drive (with_concurrency: bool) (use_experimental_unseq: bool) file (arg_strs: list string) =
  (* Setting the read-only tag definitions (used by the memory model) *)
(*
TODO: this should be removable, since we already set it in Translation
  let () = Core_ctype_aux.set_tagDefs file.Core.tagDefs in
*)
  (* first we execute the body of global definitions and remove their symbols
     from the rest of the program *)
  driver_globals with_concurrency file >>= fun tid0 (*, post_globals_dr_st) *) ->
  ND.get >>= fun post_globals_dr_st ->
  
  (* we need a startup function to have been declared *)
  match post_globals_dr_st.core_file.Core.main with
    | Just sym ->
        ND.return sym
    | Nothing ->
        ND.kill (ND.Other (DErr_other "no startup function was declared"))
  end >>= fun main_sym ->
  
  (* setting the arena of thread 0 to the body of the main function *)
  match Map.lookup main_sym post_globals_dr_st.core_file.Core.funs with
    | Nothing ->
        ND.kill (ND.Other (DErr_other "couldn't find the startup function"))
    
    | Just decl ->
        match decl with
          | Core.Fun  _ params pe ->
              ND.return (Loc.other "main args", params, Core.Expr [] (Core.Epure pe))
          | Core.ProcDecl _ _ _ ->
              ND.kill (ND.Other (DErr_other "the startup function has no definition"))
          | Core.BuiltinDecl _ _ _ ->
              ND.kill (ND.Other (DErr_other "the startup function has no definition"))
          | Core.Proc loc _ params e ->
              ND.return (loc, params, e)
        end >>= fun (loc, params, expr) ->
        
        match params with
          | [(argc_sym, _); (argv_sym, _)] ->
              (* memory_values to be stored in memory objects pointed to by
                 the element of main.argv  *)
              let args_mem_val_tys =
                List.map (fun arg_str ->
                  let mem_vals =
                    List.map (fun c ->
                      (* TODO: fixing impl choice here (ASCII) *)
                      Mem.integer_mval AilTypes.Char $ Decode.decode_character_constant (String.toString [c])
                    ) (String.toCharList arg_str) in
                  (* NOTE: adding a null termination to the char array *)
                  (
                    Mem.array_mval $ mem_vals ++ [Mem.integer_mval AilTypes.Char 0],
                    Core_ctype.Array Core_ctype.char (Just $ (integerFromNat $ List.length mem_vals) + 1)
                  )
                ) arg_strs in
              
              (* memory value to be stored in the memory object pointed to by main.argc *)
              let argc_mem_val = Mem.integer_mval (AilTypes.Signed AilTypes.Int_) (integerFromNat $ List.length args_mem_val_tys) in
              
              (* allocating and initialising an object for main.argc *)
              liftMem (
                Mem.bind (Mem.allocate_static tid0 (Symbol.PrefSource loc [main_sym; argc_sym])
                            (Mem.alignof_ival Core_ctype.signed_int) Core_ctype.signed_int Nothing) (fun ptr_val ->
                  Mem.bind (Mem.store (Loc.other "argc init") Core_ctype.signed_int false ptr_val argc_mem_val) (fun _ ->
                    Mem.return ptr_val
                  )
                )
              ) >>= fun argc_ptr_val ->
              
              (* allocating and initialising the objects pointed to by the elements of argv *)
              ND.foldlM (fun ptr_vals (arg_mem_val, arg_ty) ->
                liftMem (
                  Mem.bind (Mem.allocate_static tid0 (Symbol.PrefOther "argv refs") (Mem.alignof_ival arg_ty) arg_ty Nothing) (fun ptr_val ->
                    Mem.bind (Mem.store (Loc.other "argv refs init") arg_ty false ptr_val arg_mem_val) (fun _ ->
                      Mem.return (ptr_val :: ptr_vals)
                    )
                  )
                )
              ) [] args_mem_val_tys >>= fun ptr_vals_rev ->
              
              (* allocating and initialising an object for main.argv *)
              (* NOTE: the element argv[argc] is required to be a null pointer
                 by the STD, hence argv has one more element than the number
                 of supplied arguments *)
              let argv_array_elem_ty = Core_ctype.Pointer AilTypes.no_qualifiers Core_ctype.char in
              let argv_array_ty = Core_ctype.Array argv_array_elem_ty (Just (1 + (integerFromNat $ List.length ptr_vals_rev))) in
              let argv_array_mem_val = Mem.array_mval $
                List.map (Mem.pointer_mval Core_ctype.char) (List.reverse ptr_vals_rev ++ [Mem.null_ptrval Core_ctype.char]) in
              liftMem (
                Mem.bind (Mem.allocate_static tid0 (Symbol.PrefSource loc [main_sym; argv_sym(*TODO: change the sym?*)])
                            (Mem.alignof_ival argv_array_ty) argv_array_ty Nothing) (fun array_ptr_val ->
                Mem.bind (Mem.store (Loc.other "argv array init") argv_array_ty false array_ptr_val argv_array_mem_val) (fun _ ->
                
                (* NOTE: because of argument promotions, the char *argv[] is turned into a char **argv
                   so two objects are allocated: an array and a pointer to that array (which is what argv designate) *)
                let argv_ty = Core_ctype.Pointer AilTypes.no_qualifiers (Core_ctype.Pointer AilTypes.no_qualifiers Core_ctype.char) in
                Mem.bind (Mem.allocate_static tid0 (Symbol.PrefSource loc [main_sym; argv_sym])
                            (Mem.alignof_ival argv_ty) argv_ty Nothing) (fun argv_ptr_val ->
                Mem.bind (Mem.store (Loc.other "argv init") argv_ty false argv_ptr_val
                            (Mem.pointer_mval (Core_ctype.Pointer AilTypes.no_qualifiers Core_ctype.char) array_ptr_val)) ( fun _ ->

                Mem.return argv_ptr_val
                ))))
              ) >>= fun argv_ptr_val ->
              (* Adding the values of argc and argv to the Core symbol environment *)
              get_thread_states >>= function
                | [(_, (_, th_st))] ->
                  update_thread_state tid0
                    <| th_st with
                        Core_run.env =
                          match th_st.Core_run.env with
                            | [] ->
                                [Map.fromList [ (argc_sym ,Core.Vobject (Core.OVpointer argc_ptr_val))
                                              ; (argv_sym, Core.Vobject (Core.OVpointer argv_ptr_val)) ]]
                            | (xs :: xs') ->
                                (Map.insert argc_sym (Core.Vobject (Core.OVpointer argc_ptr_val))
                                  (Map.insert argv_sym (Core.Vobject (Core.OVpointer argv_ptr_val)) xs)) :: xs'
                          end
                   |>
                | _ ->
                    error "ERROR (in Driver 1)"
              end >>= fun () ->
              ND.return expr
          | _ ->
              ND.return expr
        end >>= fun expr ->
        
        (* allocating and initialising errno *)
        liftMem (
          Mem.bind (Mem.allocate_static tid0 (Symbol.PrefOther "errno") (Mem.alignof_ival Core_ctype.signed_int) Core_ctype.signed_int Nothing) (fun ptr_val ->
            let zero = Mem.integer_value_mval (AilTypes.Signed AilTypes.Int_) (Mem.integer_ival 0) in
            Mem.bind (Mem.store (Loc.other "errno init") Core_ctype.signed_int false ptr_val zero) (fun _ ->
              Mem.return ptr_val
            )
          )
        ) >>= fun errno_ptr_val ->
        
        get_thread_states >>= function
          | [(_, (_, th_st))] ->
              update_thread_state tid0 <|
                Core_run.arena= expr;
                Core_run.stack= Core_aux.push_empty_continuation (Just main_sym) Core_aux.empty_stack;
                Core_run.errno= errno_ptr_val;
                Core_run.current_loc= Loc.other "Driver.drive";
                Core_run.exec_loc= Core_run.ELoc_normal [main_sym];
                Core_run.env = th_st.Core_run.env;
              |>
          | _ ->
              error "ERROR (in Driver 2)"
        end >>
        driver with_concurrency >>
        
        if with_concurrency then
          error "CONCURRENCY IS BROKEN"
(*
          let dr_st' = repair_pre_execution dr_st' in
          let n     = number_of_uncommitted dr_st'.concurrency_state in
          ND.log ("Calling concurrency " ^ show n ^ " times\n") >> (* DEBUG *)
          ND.apply_to_constraints (finalize_constraints dr_st'.layout_state dr_st'.core_file dr_st'.symbolic_assoc) (stepConcurrency n dr_st') >>= fun dr_st' ->
          (* TODO: tmp *)
          ND.log ("UNCOMMITED ==> " ^ show (number_of_uncommitted dr_st'.concurrency_state)) >> (* DEBUG *)
            (* TODO: the current function should return a Core.value inside an
               undef/error monad. Not a Core.pexpr like we currently do *)
            match dr_st'.concurrency_state.Cmm_op.symUndefinedness with
              | [] ->
                  let (str, (is_blocked, conc_st, cval), steps) = finalize "drive (with concur)" dr_st' in
                  ND.print_debug 2 [Debug.DB_driver] (fun () -> "FINAL VALUE IS " ^ Pp.stringFromCore_value cval) >>
                  ND.print_debug 2 [Debug.DB_driver] (fun () -> "BEGIN SYMBOLIC ASSOC") >>
                  let _ = Map.mapi (fun sym oval ->
                    Debug.print_debug 2 [Debug.DB_driver] (fun () -> show sym ^ " == " ^ Pp.stringFromCore_value (Core.Vobject oval))
                  ) dr_st'.symbolic_assoc in
                  
                  let cval = process_objet_value dr_st'.symbolic_assoc cval in
                  ND.print_debug 2 [Debug.DB_driver] (fun () -> "CLEANED FINAL VALUE IS " ^ Pp.stringFromCore_value cval) >>
                  
                  
                  ND.return (str, (is_blocked, conc_st, Core.Pexpr [] () (Core.PEval cval)), steps)
              | (Cmm.DataRaces _)::_ ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st'.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Caux.mk_undef_pe U.UB005_data_race),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
              | (Cmm.UnsequencedRaces _)::_  ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st'.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Caux.mk_undef_pe U.UB035_unsequenced_race),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
              | (Cmm.IndeterminateReads _)::_  ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st'.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Caux.mk_undef_pe (U.DUMMY "Driver.drive -- Cmm.IndeterminateReads")),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
              | (Cmm.BadMutexes _)::_  ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st'.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Caux.mk_undef_pe (U.DUMMY "Driver.drive -- Cmm.BadMutexes")),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
              | Cmm.NotInSublanguage::_  ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st'.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Caux.mk_undef_pe (U.DUMMY "Driver.drive -- Cmm.NotInSublanguage")),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
            end
*)
        else
          ND.get >>= fun dr_st' ->
          ND.return (finalize "drive (without concur)" dr_st')
end
