open import Pervasives Cabs Std Show Show_extra
open import Utils
import Debug Pp Loc Errors Scope_table State_exception UniqueId Symbol

open import Cabs_to_ail_aux

import AilSyntax AilTypes AilTypesAux

import Map_extra

module A      = AilSyntax
module ATypes = AilTypes

open import {hol} `pp_ailTheory`


type tag_kind =
  (* TODO: we may be able to merge struct and union *)
  | Kind_struct
  | Kind_union
  | Kind_enum

(* STD §6.2.1#1, sentence 1 *)
type ordinary_kind = (* the ones that can have a linkage *)
  (* the boolean is true iff we are dealing with a function parameter (needed to determinate the linkage ...) *)
    (* TODO: should be a different ctor, but using a bool for now to make sure all the occurences
             of the normal Kind_object also apply to Kind_parameter_object *)
  | OK_object of bool
  | OK_function
  | OK_enum_constant
  | OK_typedef

type identifier_kind =
  | Kind_ordinary of ordinary_kind
  | Kind_tag of tag_kind
  | Kind_label
  | Kind_member of tag_kind
(*
  | Kind_macro_name
  | Kind_macro_parameter
*)

instance (Eq identifier_kind)
  let (=)  = unsafe_structural_equality
  let (<>) = unsafe_structural_inequality
end

instance (Show identifier_kind)
  let show = function
    | Kind_ordinary (OK_object false) ->
        "object"
    | Kind_ordinary (OK_object true) ->
        "parameter"
    | Kind_ordinary OK_function ->
        "function"
    | Kind_member Kind_struct ->
        "struct_member"
    | Kind_member Kind_union ->
        "union_member"
    | Kind_member Kind_enum ->
        "enum_member (TODO: this is invalid)"
    | Kind_ordinary OK_enum_constant ->
        "enum_constant"
    | Kind_tag Kind_struct ->
        "struct tag"
    | Kind_tag Kind_union ->
        "union tag"
    | Kind_tag King_enum ->
        "enum tag"
    | Kind_ordinary OK_typedef ->
        "typedef"
    | Kind_label ->
        "label"
  end
end

instance (SetType identifier_kind)
  let setElemCompare = defaultCompare
end


val is_object_kind: ordinary_kind -> bool
let is_object_kind = function
  | OK_object _ -> true
  | _           -> false
end

val is_parameter_object_kind: ordinary_kind -> bool
let is_parameter_object_kind = function
  | OK_object true -> true
  | _              -> false
end




(* STD §6.2.1#2 *)
type block_id = nat
type scope =
  | Scope_function
  | Scope_file
  | Scope_block of block_id
  | Scope_prototype

let scopeEqual sc1 sc2 =
  match (sc1, sc2) with
    | (Scope_function, Scope_function) ->
        true
    | (Scope_file, Scope_file) ->
        true
    | (Scope_block id1, Scope_block id2) ->
        id1 = id2
    | (Scope_prototype, Scope_prototype) ->
        true
    | _ ->
        false
  end

instance (Eq scope)
  let (=)  = scopeEqual
  let (<>) = fun x y -> not (scopeEqual x y)
end


(* TODO DEBUG *)
let string_of_scope = function
  | Scope_function ->
      "function"
  | Scope_file ->
      "file"
  | Scope_block n ->
      "block(" ^ show n ^ ")"
  | Scope_prototype ->
      "prototype"
end

let is_block_scope = function
  | Scope_block _ ->
      true
  | _ ->
      false
end




(* STD §6.2.3#1 *)
type namespace =
  | Namespace_label
  | Namespace_tag
  | Namespace_member of cabs_identifier (* NOTE: theses are only struct/union members *)
  | Namespace_ordinary (* NOTE: enumeration constants go here *)

instance (Show namespace)
  let show = function
    | Namespace_label ->
        "label"
    | Namespace_tag ->
        "tag"
    | Namespace_member ident ->
        "member{" ^ show ident ^ "}"
    | Namespace_ordinary ->
        "ordinary"
  end
end

instance (SetType namespace)
  let setElemCompare ns1 ns2 =
    let ord = function
      | Namespace_label ->
          (0 : nat)
      | Namespace_tag ->
          1
      | Namespace_member _ ->
          2
      | Namespace_ordinary ->
          3
    end in
    match (ns1, ns2) with
      | (Namespace_member ident1, Namespace_member ident2) ->
          setElemCompare ident1 ident2
      | _ ->
          setElemCompare (ord ns1) (ord ns2)
    end
end

type function_declaration =
  | FDeclPrototype of
        Loc.t
      * (ATypes.qualifiers * ATypes.ctype)
      * list (ATypes.qualifiers * ATypes.ctype * bool)
      * bool (* isVariadic *)
      * bool (* isInline *)
      * bool (* isNoReturn *)
  | FDeclEmptyParentheses of
        Loc.t
      * (ATypes.qualifiers * ATypes.ctype)
      * bool (* isVariadic *)
      * bool (* isInline *)
      * bool (* isNoReturn *)

type registration =
  | Internal of A.identifier * identifier_kind * maybe linkage
  | External

type global_definition =
  | Tentative of ATypes.ctype
  | Definition of A.expression unit
  | ExternalDefinition of A.expression unit

type state = <|
  (* Counter used to generate fresh cabs label names (see the desugaring of do-while statements) *)
  aux_supply: UniqueId.supply nat;
  (* Counter for the symbol generator *)
  symbol_supply: UniqueId.supply Symbol.sym;
  (* table (with stacked scopes) associating C identifiers to symbols *)
  
  registered_external_identifiers: map (cabs_identifier * namespace) (scope * (A.identifier * identifier_kind * maybe linkage));
  registered_identifiers: Scope_table.t scope (cabs_identifier * namespace) registration;
  
  (* TODO: this type of too large, maybe separate the namespaces into different maps under the scope table *)
(*
  registered_identifiers: Scope_table.t scope (cabs_identifier * namespace) (A.identifier * identifier_kind * maybe linkage);
*)
  
  tag_definitions: map A.identifier tag_definition;
  
  (* return type; parameters types; is_variadic; is_inline; is_Noreturn *)
  (* the first boolean records whether the function has a prototype *)
  (* the boolean in the parameters list tells whether there was a register storage-class *)
  function_declarations: map A.identifier (
    (*hasProto*)bool * Loc.t *
    ( (ATypes.qualifiers * ATypes.ctype)                     (* qualifier and return type *)
    * maybe (list (ATypes.qualifiers * ATypes.ctype * bool)) (* Nothing if there was no parameter type list,
                                                                the boolean is the isRegister flag *)
    * bool * bool * bool )                                   (* isVariadic, isInline, isNoReturn flags *)
   );
  external_object_declarations: map A.identifier  ((* isTentative *)bool * Loc.t * ATypes.storageDuration * (* isRegister *) bool * ATypes.qualifiers * ATypes.ctype);
  internal_object_declarations: map A.identifier  (Loc.t * ATypes.storageDuration * (* isRegister *) bool * ATypes.qualifiers * ATypes.ctype);
  
  function_definitions: map A.identifier (Loc.t * list A.identifier * A.statement unit);
  global_object_definitions: map A.identifier global_definition;
  
  (* TODO: I really don't like the potential lack of sync between the next field and registered_identifiers *)
  typedef_definitions: map A.identifier (ATypes.qualifiers * ATypes.ctype);
  
  static_assertions: list (A.expression unit * A.stringLiteral);
  
  (* STD §6.2.1#1, sentence 2 *)
  enumeration_constants: map A.identifier (A.expression_ unit);
  
  (* TODO: this is idiotically inefficient, should store here the converse *)
  (* list the object/functions actually used, so that we can forget everything else that is declared/defined.
     This is particularly useful when stdlib headers are included *)
  used_identifier: list A.identifier;
  current_return_type : ATypes.ctype;
  
  
  
  (* TODO TODO TODO *)
  core_eval_stuff: (map string Symbol.sym) * Core.fun_map unit * Core.impl;
|>

type desugM 'a = State_exception.stExceptM 'a state Errors.error

val return: forall 'a. 'a -> desugM 'a
let inline return = State_exception.return

val bind: forall 'a 'b. desugM 'a -> ('a -> desugM 'b) -> desugM 'b
let inline bind = State_exception.bind


val fail: forall 'a. Loc.t -> Errors.desugar_cause -> desugM 'a
let inline fail loc dcause = State_exception.fail (loc, Errors.DESUGAR dcause)



val mapM: forall 'a 'b. ('a -> desugM 'b) -> list 'a -> desugM (list 'b)
val mapM_: forall 'a 'b. ('a -> desugM 'b) -> list 'a -> desugM unit
let inline mapM = State_exception.mapM
let inline mapM_ = State_exception.mapM_

let inline foldlM = State_exception.foldlM
let inline foldrM = State_exception.foldrM

let inline iter = State_exception.iter

val tryWith: forall 'a. Errors.error -> desugM 'a -> desugM 'a
let inline tryWith = State_exception.tryWith

val fmap: forall 'a 'b. ('a -> 'b) -> desugM 'a -> desugM 'b
let inline fmap = State_exception.fmap

val app: forall 'a 'b. desugM ('a -> 'b) -> desugM 'a -> desugM 'b
let inline app  = State_exception.app


let inline (>>=)    = bind
let inline (>>) m f = m >>= fun _ -> f (* NOTE: the inline is important *)
let inline (<$>)    = fmap
let inline (<*>)    = app


val void: forall 'a. desugM 'a -> desugM unit
let cabs_to_ail_effect_void m =
  fmap (const ()) m
let inline void = cabs_to_ail_effect_void


val guard: forall 'a. desugM bool -> string -> desugM 'a -> desugM 'a
let cabs_to_ail_effect_guard m_pred err_msg m =
  m_pred >>= function
    | true  -> m
    | false -> error ("[Cabs_to_ail_effect] failed guard: " ^ err_msg ^ ".")
  end
let inline guard = cabs_to_ail_effect_guard

val liftException: forall 'a. Exception.exceptM 'a Errors.error -> desugM 'a
let inline liftException = State_exception.liftException

(* ========================================================================== *)
val current_scope_is: scope -> desugM bool
let cabs_to_ail_effect_current_scope_is scope =
  (* NOTE: it would be equivalent to use [registered_tag_declarations] *)
  State_exception.read (fun st -> Scope_table.current_scope_is st.registered_identifiers = scope)
let inline current_scope_is = cabs_to_ail_effect_current_scope_is

val scope_is_visible: scope -> desugM bool
let cabs_to_ail_effect_scope_is_visible scope =
  State_exception.read (fun st ->
    Scope_table.scope_is_visible scope st.registered_identifiers
  )
let inline scope_is_visible = cabs_to_ail_effect_scope_is_visible

val get_scope: desugM scope
let get_scope =
  (* NOTE: it would be equivalent to use [registered_tag_declarations] *)
  State_exception.read (fun st -> Scope_table.current_scope_is st.registered_identifiers)


val under_scope: forall 'a. scope -> desugM 'a -> desugM 'a
let under_scope scope m =
  State_exception.update (fun st ->
    let () = Debug.print_debug 3 [Debug.DB_desugaring] (fun () ->
      "ENTERING Scope: " ^ string_of_scope scope
    ) in
    <| st with registered_identifiers= Scope_table.create_scope scope st.registered_identifiers; |>
  ) >>
  m >>= fun res ->
  State_exception.update (fun st ->
    let (idents_map, ident_table') = Scope_table.destroy_scope st.registered_identifiers in
    let () = Debug.print_debug 3 [Debug.DB_desugaring] (fun () ->
      "EXITING Scope: " ^ string_of_scope scope
    ) in
    <| st with registered_identifiers= ident_table'; |> 
  ) >>
  return res


(* This is similary to 'under_scope', but it also returns the internal
   declarations that where declared while evaluating 'm' *)
(* NOTE: this only collect INTERNAL declarations, not the extern, static or
   _Thread_local ones *)
val collect_with_scope: forall 'a. scope -> desugM 'a -> desugM (A.bindings * 'a)
let collect_with_scope scope m =
  State_exception.update (fun st ->
    let () = Debug.print_debug 3 [Debug.DB_desugaring] (fun () ->
      "ENTERING Scope: " ^ string_of_scope scope
    ) in
    <| st with registered_identifiers= Scope_table.create_scope scope st.registered_identifiers; |>
  ) >>
  m >>= fun res ->
  State_exception.modify (fun st ->
    let (idents_map, ident_table') = Scope_table.destroy_scope st.registered_identifiers in
    let () = Debug.print_debug 3 [Debug.DB_desugaring] (fun () ->
      "EXITING Scope: " ^ string_of_scope scope
    ) in
    ( Set_helpers.fold (fun reg acc ->
      match reg with
        | Internal sym kind _ ->
            match kind with
              | Kind_ordinary (OK_object false) ->
                  match Map.lookup sym st.external_object_declarations with
                    | Just (isTentative, _, dur, isRegister, qs, ty) ->
                        (sym, ((dur, isRegister), qs, ty)) :: acc
                    | Nothing ->
                        match Map.lookup sym st.internal_object_declarations with
                          | Just (_, ATypes.Static, _, _, _) ->
                              acc
                          | Just (_, ATypes.Thread, _, _, _) ->
                              acc
                          | Just (loc, dur, isRegister, qs, ty) ->
                              (sym, ((dur, isRegister), qs, ty)) :: acc
                          | Nothing ->
                              (* TODO: check *)
                              acc
                       end
                  end
              | _ ->
                  (* TODO: functions *)
                  acc
            end
        | External ->
            let () = Debug.print_debug 1 [] (fun () ->
              "KKK: check this"
            ) in
            acc
       end) (Map.range idents_map) []
    ,  <| st with registered_identifiers= ident_table'; |> )
  ) >>= fun bs ->
  return (List.reverse bs, res)


(* TODO: rename *)
val with_scope2: forall 'a. scope -> desugM 'a -> desugM (Map.map (cabs_identifier * namespace) registration * 'a)
let with_scope2 scope m =
  State_exception.update (fun st ->
    let () = Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      "ENTERING Scope(2): " ^ string_of_scope scope
    ) in
    <| st with registered_identifiers= Scope_table.create_scope scope st.registered_identifiers; |>
  ) >>
  m >>= fun res ->
  State_exception.modify (fun st ->
    let (idents_map, ident_table') = Scope_table.destroy_scope st.registered_identifiers in
    let () = Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      "EXITING Scope(2): " ^ string_of_scope scope
    ) in
    (idents_map, <| st with registered_identifiers= ident_table'; |>)
  ) >>= fun idents_map ->
  return (idents_map, res)

let bindings_of_idents_map idents_map =
  State_exception.read (fun st ->
    List.reverse begin
      Set_helpers.fold (fun decl acc ->
        match decl with
          | External ->
              (* KKK, TODO: check *)
              acc
          | Internal sym kind _ ->
              match kind with
                | Kind_ordinary (OK_object _) ->
                    match Map.lookup sym st.external_object_declarations with
                      | Just (isTentative, loc, dur, isRegister, qs, ty) ->
                          (sym, ((dur, isRegister), qs, ty)) :: acc
                      | Nothing ->
                          match Map.lookup sym st.internal_object_declarations with
                            | Just (loc, dur, isRegister, qs, ty) ->
                                (sym, ((dur, isRegister), qs, ty)) :: acc
                            | Nothing ->
                                (* TODO: check *)
                                acc
                          end
                    end
                | _ ->
                    (* TODO: functions *)
                    acc
              end
        end) (Map.range idents_map) []
    end
  )

(* TODO: this is a massive hack (see desugar_and_register_function_definition). MUST DO BETTER *)
val hack_inject_idents_map: Map.map (cabs_identifier * namespace) registration -> desugM unit
let hack_inject_idents_map idents_map =
  State_exception.update (fun st ->
    <| st with registered_identifiers=
      Map_extra.fold (fun cabs_ident reg acc ->
        Scope_table.register cabs_ident reg acc
      ) idents_map st.registered_identifiers; |>
  )


(* ========================================================================== *)
val initial_state: nat -> (map string Symbol.sym) * Core.fun_map unit * Core.impl -> state
let initial_state n core_eval_stuff = <|
  aux_supply=    UniqueId.new_supply;
  symbol_supply= UniqueId.new_supply_from n;
  
  registered_external_identifiers= Map.empty;
  registered_identifiers=      Scope_table.empty;
  
  tag_definitions= Map.empty;

  enumeration_constants=       Map.empty;
  
  function_declarations=        Map.empty;
  external_object_declarations= Map.empty;
  internal_object_declarations= Map.empty;
  
  function_definitions=        Map.empty;
  global_object_definitions=   Map.empty;
  typedef_definitions=         Map.empty;
  static_assertions=           [];
  
  used_identifier= [];
  current_return_type= ATypes.Ctype [] ATypes.Void; (* TODO: this is morally wrong *)
  
  core_eval_stuff= core_eval_stuff;
|>

val eval: forall 'a. nat -> (map string Symbol.sym) * Core.fun_map unit * Core.impl -> desugM 'a ->
  Exception.exceptM (UniqueId.supply Symbol.sym * 'a) Errors.error
let cabs_to_ail_effect_eval n core_eval_stuff m =
  State_exception.eval (
    m                                                 >>= fun res    ->
    State_exception.read (fun st -> st.symbol_supply) >>= fun supply ->
    return (supply, res)
    ) (initial_state n core_eval_stuff)
let inline eval = cabs_to_ail_effect_eval



val freshify: cabs_identifier -> desugM cabs_identifier
let freshify (CabsIdentifier loc str) =
  State_exception.modify (fun st ->
    let (n, aux_supply') = UniqueId.fresh_id st.aux_supply in
    (CabsIdentifier loc (str ^ show n), <| st with aux_supply= aux_supply' |>)
  )

val fresh_block_scope: desugM scope
let fresh_block_scope =
  State_exception.modify (fun st ->
    let (n, aux_supply') = UniqueId.fresh_id st.aux_supply in
    (Scope_block n, <| st with aux_supply= aux_supply' |>)
  )



(* ========================================================================== *)
val ident_is_in_scope: cabs_identifier -> namespace -> desugM bool
let ident_is_in_scope ident namespace =
  State_exception.read (fun st ->
    Scope_table.is_in_scope (ident, namespace) (Scope_table.return_scope st.registered_identifiers)
  )


val ident_is_in_current_scope: cabs_identifier -> namespace -> desugM bool
let ident_is_in_current_scope ident namespace =
  State_exception.read (fun st ->
    Scope_table.is_in_current_scope (ident, namespace) (Scope_table.return_scope st.registered_identifiers)
  )


(* NOTE: this function shouldn't be called outside of the current module *)
val internal_register_identifier:
  (scope * (A.identifier * identifier_kind * maybe linkage) -> (unit -> desugM A.identifier) -> desugM A.identifier) ->
  cabs_identifier -> namespace -> identifier_kind -> maybe linkage -> desugM A.identifier
let internal_register_identifier if_found ident namespace kind link_opt =
  get_scope >>= fun sc ->
  let () =
    Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      "attempting to register identifier `" ^ show ident ^
       "' with scope= " ^ string_of_scope sc ^
       " with namespace= " ^ show namespace ^
       ", kind= " ^ show kind ^
       match link_opt with
         | Nothing -> ""
         | Just link -> ", linkage= " ^ show link_opt
       end
    ) in
  (* TODO: we should use a smaller type in the state to avoid having to do these
     checks ... *)
  match (namespace, kind, link_opt) with
    | (Namespace_label, Kind_label, Nothing) ->
        return ()
    | (Namespace_tag, Kind_tag _, Nothing) ->
        return ()
    | (Namespace_member _, Kind_member _, Nothing) ->
        return ()
    | (Namespace_ordinary, Kind_ordinary OK_enum_constant, Nothing) ->
        return ()
    | (Namespace_ordinary, Kind_ordinary OK_typedef, Nothing) ->
        return ()
    | (Namespace_ordinary, Kind_ordinary _, Just _) ->
        return ()
    | _ ->
        (* internal_register_indentifier was improperly called *)
        fail (Loc.locOf ident) (Errors.Desugar_impossible)
  end >>
  let do_fresh () =
    (* generates a fresh symbol *)
    State_exception.modify (fun st ->
      let CabsIdentifier _ str = ident in
      let (sym, symbol_supply) = Symbol.fresh_pretty str st.symbol_supply in
      (sym, <| st with symbol_supply = symbol_supply |>)
    ) >>= fun sym ->
    (* associates it to the identifier *)
    State_exception.update (fun st ->
      match link_opt with
        | Just Linkage_external ->
            (* registering a new identifier WITH external linkage *)
            <| st with
              registered_external_identifiers=
                Map.insert (ident, namespace) (sc, (sym, kind, link_opt)) st.registered_external_identifiers;
              registered_identifiers=
                Scope_table.register (ident, namespace) External st.registered_identifiers;
            |>
        | _ ->
            (* registering a new identifier (without external linkage) *)
            <| st with registered_identifiers=
              Scope_table.register (ident, namespace) (Internal sym kind link_opt) st.registered_identifiers
            |>
      end
    ) >>
    return sym in
  
  match link_opt with
    | Just Linkage_external ->
        let () = Debug.print_debug 1 [] (fun () ->
          "internal_register_identifier ==> link_opt = Just Linkage_external"
        ) in
        (* when registering an identifier with external linkage, we only care
           about previous EXTERNAL registrations *)
        State_exception.read (fun st ->
          Map.lookup (ident, namespace) st.registered_external_identifiers
        ) >>= function
          | Nothing ->
              let () = Debug.print_debug 1 [] (fun () ->
                "lookup external ==> Nothing"
              ) in
              do_fresh ()
          | Just (scope, decl) ->
              let () = Debug.print_debug 1 [] (fun () ->
                "lookup external ==> Just"
              ) in
              if_found (scope, decl) do_fresh
        end
    | _ ->
        let () = Debug.print_debug 1 [] (fun () ->
          "internal_register_identifier ==> link_opt <> Just Linkage_external"
        ) in
        (* TODO: check this is correct for link = Linkage_internal *)
        State_exception.read (fun st ->
          Scope_table.resolve (ident, namespace) st.registered_identifiers
        ) >>= function
          | Just (scope, External) ->
              let () = Debug.print_debug 1 [] (fun () ->
                "lookup registered ==> Just External"
              ) in
              State_exception.read (fun st ->
                Map.lookup (ident, namespace) st.registered_external_identifiers
              ) >>= function
                | Nothing ->
                    error "[Cabs_to_ail_effect.internal_register_identifier] - internal ERROR"
                | Just (_, decl) ->
                    let () = Debug.print_debug 1 [] (fun () ->
                      "lookup external ==> Just"
                    ) in
                    if_found (scope, decl) do_fresh
              end
          | Just (scope, Internal sym kind link_opt) ->
              let () = Debug.print_debug 1 [] (fun () ->
                "lookup registered ==> Just Internal"
              ) in
              if_found (scope, (sym, kind, link_opt)) do_fresh
          | Nothing ->
              (* KKK *)
              let () = Debug.print_debug 1 [] (fun () ->
                "lookup registered ==> Nothing"
              ) in
              State_exception.read (fun st ->
                Map.lookup (ident, namespace) st.registered_external_identifiers
              ) >>= function
                | Nothing ->
                    let () = Debug.print_debug 1 [] (fun () ->
                      "lookup external ==> Nothing"
                    ) in
                    do_fresh ()
                | Just (scope, decl) ->
                    let () = Debug.print_debug 1 [] (fun () ->
                      "lookup external ==> Just"
                    ) in
                    if_found (scope, decl) do_fresh
              end
        end
  end

val register_typedef: cabs_identifier -> ATypes.qualifiers * ATypes.ctype -> desugM unit
let register_typedef ident (qs, ty) =
  let loc = Loc.locOf ident in
  let () = Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
    "registering typedef identifier: " ^ show ident ^
    " with (qs, ty) = " ^ Pp.stringFromAil_ctype qs ty
  ) in
  (* if the identifier is already declared we reuse that existing declaration *)
  internal_register_identifier
    (fun (_, (sym, _, _)) _ -> return sym)
    ident Namespace_ordinary (Kind_ordinary OK_typedef) Nothing >>= fun sym ->
  State_exception.get >>= fun st ->
  match Map.lookup sym st.typedef_definitions with
    | Just (qs', ty') ->
        (* STD §6.7#3, first bullet *)
        if AilTypesAux.variably_modified ty then
          fail loc (Errors.Desugar_ConstraintViolation "§6.7#3, first bullet, variably modified")
        else if qs <> qs' || ty <> ty' then
          fail loc (Errors.Desugar_ConstraintViolation "§6.7#3, first bullet")
        else
          return ()
    | Nothing ->
        State_exception.put (<| st with
          typedef_definitions= Map.insert sym (qs, ty) st.typedef_definitions
         |>)
  end


val resolve_typedef: A.identifier -> desugM (ATypes.qualifiers * ATypes.ctype)
let resolve_typedef sym =
  State_exception.read (fun st ->
    match Map.lookup sym st.typedef_definitions with
      | Just qs_ty -> qs_ty
      | _ -> error "TODO(msg) Cabs_to_ail_effect.resolve_typedef"
    end
  )


(*
(* NOTE: this function shouldn't be called outside of the current module *)
val register_identifier_: cabs_identifier -> namespace -> identifier_kind -> maybe linkage -> desugM A.identifier
let register_identifier_ ident namespace kind link_opt =
  get_scope >>= fun sc ->
  let () =
    Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      "attempting to register identifier `" ^ show ident ^
       "' with scope= " ^ string_of_scope sc ^
       " with namespace= " ^ show namespace ^
       ", kind= " ^ show kind ^
       match link_opt with
         | Nothing -> ""
         | Just link -> ", linkage= " ^ show link_opt
       end
    ) in
  
  let do_fresh =
    (* generates a fresh symbol *)
    State_exception.modify (fun st ->
      let CabsIdentifier _ str = ident in
      let (sym, symbol_supply) = Symbol.fresh_pretty str st.symbol_supply in
      (sym, <| st with symbol_supply = symbol_supply |>)
    ) >>= fun sym ->
    (* associates it to the identifier *)
    State_exception.update (fun st ->
      <| st with registered_identifiers=
        Scope_table.register (ident, namespace) (sym, kind, link_opt) st.registered_identifiers
      |>
    ) >>
    return sym in
  
  State_exception.read (fun st ->
    Scope_table.resolve (ident, namespace) st.registered_identifiers
  ) >>= function
    | Just (scope, (sym, kind', link_opt')) ->
        match kind with
          | Kind_tag _ ->
              current_scope_is scope >>= function
                | true ->
                    return sym
                | false ->
                    do_fresh
             end
          | _ ->
              (* TODO: need to check that the kind/link match up *)
              if link_opt = Just Linkage_none then
                (* §6.7#3 "except that ..." *)
                (* TODO: this should be dead code now *)
                if kind = Kind_typedef then
                  (* NOTE: the "except that ..." is deal with by the call to [register_typedef] that should be done just after *)
                  return sym
(*
          else if kind = Kind_tag then
            (* TODO: multiple definition are not allowed *)
            return sym
*)
                else
                  (* TODO: check *)
                  current_scope_is scope >>= function
                    | true ->
                        fail (Loc.locOf ident) (Errors.Desugar_MultipleDeclaration ident)
                    | false ->
                        do_fresh
                  end
              else
                if kind <> kind' then
                  error "TODO: Cabs_to_ail_effect.register_identifier_, kind <> kind'"
                else
                  if link_opt <> link_opt' then
                    (* STD §6.2.2#7 *)
                    fail (Loc.locOf ident) (Errors.Desugar_UndefinedBehaviour Undefined.UB008_multiple_linkage)
                  else
                    return sym
        end
    | Nothing ->
        do_fresh
  end
*)


(* Ordinary identifiers are those declared by ordinary declarators (i.e. object
    or functions) or enumeration constants *)

type ordinary_registration =
  | OReg_enum_constant of A.identifier
  | OReg_typedef of A.identifier
  | OReg_other of A.identifier * ordinary_kind * linkage

val resolve_ordinary_identifier: Loc.t -> cabs_identifier -> desugM (maybe (scope * ordinary_registration))
let resolve_ordinary_identifier loc ident =
  return (
    Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      "attempting to resolve ordinary identifier `" ^ show ident
    )
  ) >>
  
  State_exception.read (fun st ->
    let reg_opt = match Scope_table.resolve (ident, Namespace_ordinary) st.registered_identifiers with
      | Nothing ->
          match Map.lookup (ident, Namespace_ordinary) st.registered_external_identifiers with
            | Nothing ->
                Nothing
            | Just (scope, decl) ->
                Just (scope, decl)
          end
      | Just (scope, External) ->
          match Map.lookup (ident, Namespace_ordinary) st.registered_external_identifiers with
            | Nothing ->
                error "[Cabs_to_ail_effect.resolve_ordinary_identifier] - internal ERROR"
            | Just (_, decl) ->
                Just (scope, decl)
          end
      | Just (scope, Internal sym kind link_opt) ->
          Just (scope, (sym, kind, link_opt))
    end in
    match reg_opt with
      | Nothing ->
          Nothing
      | Just (scope, (sym, Kind_ordinary OK_enum_constant, Nothing)) ->
          Just (scope, OReg_enum_constant sym)
      | Just (scope, (sym, Kind_ordinary OK_typedef, Nothing)) ->
          Just (scope, OReg_typedef sym)
      | Just (scope, (sym, Kind_ordinary okind, Just link)) ->
          Just (scope, OReg_other sym okind link)
      | Just (_, (sym, kind, _)) ->
          error ("Cabs_to_ail_effect.resolve_ordinary_identifier ==> [" ^ Loc.stringFromLocation loc ^ "]" ^ show ident ^
                 ", found INVALID: " ^ show sym ^ " with kind: " ^ show kind)
    end
  )


val resolve_extraordinary_identifier:
  cabs_identifier -> namespace -> desugM (maybe (scope * (A.identifier * identifier_kind)))
let resolve_extraordinary_identifier ident namespace =
  State_exception.read (fun st ->
    match Scope_table.resolve (ident, namespace) st.registered_identifiers with
      | Nothing ->
          Nothing
      | Just (_, External) ->
          error "Cabs_to_ail_effect.resolve_extraordinary_identifier (1)"
      | Just (_, Internal _ (Kind_ordinary _) _) ->
          error "Cabs_to_ail_effect.resolve_extraordinary_identifier (2)"
      | Just (_, Internal _ _ (Just _)) ->
          error "Cabs_to_ail_effect.resolve_extraordinary_identifier (3)"
      | Just (scope, Internal ident kind Nothing) ->
          Just (scope, (ident, kind))
    end
  )


val internal_resolve_identifier: cabs_identifier -> namespace -> desugM (maybe (scope * registration))
let internal_resolve_identifier ident namespace =
  State_exception.read (fun st ->
    Scope_table.resolve (ident, namespace) st.registered_identifiers
  )


val     determinate_linkage: cabs_identifier -> namespace -> ordinary_kind -> list storage_class_specifier -> desugM linkage
let rec determinate_linkage ident namespace kind storage_classes =
  get_scope >>= fun scope ->
  let scs = List.delete SC_Thread_local storage_classes in
  if    scope = Scope_file
     && (kind = OK_object false || kind = OK_function)
     && List.elem SC_static scs then
STD_ "§6.2.2#3" $
      return Linkage_internal
  
  else if List.elem SC_extern scs then
STD_ "§6.2.2#4" $
    internal_resolve_identifier ident namespace >>= function
      | Just (_, External) ->
          return Linkage_external
      | Just (_, Internal _ _ (Just Linkage_internal)) ->
          return Linkage_internal
      | Just (_, Internal _ _ (Just _)) ->
          return Linkage_external
      | Just _ ->
          fail Loc.unknown (Errors.Desugar_TODOCTOR "determinate_linkage ==> resolved an previous registration with Nothing as linkage")
      | Nothing ->
          return Linkage_external
    end
  
  else if kind = OK_function && List.null scs then
STD_ "§6.2.2#5, sentence 1" $
        determinate_linkage ident namespace kind [SC_extern]
  
  else if    scope = Scope_file
          && kind = OK_object false
          && List.null scs then
STD_ "§6.2.2#5, sentence 2" $
    return Linkage_external
    
    else
STD_ "§6.2.2#6" $
    if    not (is_object_kind kind || kind = OK_function)
       || is_parameter_object_kind kind (* identifier declared to be a function parameter *)
       || is_block_scope scope && is_object_kind kind && scs <> [SC_extern] then
      return Linkage_none
    else
      error "[Cabs_to_ail_effect.determinate_linkage] unknown case"
(* TODO: we need when-patterns in Lem *)
(*
  match (scope, kind, List.delete SC_Thread_local storage_classes) with
    | (Scope_file, Kind_object false, [SC_static]) ->
STD_ "§6.2.2#3" $
        return Linkage_internal
    
    | (Scope_file, Kind_function, [SC_static]) ->
STD_ "§6.2.2#3" $
        return Linkage_internal
    
    | (_, _, [SC_extern]) ->
STD_ "§6.2.2#4" $
        internal_resolve_identifier ident namespace >>= function
          | Just (_, (_, _, link)) ->
              if link = Linkage_internal || link = Linkage_external then
                return link
              else
                return Linkage_external
          | Nothing ->
              return Linkage_external
        end
    
    | (_, Kind_function, []) ->
STD_ "§6.2.2#5, sentence 1" $
        determinate_linkage ident namespace kind [SC_extern]
    
    | (Scope_file, Kind_object false, []) ->
STD_ "§6.2.2#5, sentence 2" $
        return Linkage_external
    
    | (_, _, storage_class) ->
STD_ "§6.2.2#6" $
        if    not (is_object_kind kind || kind = Kind_function)
           || is_parameter_object_kind kind (* identifier declared to be a function parameter *)
           || is_block_scope scope && is_object_kind kind && storage_class <> [SC_extern] then
          return Linkage_none
        else
          error "[Cabs_to_ail_effect.determinate_linkage] unknown case"
  end
*)


(* NOTE: don't call this on typedef identifier *)
val register_ordinary_identifier:
  cabs_identifier -> ordinary_kind -> list storage_class_specifier -> desugM (linkage * A.identifier)
let register_ordinary_identifier ident kind storage_classes =
  match kind with
    | OK_enum_constant ->
        (* internal_register_indentifier was improperly called *)
        fail (Loc.locOf ident) (Errors.Desugar_impossible)
    | _ ->
        return ()
  end >>
  determinate_linkage ident Namespace_ordinary kind storage_classes >>= fun link ->
  internal_register_identifier (fun (scope, (sym, prev_kind, prev_link_opt)) do_fresh ->
    match link with
      | Linkage_external ->
          (* STD §6.2.2#7 *)
          match prev_link_opt with
            | Just Linkage_none ->
                do_fresh ()
            | Just Linkage_internal ->
                fail (Loc.locOf ident) (Errors.Desugar_UndefinedBehaviour Undefined.UB008_multiple_linkage)
            | Just Linkage_external ->
                State_exception.update (fun st ->
                  <| st with registered_identifiers= 
                    Scope_table.register (ident, Namespace_ordinary) External st.registered_identifiers;
                  |>
                ) >>
                return sym
            | Nothing ->
                error "TODO: is this possible? (register_ordinary_identifer, prev_link_opt = Nothing)"
          end
        (* TODO: need to check that the kind/link match up *)
      | Linkage_none ->
          current_scope_is scope >>= function
            | true ->
                fail (Loc.locOf ident) (Errors.Desugar_MultipleDeclaration ident)
            | false ->
                do_fresh ()
          end
      | Linkage_internal ->
          if Kind_ordinary kind <> prev_kind then
            error "TODO: Cabs_to_ail_effect.register_ordinary_identifier, kind <> kind'"
          else if Just link <> prev_link_opt then
            (* STD §6.2.2#7 *)
            fail (Loc.locOf ident) (Errors.Desugar_UndefinedBehaviour Undefined.UB008_multiple_linkage)
          else
            return sym
    end
(*
    if link = Linkage_external then
      (* STD §6.2.2#7 *)
      if link_opt' = Just Linkage_internal then
        fail (Loc.locOf ident) (Errors.Desugar_UndefinedBehaviour Undefined.UB008_multiple_linkage)
      else
        return sym
    (* TODO: need to check that the kind/link match up *)
    else if link = Linkage_none then
      current_scope_is scope >>= function
        | true ->
            fail (Loc.locOf ident) (Errors.Desugar_MultipleDeclaration ident)
        | false ->
            do_fresh
      end
    else if Kind_ordinary kind <> kind' then
      error "TODO: Cabs_to_ail_effect.register_ordinary_identifier, kind <> kind'"
    else if Just link <> link_opt' then
      (* STD §6.2.2#7 *)
      fail (Loc.locOf ident) (Errors.Desugar_UndefinedBehaviour Undefined.UB008_multiple_linkage)
    else
      return sym
*)
  ) ident Namespace_ordinary (Kind_ordinary kind) (Just link) >>= fun sym ->
  return (link, sym)


val register_tag: tag_kind -> maybe cabs_identifier -> desugM A.identifier
let register_tag kind tag_ident_opt =
  (* generate a fresh tag identifier if none provided *)
  maybe
    (freshify (CabsIdentifier (Loc.other "anonymous_tag") "anonymous_tag_"))
    return
    tag_ident_opt >>= fun tag_ident ->
  internal_register_identifier (fun (scope, (sym, prev_kind, _)) do_fresh ->
    current_scope_is scope >>= function
      | true ->
          if Kind_tag kind = prev_kind then
            return sym
          else
            fail (Loc.locOf tag_ident) (Errors.Desugar_ConstraintViolation "§6.7.2.3#2")
      | false ->
          do_fresh ()
    end
  ) tag_ident Namespace_tag (Kind_tag kind) Nothing


val register_tag_definition: Loc.t -> A.identifier -> tag_definition -> desugM unit
let register_tag_definition loc tag_sym tag_decl =
  let () = Debug.print_debug 5 [Debug.DB_desugaring] (fun () -> "REGISTERING TAG DEFINITION: " ^ show tag_sym) in
  State_exception.read (fun st ->
    Map.member tag_sym st.tag_definitions
  ) >>= function
    | true ->
        fail loc (Errors.Desugar_ConstraintViolation "§6.7.2.3#1")
    | false ->
        return ()
  end >>
  match tag_decl with
    | Enum_definition ns_rev ->
        (* NOTE: this function doesn't care about the order of the integers *)
        (* NOTE2: this function is effectful but by its use this shouldn't be observable *)
        if Implementation_.register_enum tag_sym ns_rev then
          return ()
        else
          (* this should have been caught as redefinition just earlier *)
          fail loc Errors.Desugar_impossible
    | _ ->
        return ()
  end >>
  State_exception.update (fun st ->
    <| st with tag_definitions= Map.insert tag_sym tag_decl st.tag_definitions |>
  )


val resolve_tag_definition: A.identifier -> desugM (maybe tag_definition)
let resolve_tag_definition tag_sym =
  State_exception.read (fun st ->
    Map.lookup tag_sym st.tag_definitions
  ) 
(*
>>= function
    | Just tag_decl ->
        return tag_decl
    | Nothing ->
        (* TODO: I think this can only happen when seeing a tentative struct/union
           with a member (or recursive...) whose type is the struct/union itself.
           If this is indeed the case, we should give a better error message *)
        fail Loc.unknown (Errors.Desugar_OtherViolation ("unregistered tag: " ^ show tag_sym ^
          " (this may be from a violation of (§6.7.2.1#3, 1st sentence)"))
  end
*)


val get_tag_definitions: desugM (map A.identifier tag_definition)
let get_tag_definitions =
  State_exception.read (fun st ->
    st.tag_definitions
  )



val get_anonymous_struct_or_union:
  ATypes.ctype -> desugM (maybe (list (Cabs.cabs_identifier * (ATypes.qualifiers * ATypes.ctype))))
let get_anonymous_struct_or_union ty =
  (* TODO: the unatomic is commented because clang doesn't consider an atomic
     struct/union an anonymous (regardless of the absence of tag). So we do
     the same for now, but need to check further the STD... *)
  match (* AilTypesAux.unatomic *) ty with
    | ATypes.Ctype _ (ATypes.Struct tag_sym) ->
        resolve_tag_definition tag_sym >>= function
          | Just (Struct_definition isAnonymous membrs) ->
              return begin
                if isAnonymous then Just membrs else Nothing
              end
          | _ ->
              error "Cabs_to_ail_effect.is_anonymous_struct_or_union, Struct -- Union_definition"
        end
    | ATypes.Ctype _ (ATypes.Union tag_sym) ->
        resolve_tag_definition tag_sym >>= function
          | Just (Union_definition isAnonymous membrs) ->
              return begin
                if isAnonymous then Just membrs else Nothing
              end
          | _ ->
              error "Cabs_to_ail_effect.is_anonymous_struct_or_union, Union -- Struct_definition"
        end
    | _ ->
        return Nothing
  end



(*
KKK

type tag_declaration =
  | Struct_declaration of list (Cabs.cabs_identifier * ATypes.ctype)



  registered_tag_declarations: Scope_table.t scope A.identifier tag_declaration;
*)



(*
  match tag_ident_opt with
    | Just sym ->
        return sym
    | Nothing ->
        State_exception.modify (fun st ->
          let (sym, symbol_supply) = Symbol.fresh st.symbol_supply in
          (sym, <| st with symbol_supply = symbol_supply |>)
        )
  end >>= fun tag_sym ->
  
  



  (* associates it to the identifier *)
  State_exception.update (fun st ->
    <| st with registered_identifiers= Scope_table.register (tag_sym, Namespace_tag) (tag_sym, kind, link) st.registered_identifiers |>
  ) >>
  return sym
*)

















(*
val resolve_identifier: cabs_identifier -> t (A.identifier * identifier_kind * linkage)
let resolve_identifier name =
  bind (State_exception.read (fun st -> Scope_table.lookup name st.registered_identifiers))
    function
      | Just x  -> return x
      | Nothing -> fail (Errors.CABS_TO_AIL_UNDECLARED_IDENTIFIER name)
    end
*)








(* TODO: move somewhere else *)
(* 
TODO: HIP


val     sigma_declarations_insert: forall 'a 'b. A.sigma_declaration 'a 'b -> A.sigma 'a 'b -> A.sigma 'a 'b
let rec sigma_declarations_insert decl decls =
  match (decl, decls) with
    | (_, []) ->
        []
    | (A.SDecl_fun ident fun_decl, [A.SDecl_fun ident' fun_decl']

 function
  | [] ->
      []
  | ((ident', _) as  :: xs ->
      if ident = ident' then
        (ident, decl) :: xs
      else
        (ident', decl') :: sigma_declarations_insert k v xs
end
*)


(*
val register_declaration: A.sigma_declaration Loc.t unit -> t unit
let register_declaration decl =
  let ident = match decl with
    | A.SDecl_fun ident _ ->
        ident
    | A.SDecl_global ident _ ->
        ident
    | _ ->
        error "register_declaration: found a static_assert"
  end in
  
  (* TODO: detect multiple definitions *)
  
  State_exception.update (fun st ->
    <| st with registered_declarations= (* assoc_insert ident decl *) decl :: st.registered_declarations |>
  )

val resolve_declarations: t (list (A.sigma_declaration Loc.t unit))
let resolve_declarations =
  State_exception.read (fun st ->
    st.registered_declarations
  )
*)


val fetch_object_declaration: A.identifier -> desugM (bool * Loc.t * ATypes.storageDuration * bool * ATypes.qualifiers * ATypes.ctype)
let fetch_object_declaration sym =
  State_exception.read (fun st ->
    (* ... *)
    let map_union = Map.(union) in
    map_union
      st.external_object_declarations
      (Map.map (fun (loc, dur, isRegister, qs, ty) -> (false, loc, dur, isRegister, qs, ty)) st.internal_object_declarations)
  ) >>= fun decls ->
  match Map.lookup sym decls with
    | Just decl ->
        return decl
    | Nothing ->
        error ("TODO: failed to fetch object declaration ==> " ^ show sym)
  end


val register_global_object_definition2: Loc.t -> A.identifier -> linkage -> global_definition -> desugM unit
let register_global_object_definition2 loc sym link gdef =
  State_exception.get >>= fun st ->
  let do_update new_gdef =
    State_exception.put <| st with global_object_definitions=
      Map.insert sym new_gdef st.global_object_definitions
    |> in
  match Map.lookup sym st.global_object_definitions with
    | Nothing ->
        do_update gdef
    | Just prev_gdef ->
        match (prev_gdef, gdef) with
          | (Tentative prev_ty, Tentative ty) ->
              (* TODO: this function is not correct for desugaring *)
              match AilTypesAux.make_composite prev_ty ty with
                | Nothing ->
                    error "[register_global_object_definition2] make_composite failed"
                | Just ty' ->
                    do_update (Tentative ty')
              end
          | (_, Tentative _) ->
              (* NOTE: new tentative definitions do not override previous
                 external or "internal" definitions *)
              return ()
          | (Tentative _, _) ->
              (* NOTE: but new external or "internal" definitions do override
                 tentative ones *)
              do_update gdef
          | (Definition _, _) ->
              error "[Cabs_to_ail_effect.register_global_object_definition] - internal ERROR 1"
          | (ExternalDefinition _, ExternalDefinition _) ->
              match link with
                | Linkage_internal ->
                    (* STD §6.9#3, sentence 1 *)
                    fail loc (Errors.Desugar_ConstraintViolation "§6.9#3, sentence 1")
                | Linkage_external ->
                    (* STD §6.9#5, sentence 2 *)
                    let () = Debug.print_debug 0 [] (fun () ->
                      "register_global_object_definition2"
                    ) in
                    fail loc (Errors.Desugar_UndefinedBehaviour Undefined.UB084)
                | Linkage_none ->
                    error "[Cabs_to_ail_effect.register_global_object_definition] - internal ERROR 2"
              end
          | (ExternalDefinition _, Definition _) ->
              error "[Cabs_to_ail_effect.register_global_object_definition] - internal ERROR 3"
        end
  end


(* NOTE: no check for redefinition is made here *)
val register_global_object_definition: A.identifier -> global_definition -> desugM unit
let register_global_object_definition sym gdef =
(*
  (* this guard makes sure we are indeed registering the definition of an
     external object (§6.9.2#1) *)
  guard (current_scope_is Scope_file) "register_static_object_definition not in File scope" $
*)
  (* NOTE: previously this function was only used for external object
     definitions, now we also use it for static object with no linkage
     (i.e. declared inside functions) or thread local objects *)
  guard begin
    fetch_object_declaration sym >>= function
      | (_, _, ATypes.Static, _, _, _) ->
          return true
      | (_, _, ATypes.Thread, _, _, _) ->
          return true
      | _ ->
          return false
    end
  end ("register_static_global_definition must only be called for object with static storage duration ==> " ^ show sym) $
    State_exception.update (fun st ->
      <| st with global_object_definitions= Map.insert sym gdef st.global_object_definitions |>
    )


(* NOTE: no check for redefinition is made here *)
val register_function_definition: A.identifier -> (Loc.t * list A.identifier * A.statement unit) -> desugM unit
let register_function_definition sym fdef =
  (* NOTE: unlike for external objects, we don't need to check the scope here,
     because the parse won't allow block scoped function definitions anyway. *)
  State_exception.update (fun st ->
    let () = Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      let (_, xs, _) = fdef in
      "registering function definition of '" ^ show sym ^ "' with params: " ^ stringFromList show xs
    ) in
    <| st with function_definitions= Map.insert sym fdef st.function_definitions |>
  )


val global_object_is_defined: A.identifier -> desugM bool
let global_object_is_defined sym =
  State_exception.read (fun st ->
    Map.member sym st.global_object_definitions
  )


val function_is_defined: A.identifier -> desugM bool
let function_is_defined sym =
  State_exception.read (fun st ->
    Map.member sym st.function_definitions
  )


val register_function_declaration:
  Loc.t -> A.identifier -> bool -> ((ATypes.qualifiers * ATypes.ctype) * maybe (list (ATypes.qualifiers * ATypes.ctype * bool)) * bool * bool * bool) -> desugM unit
let register_function_declaration loc sym is_proto decl =
  (* DEBUG *)
  let string_of_decl ((ret_qs, ret_ty), params_opt, isVariadic, _, _) =
    let params' = Maybe.maybe [] id params_opt in
    let fun_ty = ATypes.Ctype [Annot.Aloc loc] (ATypes.Function is_proto (ret_qs, ret_ty) params' isVariadic) in
    Pp.stringFromAil_ctype ATypes.no_qualifiers fun_ty ^
    (if Maybe.isNothing params_opt then " NO_PARAMS" else "")
  in
(*
    Pp.stringFromAil_ctype ret_qs ret_ty ^ "(" ^ stringFromList (
      fun (qs, ty, isRegister) ->
        (if isRegister then "register " else "") ^ Pp.stringFromAil_ctype qs ty
    ) params ^ ")" in
*)
  
  State_exception.read (fun st ->
    Map.lookup sym st.function_declarations
  ) >>= function
    | Just (prev_has_proto, _, prev_decl) ->
(* KKK
        let () = Debug.print_debug 1 [] (fun () ->
          "TODO: FIXME -> Cabs_to_ail_effect.register_function_declaration"
        ) in
*)
(*
        let (prev_ret_qs_ty, prev_params, prev_is_variadic, prev_is_inline, prev_is_Noreturn) = prev_decl in
        let (new_ret_qs_ty, new_params, new_is_variadic, new_is_inline, new_is_Noreturn) = decl in
        
        let prev_fun_ty = ATypes.Function prev_has_proto prev_ret_qs_ty prev_params prev_is_variadic in
        let new_fun_ty  = ATypes.Function is_proto new_ret_qs_ty new_params new_is_variadic in
        
        let () = Debug.print_debug 0 [] (fun () ->
          "PREVIOUS qs,ty ==> " ^ Pp.stringFromAil_ctype ATypes.no_qualifiers prev_fun_ty
        ) in
        let () = Debug.print_debug 0 [] (fun () ->
          "NEW qs,ty ==> " ^ Pp.stringFromAil_ctype ATypes.no_qualifiers new_fun_ty
        ) in
        
        let () = match AilTypesAux.make_composite prev_fun_ty new_fun_ty with
          | Just compo_ty ->
              Debug.print_debug 0 [] (fun () -> "make_composite WORKED: " ^ Pp.stringFromAil_ctype ATypes.no_qualifiers compo_ty)
          | Nothing ->
              Debug.print_debug 0 [] (fun () -> "make_composite FAILED")
        end in
*)

(*
        (* function () returning void *)
        let old_ty = ATypes.Function true (ATypes.no_qualifiers, ATypes.Void) [] false in
        (* function (pointer to function () returning void) returning void *)
        let new_ty = ATypes.Function true (ATypes.no_qualifiers, ATypes.Void) [(ATypes.no_qualifiers, old_ty, false)] false in
        
*)
(*
        
        let prev_fun_type = Function prev_has_proto prev_ret_qs_ty prev_params prev_is_variadic in
        let new_fun_type  = Function new_has_proto new_ret_qs_ty new_params new_is_variadic in

Function hasProto1 (ret_qs1, ret_ty1) params1 isVariadic1

AilTypesAux.make_composite



  (* return type; parameters types; is_variadic; is_inline; is_Noreturn *)


((ATypes.qualifiers * ATypes.ctype) * (list (ATypes.qualifiers * ATypes.ctype * bool)) * bool * bool * bool)
*)

        if decl <> prev_decl then
          (* TODO: msg and location *)
          fail loc (Errors.Desugar_OtherViolation ("redeclaration of a function with a different type: " ^
                                                   show sym ^ ", old decl= " ^ string_of_decl prev_decl ^ " --- vs --- " ^ string_of_decl decl))
        else
          let () = Debug.print_debug 1 [] (fun () -> "HELLO: decl == prev_decl") in
          return ()
    | Nothing ->
        State_exception.update (fun st ->
          let () = Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
            "registering function declaration of '" ^ show sym ^ (if is_proto then "' with PROTOTYPE" else "'") ^ " with decl= " ^
           string_of_decl decl) in
          <| st with function_declarations= Map.insert sym (is_proto, loc, decl) st.function_declarations |>
        )
  end


(* TODO: the redeclaration check don't mix external/internal declarations *)
val register_external_object_declaration: A.identifier -> (bool * Loc.t * ATypes.storageDuration * bool * ATypes.qualifiers * ATypes.ctype) -> desugM unit
let register_external_object_declaration sym ((_, loc, new_dur, _, new_qs, new_ty) as new_decl) =
  return (
    Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      "attempting to register external object declaration of `" ^ show sym ^
      "' with dur: " ^ string_of_storageDuration new_dur ^ " qs, ty: " ^ Pp.stringFromAil_ctype new_qs new_ty)
  ) >>
  
  State_exception.read (fun st ->
    Map.lookup sym st.external_object_declarations
  ) >>= function
    | Just (_, _, prev_dur, _, prev_qs, prev_ty) ->
        if not (prev_dur = ATypes.Thread --> new_dur = ATypes.Thread) then
          fail loc (Errors.Desugar_ConstraintViolation "§6.7.1#3, sentence 2")
        
        (* TODO: what about the storage duration and isRegister?? *)
        else if not (AilTypesAux.are_compatible (new_qs, new_ty) (prev_qs, prev_ty)) then

(*
(ATypes.storageDuration * (* isRegister *) bool * ATypes.qualifiers * ATypes.ctype)
*)


(*        if decl <> decl' then *)
          (* TODO: there is also §6.7#4 which requires (nearly) the same an failure is a
             constraint violation, not UB. Which own should we report ???? *)
          (* STD §6.2.7#2 *)
          fail loc
            (Errors.Desugar_UndefinedBehaviour Undefined.UB015_incompatible_redeclaration)
        else
          let () = Debug.print_debug 3 [Debug.DB_desugaring] (fun () -> "found a valid redeclaration of `" ^ show sym ^ "'") in
          (* TODO: check that is ok to use AilTypesAux.make_composite for object types (see comment in AilTypesAux) *)
          (* TODO: what about qualifiers? *)
          if AilTypesAux.is_array prev_ty && AilTypesAux.is_array new_ty then
            match AilTypesAux.make_composite prev_ty new_ty with
              | Just ty' ->
                  State_exception.update (fun st ->
                    <| st with external_object_declarations= Map.insert sym new_decl st.external_object_declarations |>
                  )
              | Nothing ->
                  let () = Debug.print_debug 0 [] (fun () ->
                    "prev_ty= " ^ Pp.stringFromAil_ctype prev_qs prev_ty ^ "\n" ^
                    "new_ty= " ^ Pp.stringFromAil_ctype new_qs new_ty
                  ) in
                  error "WIP: register_external_object_declaration, make_composite failed"
            end
          else
            return ()
    | Nothing ->
        State_exception.update (fun st ->
          <| st with external_object_declarations= Map.insert sym new_decl st.external_object_declarations |>
        )
  end

val update_external_object_type: A.identifier -> ATypes.ctype -> desugM unit
let update_external_object_type sym ty =
  return (
    Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      "updating external object type of `" ^ show sym ^
      "' with ty= " ^ Pp.stringFromAil_ctype ATypes.no_qualifiers ty)
  ) >>
  State_exception.update (fun st ->
    match Map.lookup sym st.external_object_declarations with
      | Nothing ->
          error "[Cabs_to_ail_effect.update_external_object_type] called on an unregistered symbol"
      | Just (isTentative, loc, dur, is_register, qs, _) ->
          <| st with external_object_declarations=
            Map.insert sym (isTentative, loc, dur, is_register, qs, ty) st.external_object_declarations
          |>
    end
  )

(* TODO: factorize *)
val register_internal_object_declaration:
  A.identifier -> (Loc.t * ATypes.storageDuration * bool * ATypes.qualifiers * ATypes.ctype) -> desugM unit
let register_internal_object_declaration sym ((loc, _, _, _, _) as decl) =
  return (
    Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      let (_, _, _, new_qs, new_ty) = decl in
      "attempting to register internal object declaration of `" ^ show sym ^
      "' with qs, ty= " ^ Pp.stringFromAil_ctype new_qs new_ty)
  ) >>
  
  State_exception.read (fun st ->
    Map.lookup sym st.internal_object_declarations
  ) >>= function
    | Just decl' ->
        if decl <> decl' then
          (* STD §6.2.7#2 *)
          fail loc
            (Errors.Desugar_UndefinedBehaviour Undefined.UB015_incompatible_redeclaration)
        else
          return ()
    | Nothing ->
        State_exception.update (fun st ->
          <| st with internal_object_declarations= Map.insert sym decl st.internal_object_declarations |>
        )
  end

val update_internal_object_type: A.identifier -> ATypes.ctype -> desugM unit
let update_internal_object_type sym ty =
  return (
    Debug.print_debug 2 [Debug.DB_desugaring] (fun () ->
      "updating internal object type of `" ^ show sym ^
      "' with ty= " ^ Pp.stringFromAil_ctype ATypes.no_qualifiers ty)
  ) >>
  State_exception.update (fun st ->
    match Map.lookup sym st.internal_object_declarations with
      | Nothing ->
          error "[Cabs_to_ail_effect.update_internal_object_type] called on an unregistered symbol"
      | Just (loc, dur, is_register, qs, _) ->
          <| st with internal_object_declarations=
            Map.insert sym (loc, dur, is_register, qs, ty) st.internal_object_declarations
          |>
    end
  )



val register_static_assertion: A.expression unit -> A.stringLiteral -> desugM unit
let register_static_assertion e strCst =
  State_exception.update (fun st ->
    <| st with static_assertions= (e, strCst) :: st.static_assertions |>
  )


val register_label: cabs_identifier -> desugM unit
let register_label ident =
  void $ internal_register_identifier (fun _ _ ->
    fail (Loc.locOf ident) (Errors.Desugar_ConstraintViolation "§6.8.1#3")
  ) ident Namespace_label Kind_label Nothing


val resolve_label: cabs_identifier -> desugM A.identifier
let resolve_label ident =
  (* TODO: §6.8.6.1#1 *)
  internal_resolve_identifier ident Namespace_label >>= function
    | Just (_, Internal sym _ _) ->
        return sym
    | _ (*Nothing*) ->
        fail (Loc.locOf ident) (Errors.Desugar_OtherViolation "§6.8.6.1#1, sentence 1")
  end


(* Returns the return type of the function currently being desugared *)
(* val get_current_return_type: desugM ATypes.ctype *)
let get_current_return_type: desugM ATypes.ctype =
  State_exception.read (fun st ->
    st.current_return_type
  )

let set_current_return_type (ty: ATypes.ctype) : desugM unit =
  State_exception.update (fun st ->
    <| st with current_return_type= ty |>
  )



(* TODO: would be more efficient to store in the state the list of unused functions *)
val add_used_identifier: A.identifier -> desugM unit
let add_used_identifier sym =
  State_exception.update (fun st ->
    let () = Debug.print_debug 2 [Debug.DB_desugaring] (fun () -> "USED IDENTIFIER") in
    <| st with used_identifier= Utils.list_insert sym st.used_identifier |>
  )

val get_used_identifier: desugM (list A.identifier)
let get_used_identifier =
  State_exception.read (fun st ->
    st.used_identifier
  )






val register_enum_constant: cabs_identifier -> A.expression_ unit -> desugM unit
let register_enum_constant ident expr =
  let () = Debug.print_debug 2 [] (fun () -> 
    "register_enum_constant: " ^ show ident
  ) in
  internal_register_identifier (fun (scope, _) do_fresh ->
    current_scope_is scope >>= function
      | true ->
          (* STD footnote 127 *)
          fail (Loc.locOf ident) (Errors.Desugar_MultipleDeclaration ident)
      | false ->
          (* a previous registration from a different scope gets shadowed *)
          do_fresh ()
    end
  ) ident Namespace_ordinary (Kind_ordinary OK_enum_constant) Nothing >>= fun sym ->
  State_exception.update (fun st ->
    <| st with enumeration_constants= Map.insert sym expr st.enumeration_constants |>
  )

val resolve_enum_constant: A.identifier -> desugM (A.expression_ unit)
let resolve_enum_constant sym =
  State_exception.read (fun st ->
    st.enumeration_constants
  ) >>= fun enumeration_constants ->
  match Map.lookup sym enumeration_constants with
    | Just e ->
        return e
    | Nothing ->
        fail Loc.unknown Errors.Desugar_impossible
  end


(* TODO: hackish, uber inefficient *)
val remove_unused_identifiers: forall 'a. state -> A.identifier -> list (A.identifier * 'a) -> list (A.identifier * 'a)
let remove_unused_identifiers st startup_sym xs =
  List.filter (fun (sym, _) -> sym = startup_sym || List.elem sym st.used_identifier) xs

(*
val remove_block_scoped_identifiers: forall 'a. state -> list (A.identifier * 'a) -> list (A.identifier * 'a)
let remove_block_scoped_identifiers st xs =
  List.filter (fun (sym, _) ->
    match Scope_table.resolve (sym, Namespace_ordinary) st.registered_identifiers with
      | Just (Scope_file, _) ->
          true
      | _ ->
          false
    end
  ) xs
*)








(* TODO: ... *)
let map_union = Map.(union)

val extract_program: string -> desugM (A.ail_program unit)
let extract_program startup_str =
  State_exception.get >>= fun st ->
  let startup_sym_opt =
    match Map.lookup (CabsIdentifier Loc.unknown startup_str, Namespace_ordinary)
            st.registered_external_identifiers with
      | Nothing ->
          Nothing
      | Just (_, (sym, _, _)) ->
          Just sym
    end in
  
  let decls = Map_extra.toList (
    map_union
      begin map_union
        begin
          Map.map (fun (hasProto, loc, (ret_qs_ty, params_opt, isVariadic, isInline, isNoreturn)) ->
            let () = Debug.print_debug 1 [] (fun () ->
              "KKK: check + find STD quote"
            ) in
            let params = match params_opt with
              | Nothing -> []
              | Just z  -> z
            end in
            (loc, A.Decl_function hasProto ret_qs_ty params isVariadic isInline isNoreturn)
          ) st.function_declarations
        end
        begin
          Map.map (fun (_, loc, dur, isRegister, qs, ty) ->
            (loc, A.Decl_object (dur, isRegister) qs ty)
          ) st.external_object_declarations
        end
      end
      begin
        (* Adding internals object with static or thread storage duration *)
        Map_extra.fold (fun ident (loc, dur, isRegister, qs, ty) acc ->
          match dur with
            | ATypes.Static ->
                Map.insert ident (loc, A.Decl_object (dur, isRegister) qs ty) acc
            | ATypes.Thread ->
                Map.insert ident (loc, A.Decl_object (dur, isRegister) qs ty) acc
            | _ ->
                acc
          end
        ) st.internal_object_declarations Map.empty
      end
  ) in
  
  let object_defs =
    List.map (function
      | (sym, Tentative ty) ->
          (sym, mk_zeroInit st.tag_definitions ty)
      | (sym, Definition e) ->
          (sym, e)
      | (sym, ExternalDefinition e) ->
          (sym, e)
    end) (Map_extra.toList st.global_object_definitions) in
  
  mapM (fun ((ident, _), (_, (sym, kind, link_opt))) ->
    (* TODO: the errors should only be for when the identifiers are used in an
       evaluated expression (i.e. "other than as part of the operand of a sizeof
       or _Alignof operator whose result is an integer constant") *)
    match link_opt with
      | Just Linkage_internal ->
          if    List.elem sym st.used_identifier
             && (kind = Kind_ordinary (OK_object false) || kind = Kind_ordinary OK_function)
             && List.lookup sym object_defs = Nothing
             && not (Map.member sym st.function_definitions) then
            (* STD §6.9#3, sentence 2 *)
            fail (Loc.locOf ident) (Errors.Desugar_ConstraintViolation "§6.9#3, sentence 2")
          else
            return ()
      | Just Linkage_external ->
          (* TODO: the error is desactivated for functions for now. We need to have a way of telling the desugaring that
             some function are implemented in Core (i.e. printf()) *)
          if    List.elem sym st.used_identifier
             && kind = Kind_ordinary (OK_object false)
             && List.lookup sym object_defs = Nothing
             && not (Map.member sym st.function_definitions) then
            (* STD §6.9#5, sentence 2 *)
            let () = Debug.print_debug 0 [] (fun () ->
              "extract_program"
            ) in
            fail (Loc.locOf ident) (Errors.Desugar_UndefinedBehaviour Undefined.UB084)
          else
            return ()
      | _ ->
          return ()
    end
  ) (Map_extra.toList st.registered_external_identifiers) >>
  
  return (startup_sym_opt, <|
     A.declarations=         (* remove_unused_identifiers st startup_sym *) decls;
     A.object_definitions=   (* remove_unused_identifiers st startup_sym $ *) object_defs;
     A.function_definitions= (* remove_unused_identifiers st startup_sym $ *) Map_extra.toList st.function_definitions;
     A.static_assertions=    st.static_assertions;
     
     A.tag_definitions= List.foldr (fun (sym, def) acc ->
                          match def with
                           | Struct_definition _ membersDefs ->
                               (sym, A.StructDef membersDefs) :: acc
                           | Union_definition _ membersDefs ->
                               (sym, A.UnionDef membersDefs) :: acc
                           | Enum_definition ->
                               acc
                           end
                        ) [] $ Map_extra.toList st.tag_definitions
   |>)



val print_debugM: nat -> (unit -> string) -> desugM unit
let inline print_debugM n msg =
  return (Debug.print_debug n [Debug.DB_desugaring] msg)


(* TODO *)
import Core
val get_core_eval_stuff: desugM (((map string Symbol.sym) * Core.fun_map unit * Core.impl) * UniqueId.supply Symbol.sym)
let get_core_eval_stuff =
  State_exception.read (fun st ->
    (st.core_eval_stuff, st.symbol_supply)
  )


val get_gamma_sofar: desugM A.gamma
let get_gamma_sofar =
  State_exception.read (fun st ->
    (* TODO: this is putting too much in gamma (i.e. things which are not in the
       current scope). But since we are dealing with fresh symbols, this
       shouldn't be observable? *)
    List.map (fun (sym, (_, dur, b, qs, ty)) ->
      (sym, ((dur, b), qs, ty))
    ) (Map_extra.toList st.internal_object_declarations)
  )


(* Returns what would the Ail sigma be so far *)
(* TODO: factorise with extract_program *)
val get_sigma_sofar: desugM (A.sigma unit)
let get_sigma_sofar =
  State_exception.read (fun st ->
    let decls = Map_extra.toList (
      map_union
        begin
          Map.map (fun (hasProto, loc, (ty, params_opt, isVariadic, isInline, isNoreturn)) ->
            let () = Debug.print_debug 1 [] (fun () ->
              "KKK: check + find STD quote"
            ) in
            (* TODO: is it correct "complete" the params like that ? *)
            let params = match params_opt with
              | Nothing -> []
              | Just z  -> z
            end in
            (loc, A.Decl_function hasProto ty params isVariadic isInline isNoreturn)
          ) st.function_declarations
        end
        begin
          Map.map (fun (_, loc, dur, isRegister, qs, ty) ->
            (loc, A.Decl_object ((dur, isRegister)) qs ty)
          ) st.external_object_declarations
        end
    ) in
    
    <|
       A.declarations=         (* remove_unused_identifiers st startup_sym *) decls;
       A.object_definitions=   (* remove_unused_identifiers st startup_sym $ *) [(*TODO:check, but this shouldn't be used*)]
(*Map_extra.toList st.global_object_definitions*);
       A.function_definitions= (* remove_unused_identifiers st startup_sym $ *) Map_extra.toList st.function_definitions;
       A.static_assertions=    st.static_assertions;
       
       A.tag_definitions= List.foldr (fun (sym, def) acc ->
                            match def with
                             | Struct_definition _ membersDefs ->
                                 (sym, A.StructDef membersDefs) :: acc
                             | Union_definition _ membersDefs ->
                                 (sym, A.UnionDef membersDefs) :: acc
                             | Enum_definition ->
                                 acc
                             end
                          ) [] $ Map_extra.toList st.tag_definitions
     |>
  )


val is_incomplete: ATypes.ctype -> desugM bool
let cabs_to_ail_effect_is_incomplete ty =
  get_tag_definitions >>= fun ident_tagDefs ->
  let (fake_ail_sigma : A.sigma unit) = <|
    A.declarations= [];
    A.object_definitions= [];
    A.function_definitions= [];
    A.static_assertions= [];
    A.tag_definitions=
      List.foldl (fun acc (ident, tagDef) ->
        match tagDef with
          | Struct_definition _ xs ->
              (ident, A.StructDef xs) :: acc
          | Union_definition _ xs ->
              (ident, A.UnionDef xs) :: acc
          | Enum_definition _ ->
              acc
        end
      ) [] (Map_extra.toList ident_tagDefs);
  |> in
  return (AilTypesAux.is_incomplete fake_ail_sigma ty)
let inline is_incomplete = cabs_to_ail_effect_is_incomplete


