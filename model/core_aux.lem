open import Pervasives Global Show Core Core_ctype
import AilSyntax AilTypes
import Product Symbolic Exception Mem Mem_aux

open import Cthread Errors

open import{hol} `pp_coreTheory`

import Debug Pp


val strip: forall 'ty 'sym. generic_pexpr 'ty 'sym -> pexpr_ 'ty 'sym
let strip (Pexpr _ pexpr_) =
  pexpr_



val     core_object_type_of_ctype: ctype -> maybe core_object_type
let rec core_object_type_of_ctype ty =
  match ty with
   | Void ->
       Nothing
   | Basic (AilTypes.Integer _) ->
       Just OTy_integer
   | Basic (AilTypes.Floating _) ->
       Just OTy_floating
   | Array _ ty _ ->
       match core_object_type_of_ctype ty with
         | Just oTy ->
             Just (OTy_array oTy)
         | Nothing ->
             error "Core_aux.core_object_type_of_ctype: Array found a Nothing"
       end
   | Function ty xs isVariadic ->
       Just (OTy_cfunction (core_object_type_of_ctype ty) (List.length xs) isVariadic)
(*
       match maybe_mapM (core_object_type_of_ctype -| snd) xs with
         | Just oTys ->
             Just (OTy_cfunction (core_object_type_of_ctype ty) oTys)
         | Nothing ->
             error "Core_aux.core_object_type_of_ctype: Function found a Nothing"
       end
*)
   | Pointer _ _ ->
       Just OTy_pointer
   | Atomic ty ->
       core_object_type_of_ctype ty
   | Struct tag_sym ->
       Just (OTy_struct tag_sym)
   | Union tag_sym ->
       Just (OTy_union tag_sym)
   | Builtin _ ->
       error "TODO: Caux.object_type_of_ctype Builtin"
  end

val oTy_of_bTy: core_base_type -> maybe core_object_type
let oTy_of_bTy = function
  | BTy_unit ->
      Nothing
 | BTy_boolean ->
      Nothing
 | BTy_ctype ->
      Nothing
 | BTy_list _ ->
      Nothing
 | BTy_tuple _ ->
      Nothing
 | BTy_object oTy ->
     Just oTy
 | BTy_loaded oTy ->
     Just oTy
end


val     objectValueFromMemValue: Mem.mem_value -> core_object_type * object_value
let rec objectValueFromMemValue mem_val =
  Mem.case_mem_value mem_val
    (fun ty                -> error"[Core_aux.objectValueFromMemValue] FOUND AN UNSPECIFIED MVAL")
    (fun _ _               -> error "[Core_aux.objectValueFromMemValue] concurrency read")
    (fun _ ival            -> (OTy_integer, OVinteger ival))
    (fun _ fval            -> (OTy_floating, OVfloating fval))
    (fun _ ptr_val         -> (OTy_pointer, OVpointer ptr_val))
    (fun mem_vals          -> error "[Core_aux.objectValueFromMemValue] Vspecified (OVarray (List.map objectValueFromMemValue mem_vals))")
    (fun sym xs            -> (OTy_struct sym, OVstruct sym xs))
    (fun sym ident mem_val -> (OTy_union sym, OVunion sym ident mem_val))

and loadedValueFromMemValue mem_val : core_object_type * loaded_value =
  Mem.case_mem_value mem_val
    (fun ty                -> (fromJust "loadedValueFromMemValue" (core_object_type_of_ctype ty), LVunspecified ty))
    (fun _ _               -> error "[Core_aux.loadedValueFromMemValue] concurrency read")
    (fun _ ival            -> (OTy_integer, LVspecified (OVinteger ival)))
    (fun _ fval            -> (OTy_floating, LVspecified (OVfloating fval)))
    (fun _ ptr_val         -> (OTy_pointer, LVspecified (OVpointer ptr_val)))
    (fun mem_vals          -> error "[Core_aux.loadedValueFromMemValue] array")
    (fun sym xs            -> (OTy_struct sym, LVspecified (OVstruct sym xs)))
    (fun sym ident mem_val -> (OTy_union sym, LVspecified (OVunion sym ident mem_val)))


val     valueFromMemValue: Mem.mem_value -> core_object_type * value
let rec valueFromMemValue mem_val =
  Mem.case_mem_value mem_val
    (fun ty                -> (fromJust "Core_aux.valueFromMemValue" (core_object_type_of_ctype ty), Vloaded (LVunspecified ty)))
    (fun _ _               -> error "[Core_aux.valueFromMemValue] concurrency read")
    (fun _ ival            -> (OTy_integer, Vloaded (LVspecified (OVinteger ival))))
    (fun _ fval            -> (OTy_floating, Vloaded (LVspecified (OVfloating fval))))
    (fun _ ptr_val         -> (OTy_pointer, Vloaded (LVspecified (OVpointer ptr_val))))
    (fun mem_vals          -> let (oTys, lvals) = List.unzip (List.map loadedValueFromMemValue mem_vals) in
                              let oTy = match oTys with
                                | [] ->
                                    (* Something went wrong in the MLM *)
                                    error "Core_aux.valueFromMemValue ==> empty array"
                                | oTy :: _ ->
                                    oTy
                              end in
                              (OTy_array oTy, Vloaded (LVspecified (OVarray lvals))))
    (fun sym xs            -> (OTy_struct sym, Vloaded (LVspecified (OVstruct sym xs))))
    (fun sym ident mem_val -> (OTy_union sym, Vloaded (LVspecified (OVunion sym ident mem_val))))


val     memValueFromValue: ctype -> value -> maybe Mem.mem_value
let rec memValueFromValue ty cval =
  match (ty, cval) with
    | (_, Vunit) ->
        Nothing
    | (_, Vtrue) ->
        Nothing
    | (_, Vfalse) ->
        Nothing
    | (_, Vlist _ _) ->
        Nothing
    | (_, Vtuple _) ->
        Nothing
    | (_, Vctype _) ->
        Nothing
    | (_, Vloaded (LVunspecified ty')) ->
        Just (Mem.unspecified_mval ty') (* TODO: check ty = ty'? *)
    | (Basic (AilTypes.Integer ity), Vloaded (LVspecified (OVinteger ival))) ->
        Just (Mem.integer_value_mval ity ival)
    | (Basic (AilTypes.Floating fty), Vloaded (LVspecified (OVfloating fval))) ->
        Just (Mem.floating_value_mval fty fval)
    | (Pointer _ ref_ty, Vloaded (LVspecified (OVpointer ptr_val))) ->
        Just (Mem.pointer_mval ref_ty ptr_val)
    | (Array _ elem_ty _, Vloaded (LVspecified (OVarray lvals))) ->
        (* TODO: check that the sizes match? *)
        maybe Nothing (fun z -> Just (Mem.array_mval z)) $
          List.foldr (fun lval acc_opt ->
            match (memValueFromValue elem_ty (Vloaded lval), acc_opt) with
              | (Just mem_val, Just acc) ->
                  Just (mem_val :: acc)
              | _ ->
                  Nothing
            end
          ) (Just []) lvals
    | (Struct tag_sym1, Vloaded (LVspecified (OVstruct tag_sym2 xs))) ->
        if tag_sym1 = tag_sym2 then
          Just (Mem.struct_mval tag_sym1 xs)
        else
          Nothing
    | (Union tag_sym1, Vloaded (LVspecified (OVunion tag_sym2 ident mem_val))) ->
        if tag_sym1 = tag_sym2 then
          Just (Mem.union_mval tag_sym1 ident mem_val)
        else
          Nothing
    | _ ->
        Nothing
  end





(* Project an AilTypes.ctype into a Core.ctype *)
val     proj_ctype: AilTypes.ctype -> Core_ctype.ctype
let rec proj_ctype ty =
  match ty with
    | AilTypes.Void ->
        Core_ctype.Void
    | AilTypes.Basic bty ->
        Core_ctype.Basic bty
    | AilTypes.Array qs ty n_opt ->
        Core_ctype.Array qs (proj_ctype ty) n_opt
    | AilTypes.Function _ ty qs_tys is_variadic ->
        Core_ctype.Function (proj_ctype ty) (List.map (fun (qs,ty) -> (qs, proj_ctype ty)) qs_tys) is_variadic
    | AilTypes.Pointer qs ty ->
        Core_ctype.Pointer qs (proj_ctype ty)
    | AilTypes.Atomic ty ->
        Core_ctype.Atomic (proj_ctype ty)
    | AilTypes.Struct tag_sym ->
        Core_ctype.Struct tag_sym
    | AilTypes.Union tag_sym ->
        Core_ctype.Union tag_sym
(*
    | AilTypes.Struct tag_sym ident_tys ->
        Core_ctype.Struct tag_sym
          (List.map (fun (ident, ty) -> (ident, proj_ctype ty)) ident_tys)
    | AilTypes.Union tag_sym ident_tys ->
        Core_ctype.Union tag_sym
          (List.map (fun (ident, ty) -> (ident, proj_ctype ty)) ident_tys)
*)
    | AilTypes.Builtin str ->
        Core_ctype.Builtin str
  end




(* Core pattern builders **************************************************** *)

val mk_empty_pat: core_base_type -> pattern
let mk_empty_pat bTy =
  CaseBase (Nothing, bTy)

val mk_sym_pat: Symbol.sym -> core_base_type -> pattern
let mk_sym_pat sym bTy =
  CaseBase (Just sym, bTy)

val mk_tuple_pat: list pattern -> pattern
let mk_tuple_pat = function
  | [] ->
      error "[Core_aux.mk_tuple_pat] called with |pats| = 0"
  | [pat] ->
      pat
  | pats ->
      CaseCtor Ctuple pats
end

val mk_specified_pat: pattern -> pattern
let mk_specified_pat pat =
  CaseCtor Cspecified [pat]

val mk_unspecified_pat: pattern -> pattern
let mk_unspecified_pat pat =
  CaseCtor Cunspecified [pat]


(* Core pexpr builders  ***************************************************** *)
val mk_sym_pe: core_base_type -> Symbol.sym -> pexpr (* TODO: remove the bTy *)
let mk_sym_pe bTy sym =
  Pexpr () (PEsym sym)

(* TODO: mk_impl_pe *)

(* TODO: PEval Vconstrained, Vobject *)

val mk_integer_pe: integer -> pexpr
let mk_integer_pe n =
  Pexpr () (PEval (Vobject (OVinteger (Mem.integer_ival n))))

val mk_floating_value_pe: Mem.floating_value -> pexpr
let mk_floating_value_pe fval =
  Pexpr () (PEval (Vobject (OVfloating fval)))

val mk_nullptr_pe: Core_ctype.ctype -> pexpr
let mk_nullptr_pe ref_ty =
  Pexpr () (PEval (Vobject (OVpointer (Mem.null_ptrval ref_ty))))

val mk_cfunction_pe: Symbol.sym -> pexpr
let mk_cfunction_pe fsym =
  Pexpr () (PEval (Vobject (OVcfunction (Sym fsym))))

val mk_specified_pe: pexpr -> pexpr
let mk_specified_pe pe =
    Pexpr () (PEctor Cspecified [pe])

val mk_unspecified_pe: Core_ctype.ctype -> pexpr
let mk_unspecified_pe ty =
  Pexpr () (PEval (Vloaded (LVunspecified ty)))

val mk_array_pe: list pexpr -> pexpr
let mk_array_pe pes =
  Pexpr () (PEctor Carray pes)

val mk_unit_pe: pexpr
let mk_unit_pe =
  Pexpr () (PEval Vunit)

val mk_boolean_pe: bool -> pexpr
let mk_boolean_pe b =
  Pexpr () (PEval (if b then Vtrue else Vfalse))

(* TODO: PEval Vtrue, Vfalse *)

val mk_ail_ctype_pe: AilTypes.ctype -> pexpr
let mk_ail_ctype_pe ty =
  Pexpr () (PEval (Vctype (proj_ctype ty)))

val mk_ctype_pe: ctype -> pexpr
let mk_ctype_pe ty =
  Pexpr () (PEval (Vctype ty))

val     mk_list_pe: list pexpr -> pexpr
let rec mk_list_pe pes =
  Pexpr () match pes with
    | [] ->
        PEctor (Cnil ()) []
    | pe :: pes' ->
        PEctor Ccons [pe; mk_list_pe pes']
  end

val mk_tuple_pe: list pexpr -> pexpr
let mk_tuple_pe pes =
  Pexpr () (PEctor Ctuple pes)

val mk_ivmax_pe: pexpr -> pexpr
let mk_ivmax_pe pe =
  Pexpr () (PEctor Civmax [pe])

val mk_ivmin_pe: pexpr -> pexpr
let mk_ivmin_pe pe =
  Pexpr () (PEctor Civmin [pe])

val mk_sizeof_pe: pexpr -> pexpr
let mk_sizeof_pe pe =
  Pexpr () (PEctor Civsizeof [pe])

val mk_alignof_pe: pexpr -> pexpr
let mk_alignof_pe pe =
  Pexpr () (PEctor Civalignof [pe])

(* TODO: PEconstrained *)

val mk_undef_pe: Undefined.undefined_behaviour -> pexpr
let mk_undef_pe ub =
  Pexpr () (PEundef ub)

val mk_error_pe: string -> pexpr -> pexpr
let mk_error_pe str pe =
  Pexpr () (PEerror str pe)

val mk_not_pe: pexpr -> pexpr
let mk_not_pe pe =
  Pexpr () (PEnot pe)

val mk_op_pe: binop -> pexpr -> pexpr -> pexpr
let mk_op_pe bop pe1 pe2 =
  Pexpr () (PEop bop pe1 pe2)

val mk_let_pe: pattern -> pexpr -> pexpr -> pexpr
let mk_let_pe pat pe1 pe2 =
  Pexpr () (PElet pat pe1 pe2)

val mk_if_pe: pexpr -> pexpr -> pexpr -> pexpr
let mk_if_pe pe1 pe2 pe3 =
  Pexpr () (PEif pe1 pe2 pe3)

val mk_array_shift: pexpr -> ctype -> pexpr -> pexpr
let mk_array_shift pe1 ty pe2 =
  Pexpr () (PEarray_shift pe1 ty pe2)

val mk_member_shift_pe: pexpr -> Symbol.sym -> Cabs.cabs_identifier -> pexpr
let mk_member_shift_pe pe1 tag_sym member_ident =
  Pexpr () (PEmember_shift pe1 tag_sym member_ident)

val mk_case_pe: pexpr -> list (pattern * pexpr) -> pexpr
let mk_case_pe pe pat_pes =
  Pexpr () (PEcase pe pat_pes)

val mk_neg_pe: pexpr -> pexpr
let mk_neg_pe pe =
  Pexpr () (PEop OpSub (mk_integer_pe 0) pe)

val mk_struct_pe: Symbol.sym -> list (Cabs.cabs_identifier * pexpr) -> pexpr
let mk_struct_pe tag_sym xs =
  Pexpr () (PEstruct tag_sym xs)

val mk_union_pe: Symbol.sym -> Cabs.cabs_identifier -> pexpr -> pexpr
let mk_union_pe tag_sym memb_ident pe =
  Pexpr () (PEunion tag_sym memb_ident pe)
























val bitwise_complement_pe: pexpr -> pexpr -> pexpr
val integer_encode_pe:     pexpr -> pexpr -> pexpr
val integer_decode_pe:     pexpr -> pexpr -> pexpr

let bitwise_complement_pe pe1 pe2 =
  Pexpr () (PEcall (Impl Implementation_.Bitwise_complement) [pe1; pe2])
let integer_encode_pe pe1 pe2 =
  Pexpr () (PEcall (Impl Implementation_.Integer__encode) [pe1; pe2])
let integer_decode_pe pe1 pe2 =
  Pexpr () (PEcall (Impl Implementation_.Integer__decode) [pe1; pe2])

(* Some aliases for positive actions *)
let pcreate loc al ty pref = Eaction (Paction Pos (Action loc default (Create al ty pref )))
let palloc loc al e pref   = Eaction (Paction Pos (Action loc default (Alloc al e pref   )))
let pkill loc x            = Eaction (Paction Pos (Action loc default (Kill x         )))
let pstore loc ty x n mo   = Eaction (Paction Pos (Action loc default (Store ty x n mo)))
let pload loc ty x mo      = Eaction (Paction Pos (Action loc default (Load ty x mo   )))
let prmw loc ty x n1 n2 mo1 mo2 = Eaction (Paction Pos (Action loc default (RMW ty x n1 n2 mo1 mo2)))






(* for a given Ctype returns the corresponding "zero" value *)
(*val     zeros: AilSyntax.tag_definition -> Core_ctype.ctype -> pexpr *)
(* see ยง6.7.9#10 *)
let rec zeros_aux ty =
  let zero_ival = Mem.integer_ival 0 in
  match ty with
    | Core_ctype.Basic (AilTypes.Integer ity) ->
        Mem.integer_value_mval ity zero_ival
    | Core_ctype.Basic (AilTypes.Floating fty) ->
        Mem.floating_value_mval fty Mem.zero_fval
    | Core_ctype.Array _ elem_ty (Just n) ->
        Mem.array_mval (List.replicate (natFromInteger n) (zeros_aux elem_ty))
(*
  Mem.array_mval (List.replicate (natFromInteger n) (Mem.integer_value_mval zero_ival))
*)
    | Core_ctype.Pointer _ ref_ty ->
        Mem.pointer_mval ref_ty (Mem.null_ptrval ref_ty)
    | Core_ctype.Atomic ty' ->
        zeros_aux ty'
    | Core_ctype.Struct tag ->
        match Map.lookup tag (Core_ctype_aux.tagDefs ()) with
          | Just ident_tys ->
              Mem.struct_mval tag (List.map (fun (ident, ty) -> (ident, zeros_aux ty)) ident_tys)
          | _ ->
              error "Core_aux.zeros_aux, not StructDef"
        end
    | Core_ctype.Union tag ->
        match Map.lookup tag (Core_ctype_aux.tagDefs ()) with
          | Just ((ident, ty')::_) ->
              Mem.union_mval tag ident (zeros_aux ty')
          | _ ->
              error "Core_aux.zeros_aux, not UnionDef"
        end

(*
 | Builtin of string
*)
   | _ ->
       error "Core_aux.zeros should only be called on complete types"
  end

val zeros: ctype -> pexpr
let zeros ty =
  (* TODO: yucky *)
  Pexpr ()
(*
    (PEval (Vobject (snd $ objectValueFromMemValue (zeros_aux ty))))
*)
    (PEval (snd $ valueFromMemValue (zeros_aux ty)))


(*


(*

TODO: bring back structs/unions

  let proj_member = function
    | Ail.MEMBER ty               -> MEMBER (proj_ctype ty)
    | Ail.BITFIELD ty w is_packed -> BITFIELD (proj_ctype ty) w is_packed
  end in
*)
  match ty with
    | AilTypes.Void             -> Core_ctype.Void
    | AilTypes.Basic bt         -> Core_ctype.Basic bt
    | AilTypes.Array ty n       -> Core_ctype.Array (proj_ctype ty) n
    | AilTypes.Function ty ps b -> Core_ctype.Function (proj_ctype ty) (List.map (proj_ctype -| snd) ps) b
    | AilTypes.Pointer _ ty    -> Core_ctype.Pointer (proj_ctype ty)
    | AilTypes.Atomic ty        -> Core_ctype.Atomic (proj_ctype ty)
(*
    | Ail.STRUCT _ tag members -> STRUCT tag (List.map (fun (a, m) -> (a, proj_member m)) members)
    | Ail.UNION  _ tag members -> UNION  tag (List.map (fun (a, m) -> (a, proj_member m)) members)
    | Ail.ENUM id              -> ENUM id
    | Ail.ATOMIC ty            -> ATOMIC (proj_ctype ty)
    | Ail.TYPEDEF _            -> error "[Core_aux.proj_ctype] found a A.TYPEDEF"
    | Ail.SIZE_T               -> SIZE_T
    | Ail.INTPTR_T             -> INTPTR_T
    | Ail.WCHAR_T              -> WCHAR_T
    | Ail.CHAR16_T             -> CHAR16_T
    | Ail.CHAR32_T             -> CHAR32_T
*)
end
*)

(* Bring back a Core.ctype into a Ail.ctype (with loss of qualifiers if coming from proj_ctype) *)
let rec unproj_ctype ty =
  match ty with
    | Core_ctype.Void ->
        AilTypes.Void
    | Core_ctype.Basic bty ->
        AilTypes.Basic bty
    | Core_ctype.Array qs ty n_opt ->
        AilTypes.Array qs (unproj_ctype ty) n_opt
    | Core_ctype.Function ty qs_tys is_variadic ->
        AilTypes.Function (* TODO!!!! proto *) false (unproj_ctype ty) (List.map (fun (qs,ty) -> (qs, unproj_ctype ty)) qs_tys) is_variadic
    | Core_ctype.Pointer qs ty ->
        AilTypes.Pointer qs (unproj_ctype ty)
    | Core_ctype.Atomic ty ->
        AilTypes.Atomic (unproj_ctype ty)
    | Core_ctype.Struct tag ->
        AilTypes.Struct tag
    | Core_ctype.Union tag ->
        AilTypes.Union tag
    | Core_ctype.Builtin str ->
        AilTypes.Builtin str
  end


(*
(*
  let unproj_member = function
    | MEMBER ty               -> Ail.MEMBER (unproj_ctype ty)
    | BITFIELD ty w is_packed -> Ail.BITFIELD (unproj_ctype ty) w is_packed
  end in
*)
  match ty with
    | Core_ctype.Void              -> AilTypes.Void
    | Core_ctype.Basic bt          -> AilTypes.Basic bt
    | Core_ctype.Array ty n        -> AilTypes.Array (unproj_ctype ty) n
    | Core_ctype.Function ty tys b -> AilTypes.Function (unproj_ctype ty) (List.map (Product.make AilTypes.no_qualifiers -| unproj_ctype) tys) b
    | Core_ctype.Pointer ty        -> AilTypes.Pointer AilTypes.no_qualifiers (unproj_ctype ty)
    | Core_ctype.Atomic ty         -> AilTypes.Atomic (unproj_ctype ty)
(*
    | STRUCT tag members -> Ail.STRUCT Ail.no_qualifiers tag (List.map (fun (a, m) -> (a, unproj_member m)) members)
    | UNION  tag members -> Ail.UNION  Ail.no_qualifiers tag (List.map (fun (a, m) -> (a, unproj_member m)) members)
    | ENUM id            -> Ail.ENUM id
    | ATOMIC ty          -> Ail.ATOMIC (unproj_ctype ty)
    | SIZE_T             -> Ail.SIZE_T
    | INTPTR_T           -> Ail.INTPTR_T
    | WCHAR_T            -> Ail.WCHAR_T
    | CHAR16_T           -> Ail.CHAR16_T
    | CHAR32_T           -> Ail.CHAR32_T
*)
end
*)




(*
let rec mk_wseqs_aux end_e pat_es =
  match pat_es with
    | []               -> end_e
    | (pat, e) :: pat_es' -> Ewseq pat e (mk_wseqs_aux end_e pat_es')
end

val mk_wseqs: expr unit -> list (pattern * expr unit) -> expr unit
let mk_wseqs end_e = function
  | [] ->
      end_e
  | [(_, e)] ->
      e
  | pat_es ->
      mk_wseqs_aux end_e pat_es
end
*)

val     mk_sseqs: list (pattern * expr unit) -> (expr unit -> expr unit)
let rec mk_sseqs pat_es =
  fun z ->
  match pat_es with
    | [] ->
        z
    | (pat, e) :: pat_es' ->
        Esseq pat e (mk_sseqs pat_es' z)
  end



(*
(* val     mk_sseq: forall 'a. list (pattern * expr 'a) -> expr 'a *)
let rec mk_sseq a_opts_es =
  match a_opts_es with
    | []               -> Eskip
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Esseq a_opts e (mk_sseq es')
end

(* val     mk_sseq': forall 'a. list (pattern * expr 'a) -> expr 'a -> expr 'a *)
let rec mk_sseq' a_opts_es z =
  match a_opts_es with
    | []               -> z
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Esseq a_opts e (mk_sseq' es' z)
end
*)


let mk_unseq = function
  | []  -> Eskip
  | [e] -> e
  | es  -> Eunseq es
end

val     mk_unit_sseq: list (expr unit) -> (expr unit -> expr unit)
let rec mk_unit_sseq es =
  fun z ->
    match es with
      | [] ->
          z
(*
      | [e] ->
          e
*)
      | e::es' ->
          Esseq (mk_empty_pat BTy_unit) e (mk_unit_sseq es' z)
    end

val     mk_bTy_sseqs: list (core_base_type * expr unit) -> expr unit
let rec mk_bTy_sseqs bTy_es =
  match bTy_es with
    | [] ->
        Eskip
    | [(_, e)] ->
        e
    | (bTy, e) :: bTy_es' ->
        Esseq (mk_empty_pat bTy) e (mk_bTy_sseqs bTy_es')
  end

let rec concat_sseq e e' =
   match e with
     | Esseq pat e1 e2 -> Esseq pat e1 (concat_sseq e2 e')
     | Eskip           -> e'
     | _               -> Esseq (mk_empty_pat BTy_unit) e e'
  end

let is_negative = function
  | Eaction (Paction Neg _) -> true
  | _ -> false
end

let is_negative_action = function
  | (Paction Neg _) -> true
  | _ -> false
end


(* TODO: rewrite this in bottom-up *)
val     flatten_constrained_value: value -> value
let rec flatten_constrained_value v =
  match v with
    | Vconstrained xs ->
        Vconstrained $ List.concatMap (fun (constrs, v') ->
          match flatten_constrained_value v' with
            | Vconstrained ys ->
                List.map (fun (constrs', v'') ->
                  (constrs ++ constrs', v'')
                ) ys
            | v'' ->
                [(constrs, v'')]
          end
        ) xs
    | _ ->
        v
  end

val valueFromPexpr: pexpr -> maybe value
let valueFromPexpr = function
  | Pexpr () (PEval cval) ->
      Just (flatten_constrained_value cval)
  | _ ->
      Nothing
  end

val     valueFromPexprs: list pexpr -> maybe (list value)
let rec valueFromPexprs pes =
  List.foldr (fun pe acc_opt ->
    match (valueFromPexpr pe, acc_opt) with
      | (Just cval, Just acc) ->
          Just (cval :: acc)
      | _ ->
          Nothing
    end) (Just []) pes


val to_integer: pexpr -> maybe integer
let to_integer pe =
  match valueFromPexpr pe with
    | Just (Vobject (OVinteger ival)) ->
        Mem_aux.integerFromIntegerValue ival
    | _ ->
        Nothing
  end










(* check if a symbolic names is part of a pattern *)
val in_pattern: Symbol.sym -> pattern -> bool
let rec in_pattern sym pat =
  match pat with
    | CaseBase (sym_opt, _) ->
        maybe false (fun sym' -> sym = sym') sym_opt
    | CaseCtor _ pats' ->
        List.any (in_pattern sym) pats'
  end

(* substitute in an expression a symbolic name with a (pure) expression *)
val     subst_sym_pexpr: Symbol.sym -> pexpr -> pexpr -> pexpr
let rec subst_sym_pexpr sym (Pexpr annot pe_' as pe') (Pexpr _ pe_) =
  Pexpr annot match pe_ with
    | PEsym sym' ->
        if sym = sym' then pe_' else pe_
    | PEimpl _ ->
        pe_
    | PEval _ ->
        pe_
    | PEconstrained xs ->
        PEconstrained $
          List.map (fun (constrs, pe) -> (constrs, subst_sym_pexpr sym pe' pe)) xs
    | PEundef _ ->
        pe_
    | PEerror str pe ->
        PEerror str (subst_sym_pexpr sym pe' pe)
    | PEctor ctor pes ->
        PEctor ctor (List.map (subst_sym_pexpr sym pe') pes)
    | PEcase pe xs ->
        PEcase (subst_sym_pexpr sym pe' pe) (List.map (fun (pat, pe) ->
          (pat, if in_pattern sym pat then pe else subst_sym_pexpr sym pe' pe)
        ) xs)
    | PEarray_shift pe1 ty pe2 ->
        PEarray_shift (subst_sym_pexpr sym pe' pe1) ty (subst_sym_pexpr sym pe' pe2)
    | PEmember_shift pe tag_sym memb_ident ->
        PEmember_shift (subst_sym_pexpr sym pe' pe) tag_sym memb_ident
    | PEnot pe ->
        PEnot (subst_sym_pexpr sym pe' pe)
    | PEop bop pe1 pe2 ->
        PEop bop (subst_sym_pexpr sym pe' pe1) (subst_sym_pexpr sym pe' pe2)
    | PEstruct tag_sym xs ->
        PEstruct tag_sym (List.map (fun (ident, pe) -> (ident, subst_sym_pexpr sym pe' pe)) xs)
    | PEunion tag_sym ident pe ->
        PEunion tag_sym ident (subst_sym_pexpr sym pe' pe)
    | PEcall nm pes ->
        PEcall nm (List.map (subst_sym_pexpr sym pe') pes)
    | PElet pat pe1 pe2 ->
        PElet pat (subst_sym_pexpr sym pe' pe1) (if in_pattern sym pat then pe2 else subst_sym_pexpr sym pe' pe2)
    | PEif pe1 pe2 pe3 ->
        PEif (subst_sym_pexpr sym pe' pe1) (subst_sym_pexpr sym pe' pe2) (subst_sym_pexpr sym pe' pe3)
    | PEis_scalar pe ->
        PEis_scalar (subst_sym_pexpr sym pe' pe)
    | PEis_integer pe ->
        PEis_integer (subst_sym_pexpr sym pe' pe)
    | PEis_signed pe ->
        PEis_signed (subst_sym_pexpr sym pe' pe)
    | PEis_unsigned pe ->
        PEis_unsigned (subst_sym_pexpr sym pe' pe)
end


val     subst_sym_expr: forall 'a. Symbol.sym -> pexpr -> expr 'a -> expr 'a
let rec subst_sym_expr sym pe' = function
(*
  let () =
    (* TODO: debug *)
    match valueFromPexpr pe' with
      | Just _ ->
          ()
      | Nothing ->
          error ("DEBUG [Caux.subst_sym_expr]: called on a non-value: " ^ Pp.stringFromCore_expr (Epure pe'))
    end
  in
  match _pe with
*)
  | Epure pe ->
      Epure (subst_sym_pexpr sym pe' pe)
  | Ememop memop pes ->
      Ememop memop (List.map (subst_sym_pexpr sym pe') pes)
  | (Eskip as expr) ->
      expr
  | Elet pat pe1 e2 ->
      Elet pat (subst_sym_pexpr sym pe' pe1) (if in_pattern sym pat then e2 else subst_sym_expr sym pe' e2)
  | Eif pe1 e2 e3 ->
      Eif (subst_sym_pexpr sym pe' pe1) (subst_sym_expr sym pe' e2) (subst_sym_expr sym pe' e3)
  | Ecase pe pat_es ->
      Ecase (subst_sym_pexpr sym pe' pe) (List.map (fun (pat, e) ->
        (pat, if in_pattern sym pat then e else subst_sym_expr sym pe' e)
      ) pat_es)
  | Eccall annot pe pes ->
      Eccall annot (subst_sym_pexpr sym pe' pe) (List.map (subst_sym_pexpr sym pe') pes)
  | Eproc annot nm pes ->
      Eproc annot nm (List.map (subst_sym_pexpr sym pe') pes)
  | Eaction pact ->
      Eaction (subst_sym_paction sym pe' pact)
  | Eunseq es ->
      Eunseq (List.map (subst_sym_expr sym pe') es)
  | Ewseq pat e1 e2 ->
      Ewseq pat (subst_sym_expr sym pe' e1) (if in_pattern sym pat then e2 else subst_sym_expr sym pe' e2)
  | Esseq pat e1 e2 ->
      Esseq pat (subst_sym_expr sym pe' e1) (if in_pattern sym pat then e2 else subst_sym_expr sym pe' e2)
  | Easeq pat act1 pact2 ->
      Easeq pat (subst_sym_action sym pe' act1) (
        match pat with
          | Just (sym, _) ->
              pact2
          | Nothing ->
              subst_sym_paction sym pe' pact2
        end
      )
  | Eindet i e ->
      Eindet i (subst_sym_expr sym pe' e)
  | Ebound i e ->
      Ebound i (subst_sym_expr sym pe' e)
  | (Esave lab_sym sym_bTy_pes e as expr) ->
      let sym_bTy_pes' = List.map (fun (z, (bTy, pe)) ->
        (z, (bTy, subst_sym_pexpr sym pe' pe))
      ) sym_bTy_pes in
      if List.any (fun (z, _) -> sym = z) sym_bTy_pes then
        let () = Debug.warn [] "subst, Esave ==> shadowing" in
        (* TODO: check *)
        Esave lab_sym sym_bTy_pes' e 
      else
        Esave lab_sym sym_bTy_pes' (subst_sym_expr sym pe' e)
  | Erun annot lab_sym pes ->
      Erun annot lab_sym (List.map (subst_sym_pexpr sym pe') pes)
  | End es ->
      End (List.map (subst_sym_expr sym pe') es)
  | Epar es ->
      Epar (List.map (subst_sym_expr sym pe') es)
  | (Ewait _ as expr) ->
      expr
  | Eloc loc e ->
      Eloc loc (subst_sym_expr sym pe' e)
end



and subst_sym_action_ a pe' = function
  | Create pe1 pe2 pref ->
      Create (subst_sym_pexpr a pe' pe1) (subst_sym_pexpr a pe' pe2) pref
  | Alloc pe1 pe2 pref ->
      Alloc (subst_sym_pexpr a pe' pe1) (subst_sym_pexpr a pe' pe2) pref
  | Kill pe ->
      Kill (subst_sym_pexpr a pe' pe)
  | Store pe1 pe2 pe3 mo ->
      Store (subst_sym_pexpr a pe' pe1) (subst_sym_pexpr a pe' pe2) (subst_sym_pexpr a pe' pe3) mo
  | Load pe1 pe2 mo ->
      Load (subst_sym_pexpr a pe' pe1) (subst_sym_pexpr a pe' pe2) mo
  | RMW pe1 pe2 pe3 pe4 mo1 mo2 ->
      RMW (subst_sym_pexpr a pe' pe1) (subst_sym_pexpr a pe' pe2) (subst_sym_pexpr a pe' pe3) (subst_sym_pexpr a pe' pe4) mo1 mo2
  | Fence mo ->
      Fence mo
(*
  | CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 ->
      CompareExchangeStrong (subst_sym_pexpr a pe' pe1) (subst_sym_pexpr a pe' pe2) (subst_sym_pexpr a pe' pe3) (subst_sym_pexpr a pe' pe4) mo1 mo2
  | CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 ->
        CompareExchangeWeak (subst_sym_pexpr a pe' pe1) (subst_sym_pexpr a pe' pe2) (subst_sym_pexpr a pe' pe3) (subst_sym_pexpr a pe' pe4) mo1 mo2
*)
  end
and subst_sym_action a pe' (Action loc bs act_) =
  Action loc bs (subst_sym_action_ a pe' act_)
and subst_sym_paction a pe' (Paction p act) =
  Paction p (subst_sym_action  a pe' act)



(* TODO: [subst_syms _as v e] substitute the symbols _as with the corresponding
   of the value expression [v] in the expression [e]. This function leads
   to a crash if [v] is not a value or its type doesn't match the symbolic
   pattern *)
val     subst_pattern: forall 'a. pattern -> pexpr -> expr 'a -> expr 'a
let rec subst_pattern pat pe' expr =
  
  match (pat, pe') with
    | (CaseBase (Nothing, _), _) ->
        expr
    | (CaseBase (Just sym, _), _) ->
        subst_sym_expr sym pe' expr
    | (CaseCtor (Cnil ()) [], Pexpr _ (PEval (Vlist _ []))) ->
        (* empty list (value) *)
        expr
    | (CaseCtor (Cnil _) [], Pexpr _ (PEctor (Cnil _) [])) ->
        (* empty list (pure expr) *)
        expr
    | (CaseCtor Ccons [pat1; pat2], Pexpr () (PEval (Vlist bTy_elem (v::vs)))) ->
        (* populated list (value) *)
        subst_pattern pat1 (Pexpr () (PEval v)) $
          subst_pattern pat2 (Pexpr () (PEval (Vlist bTy_elem vs))) expr
    | (CaseCtor Ccons [pat1; pat2], Pexpr _ (PEctor Ccons [pe1; pe2])) ->
        (* populated list (pure expr) *)
        subst_pattern pat1 pe1 $
          subst_pattern pat2 pe2 expr
    | (CaseCtor Ctuple pats', Pexpr () (PEval (Vtuple vs))) ->
        let pes = List.map (fun v ->
          Pexpr () (PEval v)
        ) vs in
        List.foldr (fun (pat', pe) acc ->
          subst_pattern pat' pe acc
        ) expr (List.zip pats' pes)
    | (CaseCtor Ctuple pats', Pexpr _ (PEctor Ctuple pes)) ->
        List.foldr (fun (pat', pe) acc ->
          subst_pattern pat' pe acc
        ) expr (List.zip pats' pes)
    (* TODO (maybe), Carray, Civmax, Civmin, Civsizeof, Civalignof *)
    
    | (CaseCtor Cloaded [pat'], Pexpr () (PEval (Vloaded (LVspecified oval)))) ->
        subst_pattern pat' (Pexpr () (PEval (Vobject oval))) expr
    | (CaseCtor Cspecified [pat'], Pexpr () (PEctor Cspecified [pe''])) ->
        subst_pattern pat' pe'' expr
    | (CaseCtor Cunspecified [pat'], Pexpr () (PEval (Vloaded (LVunspecified ty)))) ->
        subst_pattern pat' (Pexpr () (PEval (Vctype ty))) expr
    | (CaseCtor Cunspecified [pat'], Pexpr () (PEctor Cunspecified [pe''])) ->
        subst_pattern pat' pe'' expr
    | _ ->
        error "WIP: Core_aux.subst_pattern"
  end


val     to_pure: forall 'a. expr 'a -> maybe pexpr
let rec to_pure (expr : expr 'a) =
  match expr with
    | Epure pe ->
        Just pe
    | Ememop _ _ ->
        Nothing
    | Eskip ->
        Nothing
    | Elet pat pe1 e2 ->
        match to_pure e2 with
          | Just (Pexpr bTy _ as pe2) ->
              Just (Pexpr bTy (PElet pat pe1 pe2))
          | _ ->
              Nothing
        end
    | Eif pe1 e2 e3 ->
        match (to_pure e2, to_pure e3) with
          | (Just (Pexpr bTy _ as pe2), Just pe3) ->
              Just (Pexpr bTy (PEif pe1 pe2 pe3))
          | _ ->
              Nothing
        end
    | Eccall _ _ _ ->
        Nothing
    | Eproc _ _ _ ->
        Nothing
    | Eaction _ ->
        Nothing
    | Eunseq es ->
        match to_pures es with
          | Just pes ->
              Just (Pexpr () (PEctor Ctuple pes))
          | Nothing ->
              Nothing
        end
    | Ewseq pat e1 e2 ->
        match to_pure e1 with
          | Just pe1 ->
              to_pure (subst_pattern pat pe1 e2)
          | Nothing ->
              Nothing
        end
    | Esseq pat e1 e2 ->
        match to_pure e1 with
          | Just pe1 ->
              to_pure (subst_pattern pat pe1 e2)
          | Nothing ->
              Nothing
        end
    | Easeq _ _ _ ->
      Nothing
    | Eindet _ _ ->
        Nothing
    | Ebound _ e ->
        (* TODO: checl *)
        to_pure e
    | Esave _ _ _ ->
        Nothing
    | Erun _ _ _ ->
        Nothing
    | End _ ->
        Nothing
    | Epar _ ->
        Nothing
    | Ewait _ ->
        Nothing
    | Eloc _ e ->
        to_pure e
    | Ecase pe pat_es ->
       let (pats, es) = List.unzip pat_es in
        match to_pures es with
          | Just ((Pexpr bTy _ :: _) as pes) ->
              Just (Pexpr bTy (PEcase pe (List.zip pats pes)))
          | _ ->
            Nothing
        end
end

(* val     to_pures: forall 'a. list (expr 'a) -> maybe (list pexpr)*)
and to_pures (es: list (expr 'a)) =
  List.foldr (fun e acc_opt ->
    match (to_pure e, acc_opt) with
      | (Just pe, Just acc) ->
          Just (pe :: acc)
      | _ ->
          Nothing
    end) (Just []) es



val subst_wait: forall 'a. thread_id -> value -> expr 'a -> expr 'a
let rec subst_wait tid v = function
  | (Epure _ as expr) ->
      expr
  | (Ememop _ _ as expr) ->
      expr
  | (Eskip as expr) ->
      expr
  | Elet sym pe1 e2 ->
      Elet sym pe1 (subst_wait tid v e2)
  | Eif pe1 e2 e3 ->
      Eif pe1 (subst_wait tid v e2) (subst_wait tid v e3)
  | Ecase pe pat_es ->
      Ecase pe (List.map (fun (pat, e) -> (pat, subst_wait tid v e)) pat_es)
  | (Eccall _ _ _ as expr) ->
      expr
  | (Eproc _ _ _ as expr) ->
      expr
  | (Eaction _ as expr) ->
      expr
  | Eunseq es ->
      Eunseq (List.map (subst_wait tid v) es)
   | Ewseq _as e1 e2 ->
       Ewseq _as (subst_wait tid v e1) (subst_wait tid v e2)
   | Esseq _as e1 e2 ->
       Esseq _as (subst_wait tid v e1) (subst_wait tid v e2)
   | (Easeq _ _ _ as expr) ->
       expr
   | Eindet i e ->
       Eindet i (subst_wait tid v e)
   | Ebound i e ->
       Ebound i (subst_wait tid v e)
(*
   | Esave ksym sym_tys e ->
       Esave ksym sym_tys (subst_wait tid v e)
   | (Erun _ _ _ as expr) ->
       expr
*)
   | Esave sym sym_bTys e ->
       Esave sym sym_bTys (subst_wait tid v e)
   | (Erun _ _ _ as expr) ->
       expr
   | End es ->
       End (List.map (subst_wait tid v) es)
   | Epar es ->
       Epar (List.map (subst_wait tid v) es)
   | Ewait tid' ->
       if tid = tid' then
         match v with
           | Vunit ->
               Epure (Pexpr () (PEval Vunit))
           | _ ->
               Epure (Pexpr () (PEval v))
         end
       else
         Ewait tid'
   | Eloc loc e ->
       Eloc loc (subst_wait tid v e)
end



let subst_wait_continuation_element tid v = function
  | Kunseq es1 es2 ->
      Kunseq (List.map (subst_wait tid v) es1) (List.map (subst_wait tid v) es2)
  | Kwseq syms_opt e2 ->
      Kwseq syms_opt (subst_wait tid v e2)
  | Ksseq syms_opt e2 ->
      Ksseq syms_opt (subst_wait tid v e2)
(*
  | Ktry str_es ->
      Ktry (List.map (fun (str, e) -> (str, subst_wait tid v e)) str_es)
*)
end

let subst_wait_continuation tid v cont =
  List.map (subst_wait_continuation_element tid v) cont

let rec subst_wait_stack tid v = function
  | Stack_empty ->
      Stack_empty
  | Stack_cons cont sk ->
      Stack_cons (subst_wait_continuation tid v cont) (subst_wait_stack tid v sk)
end


let rec find_labeled_continuation sym = function
  | Epure _ ->
      Nothing
  | Ememop _ _ ->
      Nothing
  | Eaction _ ->
      Nothing
  | Ecase _ pat_es ->
      let () = Debug.warn [] "Core_aux.find_labeled_continuation assumes there is atmost single match inside a Ecase" in
      List.foldl (fun acc (_, e) ->
        match acc with
          | Just _ ->
              acc
          | Nothing ->
              match find_labeled_continuation sym e with
                | Nothing ->
                    Nothing
                | Just ret ->
                    Just ret
              end
        end
      ) Nothing pat_es
  | Elet _ _ e2 ->
      find_labeled_continuation sym e2
  | Eif _ e2 e3 ->
      (* NOTE: in a well formed Core expr, [sym] cannot be bound in both e2 and e3. *)
      match find_labeled_continuation sym e2 with
        | Just z ->
            Just z
        | Nothing ->
            find_labeled_continuation sym e3
      end
  | Eskip ->
      Nothing
  | Eccall _ _ _ ->
      Nothing
  | Eproc _ _ _ ->
      Nothing
  | Eunseq _ ->
      (* NOTE: Typing forbids labeled continuation bindings inside unseq() *)
      Nothing
  | Ewseq pat e1 e2 ->
      let () = Debug.warn [] "Core_aux.find_labeled_continuation assumes the bindings of an Esave inside a Ewseq don't clash" in
      match find_labeled_continuation sym e1 with
        | Just (syms, cont_expr) ->
            Just (syms, Ewseq pat cont_expr e2)
        | Nothing ->
            find_labeled_continuation sym e2
      end
  | Esseq pat e1 e2 ->
      let () = Debug.warn [] "Core_aux.find_labeled_continuation assumes the bindings of an Esave inside a Esseq don't clash" in
      match find_labeled_continuation sym e1 with
        | Just (syms, cont_expr) ->
            Just (syms, Ewseq pat cont_expr e2)
        | Nothing ->
            find_labeled_continuation sym e2
      end
  | Easeq _ _ _ ->
      Nothing
  | Eindet  _ _ ->
      (* NOTE: Typing forbids labeled continuation bindings inside indet() *)
      Nothing
  | Ebound _ _ ->
      (* NOTE: Typing forbids labeled continuation bindings inside bound() *)
      Nothing
  | End _ ->
      (* NOTE: Typing forbids labeled continuation bindings in inside nd() *)
      Nothing
  | Esave (sym', _) sym_bTys e ->
      if sym = sym' then
        Just (List.map fst sym_bTys, e)
      else
        find_labeled_continuation sym e
  | Erun annot sym pes ->
      Nothing
  | Epar es ->
      let () = Debug.warn [] "Core_aux.find_labeled_continuation assumes there are no Esave inside par()" in
      Nothing
  | Ewait _ ->
      Nothing
  | Eloc _ e ->
      find_labeled_continuation sym e
end







val apply_continuation: forall 'a. continuation 'a -> expr 'a -> expr 'a
let apply_continuation cont expr =
  let f _cont expr =
    match _cont with
      | Kwseq pat e2 ->
          Ewseq pat expr e2
      | Ksseq pat e2 ->
          Esseq pat expr e2
      | Kunseq es1 es2 ->
          Eunseq $ es1 ++ (expr :: es2)
(*
      | Ktry str_es ->
          Etry expr str_es
*)
    end in
  foldl (fun acc x -> f x acc) expr cont


(* Functions on continuation and stacks *)
val empty_stack: forall 'a. stack 'a
let empty_stack =
  Stack_empty

val is_empty_stack: forall 'a. stack 'a -> bool
let is_empty_stack = function
  | Stack_empty ->
      true
  | _ ->
      false
end



val push_empty_continuation: forall 'a. stack 'a -> stack 'a
let push_empty_continuation sk =
  Stack_cons [] sk

val pop_stack: forall 'a. stack 'a -> Exception.exceptM (continuation 'a * stack 'a) core_run_error
let pop_stack = function
  | Stack_empty ->
      Exception.fail (Found_empty_stack "pop_stack")
  | Stack_cons cont sk ->
      Exception.return (cont, sk)
end

val pop_continuation_element: forall 'a. stack 'a -> Exception.exceptM (continuation_element 'a * stack 'a) core_run_error
let pop_continuation_element = function
  | Stack_empty ->
      Exception.fail (Found_empty_stack "pop_continuation_element")
  | Stack_cons [] _ ->
      Exception.fail Reached_end_of_proc
  | Stack_cons (cont_elem :: cont) sk ->
      Exception.return (cont_elem, Stack_cons cont sk)
end


val push_continuation_element: forall 'a. continuation_element 'a -> stack 'a -> Exception.exceptM (stack 'a) core_run_error
let push_continuation_element cont_elem = function
  | Stack_empty ->
      Exception.fail (Found_empty_stack "push_continuation_element")
  | Stack_cons cont sk ->
      Exception.return (Stack_cons (cont_elem :: cont) sk)
end



val append_to_current_continuation: forall 'a. continuation_element 'a -> stack 'a -> Exception.exceptM (stack 'a) core_run_error
let append_to_current_continuation cont = function
  | Stack_empty ->
      (* A procedure need to currently be running to append *)
      Exception.fail (Found_empty_stack "append_to_current_continuation")
  | Stack_cons ccont sk ->
      Exception.return $ Stack_cons (cont :: ccont) sk
end


val subst_sym_fun_map: forall 'a. Symbol.sym -> pexpr -> fun_map 'a -> fun_map 'a
let subst_sym_fun_map sym pe' funs =
  Map.map (function
    | Fun ty params pe ->
        Fun ty params (subst_sym_pexpr sym pe' pe)
    | ProcDecl ty params ->
        ProcDecl ty params
    | Proc ty params e ->
        Proc ty params (subst_sym_expr sym pe' e)
  end) funs


val     collect_labeled_continuations: forall 'a. expr 'a -> map Symbol.sym (list (Symbol.sym (* * core_base_type*)) * expr 'a)
let rec collect_labeled_continuations expr =
  match expr with
    | Epure _ ->
        Map.empty
    | Ememop _ _ ->
        Map.empty
    | Eskip ->
        Map.empty
    | Elet _ _ e2 ->
        collect_labeled_continuations e2
    | Eif pe1 e2 e3 ->
        Map.(union) (collect_labeled_continuations e2) (collect_labeled_continuations e3)
    | Ecase pe pat_es ->
        Map.empty (* TODO THIS IS WRONG!!!!! *)
    | Eproc _ _ _ ->
        Map.empty
    | Eccall _ _ _ ->
        Map.empty
    | Eaction _ ->
        Map.empty
    | Eunseq _ ->
        Map.empty
    | Ewseq _as e1 e2 ->
        Map.(union) (Map.map (fun (a_tys, e) -> (a_tys, Ewseq _as e e2)) $ collect_labeled_continuations e1)
                    (collect_labeled_continuations e2)
    | Esseq _as e1 e2 ->
        Map.(union) (Map.map (fun (a_tys, e) -> (a_tys, Esseq _as e e2)) $ collect_labeled_continuations e1)
                    (collect_labeled_continuations e2)
    | Easeq _ _ _ ->
        Map.empty
    | Eindet _ _ ->
        Map.empty
    | Ebound _ _ ->
        Map.empty
    | Esave (sym_lab, _) sym_bTys e ->
        Map.insert sym_lab (List.map fst sym_bTys, e) $ collect_labeled_continuations e
    | Erun _ _ _ ->
        Map.empty
    | End _ ->
        (* TODO: check *)
        Map.empty
    | Epar _ ->
        (* TODO: check *)
        Map.empty
    | Ewait _ ->
        Map.empty
    | Eloc loc e ->
        collect_labeled_continuations e
  end



val is_unseq_with_negative: forall 'a. expr 'a -> bool
let is_unseq_with_negative expr =
  match expr with
    | Eunseq es ->
        List.any is_negative es
    | _ ->
        false
  end


(*
val     has_sseqs: forall 'a. expr 'a -> bool
let rec has_sseqs expr =
  match expr with
    | Epure _ ->
        false
    | Ememop _ _ ->
        false
    | Eaction p ->
        false
    | Ecase _ pat_es ->
        List.any (fun (_, e) -> has_sseqs e) pat_es
    | Elet _ _ e2 ->
        has_sseqs e2
    | Eif _ e2 e3 ->
        has_sseqs e2 || has_sseqs e3
    | Eskip ->
        false
    | Eccall _ _ _ ->
        (* TODO: look into the called body *)
        false
    | Eproc _ _ _ ->
        (* TODO: look into the called body *)
        false
    | Eunseq es ->
        List.any has_sseqs es
    | Ewseq _ e1 e2 ->
        has_sseqs e1 || has_sseqs e2
    | Esseq _ _ _ ->
        true
    | Easeq _ _ _  ->
        error "has_sseqs found an Easeq"
    | Eindet _ e ->
        has_sseqs e
    | Ebound _ e ->
        has_sseqs e
    | Esave _ _ e ->
        has_sseqs e
    | Erun _ _ _ ->
        false
    | End es ->
        List.any has_sseqs es
    | Epar _ ->
        (* TODO: I think *)
        false
    | Ewait _ ->
        false
    | Eloc _ e ->
        has_sseqs e
  end
*)



val     match_pattern: pattern -> pexpr -> maybe (list (sym * pexpr))
let rec match_pattern pat ((Pexpr () pe_) as pexpr) =
  match (pat, pe_) with
    | (CaseBase (Nothing, _), _) ->
        Just []
    | (CaseBase (Just sym, _), _) ->
        Just [(sym, pexpr)]
(*      | Vobject of (generic_object_value 'sym) *)
    | (CaseCtor Cspecified [pat'], PEval (Vloaded (LVspecified oval))) ->
        match_pattern pat' (Pexpr () (PEval (Vobject oval)))
    | (CaseCtor Cunspecified [pat'], PEval (Vloaded (LVunspecified ty))) ->
        match_pattern pat' (mk_ctype_pe ty)
(*      | Vlist of core_base_type * list (generic_value 'sym) *)
    | (CaseCtor Ctuple pats', PEval (Vtuple cvals')) -> 
        List.foldr (fun (pat', cval') acc ->
          Maybe.bind acc (fun xs ->
            Maybe.bind (match_pattern pat' (Pexpr () (PEval cval'))) (fun x ->
              Just (x++xs)
            )
          )
        ) (Just []) (List.zip pats' cvals')
    | _ ->
        Nothing
  end

val     select_case: forall 'a. (Symbol.sym -> pexpr -> 'a -> 'a) -> pexpr -> list (pattern * 'a) -> maybe 'a
let rec select_case subst_sym pexpr = function
  | [] ->
      Nothing
  | (pat, pe) :: pat_pes' ->
      match match_pattern pat pexpr with
        | Nothing ->
            (* trying the next branch *)
            select_case subst_sym pexpr pat_pes'
        | Just (sym_pes) ->
            Just $ List.foldr (fun (sym, pe') acc ->
              subst_sym sym pe' acc
            ) pe sym_pes
      end
end


val isConstrainedValue: value -> bool
let isConstrainedValue cval =
  match flatten_constrained_value cval with
    | Vconstrained _ ->
        true
    | _ ->
        false
  end
