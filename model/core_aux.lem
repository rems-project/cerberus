open import Pervasives Utils Show Core Core_ctype Annot Map Map_extra
import AilSyntax AilTypes
import Product Exception Mem Mem_aux

open import Errors

open import{hol} `pp_coreTheory`

import Debug Pp

import Nondeterminism
module ND = Nondeterminism


val strip: forall 'ty 'sym. generic_pexpr 'ty 'sym -> pexpr_ 'ty 'sym
let strip (Pexpr _ _ pexpr_) =
  pexpr_

val strip_expr: forall 'a 'bty 'sym. generic_expr 'a 'bty 'sym -> generic_expr_ 'a 'bty 'sym
let strip_expr (Expr _ expr_) =
  expr_


val     core_object_type_of_ctype: ctype -> maybe core_object_type
let rec core_object_type_of_ctype ty =
  match ty with
   | Void ->
       Nothing
   | Basic (AilTypes.Integer _) ->
       Just OTy_integer
   | Basic (AilTypes.Floating _) ->
       Just OTy_floating
   | Array ty _ ->
       match core_object_type_of_ctype ty with
         | Just oTy ->
             Just (OTy_array oTy)
         | Nothing ->
             error "Core_aux.core_object_type_of_ctype: Array found a Nothing"
       end
   | Function (_, ret_ty) xs isVariadic ->
       (* TODO: not sure about this *)
       error "core_object_type_of_ctype: function"
   | Pointer _ _ ->
       (* TODO: not sure about the case ref_ty is function type *)
       Just OTy_pointer
   | Atomic ty ->
       core_object_type_of_ctype ty
   | Struct tag_sym ->
       Just (OTy_struct tag_sym)
   | Union tag_sym ->
       Just (OTy_union tag_sym)
   | Builtin str ->
       error ("TODO: Caux.object_type_of_ctype Builtin ==> " ^ str)
  end

val oTy_of_bTy: core_base_type -> maybe core_object_type
let oTy_of_bTy = function
 | BTy_unit ->
      Nothing
 | BTy_boolean ->
      Nothing
 | BTy_ctype ->
      Nothing
 | BTy_list _ ->
      Nothing
 | BTy_tuple _ ->
      Nothing
 | BTy_object oTy ->
     Just oTy
 | BTy_loaded oTy ->
     Just oTy
 | BTy_storable ->
     Nothing
end

val     objectValueFromMemValue: Mem.mem_value -> core_object_type * object_value
let rec objectValueFromMemValue mem_val =
  let () = Debug.print_debug 6 [] (fun () ->
    "objectValueFromMemValue ==> " ^ Mem.stringFromMem_value mem_val
  ) in
  Mem.case_mem_value mem_val
    (fun ty                -> error"[Core_aux.objectValueFromMemValue] FOUND AN UNSPECIFIED MVAL")
    (fun _ _               -> error "[Core_aux.objectValueFromMemValue] concurrency read")
    (fun _ ival            -> (OTy_integer, OVinteger ival))
    (fun _ fval            -> (OTy_floating, OVfloating fval))
    (fun _ ptr_val         -> (OTy_pointer, OVpointer ptr_val))
    (fun mem_vals          -> error "[Core_aux.objectValueFromMemValue] Vspecified (OVarray (List.map objectValueFromMemValue mem_vals))")
    (fun sym xs            -> (OTy_struct sym, OVstruct sym xs))
    (fun sym ident mem_val -> (OTy_union sym, OVunion sym ident mem_val))

and loadedValueFromMemValue mem_val : core_object_type * loaded_value =
  let () = Debug.print_debug 6 [] (fun () ->
    "loadedValueFromMemValue ==> " ^ Mem.stringFromMem_value mem_val
  ) in
  Mem.case_mem_value mem_val
    (fun ty                -> (fromJust "loadedValueFromMemValue" (core_object_type_of_ctype ty), LVunspecified ty))
    (fun _ _               -> error "[Core_aux.loadedValueFromMemValue] concurrency read")
    (fun _ ival            -> (OTy_integer, LVspecified (OVinteger ival)))
    (fun _ fval            -> (OTy_floating, LVspecified (OVfloating fval)))
    (fun _ ptr_val         -> (OTy_pointer, LVspecified (OVpointer ptr_val)))
    (fun mem_vals          ->
      match List.map loadedValueFromMemValue mem_vals with
        | [] ->
            error "[Core_aux.loadedValueFromMemValue] empty array"
        | (oTy, lval) :: oTy_lvals ->
            if List.any (fun (oTy', _) -> oTy <> oTy') oTy_lvals then
              error "[Core_aux.loadedValueFromMemValue] heterogenous array"
            else
              (OTy_array oTy, LVspecified (OVarray (lval :: List.map snd oTy_lvals)))
      end)
    (fun sym xs            -> (OTy_struct sym, LVspecified (OVstruct sym xs)))
    (fun sym ident mem_val -> (OTy_union sym, LVspecified (OVunion sym ident mem_val)))


val     valueFromMemValue: Mem.mem_value -> core_object_type * value
let rec valueFromMemValue mem_val =
  let () = Debug.print_debug 6 [] (fun () ->
    "valueFromMemValue ==> " ^ Mem.stringFromMem_value mem_val
  ) in
  Mem.case_mem_value mem_val
    (fun ty                -> (fromJust "Core_aux.valueFromMemValue" (core_object_type_of_ctype ty), Vloaded (LVunspecified ty)))
    (fun _ _               -> error "[Core_aux.valueFromMemValue] concurrency read")
    (fun _ ival            -> (OTy_integer, Vloaded (LVspecified (OVinteger ival))))
    (fun _ fval            -> (OTy_floating, Vloaded (LVspecified (OVfloating fval))))
    (fun _ ptr_val         -> (OTy_pointer, Vloaded (LVspecified (OVpointer ptr_val))))
    (fun mem_vals          -> let (oTys, lvals) = List.unzip (List.map loadedValueFromMemValue mem_vals) in
                              let oTy = match oTys with
                                | [] ->
                                    (* Something went wrong in the MLM *)
                                    error "Core_aux.valueFromMemValue ==> empty array"
                                | oTy :: _ ->
                                    oTy
                              end in
                              (OTy_array oTy, Vloaded (LVspecified (OVarray lvals))))
    (fun sym xs            -> (OTy_struct sym, Vloaded (LVspecified (OVstruct sym xs))))
    (fun sym ident mem_val -> (OTy_union sym, Vloaded (LVspecified (OVunion sym ident mem_val))))

val     memValueFromValue: ctype -> value -> maybe Mem.mem_value
let rec memValueFromValue ty cval =
  match (ty, cval) with
    | (_, Vunit) ->
        Nothing
    | (_, Vtrue) ->
        Nothing
    | (_, Vfalse) ->
        Nothing
    | (_, Vlist _ _) ->
        Nothing
    | (_, Vtuple _) ->
        Nothing
    | (_, Vctype _) ->
        Nothing
    | (_, Vloaded (LVunspecified ty')) ->
        Just (Mem.unspecified_mval ty') (* TODO: check ty = ty'? *)
    | (Basic (AilTypes.Integer ity), Vloaded (LVspecified (OVinteger ival))) ->
        Just (Mem.integer_value_mval ity ival)
    | (Basic (AilTypes.Floating fty), Vloaded (LVspecified (OVfloating fval))) ->
        Just (Mem.floating_value_mval fty fval)
    | (Pointer _ ref_ty, Vloaded (LVspecified (OVpointer ptr_val))) ->
        Just (Mem.pointer_mval ref_ty ptr_val)
    | (Array elem_ty _, Vloaded (LVspecified (OVarray lvals))) ->
        (* TODO: check that the sizes match? *)
        maybe Nothing (fun z -> Just (Mem.array_mval z)) $
          List.foldr (fun lval acc_opt ->
            match (memValueFromValue elem_ty (Vloaded lval), acc_opt) with
              | (Just mem_val, Just acc) ->
                  Just (mem_val :: acc)
              | _ ->
                  Nothing
            end
          ) (Just []) lvals
    | (Struct tag_sym1, Vloaded (LVspecified (OVstruct tag_sym2 xs))) ->
        if tag_sym1 = tag_sym2 then
          Just (Mem.struct_mval tag_sym1 xs)
        else
          Nothing
    | (Union tag_sym1, Vloaded (LVspecified (OVunion tag_sym2 ident mem_val))) ->
        if tag_sym1 = tag_sym2 then
          Just (Mem.union_mval tag_sym1 ident mem_val)
        else
          Nothing
    | _ ->
        Nothing
  end





(* Project an AilTypes.ctype into a Core.ctype *)
val     proj_ctype: AilTypes.ctype -> Core_ctype.ctype
let rec proj_ctype (AilTypes.Ctype _ ty) =
  match ty with
    | AilTypes.Void ->
        Core_ctype.Void
    | AilTypes.Basic bty ->
        Core_ctype.Basic bty
    | AilTypes.Array ty n_opt ->
        Core_ctype.Array (proj_ctype ty) n_opt
    | AilTypes.Function _ (ret_qs, ret_ty) params isVariadic ->
        Core_ctype.Function (ret_qs, proj_ctype ret_ty) (
          List.map (fun (qs, ty, _) ->
            (qs, proj_ctype ty)
          ) params
        ) isVariadic
    | AilTypes.Pointer qs ty ->
        Core_ctype.Pointer qs (proj_ctype ty)
    | AilTypes.Atomic ty ->
        Core_ctype.Atomic (proj_ctype ty)
    | AilTypes.Struct tag_sym ->
        Core_ctype.Struct tag_sym
    | AilTypes.Union tag_sym ->
        Core_ctype.Union tag_sym
(*
    | AilTypes.Struct tag_sym ident_tys ->
        Core_ctype.Struct tag_sym
          (List.map (fun (ident, ty) -> (ident, proj_ctype ty)) ident_tys)
    | AilTypes.Union tag_sym ident_tys ->
        Core_ctype.Union tag_sym
          (List.map (fun (ident, ty) -> (ident, proj_ctype ty)) ident_tys)
*)
    | AilTypes.Builtin str ->
        Core_ctype.Builtin str
  end




(* Core pattern builders **************************************************** *)

val mk_empty_pat: core_base_type -> pattern
let mk_empty_pat bTy =
  Pattern [] (CaseBase (Nothing, bTy))

val mk_sym_pat: Symbol.sym -> core_base_type -> pattern
let mk_sym_pat sym bTy =
  Pattern [] (CaseBase (Just sym, bTy))

val mk_tuple_pat: list pattern -> pattern
let mk_tuple_pat = function
  | [] ->
      error "[Core_aux.mk_tuple_pat] called with |pats| = 0"
  | [pat] ->
      pat
  | pats ->
      Pattern [] (CaseCtor Ctuple pats)
end

val mk_specified_pat: pattern -> pattern
let mk_specified_pat pat =
  Pattern [] (CaseCtor Cspecified [pat])

val mk_unspecified_pat: pattern -> pattern
let mk_unspecified_pat pat =
  Pattern [] (CaseCtor Cunspecified [pat])


(* Core pexpr builders  ***************************************************** *)
val mk_sym_pe: Symbol.sym -> pexpr
let mk_sym_pe sym =
  Pexpr [] () (PEsym sym)

(* TODO: mk_impl_pe *)

(* TODO: PEval Vconstrained, Vobject *)

val mk_integer_pe: integer -> pexpr
let mk_integer_pe n =
  Pexpr [] () (PEval (Vobject (OVinteger (Mem.integer_ival n))))

val mk_floating_value_pe: Mem.floating_value -> pexpr
let mk_floating_value_pe fval =
  Pexpr [] () (PEval (Vobject (OVfloating fval)))

val mk_nullptr_pe: Core_ctype.ctype -> pexpr
let mk_nullptr_pe ref_ty =
  Pexpr [] () (PEval (Vobject (OVpointer (Mem.null_ptrval ref_ty))))

val mk_specified_pe: pexpr -> pexpr
let mk_specified_pe pe =
    Pexpr [] () (PEctor Cspecified [pe])

val mk_unspecified_pe: Core_ctype.ctype -> pexpr
let mk_unspecified_pe ty =
  Pexpr [] () (PEval (Vloaded (LVunspecified ty)))

val mk_array_pe: list pexpr -> pexpr
let mk_array_pe pes =
  Pexpr [] () (PEctor Carray pes)

val mk_unit_pe: pexpr
let mk_unit_pe =
  Pexpr [] () (PEval Vunit)

val mk_boolean_pe: bool -> pexpr
let mk_boolean_pe b =
  Pexpr [] () (PEval (if b then Vtrue else Vfalse))

(* TODO: PEval Vtrue, Vfalse *)

val mk_ail_ctype_pe: AilTypes.ctype -> pexpr
let mk_ail_ctype_pe ty =
  Pexpr [] () (PEval (Vctype (proj_ctype ty)))

val mk_ctype_pe: ctype -> pexpr
let mk_ctype_pe ty =
  Pexpr [] () (PEval (Vctype ty))

val     mk_list_pe: list pexpr -> pexpr
let rec mk_list_pe pes =
  Pexpr [] () match pes with
    | [] ->
        PEctor (Cnil ()) []
    | pe :: pes' ->
        PEctor Ccons [pe; mk_list_pe pes']
  end

val mk_tuple_pe: list pexpr -> pexpr
let mk_tuple_pe pes =
  Pexpr [] () (PEctor Ctuple pes)

val mk_ivmax_pe: pexpr -> pexpr
let mk_ivmax_pe pe =
  Pexpr [] () (PEctor Civmax [pe])

val mk_ivmin_pe: pexpr -> pexpr
let mk_ivmin_pe pe =
  Pexpr [] () (PEctor Civmin [pe])

val mk_sizeof_pe: pexpr -> pexpr
let mk_sizeof_pe pe =
  Pexpr [] () (PEctor Civsizeof [pe])

val mk_alignof_pe: pexpr -> pexpr
let mk_alignof_pe pe =
  Pexpr [] () (PEctor Civalignof [pe])

(* TODO: PEconstrained *)

val mk_undef_pe: Loc.t -> Undefined.undefined_behaviour -> pexpr
let mk_undef_pe loc ub =
  Pexpr [] () (PEundef loc ub)

val mk_error_pe: string -> pexpr -> pexpr
let mk_error_pe str pe =
  Pexpr [] () (PEerror str pe)

val mk_not_pe: pexpr -> pexpr
let mk_not_pe pe =
  Pexpr [] () (PEnot pe)

val mk_op_pe: binop -> pexpr -> pexpr -> pexpr
let mk_op_pe bop pe1 pe2 =
  Pexpr [] () (PEop bop pe1 pe2)

val mk_let_pe: pattern -> pexpr -> pexpr -> pexpr
let mk_let_pe pat pe1 pe2 =
  Pexpr [] () (PElet pat pe1 pe2)

val mk_if_pe: pexpr -> pexpr -> pexpr -> pexpr
let mk_if_pe pe1 pe2 pe3 =
  Pexpr [] () (PEif pe1 pe2 pe3)

val mk_array_shift: pexpr -> ctype -> pexpr -> pexpr
let mk_array_shift pe1 ty pe2 =
  Pexpr [] () (PEarray_shift pe1 ty pe2)

val mk_member_shift_pe: pexpr -> Symbol.sym -> Cabs.cabs_identifier -> pexpr
let mk_member_shift_pe pe1 tag_sym member_ident =
  Pexpr [] () (PEmember_shift pe1 tag_sym member_ident)

val mk_case_pe: pexpr -> list (pattern * pexpr) -> pexpr
let mk_case_pe pe pat_pes =
  Pexpr [] () (PEcase pe pat_pes)

val mk_neg_pe: pexpr -> pexpr
let mk_neg_pe pe =
  Pexpr [] () (PEop OpSub (mk_integer_pe 0) pe)

val mk_struct_pe: Symbol.sym -> list (Cabs.cabs_identifier * pexpr) -> pexpr
let mk_struct_pe tag_sym xs =
  Pexpr [] () (PEstruct tag_sym xs)

val mk_union_pe: Symbol.sym -> Cabs.cabs_identifier -> pexpr -> pexpr
let mk_union_pe tag_sym memb_ident pe =
  Pexpr [] () (PEunion tag_sym memb_ident pe)

val mk_memberof_pe: Symbol.sym -> Cabs.cabs_identifier -> pexpr -> pexpr
let mk_memberof_pe tag_sym memb_ident pe =
  Pexpr [] () (PEmemberof tag_sym memb_ident pe)

val mk_value_pe: value -> pexpr
let mk_value_pe cval =
  Pexpr [] () (PEval cval)

val mk_cfunction_pe: pexpr -> pexpr
let mk_cfunction_pe pe =
  Pexpr [] () (PEcfunction pe)

val mk_std_pe: string -> pexpr -> pexpr
let mk_std_pe std (Pexpr annot bty pe_) =
  Pexpr ((Astd std)::annot) bty pe_

val mk_std_undef_pe: Loc.t -> string -> Undefined.undefined_behaviour -> pexpr
let mk_std_undef_pe loc std ub =
  mk_std_pe std $ mk_undef_pe loc ub

val mk_std_pair_pe: string -> pexpr * pexpr -> pexpr * pexpr
let mk_std_pair_pe std (pe1, pe2) =
  (mk_std_pe std pe1, mk_std_pe std pe2)


val mk_call_pe: name -> list pexpr -> pexpr
let mk_call_pe nm pes =
  Pexpr [] () (PEcall nm pes)

val mk_are_compatible: pexpr -> pexpr -> pexpr
let mk_are_compatible pe1 pe2 =
  Pexpr [] () (PEare_compatible pe1 pe2)




(* Some common undef *)

val mk_undef_exceptional_condition: Loc.t -> pexpr
let mk_undef_exceptional_condition loc =
  mk_std_undef_pe loc "ยง6.5#5" Undefined.UB036_exceptional_condition












val bitwise_complement_pe: pexpr -> pexpr -> pexpr
(*
val integer_encode_pe:     pexpr -> pexpr -> pexpr
val integer_decode_pe:     pexpr -> pexpr -> pexpr
*)

let bitwise_complement_pe pe1 pe2 =
  Pexpr [] () (PEctor CivCOMPL [pe1; pe2])
(*
  Pexpr [] () (PEcall (Impl Implementation_.Bitwise_complement) [pe1; pe2])
*)
(*
let integer_encode_pe pe1 pe2 =
  Pexpr [] () (PEcall (Impl Implementation_.Integer__encode) [pe1; pe2])
let integer_decode_pe pe1 pe2 =
  Pexpr [] () (PEcall (Impl Implementation_.Integer__decode) [pe1; pe2])
*)

(* Some aliases for positive actions *)
let pcreate loc al ty pref =
  Expr [] (Eaction (Paction Pos (Action loc default (Create al ty pref))))
let pcreate_readonly loc al ty init pref =
  Expr [] (Eaction (Paction Pos (Action loc default (CreateReadOnly  al ty init pref))))
let palloc loc al e pref =
  Expr [] (Eaction (Paction Pos (Action loc default (Alloc al e pref))))
let pkill loc is_dynamic x =
  Expr [] (Eaction (Paction Pos (Action loc default (Kill is_dynamic x))))
let pstore loc ty x n mo =
  Expr [] (Eaction (Paction Pos (Action loc default (Store false ty x n mo))))
let pstore_lock loc ty x n mo =
  Expr [] (Eaction (Paction Pos (Action loc default (Store true ty x n mo))))
let pload loc ty x mo =
  Expr [] (Eaction (Paction Pos (Action loc default (Load ty x mo))))
let prmw loc ty x n1 n2 mo1 mo2 =
  Expr [] (Eaction (Paction Pos (Action loc default (RMW ty x n1 n2 mo1 mo2))))






(* for a given Ctype returns the corresponding "zero" value *)
(*val     zeros: AilSyntax.tag_definition -> Core_ctype.ctype -> pexpr *)
(* see ยง6.7.9#10 *)
let rec zeros_aux tagDefs ty =
  let zero_ival = Mem.integer_ival 0 in
  match ty with
    | Core_ctype.Basic (AilTypes.Integer ity) ->
        Mem.integer_value_mval ity zero_ival
    | Core_ctype.Basic (AilTypes.Floating fty) ->
        Mem.floating_value_mval fty Mem.zero_fval
    | Core_ctype.Array elem_ty (Just n) ->
        Mem.array_mval (List.replicate (natFromInteger n) (zeros_aux tagDefs elem_ty))
(*
  Mem.array_mval (List.replicate (natFromInteger n) (Mem.integer_value_mval zero_ival))
*)
    | Core_ctype.Pointer _ ref_ty ->
        Mem.pointer_mval ref_ty (Mem.null_ptrval ref_ty)
    | Core_ctype.Atomic ty' ->
        zeros_aux tagDefs ty'
    | Core_ctype.Struct tag ->
        match Map.lookup tag tagDefs with
          | Just (Core_ctype.StructDef ident_tys) ->
              Mem.struct_mval tag (List.map (fun (ident, ty) -> (ident, ty, zeros_aux tagDefs ty)) ident_tys)
          | _ ->
              error "Core_aux.zeros_aux, not StructDef"
        end
    | Core_ctype.Union tag ->
        match Map.lookup tag tagDefs with
          | Just (Core_ctype.UnionDef ((ident, ty')::_)) ->
              Mem.union_mval tag ident (zeros_aux tagDefs ty')
          | _ ->
              error "Core_aux.zeros_aux, not UnionDef"
        end

(*
 | Builtin of string
*)
   | _ ->
       error "Core_aux.zeros should only be called on complete types"
  end

val zeros: core_tag_definitions -> ctype -> pexpr
let zeros tagDefs ty =
  (* TODO: yucky *)
  Pexpr [] ()
(*
    (PEval (Vobject (snd $ objectValueFromMemValue (zeros_aux ty))))
*)
    (PEval (snd $ valueFromMemValue (zeros_aux tagDefs ty)))


(*


(*

TODO: bring back structs/unions

  let proj_member = function
    | Ail.MEMBER ty               -> MEMBER (proj_ctype ty)
    | Ail.BITFIELD ty w is_packed -> BITFIELD (proj_ctype ty) w is_packed
  end in
*)
  match ty with
    | AilTypes.Void             -> Core_ctype.Void
    | AilTypes.Basic bt         -> Core_ctype.Basic bt
    | AilTypes.Array ty n       -> Core_ctype.Array (proj_ctype ty) n
    | AilTypes.Function ty ps b -> Core_ctype.Function (proj_ctype ty) (List.map (proj_ctype -| snd) ps) b
    | AilTypes.Pointer _ ty    -> Core_ctype.Pointer (proj_ctype ty)
    | AilTypes.Atomic ty        -> Core_ctype.Atomic (proj_ctype ty)
(*
    | Ail.STRUCT _ tag members -> STRUCT tag (List.map (fun (a, m) -> (a, proj_member m)) members)
    | Ail.UNION  _ tag members -> UNION  tag (List.map (fun (a, m) -> (a, proj_member m)) members)
    | Ail.ENUM id              -> ENUM id
    | Ail.ATOMIC ty            -> ATOMIC (proj_ctype ty)
    | Ail.TYPEDEF _            -> error "[Core_aux.proj_ctype] found a A.TYPEDEF"
    | Ail.SIZE_T               -> SIZE_T
    | Ail.INTPTR_T             -> INTPTR_T
    | Ail.WCHAR_T              -> WCHAR_T
    | Ail.CHAR16_T             -> CHAR16_T
    | Ail.CHAR32_T             -> CHAR32_T
*)
end
*)

(* Bring back a Core.ctype into a Ail.ctype (with loss of qualifiers if coming from proj_ctype) *)
let rec unproj_ctype ty =
  AilTypes.Ctype [] (match ty with
    | Core_ctype.Void ->
        AilTypes.Void
    | Core_ctype.Basic bty ->
        AilTypes.Basic bty
    | Core_ctype.Array ty n_opt ->
        AilTypes.Array (unproj_ctype ty) n_opt
    | Core_ctype.Function (qs, ty) qs_tys is_variadic ->
        (* NOTE: there is a potential loss of information here for hasProto and
           inside the parameters with isRegister. But this shouldn't matter to
           the dynamics *)
        AilTypes.Function false (qs, unproj_ctype ty) (
          List.map (fun (qs,ty) ->
            (qs, unproj_ctype ty, false)
          ) qs_tys
        ) is_variadic
    | Core_ctype.Pointer qs ty ->
        AilTypes.Pointer qs (unproj_ctype ty)
    | Core_ctype.Atomic ty ->
        AilTypes.Atomic (unproj_ctype ty)
    | Core_ctype.Struct tag ->
        AilTypes.Struct tag
    | Core_ctype.Union tag ->
        AilTypes.Union tag
    | Core_ctype.Builtin str ->
        AilTypes.Builtin str
  end)


(*
(*
  let unproj_member = function
    | MEMBER ty               -> Ail.MEMBER (unproj_ctype ty)
    | BITFIELD ty w is_packed -> Ail.BITFIELD (unproj_ctype ty) w is_packed
  end in
*)
  match ty with
    | Core_ctype.Void              -> AilTypes.Void
    | Core_ctype.Basic bt          -> AilTypes.Basic bt
    | Core_ctype.Array ty n        -> AilTypes.Array (unproj_ctype ty) n
    | Core_ctype.Function ty tys b -> AilTypes.Function (unproj_ctype ty) (List.map (Product.make AilTypes.no_qualifiers -| unproj_ctype) tys) b
    | Core_ctype.Pointer ty        -> AilTypes.Pointer AilTypes.no_qualifiers (unproj_ctype ty)
    | Core_ctype.Atomic ty         -> AilTypes.Atomic (unproj_ctype ty)
(*
    | STRUCT tag members -> Ail.STRUCT Ail.no_qualifiers tag (List.map (fun (a, m) -> (a, unproj_member m)) members)
    | UNION  tag members -> Ail.UNION  Ail.no_qualifiers tag (List.map (fun (a, m) -> (a, unproj_member m)) members)
    | ENUM id            -> Ail.ENUM id
    | ATOMIC ty          -> Ail.ATOMIC (unproj_ctype ty)
    | SIZE_T             -> Ail.SIZE_T
    | INTPTR_T           -> Ail.INTPTR_T
    | WCHAR_T            -> Ail.WCHAR_T
    | CHAR16_T           -> Ail.CHAR16_T
    | CHAR32_T           -> Ail.CHAR32_T
*)
end
*)




(*
let rec mk_wseqs_aux end_e pat_es =
  match pat_es with
    | []               -> end_e
    | (pat, e) :: pat_es' -> Ewseq pat e (mk_wseqs_aux end_e pat_es')
end

val mk_wseqs: expr unit -> list (pattern * expr unit) -> expr unit
let mk_wseqs end_e = function
  | [] ->
      end_e
  | [(_, e)] ->
      e
  | pat_es ->
      mk_wseqs_aux end_e pat_es
end
*)

val     mk_sseqs: list (pattern * expr unit) -> (expr unit -> expr unit)
let rec mk_sseqs pat_es =
  fun z ->
  match pat_es with
    | [] ->
        z
    | (pat, e) :: pat_es' ->
        Expr [] (Esseq pat e (mk_sseqs pat_es' z))
  end



(*
(* val     mk_sseq: forall 'a. list (pattern * expr 'a) -> expr 'a *)
let rec mk_sseq a_opts_es =
  match a_opts_es with
    | []               -> Eskip
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Esseq a_opts e (mk_sseq es')
end

(* val     mk_sseq': forall 'a. list (pattern * expr 'a) -> expr 'a -> expr 'a *)
let rec mk_sseq' a_opts_es z =
  match a_opts_es with
    | []               -> z
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Esseq a_opts e (mk_sseq' es' z)
end
*)


let mk_unseq = function
  | []  -> Expr [] Eskip
  | [e] -> e
  | es  -> Expr [] (Eunseq es)
end

val     mk_unit_sseq: list (expr unit) -> (expr unit -> expr unit)
let rec mk_unit_sseq es =
  fun z ->
    match es with
      | [] ->
          z
(*
      | [e] ->
          e
*)
      | e::es' ->
          Expr [] (Esseq (mk_empty_pat BTy_unit) e (mk_unit_sseq es' z))
    end

val     mk_bTy_sseqs: list (core_base_type * expr unit) -> expr unit
let rec mk_bTy_sseqs bTy_es =
  match bTy_es with
    | [] ->
        Expr [] Eskip
    | [(_, e)] ->
        e
    | (bTy, e) :: bTy_es' ->
        Expr [] (Esseq (mk_empty_pat bTy) e (mk_bTy_sseqs bTy_es'))
  end

let rec concat_sseq ((Expr annot e_) as e) e' =
   match e_ with
     | Esseq pat e1 e2 -> Expr annot (Esseq pat e1 (concat_sseq e2 e'))
     | Eskip           -> e'
     | _               -> Expr [] (Esseq (mk_empty_pat BTy_unit) e e')
  end

let is_negative = function
  | Expr _ (Eaction (Paction Neg _)) ->
      true
  | _ ->
      false
end

let is_negative_action = function
  | (Paction Neg _) ->
      true
  | _ ->
      false
end


(* TODO: rewrite this in bottom-up *)
(*
val     flatten_constrained_value: value -> value
let rec flatten_constrained_value v =
  match v with
    | Vconstrained xs ->
        Vconstrained $ List.concatMap (fun (cs, v') ->
          match flatten_constrained_value v' with
            | Vconstrained ys ->
                List.map (fun (cs', v'') ->
                  (ND.concat cs cs', v'')
                ) ys
            | v'' ->
                [(cs, v'')]
          end
        ) xs
    | _ ->
        v
  end
*)

val valueFromPexpr: pexpr -> maybe value
let valueFromPexpr = function
  | Pexpr [] () (PEval cval) ->
      Just ((*flatten_constrained_value*) cval)
  | _ ->
      Nothing
  end

val     valueFromPexprs: list pexpr -> maybe (list value)
let rec valueFromPexprs pes =
  List.foldr (fun pe acc_opt ->
    match (valueFromPexpr pe, acc_opt) with
      | (Just cval, Just acc) ->
          Just (cval :: acc)
      | _ ->
          Nothing
    end) (Just []) pes

val valueOrPEconstrainedFromPexpr: pexpr -> maybe (either value pexpr)
let valueOrPEconstrainedFromPexpr pe =
  match pe with
    | Pexpr [] () (PEval cval) ->
        Just (Left cval)
    | Pexpr [] () (PEconstrained _) ->
        Just (Right pe)
    | _ ->
        Nothing
  end

val     valueOrPEconstrainedFromPexprs: list pexpr -> maybe (either (list value) ((nat * (list (Mem.mem_iv_constraint  * pexpr))) * (list pexpr)))
let rec valueOrPEconstrainedFromPexprs pes =
  snd (List.foldr (fun pe (i, acc) ->
      (i+1, match (valueOrPEconstrainedFromPexpr pe, acc) with
        | (Just (Left cval), Just (Left cvals)) ->
            Just (Left (cval :: cvals))
        | (Just (Right (Pexpr [] () (PEconstrained xs) as pe)), Just (Left cvals)) ->
            Just (Right ((i, xs), pe :: (List.map (fun v -> Pexpr [] () (PEval v)) cvals)))
        | (Just (Right pe), Just (Right (i_xs, pes))) ->
            Just (Right (i_xs, pe :: pes))
        | _ ->
            Nothing
      end)) (0, Just (Left [])) pes)


val to_integer: pexpr -> maybe integer
let core_aux_to_integer pe =
  match valueFromPexpr pe with
    | Just (Vobject (OVinteger ival)) ->
        Mem_aux.integerFromIntegerValue ival
    | _ ->
        Nothing
  end
let inline to_integer = core_aux_to_integer










(* check if a symbolic names is part of a pattern *)
val in_pattern: Symbol.sym -> pattern -> bool
let rec in_pattern sym (Pattern _ pat) =
  match pat with
    | CaseBase (sym_opt, _) ->
        maybe false (fun sym' -> sym = sym') sym_opt
    | CaseCtor _ pats' ->
        List.any (in_pattern sym) pats'
  end





val     subst_sym_pexpr: Symbol.sym -> value -> pexpr -> pexpr
let rec subst_sym_pexpr sym cval (Pexpr annot bty pexpr_) =
  Pexpr annot bty match pexpr_ with
    | PEsym sym' ->
        if sym = sym' then PEval cval else pexpr_
    | PEimpl _ ->
        pexpr_
    | PEval _ ->
        pexpr_
    | PEconstrained xs ->
        PEconstrained $
          List.map (fun (constrs, pe) -> (constrs, subst_sym_pexpr sym cval pe)) xs
    | PEundef _ _ ->
        pexpr_
    | PEerror str pe ->
        PEerror str (subst_sym_pexpr sym cval pe)
    | PEctor ctor pes ->
        PEctor ctor (List.map (subst_sym_pexpr sym cval) pes)
    | PEcase pe xs ->
        PEcase (subst_sym_pexpr sym cval pe) (List.map (fun (pat, pe) ->
          (pat, if in_pattern sym pat then pe else subst_sym_pexpr sym cval pe)
        ) xs)
    | PEarray_shift pe1 ty pe2 ->
        PEarray_shift (subst_sym_pexpr sym cval pe1) ty (subst_sym_pexpr sym cval pe2)
    | PEmember_shift pe tag_sym memb_ident ->
        PEmember_shift (subst_sym_pexpr sym cval pe) tag_sym memb_ident
    | PEnot pe ->
        PEnot (subst_sym_pexpr sym cval pe)
    | PEop bop pe1 pe2 ->
        PEop bop (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2)
    | PEstruct tag_sym xs ->
        PEstruct tag_sym (List.map (fun (ident, pe) -> (ident, subst_sym_pexpr sym cval pe)) xs)
    | PEunion tag_sym ident pe ->
        PEunion tag_sym ident (subst_sym_pexpr sym cval pe)
    | PEcfunction pe ->
        PEcfunction (subst_sym_pexpr sym cval pe)
    | PEmemberof tag_sym memb_ident pe ->
        PEmemberof tag_sym memb_ident (subst_sym_pexpr sym cval pe)
    | PEcall nm pes ->
        PEcall nm (List.map (subst_sym_pexpr sym cval) pes)
    | PElet pat pe1 pe2 ->
        PElet pat (subst_sym_pexpr sym cval pe1) (if in_pattern sym pat then pe2 else subst_sym_pexpr sym cval pe2)
    | PEif pe1 pe2 pe3 ->
        PEif (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2) (subst_sym_pexpr sym cval pe3)
    | PEis_scalar pe ->
        PEis_scalar (subst_sym_pexpr sym cval pe)
    | PEis_integer pe ->
        PEis_integer (subst_sym_pexpr sym cval pe)
    | PEis_signed pe ->
        PEis_signed (subst_sym_pexpr sym cval pe)
    | PEis_unsigned pe ->
        PEis_unsigned (subst_sym_pexpr sym cval pe)
    | PEare_compatible pe1 pe2 ->
        PEare_compatible (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2)
end


val     subst_sym_expr: forall 'a. Symbol.sym -> value -> expr 'a -> expr 'a
let rec subst_sym_expr sym cval (Expr annot expr_) =
  Expr annot match expr_ with
    | Epure pe ->
        Epure (subst_sym_pexpr sym cval pe)
    | Ememop memop pes ->
        Ememop memop (List.map (subst_sym_pexpr sym cval) pes)
    | Eskip ->
        expr_
    | Elet pat pe1 e2 ->
        Elet pat (subst_sym_pexpr sym cval pe1)
          (if in_pattern sym pat then e2 else subst_sym_expr sym cval e2)
    | Eif pe1 e2 e3 ->
        Eif (subst_sym_pexpr sym cval pe1)
          (subst_sym_expr sym cval e2) (subst_sym_expr sym cval e3)
    | Ecase pe pat_es ->
        Ecase (subst_sym_pexpr sym cval pe) (List.map (fun (pat, e) ->
          (pat, if in_pattern sym pat then e else subst_sym_expr sym cval e)
        ) pat_es)
    | Eccall annot pe1 pe2 pes ->
        Eccall annot (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2)
          (List.map (subst_sym_pexpr sym cval) pes)
    | Eproc annot nm pes ->
        Eproc annot nm (List.map (subst_sym_pexpr sym cval) pes)
    | Eaction pact ->
        Eaction (subst_sym_paction sym cval pact)
    | Eunseq es ->
        Eunseq (List.map (subst_sym_expr sym cval) es)
    | Ewseq pat e1 e2 ->
        Ewseq pat (subst_sym_expr sym cval e1)
          (if in_pattern sym pat then e2 else subst_sym_expr sym cval e2)
    | Esseq pat e1 e2 ->
        Esseq pat (subst_sym_expr sym cval e1)
          (if in_pattern sym pat then e2 else subst_sym_expr sym cval e2)
    | Easeq (sym', bTy) act1 pact2 ->
        Easeq (sym', bTy) (subst_sym_action sym cval act1) begin
          if sym = sym' then
            pact2
          else
            subst_sym_paction sym cval pact2
        end
    | Eindet i e ->
        Eindet i (subst_sym_expr sym cval e)
    | Ebound i e ->
        Ebound i (subst_sym_expr sym cval e)
    | Esave lab_sym sym_bTy_pes e ->
        let sym_bTy_pes' = List.map (fun (z, (bTy, pe)) ->
          (z, (bTy, subst_sym_pexpr sym cval pe))
        ) sym_bTy_pes in
        if List.any (fun (z, _) -> sym = z) sym_bTy_pes then
          let () = Debug.warn [] (fun () -> "subst, Esave ==> shadowing") in
          (* TODO: check *)
          Esave lab_sym sym_bTy_pes' e 
        else
          Esave lab_sym sym_bTy_pes' (subst_sym_expr sym cval e)
    | Erun annot lab_sym pes ->
        Erun annot lab_sym (List.map (subst_sym_pexpr sym cval) pes)
    | End es ->
        End (List.map (subst_sym_expr sym cval) es)
    | Epar es ->
        Epar (List.map (subst_sym_expr sym cval) es)
    | Ewait _ ->
      expr_
(*
    | Eloc loc e ->
        Eloc loc (subst_sym_expr sym cval e)
    | Estd str e ->
        Estd str (subst_sym_expr sym cval e)
*)
  end

and subst_sym_action_ sym cval = function
  | Create pe1 pe2 pref ->
      Create (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2) pref
  | CreateReadOnly pe1 pe2 pe3 pref ->
      CreateReadOnly (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2) (subst_sym_pexpr sym cval pe3) pref
  | Alloc pe1 pe2 pref ->
      Alloc (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2) pref
  | Kill b pe ->
      Kill b (subst_sym_pexpr sym cval pe)
  | Store b pe1 pe2 pe3 mo ->
      Store b (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2)
        (subst_sym_pexpr sym cval pe3) mo
  | Load pe1 pe2 mo ->
      Load (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2) mo
  | RMW pe1 pe2 pe3 pe4 mo1 mo2 ->
      RMW (subst_sym_pexpr sym cval pe1) (subst_sym_pexpr sym cval pe2)
        (subst_sym_pexpr sym cval pe3) (subst_sym_pexpr sym cval pe4) mo1 mo2
  | Fence mo ->
      Fence mo
end
and subst_sym_action sym cval (Action loc bs act_) =
  Action loc bs (subst_sym_action_ sym cval act_)
and subst_sym_paction sym cval (Paction p act) =
  Paction p (subst_sym_action sym cval act)



val     subst_pattern_val: forall 'a. pattern -> value -> expr 'a -> expr 'a
let rec subst_pattern_val (Pattern _ pat) cval expr =
  (* TODO (maybe), Carray, Civmax, Civmin, Civsizeof, Civalignof *)
  match (pat, cval) with
    | (CaseBase (Nothing, _), _) ->
        (* e[_ \ v] = e *)
        expr
    | (CaseBase (Just sym, _), _) ->
        (* e[sym \ v] *)
        subst_sym_expr sym cval expr
    | (CaseCtor (Cnil ()) [], Vlist _ []) ->
        (* empty list (value) *)
        expr
    | (CaseCtor Ccons [pat1; pat2], Vlist bTy_elem (cval1::cvals)) ->
        (* populated list (value) *)
        subst_pattern_val pat1 cval1 $
          subst_pattern_val pat2 (Vlist bTy_elem cvals) expr
    | (CaseCtor Ctuple pats', Vtuple cvals) ->
        List.foldr (fun (pat', cval') acc ->
          subst_pattern_val pat' cval' acc
        ) expr (List.zip pats' cvals)
    | (CaseCtor Cspecified [pat'], Vloaded (LVspecified oval)) ->
        subst_pattern_val pat' (Vobject oval) expr
    | (CaseCtor Cunspecified [pat'], Vloaded (LVunspecified ty)) ->
        subst_pattern_val pat' (Vctype ty) expr
    | (CaseCtor ctor pats, _) ->
        let str_ctor = match ctor with
          | Cnil _ ->
              "nil"
          | Ccons ->
              "cons"
          | Ctuple ->
              "tuple"
          | Carray ->
              "array"
          | Civmax ->
              "ivmax"
          | Civmin ->
              "ivmin"
          | Civsizeof ->
              "ivsizeof"
          | Civalignof ->
              "ivalignof"
          | CivCOMPL ->
              "ivCOMPL"
          | CivAND ->
              "ivAND"
          | CivOR ->
              "ivOR"
          | CivXOR ->
              "ivXOR"
          | Cspecified ->
              "specified"
          | Cunspecified ->
              "unspecified"
          | Cfvfromint ->
              "fvfromint"
          | Civfromfloat ->
              "ivfromfloat"
        end in
        error ("WIP: Core_aux.subst_pattern_val ==> ctor= " ^ str_ctor ^ ", |pats|= "
               ^ (show (List.length pats)) ^ " -- " ^ Pp.stringFromCore_value cval)
  end


























(* substitute in an expression a symbolic name with a (pure) expression *)
(* NOTE: this is usually unsound to use if pe' doesn't evaluate to a defined value or generates memory constraints *)
val     unsafe_subst_sym_pexpr: Symbol.sym -> pexpr -> pexpr -> pexpr
let rec unsafe_subst_sym_pexpr sym (Pexpr annot bty pe_' as pe') (Pexpr _ _ pe_) =
  Pexpr annot bty match pe_ with
    | PEsym sym' ->
        if sym = sym' then pe_' else pe_
    | PEimpl _ ->
        pe_
    | PEval _ ->
        pe_
    | PEconstrained xs ->
        PEconstrained $
          List.map (fun (constrs, pe) -> (constrs, unsafe_subst_sym_pexpr sym pe' pe)) xs
    | PEundef _ _ ->
        pe_
    | PEerror str pe ->
        PEerror str (unsafe_subst_sym_pexpr sym pe' pe)
    | PEctor ctor pes ->
        PEctor ctor (List.map (unsafe_subst_sym_pexpr sym pe') pes)
    | PEcase pe xs ->
        PEcase (unsafe_subst_sym_pexpr sym pe' pe) (List.map (fun (pat, pe) ->
          (pat, if in_pattern sym pat then pe else unsafe_subst_sym_pexpr sym pe' pe)
        ) xs)
    | PEarray_shift pe1 ty pe2 ->
        PEarray_shift (unsafe_subst_sym_pexpr sym pe' pe1) ty (unsafe_subst_sym_pexpr sym pe' pe2)
    | PEmember_shift pe tag_sym memb_ident ->
        PEmember_shift (unsafe_subst_sym_pexpr sym pe' pe) tag_sym memb_ident
    | PEnot pe ->
        PEnot (unsafe_subst_sym_pexpr sym pe' pe)
    | PEop bop pe1 pe2 ->
        PEop bop (unsafe_subst_sym_pexpr sym pe' pe1) (unsafe_subst_sym_pexpr sym pe' pe2)
    | PEstruct tag_sym xs ->
        PEstruct tag_sym (List.map (fun (ident, pe) -> (ident, unsafe_subst_sym_pexpr sym pe' pe)) xs)
    | PEunion tag_sym ident pe ->
        PEunion tag_sym ident (unsafe_subst_sym_pexpr sym pe' pe)
    | PEcfunction pe ->
        PEcfunction (unsafe_subst_sym_pexpr sym pe' pe)
    | PEmemberof tag_sym memb_ident pe ->
        PEmemberof tag_sym memb_ident (unsafe_subst_sym_pexpr sym pe' pe)
    | PEcall nm pes ->
        PEcall nm (List.map (unsafe_subst_sym_pexpr sym pe') pes)
    | PElet pat pe1 pe2 ->
        PElet pat (unsafe_subst_sym_pexpr sym pe' pe1) (if in_pattern sym pat then pe2 else unsafe_subst_sym_pexpr sym pe' pe2)
    | PEif pe1 pe2 pe3 ->
        PEif (unsafe_subst_sym_pexpr sym pe' pe1) (unsafe_subst_sym_pexpr sym pe' pe2) (unsafe_subst_sym_pexpr sym pe' pe3)
    | PEis_scalar pe ->
        PEis_scalar (unsafe_subst_sym_pexpr sym pe' pe)
    | PEis_integer pe ->
        PEis_integer (unsafe_subst_sym_pexpr sym pe' pe)
    | PEis_signed pe ->
        PEis_signed (unsafe_subst_sym_pexpr sym pe' pe)
    | PEis_unsigned pe ->
        PEis_unsigned (unsafe_subst_sym_pexpr sym pe' pe)
    | PEare_compatible pe1 pe2 ->
        PEare_compatible (unsafe_subst_sym_pexpr sym pe' pe1) (unsafe_subst_sym_pexpr sym pe' pe2)
end


(* NOTE: this is usually unsound to use if pe' doesn't evaluate to a defined value or generates memory constraints *)
val     unsafe_subst_sym_expr: forall 'a. Symbol.sym -> pexpr -> expr 'a -> expr 'a
let rec unsafe_subst_sym_expr sym pe' (Expr annot expr_) =
  Expr annot match expr_ with
    | Epure pe ->
        Epure (unsafe_subst_sym_pexpr sym pe' pe)
    | Ememop memop pes ->
        Ememop memop (List.map (unsafe_subst_sym_pexpr sym pe') pes)
    | Eskip ->
        expr_
    | Elet pat pe1 e2 ->
        Elet pat (unsafe_subst_sym_pexpr sym pe' pe1) (if in_pattern sym pat then e2 else unsafe_subst_sym_expr sym pe' e2)
    | Eif pe1 e2 e3 ->
        Eif (unsafe_subst_sym_pexpr sym pe' pe1) (unsafe_subst_sym_expr sym pe' e2) (unsafe_subst_sym_expr sym pe' e3)
    | Ecase pe pat_es ->
        Ecase (unsafe_subst_sym_pexpr sym pe' pe) (List.map (fun (pat, e) ->
          (pat, if in_pattern sym pat then e else unsafe_subst_sym_expr sym pe' e)
        ) pat_es)
    | Eccall annot pe1 pe2 pes ->
        Eccall annot (unsafe_subst_sym_pexpr sym pe' pe1) (unsafe_subst_sym_pexpr sym pe' pe2)
          (List.map (unsafe_subst_sym_pexpr sym pe') pes)
    | Eproc annot nm pes ->
        Eproc annot nm (List.map (unsafe_subst_sym_pexpr sym pe') pes)
    | Eaction pact ->
        Eaction (unsafe_subst_sym_paction sym pe' pact)
    | Eunseq es ->
        Eunseq (List.map (unsafe_subst_sym_expr sym pe') es)
    | Ewseq pat e1 e2 ->
        Ewseq pat (unsafe_subst_sym_expr sym pe' e1) (if in_pattern sym pat then e2 else unsafe_subst_sym_expr sym pe' e2)
    | Esseq pat e1 e2 ->
        Esseq pat (unsafe_subst_sym_expr sym pe' e1) (if in_pattern sym pat then e2 else unsafe_subst_sym_expr sym pe' e2)
    | Easeq (sym', bTy) act1 pact2 ->
        Easeq (sym', bTy) (unsafe_subst_sym_action sym pe' act1) begin
          if sym = sym' then
            pact2
          else
            unsafe_subst_sym_paction sym pe' pact2
        end
    | Eindet i e ->
        Eindet i (unsafe_subst_sym_expr sym pe' e)
    | Ebound i e ->
        Ebound i (unsafe_subst_sym_expr sym pe' e)
    | Esave lab_sym sym_bTy_pes e ->
        let sym_bTy_pes' = List.map (fun (z, (bTy, pe)) ->
          (z, (bTy, unsafe_subst_sym_pexpr sym pe' pe))
        ) sym_bTy_pes in
        if List.any (fun (z, _) -> sym = z) sym_bTy_pes then
          let () = Debug.warn [] (fun () -> "unsafe_subst, Esave ==> shadowing") in
          (* TODO: check *)
          Esave lab_sym sym_bTy_pes' e 
        else
          Esave lab_sym sym_bTy_pes' (unsafe_subst_sym_expr sym pe' e)
    | Erun annot lab_sym pes ->
        Erun annot lab_sym (List.map (unsafe_subst_sym_pexpr sym pe') pes)
    | End es ->
        End (List.map (unsafe_subst_sym_expr sym pe') es)
    | Epar es ->
        Epar (List.map (unsafe_subst_sym_expr sym pe') es)
    | Ewait _ ->
        expr_
(*
    | Eloc loc e ->
        Eloc loc (unsafe_subst_sym_expr sym pe' e)
    | Estd s e ->
        Estd s (unsafe_subst_sym_expr sym pe' e)
*)
  end


(* NOTE: this is usually unsound to use if pe' doesn't evaluate to a defined value or generates memory constraints *)
and unsafe_subst_sym_action_ a pe' = function
  | Create pe1 pe2 pref ->
      Create (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2) pref
  | CreateReadOnly pe1 pe2 pe3 pref ->
      CreateReadOnly (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2) (unsafe_subst_sym_pexpr a pe' pe3) pref
  | Alloc pe1 pe2 pref ->
      Alloc (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2) pref
  | Kill b pe ->
      Kill b (unsafe_subst_sym_pexpr a pe' pe)
  | Store b pe1 pe2 pe3 mo ->
      Store b (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2)
        (unsafe_subst_sym_pexpr a pe' pe3) mo
  | Load pe1 pe2 mo ->
      Load (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2) mo
  | RMW pe1 pe2 pe3 pe4 mo1 mo2 ->
      RMW (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2)
        (unsafe_subst_sym_pexpr a pe' pe3) (unsafe_subst_sym_pexpr a pe' pe4) mo1 mo2
  | Fence mo ->
      Fence mo
(*
  | CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 ->
      CompareExchangeStrong (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2) (unsafe_subst_sym_pexpr a pe' pe3) (unsafe_subst_sym_pexpr a pe' pe4) mo1 mo2
  | CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 ->
        CompareExchangeWeak (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2) (unsafe_subst_sym_pexpr a pe' pe3) (unsafe_subst_sym_pexpr a pe' pe4) mo1 mo2
*)
  end
and unsafe_subst_sym_action a pe' (Action loc bs act_) =
  Action loc bs (unsafe_subst_sym_action_ a pe' act_)
and unsafe_subst_sym_paction a pe' (Paction p act) =
  Paction p (unsafe_subst_sym_action a pe' act)

(* TODO: [unsafe_subst_pattern _as v e] substitute the symbols _as with the corresponding
   of the value expression [v] in the expression [e]. This function leads
   to a crash if [v] is not a value or its type doesn't match the symbolic
   pattern *)
(* NOTE: this is usually unsound to use if pe' doesn't evaluate to a defined value or generates memory constraints *)
val     unsafe_subst_pattern: forall 'a. pattern -> pexpr -> expr 'a -> expr 'a
let rec unsafe_subst_pattern (Pattern _ pat) pe' expr =
  
  match (pat, pe') with
    | (CaseBase (Nothing, _), _) ->
        expr
    | (CaseBase (Just sym, _), _) ->
        unsafe_subst_sym_expr sym pe' expr
    | (CaseCtor (Cnil ()) [], Pexpr _ _ (PEval (Vlist _ []))) ->
        (* empty list (value) *)
        expr
    | (CaseCtor (Cnil _) [], Pexpr _ _ (PEctor (Cnil _) [])) ->
        (* empty list (pure expr) *)
        expr
    | (CaseCtor Ccons [pat1; pat2], Pexpr [] () (PEval (Vlist bTy_elem (cval::cvals)))) ->
        (* populated list (value) *)
        subst_pattern_val pat1 cval $
          subst_pattern_val pat2 (Vlist bTy_elem cvals) expr
    | (CaseCtor Ccons [pat1; pat2], Pexpr _ _ (PEctor Ccons [pe1; pe2])) ->
        (* populated list (pure expr) *)
        unsafe_subst_pattern pat1 pe1 $
          unsafe_subst_pattern pat2 pe2 expr
    | (CaseCtor Ctuple pats', Pexpr [] () (PEval (Vtuple cvals))) ->
        List.foldr (fun (pat', cval) acc ->
          subst_pattern_val pat' cval acc
        ) expr (List.zip pats' cvals)
    | (CaseCtor Ctuple pats', Pexpr _ _ (PEctor Ctuple pes)) ->
        List.foldr (fun (pat', pe) acc ->
          unsafe_subst_pattern pat' pe acc
        ) expr (List.zip pats' pes)
    (* TODO (maybe), Carray, Civmax, Civmin, Civsizeof, Civalignof *)
    
    | (CaseCtor Cspecified [pat'], Pexpr [] () (PEval (Vloaded (LVspecified oval)))) ->
        subst_pattern_val pat' (Vobject oval) expr
    | (CaseCtor Cspecified [pat'], Pexpr [] () (PEctor Cspecified [pe''])) ->
        unsafe_subst_pattern pat' pe'' expr
    | (CaseCtor Cunspecified [pat'], Pexpr [] () (PEval (Vloaded (LVunspecified ty)))) ->
        subst_pattern_val pat' (Vctype ty) expr
    | (CaseCtor Cunspecified [pat'], Pexpr [] () (PEctor Cunspecified [pe''])) ->
        unsafe_subst_pattern pat' pe'' expr
    | (CaseCtor ctor pats, _) ->
        let str_ctor = match ctor with
          | Cnil _ ->
              "nil"
          | Ccons ->
              "cons"
          | Ctuple ->
              "tuple"
          | Carray ->
              "array"
          | Civmax ->
              "ivmax"
          | Civmin ->
              "ivmin"
          | Civsizeof ->
              "ivsizeof"
          | Civalignof ->
              "ivalignof"
          | CivCOMPL ->
              "ivCOMPL"
          | CivAND ->
              "ivAND"
          | CivOR ->
              "ivOR"
          | CivXOR ->
              "ivXOR"
          | Cspecified ->
              "specified"
          | Cunspecified ->
              "unspecified"
          | Cfvfromint ->
              "fvfromint"
          | Civfromfloat ->
              "ivfromfloat"
        end in
        error ("WIP: Core_aux.unsafe_subst_pattern ==> ctor= " ^ str_ctor ^ ", |pats|= "
               ^ (show (List.length pats)) ^ " -- " ^ Pp.stringFromCore_pexpr pe')
  end

val     subst_pattern: forall 'a. pattern -> pexpr -> expr 'a -> maybe (expr 'a)
let rec subst_pattern (Pattern _ pat) pe' expr =
  
  match (pat, pe') with
    | (CaseBase (Nothing, _), _) ->
        Just expr
    | (CaseBase (Just sym, _), _) ->
        Just $ unsafe_subst_sym_expr sym pe' expr
    | (CaseCtor (Cnil ()) [], Pexpr _ _ (PEval (Vlist _ []))) ->
        (* empty list (value) *)
        Just expr
    | (CaseCtor (Cnil _) [], Pexpr _ _ (PEctor (Cnil _) [])) ->
        (* empty list (pure expr) *)
        Just expr
    | (CaseCtor Ccons [pat1; pat2], Pexpr [] () (PEval (Vlist bTy_elem (cval::cvals)))) ->
        (* populated list (value) *)
        Just (subst_pattern_val pat1 cval $
          subst_pattern_val pat2 (Vlist bTy_elem cvals) expr)
    | (CaseCtor Ccons [pat1; pat2], Pexpr _ _ (PEctor Ccons [pe1; pe2])) ->
        (* populated list (pure expr) *)
        match subst_pattern pat2 pe2 expr with
          | Just e -> subst_pattern pat1 pe1 e
          | Nothing -> Nothing
        end
    | (CaseCtor Ctuple pats', Pexpr [] () (PEval (Vtuple cvals))) ->
        Just $ List.foldr (fun (pat', cval) acc ->
          subst_pattern_val pat' cval acc
        ) expr (List.zip pats' cvals)
    | (CaseCtor Ctuple pats', Pexpr _ _ (PEctor Ctuple pes)) ->
        List.foldr (fun (pat', pe) acc ->
          match acc with
            | Just e -> subst_pattern pat' pe e
            | Nothing -> Nothing
          end
        ) (Just expr) (List.zip pats' pes)
    (* TODO (maybe), Carray, Civmax, Civmin, Civsizeof, Civalignof *)
    
    | (CaseCtor Cspecified [pat'], Pexpr [] () (PEval (Vloaded (LVspecified oval)))) ->
        Just $ subst_pattern_val pat' (Vobject oval) expr
    | (CaseCtor Cspecified [pat'], Pexpr [] () (PEctor Cspecified [pe''])) ->
        subst_pattern pat' pe'' expr
    | (CaseCtor Cunspecified [pat'], Pexpr [] () (PEval (Vloaded (LVunspecified ty)))) ->
        Just $ subst_pattern_val pat' (Vctype ty) expr
    | (CaseCtor Cunspecified [pat'], Pexpr [] () (PEctor Cunspecified [pe''])) ->
        subst_pattern pat' pe'' expr
    | (CaseCtor ctor pats, _) ->
        Nothing
  end



val     to_pure: forall 'a. expr 'a -> maybe pexpr
let rec to_pure (Expr annot expr_) (*(expr : expr 'a)*) =
  let to_pure_aux pat pe1 e2 =
    match subst_pattern pat pe1 e2 with
      | Just e -> to_pure e
      | Nothing ->
          match to_pure e2 with
            | Nothing ->
                Nothing
            | Just pe2 ->
                Just (Pexpr [] () (PElet pat pe1 pe2))
          end
    end
  in
  match expr_ with
    | Epure pe ->
        Just pe
    | Ememop _ _ ->
        Nothing
    | Eskip ->
        Nothing (* TODO: should turn this into Vunit ? *)
    | Elet pat pe1 e2 ->
        match to_pure e2 with
          | Just (Pexpr annot bTy _ as pe2) ->
              Just (Pexpr annot bTy (PElet pat pe1 pe2))
          | _ ->
              Nothing
        end
    | Eif pe1 e2 e3 ->
        match (to_pure e2, to_pure e3) with
          | (Just (Pexpr annot bTy _ as pe2), Just pe3) ->
              Just (Pexpr annot bTy (PEif pe1 pe2 pe3))
          | _ ->
              Nothing
        end
    | Eccall _ _ _ _ ->
        Nothing
    | Eproc _ _ _ ->
        Nothing
    | Eaction _ ->
        Nothing
    | Eunseq es ->
        match to_pures es with
          | Just pes ->
              Just (Pexpr [] () (PEctor Ctuple pes))
          | Nothing ->
              Nothing
        end
    | Ewseq pat e1 e2 ->
        match to_pure e1 with
          | Just pe1 ->
              to_pure_aux pat pe1 e2
          | Nothing ->
              Nothing
        end
    | Esseq pat e1 e2 ->
        match to_pure e1 with
          | Just pe1 ->
              to_pure_aux pat pe1 e2
          | Nothing ->
              Nothing
        end
    | Easeq _ _ _ ->
      Nothing
    | Eindet _ _ ->
        Nothing
    | Ebound _ e ->
        (* TODO: check *)
        to_pure e
    | Esave _ _ _ ->
        Nothing
    | Erun _ _ _ ->
        Nothing
    | End _ ->
        Nothing
    | Epar _ ->
        Nothing
    | Ewait _ ->
        Nothing
(*
    | Eloc _ e ->
        to_pure e
    | Estd _ e ->
        to_pure e
*)
    | Ecase pe pat_es ->
       let (pats, es) = List.unzip pat_es in
        match to_pures es with
          | Just ((Pexpr annot bTy _ :: _) as pes) ->
              Just (Pexpr annot bTy (PEcase pe (List.zip pats pes)))
          | _ ->
            Nothing
        end
end

(* val     to_pures: forall 'a. list (expr 'a) -> maybe (list pexpr)*)
and to_pures (es: list (expr 'a)) =
  List.foldr (fun e acc_opt ->
    match (to_pure e, acc_opt) with
      | (Just pe, Just acc) ->
          Just (pe :: acc)
      | _ ->
          Nothing
    end) (Just []) es



val subst_wait: forall 'a. thread_id -> value -> expr 'a -> expr 'a
let rec subst_wait tid v (Expr annot expr_) =
  Expr annot match expr_ with
  | Epure _ ->
      expr_
  | Ememop _ _ ->
      expr_
  | Eskip ->
      expr_
  | Elet sym pe1 e2 ->
      Elet sym pe1 (subst_wait tid v e2)
  | Eif pe1 e2 e3 ->
      Eif pe1 (subst_wait tid v e2) (subst_wait tid v e3)
  | Ecase pe pat_es ->
      Ecase pe (List.map (fun (pat, e) -> (pat, subst_wait tid v e)) pat_es)
  | Eccall _ _ _ _ ->
      expr_
  | Eproc _ _ _ ->
      expr_
  | Eaction _ ->
      expr_
  | Eunseq es ->
      Eunseq (List.map (subst_wait tid v) es)
   | Ewseq _as e1 e2 ->
       Ewseq _as (subst_wait tid v e1) (subst_wait tid v e2)
   | Esseq _as e1 e2 ->
       Esseq _as (subst_wait tid v e1) (subst_wait tid v e2)
   | Easeq _ _ _ ->
       expr_
   | Eindet i e ->
       Eindet i (subst_wait tid v e)
   | Ebound i e ->
       Ebound i (subst_wait tid v e)
(*
   | Esave ksym sym_tys e ->
       Esave ksym sym_tys (subst_wait tid v e)
   | (Erun _ _ _ as expr) ->
       expr
*)
   | Esave sym sym_bTys e ->
       Esave sym sym_bTys (subst_wait tid v e)
   | Erun _ _ _ ->
       expr_
   | End es ->
       End (List.map (subst_wait tid v) es)
   | Epar es ->
       Epar (List.map (subst_wait tid v) es)
   | Ewait tid' ->
       if tid = tid' then
         match v with
           | Vunit ->
               Epure (Pexpr [] () (PEval Vunit))
           | _ ->
               Epure (Pexpr [] () (PEval v))
         end
       else
         Ewait tid'
(*
   | Eloc loc e ->
       Eloc loc (subst_wait tid v e)
   | Estd s e ->
       Estd s (subst_wait tid v e)
*)
end



let subst_wait_continuation_element tid v = function
  | Kunseq annots es1 es2 ->
      Kunseq annots (List.map (subst_wait tid v) es1) (List.map (subst_wait tid v) es2)
  | Kwseq annots syms_opt e2 ->
      Kwseq annots syms_opt (subst_wait tid v e2)
  | Ksseq annots syms_opt e2 ->
      Ksseq annots syms_opt (subst_wait tid v e2)
(*
  | Ktry str_es ->
      Ktry (List.map (fun (str, e) -> (str, subst_wait tid v e)) str_es)
*)
end

let subst_wait_continuation tid v cont =
  List.map (subst_wait_continuation_element tid v) cont

let rec subst_wait_stack tid v = function
  | Stack_empty ->
      Stack_empty
  | Stack_cons sym_opt cont sk ->
      Stack_cons sym_opt
        (subst_wait_continuation tid v cont) (subst_wait_stack tid v sk)
end


let rec find_labeled_continuation sym (Expr annot expr_) =
  match expr_ with
    | Epure _ ->
        Nothing
    | Ememop _ _ ->
        Nothing
    | Eaction _ ->
        Nothing
    | Ecase _ pat_es ->
        let () = Debug.warn [] (fun () -> "Core_aux.find_labeled_continuation assumes there is atmost single match inside a Ecase") in
        List.foldl (fun acc (_, e) ->
          match acc with
            | Just _ ->
                acc
            | Nothing ->
                match find_labeled_continuation sym e with
                  | Nothing ->
                      Nothing
                  | Just ret ->
                      Just ret
                end
          end
        ) Nothing pat_es
    | Elet _ _ e2 ->
        find_labeled_continuation sym e2
    | Eif _ e2 e3 ->
        (* NOTE: in a well formed Core expr, [sym] cannot be bound in both e2 and e3. *)
        match find_labeled_continuation sym e2 with
          | Just z ->
              Just z
          | Nothing ->
              find_labeled_continuation sym e3
        end
    | Eskip ->
        Nothing
    | Eccall _ _ _ _ ->
        Nothing
    | Eproc _ _ _ ->
        Nothing
    | Eunseq _ ->
        (* NOTE: Typing forbids labeled continuation bindings inside unseq() *)
        Nothing
    | Ewseq pat e1 e2 ->
        let () = Debug.warn [] (fun () -> "Core_aux.find_labeled_continuation assumes the bindings of an Esave inside a Ewseq don't clash") in
        match find_labeled_continuation sym e1 with
          | Just (syms, cont_expr) ->
              Just (syms, Expr annot (Ewseq pat cont_expr e2))
          | Nothing ->
              find_labeled_continuation sym e2
        end
    | Esseq pat e1 e2 ->
        let () = Debug.warn [] (fun () -> "Core_aux.find_labeled_continuation assumes the bindings of an Esave inside a Esseq don't clash") in
        match find_labeled_continuation sym e1 with
          | Just (syms, cont_expr) ->
              Just (syms, Expr annot (Esseq pat cont_expr e2))
          | Nothing ->
              find_labeled_continuation sym e2
        end
    | Easeq _ _ _ ->
        Nothing
    | Eindet  _ _ ->
        (* NOTE: Typing forbids labeled continuation bindings inside indet() *)
        Nothing
    | Ebound _ _ ->
        (* NOTE: Typing forbids labeled continuation bindings inside bound() *)
        Nothing
    | End _ ->
        (* NOTE: Typing forbids labeled continuation bindings in inside nd() *)
        Nothing
    | Esave (sym', _) sym_bTys e ->
        if sym = sym' then
          Just (List.map fst sym_bTys, e)
        else
          find_labeled_continuation sym e
    | Erun annot sym pes ->
        Nothing
    | Epar es ->
        let () = Debug.warn [] (fun () -> "Core_aux.find_labeled_continuation assumes there are no Esave inside par()") in
        Nothing
    | Ewait _ ->
        Nothing
(*
    | Eloc _ e ->
        find_labeled_continuation sym e
    | Estd _ e ->
        find_labeled_continuation sym e
*)
  end


val find_labeled_continuation2_aux: forall 'a.
  map Symbol.sym (list Symbol.sym * expr 'a) -> Symbol.sym -> expr 'a ->
(*  maybe ((list Symbol.sym * expr 'a) * map Symbol.sym (list Symbol.sym * expr 'a)) *)
  map Symbol.sym (list Symbol.sym * expr 'a)
let rec find_labeled_continuation2_aux acc sym (Expr annot expr_) =
  match expr_ with
    | Epure _ ->
        acc
    | Ememop _ _ ->
        acc
    | Eaction _ ->
        acc
    | Ecase _ pat_es ->
        let () = Debug.warn [] (fun () -> "Core_aux.find_labeled_continuation2_aux assumes there is atmost single match inside a Ecase") in
        List.foldl (fun acc' (_, e) ->
          find_labeled_continuation2_aux acc' sym e
        ) acc pat_es
    | Elet _ _ e2 ->
        find_labeled_continuation2_aux acc sym e2
    | Eif _ e2 e3 ->
        let acc' = find_labeled_continuation2_aux acc sym e2 in
        find_labeled_continuation2_aux acc' sym e3
    | Eskip ->
        acc
    | Eccall _ _ _ _ ->
        acc
    | Eproc _ _ _ ->
        acc
    | Eunseq _ ->
        (* NOTE: Typing forbids labeled continuation bindings inside unseq() *)
        acc
    | Ewseq pat e1 e2 ->
        let () = Debug.warn [] (fun () ->
          "Core_aux.find_labeled_continuation2_aux assumes the bindings of an Esave inside a Ewseq don't clash") in
        let acc' = Map.map (fun (syms, z) ->
                     (syms, Expr annot (Ewseq pat z e2))
                   ) (find_labeled_continuation2_aux Map.empty sym e1) in
        find_labeled_continuation2_aux (Map.(union) acc acc') sym e2
    | Esseq pat e1 e2 ->
        let () = Debug.warn [] (fun () ->
          "Core_aux.find_labeled_continuation2_aux assumes the bindings of an Esave inside a Esseq don't clash") in
        let acc' = Map.map (fun (syms, z) ->
                     (syms, Expr annot (Esseq pat z e2))
                   ) (find_labeled_continuation2_aux Map.empty sym e1) in
        find_labeled_continuation2_aux (Map.(union) acc acc') sym e2
    | Easeq _ _ _ ->
        acc
    | Eindet  _ _ ->
        (* NOTE: Typing forbids labeled continuation bindings inside indet() *)
        acc
    | Ebound _ _ ->
        (* NOTE: Typing forbids labeled continuation bindings inside bound() *)
        acc
    | End _ ->
        (* NOTE: Typing forbids labeled continuation bindings in inside nd() *)
        acc
    | Esave (sym', _) sym_bTys e ->
        if sym = sym' then
          Map.insert sym (List.map fst sym_bTys, e) acc
        else
          find_labeled_continuation2_aux (Map.insert sym' (List.map fst sym_bTys, e) acc) sym e
    | Erun annot sym pes ->
        acc
    | Epar es ->
        let () = Debug.warn [] (fun () -> "Core_aux.find_labeled_continuation2_aux assumes there are no Esave inside par()") in
        acc
    | Ewait _ ->
        acc
(*
    | Eloc _ e ->
        find_labeled_continuation2_aux acc sym e
    | Estd _ e ->
        find_labeled_continuation2_aux acc sym e
*)
end

let find_labeled_continuation2 sym e =
  let lconts = find_labeled_continuation2_aux Map.empty sym e in
  match Map.lookup sym lconts  with
    | Just cont ->
        Just (cont, lconts)
    | Nothing ->
        Nothing
  end







val apply_continuation: forall 'a. continuation 'a -> expr 'a -> expr 'a
let apply_continuation cont expr =
  let f _cont (Expr annot _ as expr) =
    match _cont with
      | Kwseq annots pat e2 ->
          Expr annots (Ewseq pat expr e2)
      | Ksseq annots pat e2 ->
          Expr annots (Esseq pat expr e2)
      | Kunseq annots es1 es2 ->
          Expr annots (Eunseq $ es1 ++ (expr :: es2))
(*
      | Ktry str_es ->
          Etry expr str_es
*)
    end in
  foldl (fun acc x -> f x acc) expr cont


(* Functions on continuation and stacks *)
val empty_stack: forall 'a. stack 'a
let empty_stack =
  Stack_empty

val is_empty_stack: forall 'a. stack 'a -> bool
let is_empty_stack = function
  | Stack_empty ->
      true
  | _ ->
      false
end



val push_empty_continuation: forall 'a. maybe Symbol.sym -> stack 'a -> stack 'a
let push_empty_continuation sym_opt sk =
  Stack_cons sym_opt [] sk

val reset_continuation: forall 'a. stack 'a -> stack 'a
let reset_continuation = function
  | Stack_empty ->
      (* TODO: are should this fail, just to catch ill-uses? *)
      Stack_empty
  | Stack_cons sym_opt cont sk ->
      Stack_cons sym_opt [] sk
end

val pop_stack: forall 'a. stack 'a -> Exception.exceptM (continuation 'a * stack 'a) core_run_cause
let pop_stack = function
  | Stack_empty ->
      Exception.fail (Found_empty_stack "pop_stack")
  | Stack_cons _ cont sk ->
      Exception.return (cont, sk)
end

val pop_continuation_element: forall 'a. stack 'a -> Exception.exceptM (continuation_element 'a * stack 'a) core_run_cause
let pop_continuation_element = function
  | Stack_empty ->
      Exception.fail (Found_empty_stack "pop_continuation_element")
  | Stack_cons _ [] _ ->
      Exception.fail Reached_end_of_proc
  | Stack_cons sym_opt (cont_elem :: cont) sk ->
      Exception.return (cont_elem, Stack_cons sym_opt cont sk)
end


val push_continuation_element: forall 'a. continuation_element 'a -> stack 'a -> Exception.exceptM (stack 'a) core_run_cause
let push_continuation_element cont_elem = function
  | Stack_empty ->
      Exception.fail (Found_empty_stack "push_continuation_element")
  | Stack_cons sym_opt cont sk ->
      Exception.return (Stack_cons sym_opt (cont_elem :: cont) sk)
end



val append_to_current_continuation: forall 'a. continuation_element 'a -> stack 'a -> Exception.exceptM (stack 'a) core_run_cause
let append_to_current_continuation cont_elem = function
  | Stack_empty ->
      (* A procedure need to currently be running to append *)
      Exception.fail (Found_empty_stack "append_to_current_continuation")
  | Stack_cons sym_opt cont sk ->
      Exception.return $ Stack_cons sym_opt (cont_elem :: cont) sk
end


val unsafe_subst_sym_fun_map: forall 'a. Symbol.sym -> pexpr -> fun_map 'a -> fun_map 'a
let unsafe_subst_sym_fun_map sym pe' funs =
  Map.map (function
    | Fun bTy params pe ->
        Fun bTy params (unsafe_subst_sym_pexpr sym pe' pe)
    | ProcDecl loc bTy params ->
        ProcDecl loc bTy params
    | BuiltinDecl loc bTy params ->
        BuiltinDecl loc bTy params
    | Proc loc bTy params e ->
        Proc loc bTy params (unsafe_subst_sym_expr sym pe' e)
  end) funs


val     collect_labeled_continuations: forall 'a. expr 'a -> map Symbol.sym (list (Symbol.sym (* * core_base_type*)) * expr 'a)
let rec collect_labeled_continuations (Expr annot expr_) =
  match expr_ with
    | Epure _ ->
        Map.empty
    | Ememop _ _ ->
        Map.empty
    | Eskip ->
        Map.empty
    | Elet _ _ e2 ->
        collect_labeled_continuations e2
    | Eif pe1 e2 e3 ->
        Map.(union) (collect_labeled_continuations e2) (collect_labeled_continuations e3)
    | Ecase pe pat_es ->
        Map.empty (* TODO THIS IS WRONG!!!!! *)
    | Eproc _ _ _ ->
        Map.empty
    | Eccall _ _ _ _ ->
        Map.empty
    | Eaction _ ->
        Map.empty
    | Eunseq _ ->
        Map.empty
    | Ewseq _as e1 e2 ->
        Map.(union) (Map.map (fun (a_tys, e) -> (a_tys, Expr annot (Ewseq _as e e2))) $ collect_labeled_continuations e1)
                    (collect_labeled_continuations e2)
    | Esseq _as e1 e2 ->
        Map.(union) (Map.map (fun (a_tys, e) -> (a_tys, Expr annot (Esseq _as e e2))) $ collect_labeled_continuations e1)
                    (collect_labeled_continuations e2)
    | Easeq _ _ _ ->
        Map.empty
    | Eindet _ _ ->
        Map.empty
    | Ebound _ _ ->
        Map.empty
    | Esave (sym_lab, _) sym_bTys e ->
        Map.insert sym_lab (List.map fst sym_bTys, e) $ collect_labeled_continuations e
    | Erun _ _ _ ->
        Map.empty
    | End _ ->
        (* TODO: check *)
        Map.empty
    | Epar _ ->
        (* TODO: check *)
        Map.empty
    | Ewait _ ->
        Map.empty
(*
    | Eloc loc e ->
        collect_labeled_continuations e
    | Estd _ e ->
        collect_labeled_continuations e
*)
  end



val is_unseq_with_negative: forall 'a. expr 'a -> bool
let is_unseq_with_negative = function
  | Expr _ (Eunseq es) ->
      List.any is_negative es
  | _ ->
      false
end


(*
val     has_sseqs: forall 'a. expr 'a -> bool
let rec has_sseqs expr =
  match expr with
    | Epure _ ->
        false
    | Ememop _ _ ->
        false
    | Eaction p ->
        false
    | Ecase _ pat_es ->
        List.any (fun (_, e) -> has_sseqs e) pat_es
    | Elet _ _ e2 ->
        has_sseqs e2
    | Eif _ e2 e3 ->
        has_sseqs e2 || has_sseqs e3
    | Eskip ->
        false
    | Eccall _ _ _ ->
        (* TODO: look into the called body *)
        false
    | Eproc _ _ _ ->
        (* TODO: look into the called body *)
        false
    | Eunseq es ->
        List.any has_sseqs es
    | Ewseq _ e1 e2 ->
        has_sseqs e1 || has_sseqs e2
    | Esseq _ _ _ ->
        true
    | Easeq _ _ _  ->
        error "has_sseqs found an Easeq"
    | Eindet _ e ->
        has_sseqs e
    | Ebound _ e ->
        has_sseqs e
    | Esave _ _ e ->
        has_sseqs e
    | Erun _ _ _ ->
        false
    | End es ->
        List.any has_sseqs es
    | Epar _ ->
        (* TODO: I think *)
        false
    | Ewait _ ->
        false
    | Eloc _ e ->
        has_sseqs e
  end
*)



val     match_pattern: pattern -> value -> maybe (list (sym * value))
let rec match_pattern (Pattern _ pat) cval =
  match (pat, cval) with
    | (CaseBase (Nothing, _), _) ->
        Just []
    | (CaseBase (Just sym, _), _) ->
        Just [(sym, cval)]
(*      | Vobject of (generic_object_value 'sym) *)
    | (CaseCtor Cspecified [pat'], Vloaded (LVspecified oval)) ->
        match_pattern pat' (Vobject oval)
    | (CaseCtor Cunspecified [pat'], Vloaded (LVunspecified ty)) ->
        match_pattern pat' (Vctype ty)
(*      | Vlist of core_base_type * list (generic_value 'sym) *)
    | (CaseCtor Ctuple pats', Vtuple cvals') -> 
        List.foldr (fun (pat', cval') acc ->
          Maybe.bind acc (fun xs ->
            Maybe.bind (match_pattern pat' cval') (fun x ->
              Just (x++xs)
            )
          )
        ) (Just []) (List.zip pats' cvals')
    | (CaseCtor (Cnil _) [], Vlist _ []) ->
        let () = Debug.warn [] (fun () -> "Pattern matching nil without checking types!") in
        Just []
    | (CaseCtor Ccons [pat_x; pat_xs], Vlist ty (x::xs)) ->
        Maybe.bind (match_pattern pat_x x) (fun x ->
          Maybe.bind (match_pattern pat_xs (Vlist ty xs)) (fun xs ->
            Just (x++xs)
          )
        )
    | _ ->
        Nothing
  end

val     select_case: forall 'a. (Symbol.sym -> value -> 'a -> 'a) -> value -> list (pattern * 'a) -> maybe 'a
let rec select_case subst_sym cval = function
  | [] ->
      let () = Debug.print_debug 1 [] (fun () -> "NOTHING") in
      Nothing
  | (pat, pe) :: pat_pes' ->
      let () = Debug.print_debug 1 [] (fun () -> "SELECT_CASE") in
      match match_pattern pat cval with
        | Nothing ->
            (* trying the next branch *)
            select_case subst_sym cval pat_pes'
        | Just (sym_cvals) ->
            Just $ List.foldr (fun (sym, cval') acc ->
              subst_sym sym cval' acc
            ) pe sym_cvals
      end
end


(*
val isConstrainedValue: value -> bool
let isConstrainedValue cval =
  match flatten_constrained_value cval with
    | Vconstrained _ ->
        true
    | _ ->
        false
  end
*)

val mk_pure_e: pexpr -> expr unit
let mk_pure_e pe =
  Expr [] (Epure pe)

val mk_skip_e: expr unit
let mk_skip_e =
  Expr [] Eskip


val mk_unseq_e: list (expr unit) -> expr unit
let mk_unseq_e es =
  Expr [] (Eunseq es)

val mk_case_e: pexpr -> list (pattern * expr unit) -> expr unit
let mk_case_e pe pat_es =
  Expr [] (Ecase pe pat_es)

val mk_wseq_e: pattern -> expr unit -> expr unit -> expr unit
let mk_wseq_e pat e1 e2 =
  Expr [] (Ewseq pat e1 e2)

val mk_sseq_e: pattern -> expr unit -> expr unit -> expr unit
let mk_sseq_e pat e1 e2 =
  Expr [] (Esseq pat e1 e2)

val mk_save_e: (Symbol.sym * core_base_type) -> list (Symbol.sym * (core_base_type * pexpr)) -> expr unit -> expr unit
let mk_save_e sym_bTy sym_bTy_pes e =
  Expr [] (Esave sym_bTy sym_bTy_pes e)

val mk_run_e: Symbol.sym -> list pexpr -> expr unit
let mk_run_e sym pes =
  Expr [] (Erun () sym pes)

val mk_nd_e: list (expr unit) -> expr unit
let mk_nd_e es =
  Expr [] (End es)

val mk_if_e: pexpr -> expr unit -> expr unit -> expr unit
let mk_if_e pe e1 e2 =
  Expr [] (Eif pe e1 e2)

val mk_let_e: pattern -> pexpr -> expr unit -> expr unit
let mk_let_e pat pe e =
  Expr [] (Elet pat pe e)

val mk_ccall_e: pexpr -> pexpr -> list pexpr -> expr unit
let mk_ccall_e cty pe pes =
  Expr [] (Eccall default cty pe pes)

val mk_memop_e: Mem_common.memop -> list pexpr -> expr unit
let mk_memop_e mop pes =
  Expr [] (Ememop mop pes)


val add_loc: Loc.t -> expr unit -> expr unit
let add_loc loc (Expr annot expr_) =
  Expr (Aloc loc :: annot) expr_

val add_std: string -> expr unit -> expr unit
let add_std str (Expr annot expr_) =
  Expr (Astd str :: annot) expr_

val     set_uid_pe: string -> nat -> pexpr -> pexpr
let rec set_uid_pe uid n (Pexpr annots bty pe_) =
  let uid' = uid ^ show n in
  let self n pe = set_uid_pe uid' n pe in
  let selfs pes = List.mapi (fun i pe -> self (i+1) pe) pes in
  Pexpr annots bty
  match pe_ with
  | PEsym s -> PEsym s
  | PEimpl impl -> PEimpl impl
  | PEval v -> PEval v
  | PEconstrained cs ->
    PEconstrained (List.mapi (fun i (m, pe) -> (m, self (i+1) pe)) cs)
  | PEundef loc undef -> PEundef loc undef
  | PEerror err pe -> PEerror err (self 1 pe)
  | PEctor ctor pes -> PEctor ctor (selfs pes)
  | PEcase pe cases -> PEcase (self 0 pe)
                        (List.mapi (fun i (pat, pe) -> (pat, self (i+1) pe)) cases)
  | PEarray_shift pe cty pes -> PEarray_shift (self 1 pe) cty (self 2 pes)
  | PEmember_shift pe sym cid -> PEmember_shift (self 1 pe) sym cid
  | PEnot pe -> PEnot (self 1 pe)
  | PEop bop pe1 pe2 -> PEop bop (self 1 pe1) (self 2 pe2)
  | PEstruct sym fields -> PEstruct sym
                      (List.mapi (fun i (cid, pe) -> (cid, self (i+1) pe)) fields)
  | PEunion sym cid pe -> PEunion sym cid (self 1 pe)
  | PEcfunction pe -> PEcfunction (self 1 pe)
  | PEmemberof tag_sym memb_ident pe -> PEmemberof tag_sym memb_ident (self 1 pe)
  | PEcall name pes -> PEcall name (selfs pes)
  | PElet pat pe1 pe2 -> PElet pat (self 1 pe1) (self 2 pe2)
  | PEif pe1 pe2 pe3 -> PEif (self 1 pe1) (self 2 pe2) (self 3 pe3)
  | PEis_scalar pe -> PEis_scalar (self 1 pe)
  | PEis_integer pe -> PEis_integer (self 1 pe)
  | PEis_signed pe -> PEis_signed (self 1 pe)
  | PEis_unsigned pe -> PEis_unsigned (self 1 pe)
  | PEare_compatible pe1 pe2 -> PEare_compatible (self 1 pe1) (self 2 pe2)
  end

val     set_uid_e: forall 'a. string -> nat -> expr 'a -> expr 'a
let rec set_uid_e uid n (Expr annots e_) =
  let uid' = uid ^ show n in
  let pure_uid n pe = set_uid_pe uid' n pe in
  let pure_uids pes = List.mapi (fun i pe -> pure_uid (i+1) pe) pes in
  let self n e = set_uid_e uid' n e in
  let selfs es = List.mapi (fun i e -> self (i+1) e) es in
  Expr (Auid uid' :: annots)
  match e_ with
  | Epure pe -> Epure (set_uid_pe uid' 0 pe)
  | Ememop memop pes -> Ememop memop (pure_uids pes)
  | Eaction pact -> Eaction pact
  | Ecase pe cases -> Ecase (set_uid_pe uid' 0 pe)
                        (List.mapi (fun i (pat, e) -> (pat, self (i+1) e)) cases)
  | Elet pat pe e -> Elet pat (set_uid_pe uid' 0 pe) (self 1 e)
  | Eif pe e1 e2 -> Eif (set_uid_pe uid' 0 pe) (self 1 e1) (self 2 e2)
  | Eskip -> Eskip
  | Eccall x pe1 pe2 args -> Eccall x (set_uid_pe uid' 0 pe1) (set_uid_pe uid' 0 pe2) (pure_uids args)
  | Eproc x name args -> Eproc x name (pure_uids args)
  | Eunseq es -> Eunseq (selfs es)
  | Ewseq pat e1 e2 -> Ewseq pat (self 1 e1) (self 2 e2)
  | Esseq pat e1 e2 -> Esseq pat (self 1 e1) (self 2 e2)
  | Easeq bty act pact -> Easeq bty act pact
  | Eindet n e -> Eindet n (self 1 e)
  | Ebound n e -> Ebound n (self 1 e)
  | End es -> End (selfs es)
  | Esave lab_bty args e -> Esave lab_bty
      (List.mapi (fun i (s, (bty, pe)) -> (s, (bty, pure_uid (i+1) pe))) args)
      (self 0 e)
  | Erun x lab pes -> Erun x lab (pure_uids pes)
  | Epar es -> Epar (selfs es)
  | Ewait thid -> Ewait thid
  end

val string_of_symbol: Symbol.sym -> string
declare ocaml target_rep function string_of_symbol = `Pp_symbol.to_string_pretty`

let set_uid_fun fname = function
  | Fun bty args pe -> Fun bty args pe
  | ProcDecl loc ret_bty args_bty -> ProcDecl loc ret_bty args_bty
  | BuiltinDecl loc ret_bty args_bty -> BuiltinDecl loc ret_bty args_bty
  | Proc loc bty args e -> Proc loc bty args (set_uid_e (string_of_symbol fname) 1 e)
end

let set_uid_globs (gname, glb) =
  (gname, match glb with
  | GlobalDef bty e -> GlobalDef bty (set_uid_e (string_of_symbol gname) 1 e)
  | GlobalDecl bty -> GlobalDecl bty
  end)

let set_uid file =
 <|
  main=    file.main;
  tagDefs= file.tagDefs;
  stdlib=  file.stdlib;
  impl=    file.impl;
  globs=   List.map set_uid_globs file.globs;
  funs=    Map.mapi set_uid_fun file.funs;
  extern=  file.extern;
  funinfo= file.funinfo;
 |>


type collect_saves_state 'a = <|
  tmp_acc:    Core.labeled_continuations 'a;
  closed_acc: Core.labeled_continuations 'a;
|>

let empty_saves = <| tmp_acc= Map.empty; closed_acc= Map.empty |>

let union_saves st1 st2 =
  <| tmp_acc= Map.(union) st1.tmp_acc st2.tmp_acc;
     closed_acc= Map.(union) st1.closed_acc st2.closed_acc |>

(* NOTE: assumes the expression is well formed/typed *)
val     collect_saves_aux: forall 'a. collect_saves_state 'a -> expr 'a -> collect_saves_state 'a
let rec collect_saves_aux st (Expr annots expr_) =
  match expr_ with
    | Epure _ ->
        st
    | Ememop _ _ ->
        st
    | Eaction _ ->
        st
    | Ecase _ pat_es ->
        List.foldl (fun acc (_, e) ->
          collect_saves_aux acc e
        ) st pat_es
    | Elet _ _ e ->
        collect_saves_aux st e
    | Eif _ e1 e2 ->
        collect_saves_aux (collect_saves_aux st e1) e2
    | Eskip ->
        st
    | Eccall _ _ _ _ ->
        st
    | Eproc _ _ _ ->
        st
    | Eunseq es ->
        List.foldl collect_saves_aux st es
    | Ewseq pat e1 e2 ->
        let st1 = collect_saves_aux empty_saves e1 in
        let st2 = collect_saves_aux empty_saves e2 in
        union_saves st begin
          union_saves
            <| st1 with
              tmp_acc= Map.map (fun (syms, e) -> (syms, Expr annots (Ewseq pat e e2))) st1.tmp_acc
            |>
            st2
        end
    | Esseq pat e1 e2 ->
        let st1 = collect_saves_aux empty_saves e1 in
        let st2 = collect_saves_aux empty_saves e2 in
        union_saves st begin
          union_saves
            <| st1 with
              tmp_acc= Map.map (fun (syms, e) -> (syms, Expr annots (Esseq pat e e2))) st1.tmp_acc
            |>
            st2
        end
    | Easeq _ _ _ ->
        st
    | Eindet _ _ ->
        (* typing forbids "saves" inside an "indet()" *)
        st
    | Ebound _ _ ->
        (* typing forbids "saves" inside a "bound()" *)
        st
    | End _ ->
        (* typing forbids "saves" inside a "nd()" *)
        st
    | Esave (sym, _) params e ->
        collect_saves_aux
          <| st with tmp_acc= Map.insert sym (List.map fst params, e) st.tmp_acc |>
          e
    | Erun _ _ _ ->
        st
    | Epar es ->
        let acc = List.foldl collect_saves_aux
          empty_saves es in
        <| st with closed_acc=
          Map.(union) (Map.(union) acc.tmp_acc acc.closed_acc)
                      st.closed_acc |>
    | Ewait _ ->
        st
  end

val collect_saves: forall 'a. expr 'a -> labeled_continuations 'a
let collect_saves expr =
  let st = collect_saves_aux <| tmp_acc= Map.empty; closed_acc= Map.empty |> expr in
  Map.(union) st.tmp_acc st.closed_acc


import Map_extra

val collect_labeled_continuations_NEW: forall 'a. file 'a -> map Symbol.sym (labeled_continuations 'a)
let collect_labeled_continuations_NEW file =
(*  let xs =  *)
  Map_extra.fold (fun fun_sym decl acc ->
    match decl with
      | Fun _ _ _ ->
          acc
      | ProcDecl _ _ _ ->
          acc
      | BuiltinDecl _ _ _ ->
          acc
      | Proc _ _ _ e ->
          Map.insert fun_sym (collect_saves e) acc
    end
  ) (Map.(union) file.stdlib file.funs) Map.empty
(*
in
  let _ = Map.mapi (fun sym labs ->
    Debug.print_debug 1 [] (fun () ->
      "PROC " ^ show sym ^ " ==>\n" ^
      List.foldl (fun acc (sym, (_, e)) -> show sym ^ " ==> " ^ Pp.stringFromCore_expr e) "" (Map_extra.toList labs) 
    )
  ) xs in
  xs
*)


val     update_env: pattern -> value -> list (map Symbol.sym value) -> list (map Symbol.sym value)
let rec update_env_aux (Pattern _ pat) cval env =
  (* TODO (maybe), Carray, Civmax, Civmin, Civsizeof, Civalignof *)
  match (pat, cval) with
    | (CaseBase (Nothing, _), _) ->
        (* e[_ \ v] = e *)
        env
    | (CaseBase (Just sym, _), _) ->
        (* e[sym \ v] *)
        Map.insert sym cval env
    | (CaseCtor (Cnil ()) [], Vlist _ []) ->
        (* empty list (value) *)
        env
    | (CaseCtor Ccons [pat1; pat2], Vlist bTy_elem (cval1::cvals)) ->
        (* populated list (value) *)
        update_env_aux pat1 cval1 $
          update_env_aux pat2 (Vlist bTy_elem cvals) env
    | (CaseCtor Ctuple pats', Vtuple cvals) ->
        List.foldr (fun (pat', cval') acc ->
          update_env_aux pat' cval' acc
        ) env (List.zip pats' cvals)
    | (CaseCtor Cspecified [pat'], Vloaded (LVspecified oval)) ->
        update_env_aux pat' (Vobject oval) env
    | (CaseCtor Cunspecified [pat'], Vloaded (LVunspecified ty)) ->
        update_env_aux pat' (Vctype ty) env
    | (CaseCtor ctor pats, _) ->
        let str_ctor = match ctor with
          | Cnil _ ->
              "nil"
          | Ccons ->
              "cons"
          | Ctuple ->
              "tuple"
          | Carray ->
              "array"
          | Civmax ->
              "ivmax"
          | Civmin ->
              "ivmin"
          | Civsizeof ->
              "ivsizeof"
          | Civalignof ->
              "ivalignof"
          | CivCOMPL ->
              "ivCOMPL"
          | CivAND ->
              "ivAND"
          | CivOR ->
              "ivOR"
          | CivXOR ->
              "ivXOR"
          | Cspecified ->
              "specified"
          | Cunspecified ->
              "unspecified"
          | Cfvfromint ->
              "fvfromint"
          | Civfromfloat ->
              "ivfromfloat"
        end in
        error ("WIP: Core_aux.update_env_aux ==> ctor= " ^ str_ctor ^ ", |pats|= "
               ^ (show (List.length pats)) ^ " -- " ^ Pp.stringFromCore_value cval)
  end

let update_env pat cval = function
  | [] ->
      error "Core_aux.update_env: found empty env"
  | env::xs ->
      update_env_aux pat cval  env :: xs
end


let rec lookup_env sym = function
  | [] ->
      Nothing
  | env :: xs ->
      match Map.lookup sym env with
        | Nothing ->
            lookup_env sym xs
        | Just ret ->
            Just ret
      end
end



(* Linkage *)

(* NOTE: the function returns a list of redundant tentative global definitions *)
let link_extern ext acc =
  Map_extra.fold (fun k (decls, lk_def) (acc_ext, acc_tent) ->
    let () = Debug.print_debug 3 [] (fun _ -> "linking " ^ show k) in
    match Map.lookup k acc with
    | Nothing ->
      (Map.insert k (decls, lk_def) acc_ext, acc_tent)
    | Just (acc_decls, LK_none) ->
      (Map.insert k (decls ++ acc_decls, lk_def) acc_ext, acc_tent)
    | Just (acc_decls, LK_tentative tent) ->
      match lk_def with
      | LK_normal _ ->
        (Map.insert k (decls ++ acc_decls, lk_def) acc_ext, tent :: acc_tent)
      | LK_tentative _ ->
        (Map.insert k (decls ++ acc_decls, lk_def) acc_ext, tent :: acc_tent)
      | LK_none ->
        (Map.insert k (decls ++ acc_decls, LK_tentative tent) acc_ext, acc_tent)
      end
    | Just (acc_decls, LK_normal def) ->
      match lk_def with
      | LK_normal _ ->
        error ("two definition for the same identifier: " ^ show k)
      | LK_tentative tent ->
        (Map.insert k (decls ++ acc_decls, LK_normal def) acc_ext, tent :: acc_tent)
      | LK_none ->
        (Map.insert k (decls ++ acc_decls, LK_normal def) acc_ext, acc_tent)
      end
  end) ext (acc, [])

let link_main opt_m1 opt_m2 =
  match (opt_m1, opt_m2) with
  | (Just _, Just _) -> error "two mains declared"
  | (Just m1, Nothing) -> Just m1
  | (Nothing, Just m2) -> Just m2
  | (Nothing, Nothing) -> Nothing
  end

val list_remove_assoc: forall 'a 'b. 'a -> list ('a * 'b) -> list ('a * 'b)
declare ocaml target_rep function list_remove_assoc = `List.remove_assoc`

let merge f1 f2 =
  let (extern, reduntant_globs) = link_extern f2.extern f1.extern in
  let globs =
    List.foldl (fun acc g -> list_remove_assoc g acc)
      (f1.globs ++ f2.globs) reduntant_globs
  in
  <| main = link_main f1.main f2.main;
     tagDefs = f1.tagDefs union f2.tagDefs;
     stdlib = f1.stdlib;
     impl = f1.impl;
     globs = globs;
     funs = f1.funs union f2.funs;
     extern = extern;
     funinfo = f1.funinfo union f2.funinfo;
  |>

val link: forall 'a 'b. list (generic_file 'a 'b) -> generic_file 'a 'b
let link = function
  | [] -> error "linking: no core files"
  | f::fs -> List.foldl merge f fs
end
