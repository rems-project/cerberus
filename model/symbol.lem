open import Pervasives Utils Show Show_extra Enum
import Loc Debug

type digest
declare ocaml target_rep type digest = `Digest.t`

val digest: unit -> digest
declare ocaml target_rep function digest = `Fresh.digest`

val digest_compare: digest -> digest ->int 
declare ocaml target_rep function digest_compare = `Digest.compare`

val string_of_digest: digest -> string
declare ocaml target_rep function string_of_digest = `Digest.to_hex`

instance (Eq digest)
  let (=) x y = digest_compare x y = 0
  let (<>) x y = digest_compare x y <> 0
end

instance (Ord digest)
  let compare x y =
    let cmp = digest_compare x y in
    if cmp < 0 then LT else if cmp = 0 then EQ else GT
  let (<) x y =
    digest_compare x y < 0
  let (<=) x y =
    digest_compare x y <= 0
  let (>) x y =
    digest_compare x y > 0
  let (>=) x y =
    digest_compare x y >= 0
end


instance (Show digest)
  let show d = string_of_digest d
end

(* Symbolic identifiers *)
type sym =
  Symbol of digest * nat * maybe string

val        symbolEqual: sym -> sym -> bool
let inline symbolEqual sym1 sym2 =
  match (sym1, sym2) with
    | (Symbol d1 n1 str_opt1, Symbol d2 n2 str_opt2) ->
        if d1 = d2 && n1 = n2 then
          if Debug.get_level () >= 5 && str_opt1 <> str_opt2 then
            let () = Debug.print_debug 5 [] (fun () -> "[Symbol.symbolEqual] suspicious equality ==> " ^ show str_opt1 ^ " <-> " ^ show str_opt2) in
            true
          else
            true
        else
          false
  end

instance (Eq sym)
  let (=)            = symbolEqual
  let (<>) sym1 sym2 = not (symbolEqual sym1 sym2)
end

instance (Ord sym)
  let compare sym1 sym2 =
    let (Symbol d1 n1 _) = sym1 in
    let (Symbol d2 n2 _) = sym2 in
      if d1 = d2 then compare n1 n2
      else compare d1 d2
  let (<) sym1 sym2 = 
    let (Symbol d1 n1 _) = sym1 in
    let (Symbol d2 n2 _) = sym2 in
    d1 < d2 || (d1 = d2 && n1 < n2)
  let (<=) sym1 sym2 = 
    let (Symbol d1 n1 _) = sym1 in
    let (Symbol d2 n2 _) = sym2 in
    d1 <= d2 || (d1 = d2 && n1 <= n2)
  let (>) sym1 sym2 = 
    let (Symbol d1 n1 _) = sym1 in
    let (Symbol d2 n2 _) = sym2 in
    d1 > d2 || (d1 = d2 && n1 > n2)
  let (>=) sym1 sym2 = 
    let (Symbol d1 n1 _) = sym1 in
    let (Symbol d2 n2 _) = sym2 in
    d1 >= d2 || (d1 = d2 && n1 >= n2)
end

instance (NumSucc sym)
  let succ sym =
    let (Symbol d n str_opt) = sym in 
    Symbol d (n+1) str_opt
end

(*
instance (Enum sym)
  let toEnum n =
    Symbol (digest ()) n Nothing
  let fromEnum sym =
    let (Symbol _ n _) = sym in n
end
*)

instance (SetType sym)
  let setElemCompare sym1 sym2 = ordCompare sym1 sym2
end

instance (Show sym)
  let show sym =
    let Symbol d n str_opt = sym in
    "Symbol" ^ show (n, str_opt)
end

let show_raw (Symbol d n str_opt) =
  "Symbol(" ^ show d ^ ", " ^ show n ^ ", " ^ show str_opt ^ ")"

(* Location prefix *)
type prefix =
  | PrefSource of Loc.t * list sym
  | PrefFunArg of Loc.t * digest * int
  | PrefStringLiteral of Loc.t * digest
  | PrefOther of string

val fresh_int: unit -> nat
declare ocaml target_rep function fresh_int = `Fresh.int`

val digest_of_sym: sym -> digest
let digest_of_sym (Symbol dig _ _) = dig

val fresh: unit -> sym
let fresh () =
  Symbol (digest()) (fresh_int ()) Nothing

val fresh_pretty : string -> sym
let fresh_pretty str =
  Symbol (digest()) (fresh_int ()) (Just str)

val fresh_pretty_with_id : (nat -> string) -> sym
let fresh_pretty_with_id mkStr =
  let id = fresh_int () in
  Symbol (digest()) id (Just (mkStr id))

val fresh_fancy : maybe string -> sym
let fresh_fancy = function
  | Just str -> fresh_pretty str
  | Nothing  -> fresh ()
end
