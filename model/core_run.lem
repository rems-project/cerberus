
open import Pervasives String_extra Global Core Core_ctype Core_ctype_aux Core_aux Show Show_extra
import Set_extra (* Set_helpers *)
import State State_operators Loc
import Nondeterminism Exception Errors Undefined Exception_undefined State_exception_undefined Symbolic
import Cmm_csem Mem Mem_common Mem_aux
import AilSyntax AilTypes AilTypesAux
import Dlist

open import Implementation_ Decode

open import Thread Driver_util Core_run_aux Errors
(* import Output *)

(* TODO: tmp*) import Defacto_memory_types


open import Core_eval


module Caux = Core_aux


module Cmm = Cmm_csem


module U   = Undefined
(* module ND  = Nondeterminism *)
module EU  = Exception_undefined
module SEU = State_exception_undefined












val call_proc: Core.file core_run_annotation -> Symbol.sym -> list Core.value ->
               Exception.t (Core.expr core_run_annotation) core_run_error
let call_proc file psym cvals =
  let bTy_params_body_opt =
    match Map.lookup psym file.stdlib with
      | Just (Proc bTy params body) ->
          Just (bTy, params, body)
      | _ ->
          match Map.lookup psym file.funs with
            | Just (Proc bTy params body) ->
                Just (bTy, params, body)
            | _ ->
                Nothing
          end
    end in
  match bTy_params_body_opt with
    | Just (bTy, params, body) ->
        if List.length params <> List.length cvals then
          error $ "[Core_run.call_proc] wrong number of args applied to `" ^ show psym  ^ "' |args|=" ^
          show (List.length cvals) ^ "expecting: " ^ show (List.length params)

(* TODO[newLem] ^ Pp.pp_core_expr (Esym psym) ^ "'" *)
        else
          Exception.return (Global.foldl2 (fun acc (sym, _) cval -> subst_sym_expr sym (Pexpr bTy (PEval cval)) acc) body params cvals)
    | Nothing ->
        Exception.fail (Illformed_program ("calling an unknown procedure: " ^ show psym))
  end






let rec resolve_concur_sym sym concur_sym_map seen_syms =
  match Map.lookup sym concur_sym_map with
(* TODO CONCUR
  | Just (Vobject (OVsymbolic (Symbolic.SYMBsym _ sym'))) ->
        if List.elem sym' seen_syms then
          Nothing
        else
          resolve_concur_sym sym' concur_sym_map (sym' :: seen_syms)
*)
    | Just cval ->
        Just cval
    | Nothing ->
        Nothing
  end





(*
            match cval with
              | Vlist [] ->
                  
              | Vlist cvals ->
                  
              | Vtuple cvals ->

  | Vtuple of list value
  | Vctype of ctype
(*  | Vconst of Mem.mem_value *)
  | Vsymbolic of Symbolic.symbolic value Mem.pointer_value (* symbolicity coming from the concurrency *)
  
  | Vunspecified of ctype
  | Vinteger of Mem.integer_value
  | Vfloating of string
  | Vpointer of Mem.pointer_value
  | Varray of list value (* Mem.mem_value *)
  | Vstruct of Symbol.t * list (Cabs.cabs_identifier * Mem.mem_value)
  | Vunion of Symbol.t * Cabs.cabs_identifier * Mem.mem_value

(*
of pexpr * list (case_pattern * pexpr)

type case_pattern =
  | CaseBase of ctor * pattern
  | CaseCtor of ctor * list case_pattern
  | CaseWildcard
*)
*)

(* TODO
let rec lookup_case_pattern ctor = function
  | [] ->
      Nothing
  | (CaseBase ctor' pat, pe) :: cpat_pes' ->
      if ctor = ctor' then
        Just (pat, pe)
      else
        lookup_case_pattern ctor cpat_pes'
(*
  | (CaseCtor ctor' cpats, p) ->
      if ctor = ctor' then
        
*)
end
*)

val subst_syms_opt: list (maybe (Symbol.sym * Core.core_base_type)) -> list Core.value -> Core.pexpr -> Core.pexpr
let subst_syms_opt sym_ty_opts cvals pe =
  List.foldl (fun acc (sym_ty_opt, cval) ->
    maybe acc (fun (sym, bTy) -> subst_sym_pexpr sym (Pexpr bTy (PEval cval)) acc) sym_ty_opt
  ) pe (List.zip sym_ty_opts cvals)

(*
val     core_case: Core.value -> list (Core.case_pattern * Core.pexpr) -> maybe (Core.pexpr)
let rec core_case cval cpat_pes =
  match cval with
    | Vlist bTy [] ->
        match lookup_case_pattern (Cnil bTy) cpat_pes with
          | Just ([], body_pe) ->
              Just body_pe
          | Nothing ->
              Nothing
        end
    | Vlist bTy (cval'::cvals') ->
        match lookup_case_pattern (Ccons bTy) cpat_pes with
          | Just (pat, body_pe) ->
              Just (subst_syms_opt pat [cval'; Vlist bTy cvals'] body_pe)
          | Nothing ->
              Nothing
        end
(*
        
    | Vtuple cvals ->
        
*)
  end
*)


val     old_eval_pexpr: Loc.t -> Mem.mem_state -> Core.file core_run_annotation ->
                    map Symbol.sym Core.object_value -> bool -> Core.pexpr ->
                    EU.t Core.pexpr core_run_error
let rec old_eval_pexpr loc mem_st file concur_sym_map inside_if (Pexpr bTy _pe as pexpr) =
  match _pe with
    | PEsym sym ->
(*
        if inside_if then
          EU.return pexpr
        else
*)
          EU.fail $ Unresolved_symbol sym
  | PEimpl iCst ->
      match Map.lookup iCst file.impl with
        | Just (Def _ pe) ->
            EU.return pe
        | _ ->
            EU.fail Unknown_impl
      end
  | PEval _ ->
      EU.return pexpr

(*
    | PEconstrained xs ->
val     foldrM: forall 'a 'b 'msg. ('a -> 'b -> t 'b 'msg) -> 'b -> list 'a -> t 'b 'msg

      EU.foldrM (fun (cs, pe) acc ->
        old_eval_pexpr loc mem_st file concur_sym_map inside_if pe >>= function
          | PEval (Vconstrained xs')
        end
      ) xs >>= fun pes' ->
*)
    | PEundef ub ->
        Exception.return (Undefined.undef loc [ub])
    | PEerror str pe ->
        Exception.return (Undefined.error loc (str ^ " ==> " ^ Pp.stringFromCore_pexpr pe))


    | _ ->
        error "WIP: old_eval_pexpr"

(*

(*
  | (PEval (Vsymbolic (Symbolic.SYMBsym _ sym)) as pexpr) ->
      EU.return match resolve_concur_sym sym concur_sym_map [] with
        | Just cval ->
            PEval cval
        | Nothing ->
            let _ = Boot.print_debug 1 ("CORE_EVAL SYM FAILED: " ^ show sym) in
            pexpr
      end
*)
(*
TODO: CONCUR
  | (PEval (Vobject (OVsymbolic symb)) as pexpr) ->
      match Core_aux.pexprFromSymbolic concur_sym_map symb with
        | Just pe ->
            EU.return pe
        | Nothing ->
            EU.return pexpr
      end
*)

  | PEval _ ->
(* TODO:
    match expr with
      | Econst (Mem.MVinteger symb) ->
          EU.return match Symbolic.reduce symb with
            | Symbolic.SYMBtrue ->
                Etrue
            | Symbolic.SYMBfalse ->
                Efalse
            | symb' ->
                Econst (Mem.MVinteger symb')
          end
      | _ ->
          EU.return expr
    end
*)
      EU.return pexpr
  | PEsym sym ->
      if inside_if then
        EU.return pexpr
      else
        EU.fail $ Unresolved_symbol sym
  | PEimpl iCst ->
      match Map.lookup iCst file.impl with
        | Just (Def _ pe) ->
            EU.return pe
        | _ ->
            EU.fail Unknown_impl
      end
  
  | PEctor ctor pes ->
      EU.mapM (eval_pexpr loc mem_st file concur_sym_map inside_if) pes >>= fun pes' ->
      match (ctor, valueFromPexprs pes') with
        | (Cnil bTy, Just []) ->
            EU.return $ PEval (Vlist bTy [])
        | (Ccons, Just [cval1; Vlist bTy' cvals]) ->
            if bTy <> bTy' then
              EU.fail (Illformed_program "illtyped operand for Ccons")
            else
              EU.return $ PEval (Vlist bTy (cval1 :: cvals))
        | (Ctuple, Just cvals) ->
              EU.return $ PEval (Vtuple cvals)
(*
        | (Carray, Just [cval1; Vlist cvals]) ->
              EU.return $ PEval (Vlist (cval1 :: cvals))
*)
        | (Civmax, Just [Vctype ty]) ->
            match Core_ctype.unatomic ty with
              | (Core_ctype.Basic (AilTypes.Integer ity)) ->
                  EU.return $ PEval (Vobject (OVinteger (Mem.max_ival ity)))
              | _ ->
                  error ("Core_run ivmax" ^
                             Pp.stringFromCore_expr (Core.Epure (Core.Pexpr Core.BTy_ctype (Core.PEval (Vctype ty))) : Core.expr unit))
            end
        | (Civmin, Just [Vctype ty]) ->
            match Core_ctype.unatomic ty with
              | (Core_ctype.Basic (AilTypes.Integer ity)) ->
                  EU.return $ PEval (Vobject (OVinteger (Mem.min_ival ity)))
              | _ ->
                  error ("Core_run ivmin [" ^ Loc.stringFromLocation loc ^ "] ==> " ^
                             Pp.stringFromCore_expr (Core.Epure (Core.Pexpr Core.BTy_ctype (Core.PEval (Vctype ty))) : Core.expr unit))
            end
        | (Civsizeof, Just [Vctype ty]) ->
            EU.return $ PEval (Vobject (OVinteger (Mem.sizeof_ival ty)))
        | (Civalignof, Just [Vctype ty]) ->
            EU.return $ PEval (Vobject (OVinteger (Mem.alignof_ival ty)))

        | (Cunspecified, Just [Vctype ty]) ->
            EU.return $ PEval (Vunspecified ty)

        
        | (_, Just _) ->
            EU.fail $ Illformed_program ("PEctor: one of the operands was ill-typed ==> " (*^
                                         Pp.stringFromCore_expr (Epure (PEctor ctor pes') : Core.expr unit) *))
        | (_, Nothing) ->
            EU.return $ PEctor ctor pes'
      end

(*  
  | PEcase pe cpats =
      eval_pexpr loc mem_st file concur_sym_map inside_if pe >>= function ->
        | PEval cval ->
            match core_case cval cpats with
              | Just body_pe ->
                  EU.return body_pe'
              | Nothing ->
                  EU.fail $ Illformed_program "PEcase: first operand should be caseable"
            end
        | pe' ->
            EU.return $ PEcase pe' cpats
      end
*)






  
(*
TODO:
  | PEcase_list pe pe_nil nm_cons ->
      eval_pexpr loc mem_st file concur_sym_map inside_if pe >>= function
        | PEval (Vlist []) ->
            EU.return pe_nil
        | PEval (Vlist (cval::cvals)) ->
            EU.return $ PEcall nm_cons [PEval cval; PEval (Vlist cvals)]
        | PEval _ ->
            EU.fail $ Illformed_program "PEcase_list: first operand should be a list"
        | pe' ->
            EU.return $ PEcase_list pe' pe_nil nm_cons
      end
  | PEcase_ctype pe pe_void nm_basic nm_array nm_fun nm_ptr nm_atom nm_struct nm_union nm_builtin ->
      eval_pexpr loc mem_st file concur_sym_map inside_if pe >>= function
        | PEval (Vctype ty) ->
            match ty with
              | Void ->
                  EU.return pe_void
              | ((Basic _) as ty) ->
                  EU.return $ PEcall nm_basic [PEval (Vctype ty)]
              | Array elem_ty (Just n) ->
                  EU.return $ PEcall nm_array [PEval (Vctype elem_ty); PEval (Vobject (OVinteger (Mem.integer_ival n)))]
              | Array _ Nothing ->
                  error "WIP: Core_run.eval_pexpr PEcase_ctype, Array Nothing"
              | Function return_ty qs_tys is_variadic ->
                  (* TODO: qualifiers *)
                  EU.return $ PEcall nm_fun [PEval (Vctype return_ty);
                                             PEval (Vlist $ List.map (fun (_, ty) -> Vctype ty) qs_tys);
                                             PEval (if is_variadic then Vtrue else Vfalse)]
              | Pointer _ ref_ty ->
                  (* TODO: qualifiers *)
                  EU.return $ PEcall nm_ptr [PEval (Vctype ref_ty)]
              | Atomic ty ->
                  EU.return $ PEcall nm_atom [PEval (Vctype ty)]
              | Struct tag ->
                  match Map.lookup tag (tagDefs ()) with
                    | Just ident_tys ->
                        (* TODO: identifiers *)
                        EU.return $ PEcall nm_struct [PEval (Vlist $ List.map (fun (_, ty) -> Vctype ty) ident_tys)]
                    | Nothing ->
                        EU.fail $ Illformed_program ("couldn't find definition of tag: " ^ show tag)
                  end
              | Union tag ->
                  match Map.lookup tag (tagDefs ()) with
                    | Just ident_tys ->
                        (* TODO: identifiers *)
                        EU.return $ PEcall nm_union [PEval (Vlist $ List.map (fun (_, ty) -> Vctype ty) ident_tys)]
                    | Nothing ->
                        EU.fail $ Illformed_program ("couldn't find definition of tag: " ^ show tag)
                  end
              | Builtin str ->
                  error "WIP: Core_run.eval_pexpr PEcase_ctype, Builtin"
            end
        | PEval _ ->
            EU.fail $ Illformed_program "PEcase_ctype: first operand should be a ctype"
        | pe' ->
            EU.return $ PEcase_ctype pe' pe_void nm_basic nm_array nm_fun nm_ptr nm_atom nm_struct nm_union nm_builtin
      end
*)

  | PEarray_shift pe1 ty pe2 ->
      eval_pexpr loc mem_st file concur_sym_map inside_if pe1 >>= fun pe1' ->
      eval_pexpr loc mem_st file concur_sym_map inside_if pe2 >>= fun pe2' ->
      match (pe1', pe2') with
        | (PEval (Vobject (OVpointer ptr_val)), PEval (Vobject (OVinteger ival))) ->
            EU.return $ PEval (Vobject (OVpointer (Mem.array_shift_ptrval ptr_val ty ival)))
        | (PEval _, PEval _) ->
            EU.fail $ Illformed_program ("PEarray_shift: type error ==> " ^ Pp.stringFromCore_expr (Epure (PEarray_shift pe1' ty pe2') : Core.expr unit))
        | _ ->
            EU.return $ PEarray_shift pe1' ty pe2'
      end
  
  | PEmember_shift pe tag_sym memb_ident ->
      eval_pexpr loc mem_st file concur_sym_map inside_if pe >>= function
        | PEval (Vobject (OVpointer ptr_val)) ->
            EU.return $ PEval (Vobject (OVpointer (Mem.member_shift_ptrval ptr_val tag_sym memb_ident)))
        | PEval (Vobject (OVsymbolic symb)) ->
            EU.return $ PEval (Vobject (OVsymbolic (Symbolic.SYMBmember_shift symb tag_sym memb_ident)))
        | (PEval _ as pe') ->
            EU.fail $ Illformed_program ("PEmember_shift: type error ==> " ^ Pp.stringFromCore_expr (Epure (PEmember_shift pe' tag_sym memb_ident) : Core.expr unit))
        | pe' ->
            EU.return $ PEmember_shift pe' tag_sym memb_ident
      end

  | PEnot pe ->
      eval_pexpr loc mem_st file concur_sym_map inside_if pe >>= function
        | PEval Vtrue ->
            EU.return $ PEval Vfalse
        | PEval Vfalse ->
            EU.return $ PEval Vtrue
        | PEval (Vobject (OVsymbolic symb)) ->
            EU.return $ PEval (Vobject (OVsymbolic (Symbolic.SYMBnot symb)))
        | PEval _ ->
            EU.fail $ Illformed_program "PEnot: operand should be a boolean"
        | pe' ->
            EU.return $ PEnot pe'
      end
  
  | PEop binop pe1 pe2 ->
      eval_pexpr loc mem_st file concur_sym_map inside_if pe1 >>= fun pe1' ->
      eval_pexpr loc mem_st file concur_sym_map inside_if pe2 >>= fun pe2' ->
      match (binop, valueFromPexpr pe1', valueFromPexpr pe2') with
        (* Ctype equality *)
        | (OpEq, Just (Vctype ty1), Just (Vctype ty2)) ->
            EU.return $ PEval (if ty1 = ty2 then Vtrue else Vfalse)
        
        (* Integer equality *)
        | (OpEq, Just (Vobject (OVinteger ival1)), Just (Vobject (OVinteger ival2))) ->
            match Mem.eq_ival mem_st Symbolic.Constraints_TODO ival1 ival2 with
              | Just b ->
                  EU.return (PEval (if b then Vtrue else Vfalse))
              | Nothing ->
                  (* the current constraints allow both outcomes *)
                  error ("WIP: symbolic integer_value equality ==> " ^ Pp.stringFromCore_expr ((Epure (PEop binop pe1' pe2')) : Core.expr unit))
            end
        
        (* NOTE: this is for the concurrency *)
        | (OpEq, Just (Vobject (OVsymbolic symb1)), Just (Vobject oval2)) ->
            EU.return (PEval (Vobject (OVsymbolic (Symbolic.make_op Symbolic.Eq symb1 (Symbolic.SYMBconst oval2)))))


        | (OpLt, Just (Vobject (OVinteger ival1)), Just (Vobject (OVinteger ival2))) ->
            match Mem.lt_ival Symbolic.Constraints_TODO ival1 ival2 with
              | Just b ->
                  EU.return (PEval (if b then Vtrue else Vfalse))
              | Nothing ->
                  (* the current constraints allow both outcomes *)
                  error ("WIP: symbolic integer_value less-than ==> " ^
                         Pp.stringFromCore_expr ((Epure (PEop binop pe1' pe2')) : Core.expr unit))
            end
        
        | (OpLe, Just (Vobject (OVinteger ival1)), Just (Vobject (OVinteger ival2))) ->
            match Mem.le_ival Symbolic.Constraints_TODO ival1 ival2 with
              | Just b ->
                  EU.return (PEval (if b then Vtrue else Vfalse))
              | Nothing ->
                  (* the current constraints allow both outcomes *)
                  error ("WIP: symbolic integer_value less_equal-than ==> " ^
                         Pp.stringFromCore_expr ((Epure (PEop binop pe1' pe2')) : Core.expr unit))
            end
        
        | (OpGe, Just (Vobject (OVinteger ival1)), Just (Vobject (OVinteger ival2))) ->
            (* TODO CHECK *)
            match Mem.le_ival Symbolic.Constraints_TODO ival2 ival1 with
              | Just b ->
                  EU.return (PEval (if b then Vtrue else Vfalse))
              | Nothing ->
                  (* the current constraints allow both outcomes *)
                  error ("WIP: symbolic integer_value greater_equal-than ==> " ^
                         Pp.stringFromCore_expr ((Epure (PEop binop pe1' pe2')) : Core.expr unit))
            end
        
        | (OpGt, Just (Vobject (OVinteger ival1)), Just (Vobject (OVinteger ival2))) ->
            (* TODO CHECK *)
            match Mem.lt_ival Symbolic.Constraints_TODO ival2 ival1 with
              | Just b ->
                  EU.return (PEval (if b then Vtrue else Vfalse))
              | Nothing ->
                  (* the current constraints allow both outcomes *)
                  error ("WIP: symbolic integer_value greater-than ==> " ^
                         Pp.stringFromCore_expr ((Epure (PEop binop pe1' pe2')) : Core.expr unit))
            end
        
        | (_, Just (Vobject (OVinteger ival1)), Just (Vobject (OVinteger ival2))) ->
            let iop = match binop with
              | OpAdd ->
                  Mem_common.IntAdd
              | OpSub ->
                  Mem_common.IntSub
              | OpMul ->
                  Mem_common.IntMul
              | OpDiv ->
                  Mem_common.IntDiv
              | OpRem_t ->
                  Mem_common.IntRem_t
              | OpRem_f ->
                  Mem_common.IntRem_f
              | OpExp ->
                  Mem_common.IntExp
              | _ ->
                  error ("Core_run.eval_pexpr, PEop Vinteger Vinteger: " ^ show binop)
            end in
            EU.return (PEval (Vobject (OVinteger (Mem.op_ival iop ival1 ival2))))



        | (OpAnd, Just v1, Just v2) ->
            match (v1, v2) with
              | (Vtrue, Vtrue) ->
                  EU.return $ PEval Vtrue
              | (Vtrue, Vfalse) ->
                  EU.return $ PEval Vfalse
              | (Vfalse, Vtrue) ->
                  EU.return $ PEval Vfalse
              | (Vfalse, Vfalse) ->
                  EU.return $ PEval Vfalse
              | _ ->
                  EU.fail $ Illformed_program ("PEop OpAnd: the two operands should be booleans ==> " ^
                                               Pp.stringFromCore_expr ((Epure (PEop binop pe1' pe2')) : Core.expr unit))
            end
        | (OpOr, Just v1, Just v2) ->
            match (v1, v2) with
              | (Vtrue, Vtrue) ->
                  EU.return $ PEval Vtrue
              | (Vtrue, Vfalse) ->
                  EU.return $ PEval Vtrue
              | (Vfalse, Vtrue) ->
                  EU.return $ PEval Vtrue
              | (Vfalse, Vfalse) ->
                  EU.return $ PEval Vfalse
              | _ ->
                  EU.fail $ Illformed_program ("PEop OpOr: the two operands should be booleans ==> " ^
                                               Pp.stringFromCore_expr ((Epure (PEop binop pe1' pe2')) : Core.expr unit))
            end

(* TODO: symbolics *)
        | (_, Just (Vobject (OVsymbolic symb)), Just (Vobject (OVinteger ival as oval))) ->
            let n = match Mem_aux.integerFromIntegerValue ival with
              | Just n ->
                  n
              | Nothing ->
                  error "Core_run.eval_pexpr PEop: symbolic vs non-trivial ival"
            end in
            let sym_op = match binop with
              | OpAdd ->
                  Symbolic.Add
              | OpSub ->
                  Symbolic.Sub
              | OpMul ->
                  Symbolic.Mul
              | OpDiv ->
                  Symbolic.Div
              | OpRem_t ->
                  Symbolic.Rem_t
              | OpRem_f ->
                  Symbolic.Rem_f
              | _ ->
                  error "Core_run.eval_pexpr, PEop Vsymbolic Vinteger sym_op match"
            end in
            EU.return (PEval (Vobject (OVsymbolic (Symbolic.make_op sym_op symb (Symbolic.SYMBconst oval)))))

        | (_, Just (Vobject (OVinteger ival as oval)), Just (Vobject (OVsymbolic symb))) ->
            let n = match Mem_aux.integerFromIntegerValue ival with
              | Just n ->
                  n
              | Nothing ->
                  error "Core_run.eval_pexpr PEop: non-trivial ival vs symbolic"
            end in
            let sym_op = match binop with
              | OpAdd ->
                  Symbolic.Add
              | OpSub ->
                  Symbolic.Sub
              | OpMul ->
                  Symbolic.Mul
              | OpDiv ->
                  Symbolic.Div
              | OpRem_t ->
                  Symbolic.Rem_t
              | OpRem_f ->
                  Symbolic.Rem_f
              | _ ->
                  error "Core_run.eval_pexpr, PEop Vinteger Vsymbolic sym_op match"
            end in
            EU.return (PEval (Vobject (OVsymbolic (Symbolic.make_op sym_op symb (Symbolic.SYMBconst oval)))))

        | (_, Just (Vobject (OVsymbolic symb1)), Just (Vobject (OVsymbolic symb2))) ->
            let sym_op = match binop with
              | OpAdd ->
                  Symbolic.Add
              | OpSub ->
                  Symbolic.Sub
              | OpMul ->
                  Symbolic.Mul
              | OpDiv ->
                  Symbolic.Div
              | OpRem_t ->
                  Symbolic.Rem_t
              | OpRem_f ->
                  Symbolic.Rem_f
              | OpLt ->
                  Symbolic.Lt
              | _ ->
                  error "Core_run.eval_pexpr, PEop Vsymbolic Vsymbolic sym_op match"
            end in
            EU.return (PEval (Vobject (OVsymbolic (Symbolic.make_op sym_op symb1 symb2))))
        | (_, Just _, Just _) ->
            EU.fail $ Illformed_program ("[" ^ Loc.stringFromLocation loc ^ "] ill-typed PEop: " ^
                                         Pp.stringFromCore_expr ((Epure (PEop binop pe1' pe2')) : Core.expr unit))
        | _ ->
            EU.return $ PEop binop pe1' pe2'
      end

(*


      | Eop binop pe1 pe2 ->
          eval_pexpr file inside_if pe1 >>= fun pe1' ->
          eval_pexpr file inside_if pe2 >>= fun pe2' ->
          if is_value pe1' && is_value pe2' then
            match (binop, pe1', pe2') with
                
                | (OpEq, Econst (Mem.MVinteger symb1), Econst (Mem.MVinteger symb2)) ->
                    match Symbolic.try_eq symb1 symb2 with
                      | Left true ->
                          EU.return Etrue
                      | Left false ->
                          EU.return Efalse
                      | Right (symb1', symb2') ->
                          EU.return (Econst (Mem.MVinteger (Symbolic.make_op Symbolic.Eq symb1' symb2')))
                    end

                | (OpLt, Econst (Mem.MVinteger symb1), Econst (Mem.MVinteger symb2)) ->
                    match Symbolic.try_lt symb1 symb2 with
                      | Left true ->
                          EU.return Etrue
                      | Left false ->
                          EU.return Efalse
                      | Right (symb1', symb2') ->
                          EU.return (Econst (Mem.MVinteger (Symbolic.make_op Symbolic.Lt symb1' symb2')))
                    end


(* TODO: check *)
                | (OpAdd, Econst (Mem.MVinteger symb1), Econst (Mem.MVinteger symb2)) ->
                    EU.return (Econst (Mem.MVinteger (Symbolic.make_op Symbolic.Add symb1 symb2)))
                | (OpSub, Econst (Mem.MVinteger symb1), Econst (Mem.MVinteger symb2)) ->
                    EU.return (Econst (Mem.MVinteger (Symbolic.make_op Symbolic.Sub symb1 symb2)))
                | (OpMul, Econst (Mem.MVinteger symb1), Econst (Mem.MVinteger symb2)) ->
                    EU.return (Econst (Mem.MVinteger (Symbolic.make_op Symbolic.Mul symb1 symb2)))
                | (OpDiv, Econst (Mem.MVinteger symb1), Econst (Mem.MVinteger symb2)) ->
                    EU.return (Econst (Mem.MVinteger (Symbolic.make_op Symbolic.Div symb1 symb2)))
                | (OpMod, Econst (Mem.MVinteger symb1), Econst (Mem.MVinteger symb2)) ->
                    EU.return (Econst (Mem.MVinteger (Symbolic.make_op Symbolic.Mod symb1 symb2)))


                | (op, Econst (Mem.MVinteger symb1), Econst (Mem.MVinteger symb2)) ->
                    let op = match op with
                      | OpAdd -> Symbolic.Add
                      | OpSub -> Symbolic.Sub
                      | OpMul -> Symbolic.Mul
                      | OpDiv -> Symbolic.Div
                      | OpMod -> Symbolic.Mod
                      | OpExp -> Symbolic.Exp
                      | OpEq  -> Symbolic.Eq
                      | OpLt  -> Symbolic.Lt
                      | OpAnd -> Symbolic.And
                      | OpOr  -> Symbolic.Or
                    end in
                    EU.return (Econst (Mem.MVinteger (Symbolic.make_op op symb1 symb2)))
*)
(*
| PEmemop of Mem.memop * list pexpr
*)
(*
KKK NOW

  | PEmemop memop pes ->
      EU.mapM (eval_pexpr file inside_if) pes >>= fun pes' ->
      match (memop, valueFromPexprs pes') with
        | (Ptreq, Just [Vpointer ptr_val1; Vpointer ptr_val2]) ->
              match Mem.eq_ptrval (* TODO *)Symbolic.Constraints_TODO ptr_val1 ptr_val2 with
                | Just b ->
                    EU.return $ PEval (if b then Vtrue else Vfalse)
                | Nothing ->
                    error "TODO: symbolic case for pointer equality"
              end
        | (IntFromPtr, Just [Vctype ref_ty; Vctype ty; Vpointer ptr_val]) ->
            EU.return $
              PEval (Vinteger (Mem.intcast_ptrval ref_ty ty ptr_val))
        | (PtrFromInt, Just [Vctype ty; Vctype ref_ty; Vinteger ival]) ->
            EU.return $
              PEval (Vpointer (Mem.ptrcast_ival ty ref_ty ival))

        | (PtrValidForDeref, Just [Vpointer ptr_val]) ->
            EU.return $ PEval
              (if Mem.validForDeref_ptrval ptr_val then
                Vtrue
              else
                Vfalse)

        
        | (_, Just _) ->
            error "WIP: Core_run.eval_pexpr PEmemop _"
        
        | (_, Nothing) ->
            EU.return $ PEmemop memop pes'
      end
(*
  | Ptreq
  | Ptrdiff     (* (address, address) -> integer *)
  | PtrLt
*)
*)
(*
  | PEis_unspec pe ->
      eval_pexpr loc mem_st file concur_sym_map inside_if pe >>= function
        | PEval (Vunspecified _) ->
            EU.return $ PEval Vtrue
        | PEval _ ->
            EU.return $ PEval Vfalse
        | pe' ->
            EU.return $ PEis_unspec pe'
      end
  
  | PEtuple pes ->
      EU.mapM (eval_pexpr loc mem_st file concur_sym_map inside_if) pes >>= fun pes' ->
      EU.return $ match valueFromPexprs pes' with
        | Just cvals ->
            PEval (Vtuple cvals)
        | Nothing ->
            PEtuple pes'
      end
*)
(*
TODO: 
  | PEarray pes ->
      EU.mapM (eval_pexpr loc mem_st file concur_sym_map inside_if) pes >>= fun pes' ->
      match valueFromPexprs pes' with
        | Just cvals ->
            EU.return $ PEval (Vobject (OVarray cvals))
(*
            maybe (EU.fail $ Illformed_program ("PEarray: found a symbol during evaluation> " ^ Pp.stringFromCore_expr (Epure (PEarray pes') : expr unit)))
              (fun mem_vals -> EU.return $ PEval (Varray mem_vals)) $
            List.foldr (fun cval acc_opt ->
              match (memValueFromValue cval, acc_opt) with
                | (Just mem_val, Just acc) ->
                    Just (mem_val :: acc)
                | _ ->
                    Nothing
              end) (Just []) cvals
*)
        | Nothing ->
            EU.return $ PEarray pes'
      end
*)
(*
  | PEarray xs ->
      maybe (EU.fail $ Illformed_program "PEarray: found a symbol during evaluation")
            (fun vs -> EU.return $ PEval (Varray vs)) $
        List.foldr (fun xs acc_opt ->
          match (xs, acc_opt) with
            | (Left mem_val, Just acc) ->
                Just (mem_val :: acc)
            | _ ->
                Nothing
          end) (Just []) xs
*)
  | PEcall nm_bTy pe_bTys ->
      EU.mapM (fun (pe, bTy) -> eval_pexpr loc mem_st file concur_sym_map inside_if pe >>= fun pe' -> EU.return (pe', bTy)) pe_bTys >>= fun pe_bTys' ->
      match valueFromPexprs (List.map fst pe_bTys') with
        | Just cvals ->
            if List.all Core_aux.is_concrete cvals then
              (* We do not immediately call eval on the result of call_function,
                 as that could lead to non-termination. *)
              Exception.bind (call_function file (fst nm_bTy) cvals)
                EU.return
            else
              let symb_nm = match fst nm_bTy with
                | Sym f -> Symbolic.SYMBfsym f
                | Impl i -> Symbolic.SYMBimpl i
              end in
              EU.return $ PEval (Vobject (OVsymbolic (Symbolic.make_call symb_nm (List.map symbolify cvals))))
        | Nothing ->
            EU.return $ PEcall nm_bTy pe_bTys'
      end
  | PElet ((sym, _) as pat) pe1 pe2 ->
      eval_pexpr loc mem_st file concur_sym_map inside_if pe1 >>= fun pe1' ->
      EU.return $ match valueFromPexpr pe1' with
        | Just cval ->
            subst_sym_pexpr sym (PEval cval) pe2
        | Nothing ->
            PElet pat pe1' pe2
      end
  | PEif pe1 pe2 pe3 ->
      eval_pexpr loc mem_st file concur_sym_map inside_if pe1 >>= fun pe1' ->
      match valueFromPexpr pe1' with
        | Just Vtrue ->
            eval_pexpr loc mem_st file concur_sym_map inside_if pe2
        | Just Vfalse ->
            eval_pexpr loc mem_st file concur_sym_map inside_if pe3

        | Just (Vobject (OVsymbolic symb)) ->
            eval_pexpr loc mem_st file concur_sym_map inside_if pe2 >>= fun pe2' ->
            eval_pexpr loc mem_st file concur_sym_map inside_if pe3 >>= fun pe3' ->
            EU.return $ match (valueFromPexpr pe2', valueFromPexpr pe3') with
              | (Just cval2, Just cval3) ->
                  PEval (Vobject (OVsymbolic (Symbolic.make_ite symb (symbolify cval2) (symbolify cval3))))
              | _ ->
                  PEif pe1' pe2' pe3'
            end
            

        | Just _ ->
            EU.fail $ Illformed_program "PEif: first operand should be a boolean"
        | Nothing ->
            EU.return $ PEif pe1' pe2 pe3
      end
  | PEis_scalar pe ->
      eval_pexpr loc mem_st file concur_sym_map inside_if pe >>= fun pe' ->
      match valueFromPexpr pe' with
        | Just (Vctype ty) ->
            EU.return $ PEval (if AilTypesAux.is_scalar (unproj_ctype ty) then Vtrue else Vfalse)
        | Just _ ->
            EU.fail $ Illformed_program "PEis_scalar: operand should be a ctype"
        | _ ->
            EU.return $ PEis_scalar pe'
      end
  | PEis_integer pe ->
      eval_pexpr loc mem_st file concur_sym_map inside_if pe >>= fun pe' ->
      match valueFromPexpr pe' with
        | Just (Vctype ty) ->
            EU.return $ PEval (if AilTypesAux.is_integer (unproj_ctype ty) then Vtrue else Vfalse)
        | Just _ ->
            EU.fail $ Illformed_program "PEis_integer: operand should be ctype"
        | _ ->
            EU.return $ PEis_integer pe'
      end
  | PEis_signed pe ->
      eval_pexpr loc mem_st file concur_sym_map inside_if pe >>= fun pe' ->
      match valueFromPexpr pe' with
        | Just (Vctype ty) ->
            EU.return $ PEval (if AilTypesAux.is_signed_integer_type (unproj_ctype ty) then Vtrue else Vfalse)
        | Just _ ->
            EU.fail $ Illformed_program "PEis_signed: operand should be a ctype"
        | Nothing ->
            EU.return $ PEis_signed pe'
      end
  | PEis_unsigned pe ->
      eval_pexpr loc mem_st file concur_sym_map inside_if pe >>= fun pe' ->
      match valueFromPexpr pe' with
        | Just (Vctype ty) ->
            EU.return $ PEval (if AilTypesAux.is_unsigned_integer_type (unproj_ctype ty) then Vtrue else Vfalse)
        | Just _ ->
            EU.fail $ Illformed_program "PEis_unsigned: operand should be a ctype"
        | Nothing ->
            EU.return $ PEis_unsigned pe'
end

  | PEstruct tag_sym xs ->
      EU.mapM (fun (ident, pe) -> eval_pexpr loc mem_st file concur_sym_map inside_if pe) xs >>= fun pes' ->
      match valueFromPexprs pes' with
        | Just cvals ->
            let xs' = List.map (fun ((ident, ty), cval) ->
              (ident, fromJust ("Core_run.eval_pexpr, PEstruct ==> " ^ show ident) $ memValueFromValue ty cval)
            ) (List.zip (Core_ctype_aux.get_membersDefs tag_sym) cvals) in
            EU.return $ PEval (Vobject (OVstruct tag_sym xs'))
        | Nothing ->
            EU.return $ PEstruct tag_sym (List.zip (List.map fst xs) pes')
      end
      
  | _ ->
    error (">>> " ^ Pp.stringFromCore_expr (Epure (Pexpr bTy _pe) : expr unit))

*)
end



(*
      (* TODO: think about this *)
      | Eshift pe sh_path ->
          match pe with
            | Econst mem_val ->
                match Mem.ptr_from_mem_value mem_val with
                  | Just ptr_val ->
                      (* evaluating the shift_path indices, which must be pure integer expressions *)
                      EU.mapM (fun (ty, sh_pe) ->
                        eval_pexpr file inside_if sh_pe >>= fun sh_pe' ->
                        EU.return (ty, sh_pe')
                      ) sh_path >>= fun sh_path' ->
                      if List.all (fun (_, pe) -> is_value pe) sh_path' then
                        
                        (* TODO: this is partial, and fails on ill-typed paths *)
                        let sh_path' = List.map (fun (ty, Econst mem_val) ->
                          match Mem.symb_from_mem_value mem_val with
                            | Just symb ->
                                (ty, symb)
                            | Nothing ->
                                error $ "Eshift, something wrong inside a path: " ^ Pp.stringFromCore_expr (Eshift pe sh_path)
                          end
                        ) sh_path' in
                        
                        EU.return $
                          Econst (Mem.mk_pointer (Mem.shift_ptrval ptr_val sh_path'))
                      else
                        EU.return (Eshift pe sh_path')
                  | Nothing ->
                      EU.fail (Illformed_program "Eshift: first operand was a non-pointer memory value")
                end
            | _ ->
                if is_value pe then
                  EU.fail (Illformed_program "Eshift: first operand didn't reduce to an Econst")
                else
                  eval_pexpr file inside_if pe >>= fun pe' ->
                  EU.return (Eshift pe' sh_path)
          end
(*
          eval_pexpr file inside_if pe >>= function
            (* TODO: shouldn't break the abstraction of Mem like that ... *)
            | Econst (Mem.MVpointer ptr_val) ->
                (* evaluating the shift_path indices, which must be pure integer expressions *)
                EU.mapM (fun (ty, pe) ->
                  EU.bind (eval_pexpr file inside_if pe) (fun pe' ->
                  EU.return (ty, pe'))
                ) >>= fun sh_path' ->


                error "WIP: EU.return $ Econst (Mem.mk_pointer (Mem.shift_ptrval ptr_val sh_path))"
(*
(Mem.mk_pointer (
                  match path with
                    | ShiftArray n ->
                        Mem.Pointer_shift ptr_val n
                    | ShiftMember tag_sym ident ->
                        Mem.Pointer_memberof ptr_val tag_sym ident
                  end
                )))
*)
            | pe' ->
                if is_value pe' then
                  EU.fail (Illformed_program "ill-typed Eshift")
                else
                  EU.return (Eshift pe' sh_path)
          end

*)
    
      
      
(*
      | Eif pe1 pe2 pe3 ->
        eval_pexpr file inside_if pe1 >>= function
          | Etrue ->
              eval_pexpr file inside_if pe2
          | Efalse ->
              eval_pexpr file inside_if pe3
          | (Econst (Mem.MVinteger symb) as pe1') ->
              if is_value pe2 then
                if is_value pe3 then
                  match (pe2, pe3) with
                    | (Econst (Mem.MVinteger symb2), Econst (Mem.MVinteger symb3)) ->
                        EU.return (Econst (Mem.MVinteger (Symbolic.make_ite symb symb2 symb3)))
                    | _ ->
                        EU.fail (Illformed_program "ill-typed Eif")
                  end
                else
                  eval_pexpr file inside_if pe2 >>= fun pe2' ->
                  EU.return (Eif pe1' pe2' pe3)
              else
                  eval_pexpr file inside_if pe3 >>= fun pe3' ->
                  EU.return (Eif pe1' pe2 pe3')
          | pe1' ->
              if is_value pe1' then
                EU.fail (Illformed_program "ill-typed Eif")
              else
                EU.return (Eif pe1' pe2 pe3)
        end
*)
      
| e ->
    error (">>> " ^ Pp.stringFromCore_expr e)
end


*)






(* DEBUG *)
type exec_location =
  | ELoc_globals
  | ELoc_normal of list Symbol.sym

let push_exec_loc sym = function
  | ELoc_globals ->
      ELoc_normal [sym]
  | ELoc_normal syms ->
      ELoc_normal (sym :: syms)
end

type thread_state = <|
  arena:  expr core_run_annotation;
(*  arenas:  list (expr core_run_annotation); *)
  stack:  stack core_run_annotation;
  labels: map ksym (list (sym * ctype) * expr core_run_annotation);
  
  current_loc: Loc.t; (* DEBUG *)
  exec_loc: exec_location; (* DEBUG *)
|>


(* TODO: more *)
type io_state = <|
  stdout: Dlist.dlist string;
|>

type core_state = <|
  thread_states: list (thread_id * (maybe thread_id * thread_state)); (* the associated tid is that of the parent thread *)
  io:            io_state;
(*  handlers:      Map.map handler_event (list name); *)
|>

(*
let core_state_eq core_st1 core_st2 =
  (* TODO: IO and handlers *)
  core_st1 

instance (Eq core_state)
  let (=) = core_state_eq
  let (<>) = fun x y -> not (core_state_eq x y)
end
*)


let string_of_thread_state th_st =
  "Arena= " ^ Pp.stringFromCore_expr th_st.arena ^ "\nStack= " ^ Pp.stringFromCore_stack th_st.stack ^ "\n"
(*
  List.foldr (fun (n, arena) acc ->
    "Arena[" ^ show n ^ "]= " ^ Pp.stringFromCore_expr arena
  ) ("Stack= " ^ "TODO" ^ "\n") (numerote th_st.arenas)
*)

let string_of_core_state core_st =
  List.foldr (fun (tid, (parent_tid_opt, th_st)) acc ->
    "Thread " ^ show tid ^ (maybe "" (fun z -> "(spawn of thread " ^ show z ^ ")") parent_tid_opt) ^ "\n" ^
    string_of_thread_state th_st ^
    "-----------------------------\n\n" ^ acc
  ) "" core_st.thread_states


instance (Show core_state)
  let show = string_of_core_state
end




type core_run_state = <|
  tid_supply:    UniqueId.supply thread_id;
  symbol_supply: UniqueId.supply Symbol.sym;
  aid_supply:    UniqueId.supply action_id;
  
  (* DEBUG *)
  step_counter: nat;
|>




(* Monad of the core evaluator (State + Exception + Undefined) *)
type core_runM 'a = SEU.t 'a core_run_state core_run_error




val increment_step_counter: core_runM unit
let increment_step_counter =
  SEU.runS (
    State.update (fun run_st ->
      <| run_st with step_counter= run_st.step_counter + 1 |>
    )
  )




(* TODO: this is instanciated to Naive_memory *)
(*
val runMem: forall 'a. Mem.memM 'a -> core_runM 'a
let runMem m =
  SEU.runS (
    State.modify (fun run_st ->
      match SEU.run m run_st.layout_state with
        | Exception.Result (Undefined.Defined z, mem_st') ->
(*            let _ = Boot.output_string ("AFTER2> " ^ show mem_st') in *)
            (z, <| run_st with layout_state= mem_st' |>)

        | Exception.Result (Undefined.Undef ubs, mem_st') ->
            error "Core_run.runMem undef"
        
        | Exception.Result (Undefined.Error str, mem_st') ->
            error ("Core_run.runMem error: " ^ str)
        
        | Exception.Exception err ->
            let str = match err with
              | Mem.MerrUnitialised _ ->
                  "MerrUnitialised"
              | Mem.MerrInternal str ->
                  "(MerrInternal '" ^ str ^ "'"
              | Mem.MerrOther str ->
                  "(MerrOther '" ^ str ^ "'"
            end in
            error ("Core_run.runMem other: " ^ str)
      end
    )
  )
*)
(*
val liftMem: forall 'a. Mem.memM 'a -> core_runM 'a
let liftMem m =
  SEU.runS (
    State.modify (fun run_st ->
      match Mem.runMem m run_st.layout_state with
        | Left err ->
            error "ERROR in memory model layout"
        | Right (z, mem_st') ->
            (z, <| run_st with layout_state= mem_st' |>)
      end
    )
  )
*)

(*
type action_request =
  (* RequestName  of sbBefore * ddBefore * aswBefore
                     parameters of request *
                     the new state or a callback *)
  | AllocRequest  of set action_id * set action_id * set action_id *
                     action_id * thread_id * Symbol.prefix * Mem.integer_value * Mem.integer_value *
                     (Mem.pointer_value -> core_state)
  
  | CreateRequest of set action_id * set action_id * set action_id *
                     action_id * thread_id * Symbol.prefix * Mem.integer_value * ctype *
                     (Mem.pointer_value -> core_state)
  
  | LoadRequest   of set action_id * set action_id * set action_id * 
                     (* the request provide a fresh symbolic name to be used by the concurrency if needed *)
                     action_id * thread_id * Cmm.memory_order * ctype * Mem.pointer_value * Symbol.t *
                     (* the argument of the callback is either a concrete value if the memory model
                        is able to give one right away, or is equal to the symbolic value provided by the
                        present LoadRequest *)
                     (Mem.mem_value -> core_state)

  | StoreRequest  of set action_id * set action_id * set action_id *
                     action_id * thread_id * Cmm.memory_order * ctype * Mem.pointer_value * Mem.mem_value *
                     core_state

(*
  | LockRequest   of set action_id * set action_id * set action_id *
                     action_id * thread_id * Mem.pointer_value * location_kind *
                     (lock_outcome -> SEU.t thread_state Symbol.counter core_run_error)

  | UnlockRequest of set action_id * set action_id * set action_id * 
                     action_id * thread_id * Mem.pointer_value * location_kind *
                     (SEU.t thread_state Symbol.counter core_run_error)

  | RmwRequest    of set action_id * set action_id * set action_id *
                     action_id * thread_id * Cmm.memory_order * Mem.pointer_value * location_kind * Mem.mem_value *
                     (Mem.mem_value -> SEU.t thread_state Symbol.counter core_run_error)

  | FenceRequest  of set action_id * set action_id * set action_id *
                     action_id * thread_id * Cmm.memory_order *
                     (SEU.t thread_state Symbol.counter core_run_error)
*)
*)


(*
type pointer_request =
(*
  | PtrEqRequest 
  | PtrNeRequest 
*)
  | PtrShiftRequest of ctype * Mem.pointer_value * Symbolic.symbolic (* integer value *) *
                       (Core.expr core_run_annotation -> core_state)
*)








(*
val update_thread_state: thread_id -> thread_state -> core_state -> Exception.t core_state core_run_error
let update_thread_state tid th_st st =
  Exception.bind match List.lookup tid st.thread_states with
    | Just z ->
        Exception.return z
    | Nothing ->
        Exception.fail (Illformed_program "trying to update the state of a non existing thread")
  end (fun (parent_tid_opt, _) ->
    Exception.return <| st with thread_states= assoc_insert tid (parent_tid_opt, th_st) st.thread_states |>
  )
*)

val register_handler: core_state -> core_state
let register_handler st =
  error "WIP: register_handler"

val update_thread_state: thread_id -> thread_state -> core_state -> core_state
let update_thread_state tid th_st st =
  let f (parent_tid_opt, _) = (parent_tid_opt, th_st) in
  <| st with thread_states= assoc_adjust f tid st.thread_states |>


val spawn_thread: maybe thread_id -> thread_state -> core_state -> State.t (thread_id * core_state) core_run_state
let spawn_thread parent_tid_opt th_st st =
  State.modify (fun run_st ->
    let (tid, tid_suppl') = UniqueId.fresh_id run_st.tid_supply in
    ((tid, <| st with thread_states= assoc_insert tid (parent_tid_opt, th_st) st.thread_states |>),
     <| run_st with tid_supply= tid_suppl' |>)
  )


val kill_thread: thread_id -> thread_id -> set action_id -> Core.value -> core_state -> core_state
let kill_thread tid parent_tid aswBefores v st =
  let () = Debug.print_debug 5 ("KILLING Thread " ^ show tid ^ " (child of thread " ^ show parent_tid ^ ")") in
  let _ = Set.map (fun aid ->
    Debug.print_debug 5 ("AID ==> " ^ show aid)
  ) aswBefores in
  <| st with
       thread_states= assoc_adjust (fun (parent_tid_opt, th_st) ->
         (parent_tid_opt, <| th_st with
            arena= subst_wait tid v th_st.arena;
(*
            arenas= List.map (subst_wait tid v) th_st.arenas; (* NOTE!!!! ==> in fact here arenas must be a singleton (since Epar is not allowed inside Eunseq) *)
*)
            stack= add_to_asw_stack aswBefores (subst_wait_stack tid v th_st.stack) |>)
       ) parent_tid $ assoc_remove tid st.thread_states
  |>


val fresh_symbol: State.t Symbol.sym core_run_state
let fresh_symbol =
  State.modify (fun run_st ->
    let (sym, symbol_suppl') = UniqueId.fresh_id run_st.symbol_supply in
    (sym, <| run_st with symbol_supply= symbol_suppl' |>)
  )


val fresh_action_id: State.t action_id core_run_state
let fresh_action_id =
  State.modify (fun run_st ->
    let (aid, aid_suppl') = UniqueId.fresh_id run_st.aid_supply in
    (aid, <| run_st with aid_supply= aid_suppl' |>)
  )




open State.Operators

val     hoist_negatives: forall 'a. expr 'a -> State.t (expr 'a) (list (expr 'a) * core_run_state)
let rec hoist_negatives expr =
  let add_neg neg_e =
    State.modify (fun (negs, run_st) ->
      ((), (neg_e :: negs, run_st))
    ) in
(*
  let flush_negs = 
    State.modify (fun (negs, run_st) ->
      (negs, ([], run_st))
    ) in
*)
  match expr with
    | Epure _ ->
        State.return expr
    | Ememop _ _ ->
        State.return expr
(*
    | Eraise _ ->
        State.return expr
    | Eregister _ _ ->
        State.return expr
*)
    | Eskip ->
        State.return expr
    | Elet sym pe1 e2 ->
        hoist_negatives e2 >>= fun e2' ->
        State.return (Elet sym pe1 e2')
    | Eif pe1 e2 e3 ->
        hoist_negatives e2 >>= fun e2' ->
        hoist_negatives e3 >>= fun e3' ->
        State.return (Eif pe1 e2' e3')
    | Eproc _ _ _ ->
        State.return expr
    | Eaction pact ->
        if is_negative_action pact then
          add_neg expr >> State.return (Epure (Pexpr BTy_unit (PEval Vunit)))
        else
          State.return expr
    | Eunseq es ->
        State.mapM hoist_negatives es >>= fun es' ->
        State.return (Eunseq es')
    | Ewseq _as e1 e2 ->
        hoist_negatives e1 >>= fun e1'  ->
        hoist_negatives e2 >>= fun e2'  ->
        State.return (Ewseq _as e1' e2')
    | Esseq _as e1 e2 ->
        error "Core_run.hoist_negatives: found an Esseq"
(*
        hoist_negatives e1 >>= fun e1'  ->
        flush_negs         >>= fun negs ->
        hoist_negatives e2 >>= fun e2'  ->
        let nothings = Global.replicate_list Nothing (List.length negs) in
        match negs with
          | [] ->
              State.return (Esseq _as e1' e2')
          | _ ->
              State.return (
                Esseq (nothings ++ _as) (Eunseq (negs ++ [e1'])) e2'
              )
        end
*)
    | Easeq sym_opt act1 pact2 ->
        error "Core_run.hoist_negatives found an Easeq"
    | Eindet i e ->
        hoist_negatives e >>= fun e' ->
        State.return (Eindet i e')
    | Ebound i e ->
        hoist_negatives e >>= fun e' ->
        State.return (Ebound i e')
    | Esave ksym sym_tys e ->
        hoist_negatives e >>= fun e' ->
        State.return (Esave ksym sym_tys e')
    | Erun _ _ _ ->
      State.return expr
(*
    | Ereturn _ ->
        State.return expr
*)
    | End es ->
        State.mapM hoist_negatives es >>= fun es' ->
        State.return (End es')
    | Epar _ ->
        (* TODO: check *)
        State.return expr
    | Ewait _ ->
        State.return expr
    | Eloc loc e ->
        hoist_negatives e >>= fun e' ->
        State.return (Eloc loc e')
  end












open SEU.Operators


(*
val printf_hack: core_state -> list (expr core_run_annotation) -> ND.t core_step
let printf_hack core_st pes =
  let mk_string = function
    | Mem.MVarray vs ->
        let _ = Boot.output_string ("KKK> " ^ string_of_natural (naturalFromNat (List.length vs))) in (* DEBUG *)
        String.toString $ List.map (function
          | Mem.MVinteger (Symbolic.SYMBconst n) ->
              Decode.encode_character_constant n
          | _ ->
              error "printf_hack: one of the element of the format array was invalid"
        end) vs
    | _ ->
        error "printf_hack: the format argument was not an array"
  end in
  match pes with
    | [Econst (Mem.MVpointer ptr1)] ->
        ND.return $ Step_output (
          liftMem (Mem.load ptr1)       >>= fun (Mem.MVpointer ptr_format) ->
          liftMem (Mem.load ptr_format) >>= fun format                      ->
          SEU.return (mk_string format, core_st)
        )
    | _ ->
        error "invalid arguments for printf"
  end
*)

(* TODO: hack *)
(*
type formatting
declare ocaml target_rep type formatting = `Boot_printf.formatting`
val pseudo_printf: string -> list (formatting * Core_ctype.ctype) * (list string -> string)
declare ocaml target_rep function pseudo_printf = `Boot_printf.pseudo_printf`
*)











module E = struct
  let return =
    SEU.return
  let step_eval_pexprs loc mem_st file concur_sym_map inside_if pes =
    SEU.runEU (EU.mapM (step_eval_pexpr loc mem_st file concur_sym_map inside_if) pes)
  let step_eval_pexpr loc mem_st file concur_sym_map inside_if pe =
    SEU.runEU (step_eval_pexpr loc mem_st file concur_sym_map inside_if pe)
  let fresh_action_id =
    SEU.runS fresh_action_id
  let fresh_symbol =
    SEU.runS fresh_symbol
end


type action_request =
  (* RequestName  of location * sbBefore * ddBefore * aswBefore
                     parameters of request *
                     the new state or a callback *)
  | AllocRequest of Loc.t * set action_id * set action_id * set action_id *
                    action_id * thread_id * Symbol.prefix * Mem.integer_value * Mem.integer_value *
                    (Mem.pointer_value -> thread_state)
  
  | CreateRequest of Loc.t * set action_id * set action_id * set action_id *
                     action_id * thread_id * Symbol.prefix * Mem.integer_value * ctype *
                     (Mem.pointer_value -> thread_state)
  
  | LoadRequest of Loc.t * set action_id * set action_id * set action_id * 
                   (* the request provide a fresh symbolic name to be used by the concurrency if needed *)
                   action_id * thread_id * Cmm.memory_order * ctype * Mem.pointer_value * Symbol.sym *
                   (* the argument of the callback is either a concrete value if the memory model
                      is able to give one right away, or is equal to the symbolic value provided by the
                      present LoadRequest *)
                   (Mem.mem_value -> thread_state)
  
  | StoreRequest of Loc.t * set action_id * set action_id * set action_id *
                    action_id * thread_id * Cmm.memory_order * ctype * Mem.pointer_value * Mem.mem_value *
                    thread_state
  | RMWRequest of Loc.t * set action_id * set action_id * set action_id *
                  action_id * thread_id * Cmm.memory_order * Cmm.memory_order * ctype * Mem.pointer_value *
                  Mem.mem_value * Mem.mem_value * thread_state
  | FenceRequest of Loc.t * set action_id * set action_id * set action_id *
                    action_id * thread_id * Cmm.memory_order *
                    thread_state
  | KillRequest of Loc.t * set action_id * set action_id * set action_id *
                   action_id * thread_id * Mem.pointer_value * thread_state

type core_step =
  | Step_action_request of core_runM action_request
  | Step_memop_request of Mem.memop * list Core.value * thread_id * (Core.value -> thread_state)
  | Step_tau of string * core_runM thread_state
  | Step_eval of string * core_runM thread_state
  | Step_thread_done of thread_id * Core.value
(*  | Step_nd of string * list core_step *)
  | Step_blocked
  | Step_error of string
  | Step_branch of (* DEBUG *) string * (Constraints.t -> Constraints.t) * (Constraints.t -> Constraints.t) * core_runM thread_state * core_runM thread_state

  | Step_constrained of string * list (list Mem.mem_constraint2 * core_runM thread_state)

  | Step_done of Core.value
  | Step_spawn_threads of (Core.expr core_run_annotation -> thread_state) * list thread_state (* initial states for the children *)
  | Step_output of (* DEBUG *) string * string * thread_state
(*  | Step_printf of list (formatting * Core_ctype.ctype) * list Core.value * (list string -> string) * (integer -> thread_state) *)
  
    (* format string; arg pointers; callback taking as argument the length of the printed string *)
  | Step_printf2 of list char * list (Core_ctype.ctype * Mem.pointer_value) * (integer -> thread_state)



val core_action_step:
    Mem.mem_state -> Core.file core_run_annotation -> map Symbol.sym Core.object_value -> thread_id -> (maybe thread_id * thread_state) -> Core.paction core_run_annotation -> core_step
let core_action_step mem_st file concur_sym_map current_tid (parent_tid_opt, th_st) (Paction p (Action loc annots act)) =
  let sb_before =
    (* filter out actions from other threads *)
    Set.map snd $ Set.filter (fun (tid, _) -> tid = current_tid) annots.sb_before in
  let dd_before = {(* TODO *)} in
  let asw_before_ =
    if has_sbBefore_on_thread current_tid annots then
      {}
    else
      Set.map snd $ Set.filter (fun (tid, _) ->
        match parent_tid_opt with
          | Just parent_tid ->
              tid = parent_tid
          | _ ->
              false
        end) annots.sb_before in
  
  let asw_before = annots.asw_before union asw_before_ in

  
  match act with
    | Create pe1 pe2 pref ->
        match (valueFromPexpr pe1, valueFromPexpr pe2) with
          | (Just (_, Vobject (OVinteger ival)), Just (_, Vctype ty)) ->
              Step_action_request (
                E.fresh_action_id >>= fun create_aid ->
                E.return (
                  CreateRequest loc sb_before dd_before asw_before
                    create_aid current_tid pref ival ty
                    (fun ptr_val -> <| th_st with
                        arena= Epure (Pexpr (BTy_object OTy_pointer) (PEval (Vobject (OVpointer ptr_val))));
                        stack= add_to_sb_stack {(p, (current_tid, create_aid))} (* TODO: remove for sequential !!! *) th_st.stack;
                    |>)
                    )
                  )
          | (Just _, Just _) ->
              Step_error ("found a create() with ill-typed operands [" ^ Pp.stringFromSymbol_prefix pref ^ "]")
          | (Nothing, _) ->
              Step_eval "first operand of a Create" (
                E.step_eval_pexpr loc mem_st file concur_sym_map false pe1 >>= fun pe1' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Create pe1' pe2 pref)))
                |>
              )
          | (_, Nothing) ->
              Step_eval "second operand of a Create" (
                E.step_eval_pexpr loc mem_st file concur_sym_map false pe2 >>= fun pe2' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Create pe1 pe2' pref)))
                |>
              )
        end
    | Alloc pe1 pe2 pref ->
        match (valueFromPexpr pe1, valueFromPexpr pe2) with
          | (Just (_, Vobject (OVinteger ival1)), Just (_, Vobject (OVinteger ival2))) ->
              Step_action_request (
                E.fresh_action_id >>= fun alloc_aid ->
                E.return (
                  AllocRequest loc sb_before dd_before asw_before
                    alloc_aid current_tid pref ival1 ival2
                    (fun ptr_val -> <| th_st with
                        arena= Epure (Pexpr (BTy_object OTy_pointer) (PEval (Vobject (OVpointer ptr_val))));
                        stack= add_to_sb_stack {(p, (current_tid, alloc_aid))} (* TODO: remove for sequential !!! *) th_st.stack;
                    |>)
                    )
                  )
          | (Just _, Just _) ->
              Step_error "found a alloc() with ill-typed operands"
          | (Nothing, _) ->
              Step_eval "first operand of a Alloc" (
                E.step_eval_pexpr loc mem_st file concur_sym_map false pe1 >>= fun pe1' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Alloc pe1' pe2 pref)))
                |>
              )
          | (_, Nothing) ->
              Step_eval "second operand of a Alloc" (
                E.step_eval_pexpr loc mem_st file concur_sym_map false pe2 >>= fun pe2' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Alloc pe1 pe2' pref)))
                |>
              )
        end
    | Kill pe ->
        match valueFromPexpr pe with
          | Just (_, Vobject (OVpointer ptr_val)) ->
              Step_action_request (
                E.fresh_action_id >>= fun kill_aid ->
                E.return (
                  KillRequest loc sb_before dd_before asw_before
                    kill_aid current_tid ptr_val
                    <| th_st with
                      arena= Eskip;
                      stack= add_to_sb_stack {(p, (current_tid, kill_aid))} (* TODO: remove for sequential !!! *) th_st.stack;
                    |>
                )
              )
          | Just _ ->
              Step_error "found a kill() with an ill-typed operand"
          | Nothing ->
              Step_eval "operand of kill()" (
                E.step_eval_pexpr loc mem_st file concur_sym_map false pe >>= fun pe' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Kill pe')))
                |>
              )
        end
    | Store pe1 pe2 pe3 mo ->
        match (valueFromPexpr pe1, valueFromPexpr pe2, valueFromPexpr pe3) with
          | (Just (_, Vctype ty), Just (_, Vobject (OVpointer ptr_val)), Just (_, cval)) ->
              match memValueFromValue (Core_ctype.unatomic ty) cval with
                | Just mem_val ->
                    Step_action_request (
                      E.fresh_action_id >>= fun store_aid ->
                      E.fresh_symbol    >>= fun val_sym   ->
                      E.return (
                        StoreRequest loc sb_before dd_before asw_before
                          store_aid current_tid mo ty ptr_val mem_val
                          <| th_st with
                            arena= Eskip (* Epure (PEval (objectValueFromMemValue mem_val)) *);
                            stack= add_to_sb_stack {(p, (current_tid, store_aid))} (* TODO: remove for sequential !!! *) th_st.stack;
                          |>
                      )
                    )
                | Nothing ->
                    Step_error ((Loc.stringFromLocation loc) ^ "the value of a store() didn't match the lvalue type: " ^ Pp.stringFromCore_value cval)
              end
          | (Just (_, cval1), Just (_, cval2), Just (_, cval3)) ->
              Step_error ("found a store() with ill-typed operands: " ^
                           Pp.stringFromCore_value cval1 ^ " <-> " ^ Pp.stringFromCore_value cval2 ^ " <-> " ^ Pp.stringFromCore_value cval3)
          | (Nothing, _, _) ->
              Step_eval "first operand of a Store" (
                E.step_eval_pexpr loc mem_st file concur_sym_map false pe1 >>= fun pe1' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Store pe1' pe2 pe3 mo)))
                |>
              )
          | (_, Nothing, _) ->
              Step_eval "second operand of a Store" (
                E.step_eval_pexpr loc mem_st file concur_sym_map false pe2 >>= fun pe2' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Store pe1 pe2' pe3 mo)))
                |>
              )
          | (_, _, Nothing) ->
              Step_eval "third operand of a Store" (
                E.step_eval_pexpr loc mem_st file concur_sym_map false pe3 >>= fun pe3' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Store pe1 pe2 pe3' mo)))
                |>
              )
        end
    | Load pe1 pe2 mo ->
        match (valueFromPexpr pe1, valueFromPexpr pe2) with
          | (Just (_, Vctype ty), Just (_, Vobject (OVpointer ptr_val))) ->
              Step_action_request (
                E.fresh_action_id >>= fun load_aid ->
                E.fresh_symbol    >>= fun val_sym  ->
                E.return (
                  LoadRequest loc sb_before dd_before asw_before
                    load_aid current_tid mo ty ptr_val val_sym
                    (fun mem_val -> <| th_st with
                        (* NOTE: the parenthesis are needed because of a Lem's bug... *)
                        arena= (let (oTy, cval) = valueFromMemValue mem_val in
                                Epure (Pexpr (BTy_loaded oTy) (PEval cval)));
                        stack= add_to_sb_stack {(p, (current_tid, load_aid))} (* TODO: remove for sequential !!! *) th_st.stack
                    |>)
                )
              )
          | (Just _, Just _) ->
              Step_error "found a load with ill-typed operands"
          | (Nothing, _) ->
              Step_eval "first operand of a Load" (
                E.step_eval_pexpr loc mem_st file concur_sym_map false pe1 >>= fun pe1' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Load pe1' pe2 mo)))
                |>
              )
          | (_, Nothing) ->
              Step_eval "second operand of a Load" (
                E.step_eval_pexpr loc mem_st file concur_sym_map false pe2 >>= fun pe2' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Load pe1 pe2' mo)))
                |>
              )
        end
    | RMW pe1 pe2 pe3 pe4 mo1 mo2 ->
        match (valueFromPexpr pe1, valueFromPexpr pe2, valueFromPexpr pe3, valueFromPexpr pe4) with
          | (Just (_, Vctype ty), Just (_, Vobject (OVpointer ptr_val)), Just (_, cval_expected), Just (_, cval_desired)) ->
              match (memValueFromValue ty cval_expected, memValueFromValue ty cval_desired) with
                | (Just mval_expected, Just mval_desired) ->
                    Step_action_request (
                      E.fresh_action_id >>= fun rmw_aid ->
                      E.return (
                        RMWRequest loc sb_before dd_before asw_before
                          rmw_aid current_tid mo1 mo2 ty ptr_val mval_expected mval_desired
                          <| th_st with
                            arena= Epure (Pexpr BTy_boolean (PEval Vtrue)); (* TODO *)
                            stack= add_to_sb_stack {(p, (current_tid, rmw_aid))} (* TODO: remove for sequential !!! *) th_st.stack;
                          |>
                      )
                    )
(*
  | RMW of aid * tid * memory_order * location * cvalue * cvalue  (* first val = value read; second val = value written *)
*)

(*
                    Step_action_request (
                      E.fresh_action_id >>= fun rmw_aid ->
                      E.fresh_symbol    >>= fun val_sym ->
                      E.return (
                        StoreRequest loc sb_before dd_before asw_before
                          store_aid current_tid mo ty ptr_val mem_val
                          <| th_st with
                            arena= Eskip (* Epure (PEval (objectValueFromMemValue mem_val)) *);
                            stack= (* add_to_sb_stack {(p, (current_tid, store_aid))} *) (* TODO: bring back for concurrency !!! *) th_st.stack;
                          |>
                      )
                    )
*)
                | _ ->
                    Step_error ("one of the values of a rmw() didn't match the lvalue type: " (* ^
                      Pp.pp_ail_ctype (Core_aux.unproj_ctype ty) ^ " <-> " ^
                                Pp.stringFromCore_expr ((Epure (PEval cval_expected)) : Core.expr unit) ^ " <-> " ^
                                Pp.stringFromCore_expr ((Epure (PEval cval_desired)) : Core.expr unit) *))
              end
          | (Just _, Just _, Just _, Just _) ->
              Step_error "found a rmw with ill-typed operands"
          | (Nothing, _, _, _) ->
              Step_eval "first operand of a RMW" (
                E.step_eval_pexpr loc mem_st file concur_sym_map false pe1 >>= fun pe1' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (RMW pe1' pe2 pe3 pe4 mo1 mo2)))
                |>
              )
          | (_, Nothing, _, _) ->
              Step_eval "second operand of a RMW" (
                E.step_eval_pexpr loc mem_st file concur_sym_map false pe2 >>= fun pe2' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (RMW pe1 pe2' pe3 pe4 mo1 mo2)))
                |>
              )
          | (_, _, Nothing, _) ->
              Step_eval "third operand of a RMW" (
                E.step_eval_pexpr loc mem_st file concur_sym_map false pe3 >>= fun pe3' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (RMW pe1 pe2 pe3' pe4 mo1 mo2)))
                |>
              )
          | (_, _, _, Nothing) ->
              Step_eval "fourth operand of a RMW" (
                E.step_eval_pexpr loc mem_st file concur_sym_map false pe4 >>= fun pe4' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (RMW pe1 pe2 pe3 pe4' mo1 mo2)))
                |>
              )
        end

(*
        match (valueFromPexpr pe1, valueFromPexpr pe2) with
          | (Just (Vctype ty), Just (Vpointer ptr_val)) ->
              Step_action_request (
                E.fresh_action_id >>= fun load_aid ->
                E.fresh_symbol    >>= fun val_sym  ->
                E.return (
                  LoadRequest loc sb_before dd_before asw_before
                    load_aid current_tid mo ty ptr_val val_sym
                    (fun mem_val -> <| th_st with
                        arena= Epure (PEval (objectValueFromMemValue mem_val));
                        stack= (* add_to_sb_stack {(p, (current_tid, load_aid))} *) th_st.stack
                    |>)
                )
              )
          | (Just _, Just _) ->
              Step_error "found a load with ill-typed operands"
          | (Nothing, _) ->
              Step_eval "first operand of a Load" (
                E.step_eval_pexpr file concur_sym_map false pe1 >>= fun pe1' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Load pe1' pe2 mo)))
                |>
              )
          | (_, Nothing) ->
              Step_eval "second operand of a Load" (
                E.step_eval_pexpr file concur_sym_map false pe2 >>= fun pe2' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Load pe1 pe2' mo)))
                |>
              )
        end
*)
    | Fence mo ->
        Step_action_request (
          E.fresh_action_id >>= fun fence_aid ->
          E.return (
            FenceRequest loc sb_before dd_before asw_before
              fence_aid current_tid mo
              <| th_st with
                arena= Eskip;
                stack= add_to_sb_stack {(p, (current_tid, fence_aid))} (* TODO: remove for sequential !!! *) th_st.stack;
              |>
          )
        )
(*
  | FenceRequest of Loc.t * set action_id * set action_id * set action_id *
                    action_id * thread_id * Cmm.memory_order * ctype *
                    thread_state
*)
  end



val core_thread_step2: Mem.mem_state -> Core.file core_run_annotation -> map Symbol.sym Core.object_value -> thread_id -> (maybe thread_id * thread_state) -> list core_step
let core_thread_step2 mem_st file concur_sym_map current_tid (parent_tid_opt, th_st) =
  let one z = [z] in
  match (th_st.arena, th_st.stack) with
    | (Eskip, Stack_cons cont sk') ->
        (* ---------------------------------------
           <skip, .s, > ----> <(unit), .s, > *)
        one $ Step_tau "Eskip" (
          E.return <| th_st with arena= apply_continuation cont (Epure (Pexpr BTy_unit (PEval Vunit))); stack= Stack_cons [] sk' |>
        )
    
    | (Ecase pe pat_es, _) ->
        one match pe with
          | Pexpr bTy (PEval (Vconstrained xs)) ->
              Step_constrained "Ecase" (
                List.map (fun (constrs, cval) ->
                    (constrs, E.return <| th_st with arena= Ecase (Pexpr bTy (PEval cval)) pat_es |>)
                ) xs 
              )
          | Pexpr _ (PEval _) ->
              match select_case subst_sym_expr pe pat_es with
                | Just e' ->
                    Step_tau "Ecase" (
                      E.return <| th_st with arena= e' |>
                    )
                | Nothing ->
                    Step_error ("Ecase, mismatched ==> " ^ Pp.stringFromCore_expr th_st.arena)
              end
          | _ ->
              Step_eval "Ecase" (
                E.step_eval_pexpr th_st.current_loc mem_st file concur_sym_map false pe >>= fun pe' ->
                E.return <| th_st with arena= Ecase pe' pat_es |>
              )
        end
    
    | (Elet pat pe1 e2, _) ->
        (*                [| pe1 |] = v
           --------------------------------------------------
           <let  = pe1 in e2, s, > ----> <e2[\v], s, > *)
        one match valueFromPexpr pe1 with
          | Just (bTy, cval) ->
              Step_tau "Elet" (
                E.return <| th_st with arena= subst_pattern pat (Pexpr bTy (PEval cval)) e2 |>
              )
          | Nothing ->
              Step_eval "Elet" (
                E.step_eval_pexpr th_st.current_loc mem_st file concur_sym_map false pe1 >>= fun pe1' ->
                E.return <| th_st with arena= Elet pat pe1' e2 |>
              )
        end
    
    | (Eif pe1 e2 e3, Stack_cons cont _) ->
        (* [| pe1 |] = v    e' = e2 labels e2
           -----------------------------------------------------------------
                                                   .- <e2, s>  IF v = true
           <if pe1 then e2 else e3, s, > ----> <
                                                   '- <e3, s>  IF v = false *)
        match valueFromPexpr pe1 with
          | Just (_, Vtrue) ->
              one $ Step_tau "Eif (then)" (
                let labeled_conts =
                  Map.map (fun (sym_tys, e) -> (sym_tys, apply_continuation cont e)) $ collect_labeled_continuations e3 in
                E.return <| th_st with arena= e2; labels= Map.(union) labeled_conts th_st.labels |>
              )
          | Just (_, Vfalse) ->
              one $ Step_tau "Eif (else)" (
                let labeled_conts =
                  Map.map (fun (sym_tys, e) -> (sym_tys, apply_continuation cont e)) $ collect_labeled_continuations e2 in
                E.return <| th_st with arena= e3; labels= Map.(union) labeled_conts th_st.labels |>
                                          )
(*
          | Just (Vobject (OVsymbolic symb)) ->
              let (constr_then, constr_else) =
                match symb with
                  | Symbolic.SYMBop Symbolic.Eq symb1 symb2 ->
                      (Constraints.assert_eq symb1 symb2, Constraints.assert_neq symb1 symb2)
                  | Symbolic.SYMBop Symbolic.Neq symb1 symb2 ->
                      (Constraints.assert_neq symb1 symb2, Constraints.assert_eq symb1 symb2)
                  | Symbolic.SYMBnot (Symbolic.SYMBop Symbolic.Eq symb1 symb2) ->
                      (Constraints.assert_neq symb1 symb2, Constraints.assert_eq symb1 symb2)
                  | Symbolic.SYMBnot (Symbolic.SYMBop Symbolic.Neq symb1 symb2) ->
                      (Constraints.assert_eq symb1 symb2, Constraints.assert_neq symb1 symb2)
                end in
              one $ Step_branch "Eif (symbolic)" constr_then constr_else
                begin
                  let labeled_conts =
                    Map.map (fun (sym_tys, e) -> (sym_tys, apply_continuation cont e)) $ collect_labeled_continuations e3 in
                  E.return <| th_st with arena= e2; labels= Map.(union) labeled_conts th_st.labels |>
                end
                begin
                  let labeled_conts =
                    Map.map (fun (sym_tys, e) -> (sym_tys, apply_continuation cont e)) $ collect_labeled_continuations e2 in
                  E.return <| th_st with arena= e3; labels= Map.(union) labeled_conts th_st.labels |>
                end
*)

          | Just _ ->
              one $ Step_error "the first operand of an Eif didn't evaluated to a boolean"
          | Nothing ->
              one $ Step_eval "Eif" (
                E.step_eval_pexpr th_st.current_loc mem_st file concur_sym_map true pe1 >>= fun pe1' ->
                E.return <| th_st with arena= Eif pe1' e2 e3 |>
              )
        end
    
    | (Eproc annots pe pes, sk) ->
        one match valueFromPexpr pe with
          | Just (_, Vobject (OVcfunction nm)) ->
              match valueFromPexprs pes with
                | Just bTy_cvals ->
                    match nm with
                      | Sym psym ->
                          Step_tau "Eproc" (
                            SEU.runEU (
                              Exception.bind (call_proc file psym (List.map snd bTy_cvals))
                                EU.return
                            ) >>= fun expr ->
                            (* TODO: HACK here we always annotate the action as being positive, I'm pretty sure this is wrong *)
                            let a_expr = add_to_sb (Set.map (fun z -> (Pos, z)) annots.sb_before) (* TODO: remove for sequential !!! *) expr in
                            E.return <| th_st with arena= a_expr; stack= push_empty_continuation sk; exec_loc= push_exec_loc psym th_st.exec_loc |>
                          )
                      | Impl (StdFunction "printf") ->
                          match List.map snd bTy_cvals with
                            | [Vlist (BTy_object OTy_integer) frmt_cvals;
                               Vlist (BTy_tuple [BTy_ctype; BTy_object OTy_pointer]) args_cvals] ->
(*
                          (* building an OCaml string for the format *)
                          let frmt_str =
                            String.toString $ List.map (function
                              | Vinteger ival ->
                                  match Mem_aux.integerFromIntegerValue ival with
                                    | Just n ->
                                        Decode.encode_character_constant n
                                    | Nothing ->
                                        error "printf_hack: one of the element of the format array was invalid (1)"
                                  end
                              | z ->
                                  error "printf_hack: one of the element of the format array was invalid (2)"
                            end) (List.reverse chars) in
                          
                          (* get the list of types specified by the format string, and a builder function
                             for the string to be printed *)
                          let (format_tys, mk_str) = pseudo_printf frmt_str in
                          Step_printf format_tys args mk_str (fun n ->
                            <| th_st with arena= Epure (PEval (Vinteger (Mem.integer_ival n))) |>
                          )
*)
                          let frmt_chars = List.map (function
                            | Vobject (OVinteger ival) ->
                                match Mem_aux.integerFromIntegerValue ival with
                                  | Just n ->
                                      Decode.encode_character_constant n
                                  | Nothing ->
                                      error "Core_run, printf one of the element of the format array was invalid (1)"
                                end
                              | z ->
                                  error "Core_run, printf one of the element of the format array was invalid (2)"
                          end) (List.reverse frmt_cvals) in (* TODO: why is this reversed?? *)
                          let args_ptrvals = List.map (function
                            | Vtuple [Vctype ty; Vobject (OVpointer ptr_val)] ->
                                (* TODO: WIP *)
                                (ty, ptr_val)
                            | _ ->
                                error "Core_run, printf the second argument should be a list of (ctype, pointer) pairs"
                          end) args_cvals in
                          Step_printf2 frmt_chars args_ptrvals (fun n ->
                            <| th_st with arena= Epure (Caux.integer_pe n) |>
                          )
(*
  | Step_printf2 of list Core.value * list Mem.pointer_value * (integer -> thread_state)
*)

                      | _ ->
                          error "Core_run, printf giving arguments of wrong types"
                    end
                | _ ->
                    error ("WIP: Eproc ==> " ^ Pp.stringFromCore_expr th_st.arena)
              end
              
                | Nothing ->
                    Step_eval "Eproc" (
                      E.step_eval_pexprs th_st.current_loc mem_st file concur_sym_map false pes >>= fun pes' ->
                      E.return <| th_st with arena= Eproc annots pe pes' |>
                    )
              end
          | Just (bTy, cval) ->
              Step_error ((Loc.stringFromLocation th_st.current_loc) ^ "the first argument of pcall() must evaluate to a cfunction, found: " ^
                Pp.stringFromCore_expr ((Epure (Pexpr bTy (PEval cval))) : Core.expr unit) ^ "")
          | Nothing ->
              Step_eval "Eproc" (
                E.step_eval_pexpr th_st.current_loc mem_st file concur_sym_map false pe >>= fun pe' ->
                E.return <| th_st with arena= Eproc annots pe' pes |>
              )
        end
    
    | (Eaction pact, _) ->
        one $ core_action_step mem_st file concur_sym_map current_tid (parent_tid_opt, th_st) pact
    | (Ememop memop pes, _) ->
        error "Core_run, WIP Ememop"
(*
        one match valueFromPexprs pes with
          | Just bTy_cvals ->
              Step_memop_request memop bTy_cvals current_tid (fun (bTy, cval) ->
                <| th_st with arena= Epure (Pexpr bTy (PEval cval)) |>
              )
          | Nothing ->
              Step_eval "Ememop" (
                E.step_eval_pexprs th_st.current_loc mem_st file concur_sym_map false pes >>= fun pes' ->
                E.return <| th_st with arena= Ememop memop pes' |>
              )
        end
*)

(*
          | (Ptreq, Just cvals) ->
              match Mem.eq_ptrval (* TODO *)Symbolic.Constraints_TODO ptr_val1 ptr_val2 with
                | Just b ->
                    one $ Step_tau "Ememop, Ptreq" (
                      E.return <| th_st with arena= Epure (PEval (if b then Vtrue else Vfalse)) |>
                    )
                | Nothing ->
                    error "TODO: symbolic case for pointer equality"
              end
          | (IntFromPtr, Just [Vctype ref_ty; Vctype ty; Vpointer ptr_val]) ->
              EU.return $
              PEval (Vinteger (Mem.intcast_ptrval ref_ty ty ptr_val))
          | (PtrFromInt, Just [Vctype ty; Vctype ref_ty; Vinteger ival]) ->
              EU.return $
                PEval (Vpointer (Mem.ptrcast_ival ty ref_ty ival))
          | (PtrValidForDeref, Just [Vpointer ptr_val]) ->
              EU.return $ PEval
                (if Mem.validForDeref_ptrval ptr_val then
                  Vtrue
                else
                  Vfalse)
*)
    
    | (Eunseq es, Stack_cons cont sk) ->
        match to_pures es with
          | Just pes ->
              one $ Step_tau "Eunseq pure" (
                E.return <| th_st with arena= Epure (Caux.mk_tuple_pe pes) |>
              )
          | Nothing ->
              let is_wait = function
                | Ewait _ ->
                    true
                | _ ->
                  false
              end in
              if List.all (fun e -> is_wait e || to_pure e <> Nothing) es then
                one Step_blocked
              else
                let xs = 
                List.map (fun (es1, ej, es2) ->
                  Step_tau "Eunseq" (
                    E.return <| th_st with arena= ej; stack= Stack_cons (Kunseq es1 es2 :: cont) sk |>
                  )
                ) (pickWith (fun e -> to_pure e = Nothing && not (is_wait e)) es) in
                if List.length xs = 0 then
                  error ("BOOM Core_run, Eunseq, empty list ==> " ^ Pp.stringFromCore_expr (Eunseq es)) (* TODO: debug *)
                else
                  xs
        end
    
    | (Ewseq pat e1 e2, Stack_cons cont sk) ->
        (* TODO: negatives *)
        one match to_pure e1 with
          | Just pe ->
              match valueFromPexpr pe with
                | Just (bTy, cval) ->
                    Step_tau "Ewseq subst" (
                      E.return <| th_st with arena= subst_pattern pat (Pexpr bTy (PEval cval)) e2 |>
                    )
                | Nothing ->
                    Step_eval "Ewseq" (
                      E.step_eval_pexpr th_st.current_loc mem_st file concur_sym_map false pe >>= fun pe' ->
                      E.return <| th_st with arena= Ewseq pat (Epure pe') e2 |>
                    )
              end
          | Nothing ->
              (* focus the execution on the first operand *)
              Step_tau "Ewseq" (
                E.return <| th_st with
                  arena= e1;
                  stack= Stack_cons (Kwseq pat e2 :: cont) sk
                |>
              )
        end
    
    | (Esseq pat e1 e2, Stack_cons cont sk) ->
        (* TODO: negatives *)
        one match to_pure e1 with
          | Just pe ->
              match valueFromPexpr pe with
                | Just (bTy, cval) ->
                    Step_tau "Esseq subst" (
                      E.return <| th_st with arena= subst_pattern pat (Pexpr bTy (PEval cval)) e2 |>
                    )
                | Nothing ->
                    Step_eval "Esseq" (
                      E.step_eval_pexpr th_st.current_loc mem_st file concur_sym_map false pe >>= fun pe' ->
                      E.return <| th_st with arena= Esseq pat (Epure pe') e2 |>
                    )
              end
          | Nothing ->
              (* focus the execution on the first operand *)
              Step_tau "Esseq" (
                E.return <| th_st with
                  arena= e1;
                  stack= Stack_cons (Ksseq pat e2 :: cont) sk
                |>
              )
        end

    
    | (Esave k a_tys e, Stack_cons cont _) ->
        (* TODO: this is partial *)
        one $ Step_tau "Esave" (
          E.return <| th_st with arena= e; labels= Map.insert k (a_tys, apply_continuation cont e) th_st.labels |>
        )
    
    | (Erun annots k sym_vs, Stack_cons cont sk) ->
        one $ Step_tau "Erun" (
          match Map.lookup k th_st.labels with
            | Just cont ->
                SEU.return cont
            | Nothing ->
                match find_labeled_continuation k (apply_continuation cont th_st.arena) with
                  | Nothing ->
                      SEU.fail (Illformed_program ("unknown ksym when running an Erun" ^ show k))
                  | Just cont ->
                      SEU.return cont
                end
          end >>= fun ((sym_tys, e_cont) as cont) ->
          (* TODO: debug *)
(*          let _ = Boot.output_string ("stepping Erun ===> " ^ Pp.stringFromCore_expr e_cont) in *)
          
          (* we have to create the objects which are visible at the level of the save but not from the run *)
          let (create_syms, create_tys) = unzip $
            List.filter (fun (sym, _) -> not (List.any (fun (z, _) -> z = sym) sym_vs)) sym_tys in
          (* symmetrically, we have to kill the objects which are visible at the level of the run but not from the save.*)
          let kill_es = List.map snd $ List.filter (fun (sym, _) ->
            not (List.any (fun (z, _) -> z = sym) sym_tys)
          ) sym_vs in
          let e =
            Ewseq Caux.mk_empty_pat (mk_unseq $ List.map (fun e -> pkill Loc.unknown e) kill_es)
              match create_syms with
                | [] ->
                    (foldl (fun acc (a, v) -> subst_sym_expr a v acc) e_cont sym_vs)
                | _ ->
                    Ewseq (Caux.mk_tuple_pat (List.map (fun z -> CaseBase (Just (z, BTy_object OTy_pointer))) create_syms))
                       (mk_unseq $ List.map (fun ty ->
                          let pe_ty = Pexpr BTy_ctype (PEval (Vctype ty)) in
                          pcreate Loc.unknown (Caux.alignof_pe pe_ty) pe_ty (Symbol.PrefOther "core_run, Erun")
                       ) create_tys)
                       (foldl (fun acc (a, v) -> subst_sym_expr a v acc) e_cont sym_vs)
              end in
          (* TODO: it seems strange that annotate_expr need to know the polarity *)
          let e' = 
let () = Debug.print_debug 5 "HELLO Erun" in
add_to_asw annots.asw_before $
add_to_sb (Set.map (fun z -> (Pos, z)) annots.sb_before) e in (* TODO: remove for sequential !!! *)
          E.return <| th_st with arena= e';
                                 stack= push_empty_continuation sk;
                                 labels= Map.insert k cont th_st.labels
                   |>
      )







    | (Ereturn pe, Stack_cons _ sk) ->
(*
    | (Epure pe, Stack_cons [] sk) ->
*)
        one match valueFromPexpr pe with
          | Just (bTy, cval) ->
              match sk with
                | Stack_empty ->
                    (* "return" ending the execution of a thread. *)
                    match parent_tid_opt with
                      | Just parent_tid ->
                          Step_thread_done parent_tid cval
                      | Nothing ->
                          (* we reached the end of the startup thread's execution *)
                          (* TODO: this seems like a silly indirection *)
                          Step_tau "end of main thread" (
                            E.return <| th_st with arena= Epure pe; stack= empty_stack |>
                          )
                    end
                | Stack_cons cont sk' ->
                    (* "return" only ending the execution of a procedure. *)
                    Step_tau "end of procedure" (
                      E.return <| th_st with
                        arena= apply_continuation cont (Epure (Pexpr bTy (PEval cval)));
                        stack= push_empty_continuation sk';
(*
(* TODO: need stacked scopes ... *)
                        labels= Map.empty (* TODO: this is too violent, but doing no reset is unsound *)
*)
                      |>
                    )
              end
          | Nothing ->
              Step_eval "Ereturn" (
                E.step_eval_pexpr th_st.current_loc mem_st file concur_sym_map false pe >>= fun pe' ->
                E.return <| th_st with arena= Ereturn pe' |>
              )
        end
    
    | (End es, _) ->
        (* -------------------------------------------
           <nd(e1, ..., eN), s, > ----> <ej, s, >    j  {1, ..., N} *)
        List.map (fun e ->
          Step_tau "End" (E.return <| th_st with arena= e |>)
       ) es
    
    | (Epar es, _) ->
        (* TODO: doc *)
        one $ Step_spawn_threads (fun e -> <| th_st with arena= e |>) (
          List.map (fun e -> <|
            arena= e;
            stack= push_empty_continuation empty_stack;
            labels= Map.empty;
            current_loc= th_st.current_loc;
            exec_loc= ELoc_normal []
          |>) es
        )
    | (Ewait _, _) ->
        (* We don't do anything here. When a thread terminated, the driver
           substitute the corresponding wait in parent thread with the returned
           value. *)
        error "Core_run, Ewait"
    
    | (Eloc loc e, _) ->
        one $ Step_tau "Eloc" (
          E.return <| th_st with current_loc= loc; arena= e |>
        )
    
(*
    | (Eraise handl, sk) ->
        error "WIP: Eraise"
    | (Eregister handl nm, sk) ->
        error "WIPL Eregister"
*)
    
    | (Easeq _ _ _, _) ->
        error "Core_run must be called after Core_indet"
    | (Eindet _ _, _) ->
        error "Core_run must be called after Core_indet"
    | (Ebound _ _, _) ->
        error "Core_run must be called after Core_indet"
    
    | (e, Stack_empty) ->
        (* End of program execution *)
        one match maybe Nothing valueFromPexpr (to_pure e) with
          | Just (_,  cval) ->
              Step_done cval
          | Nothing ->
              Step_error ("reached empty stack on a non-value arena: " ^ Pp.stringFromCore_expr e) (* TODO: better error message *)
        end
    
    | (e, Stack_cons cont sk) ->
        match to_pure e with
          | Just pe ->
              one match valueFromPexpr pe with
                | Just (bTy, cval) ->
                    Step_tau "value" (match cont with
                      | [] ->
                          error ("<e, Stack_cons []> with e= " ^ Pp.stringFromCore_expr e) (* TODO: what case is that? *)
                      | _ ->
                          (* -----------------------------------
                             <v, .s, > ----> <(v), .s, > *)
                          E.return <| th_st with
                            arena= apply_continuation cont (Epure (Pexpr bTy (PEval cval)));
                            stack= push_empty_continuation sk
                          |>
                    end)
                  | Nothing ->
                      (*          [| pe |] = v
                         -----------------------------
                         <pe, s, > ----> <v, s, > *)
                      Step_eval "pure" (
                        E.step_eval_pexpr th_st.current_loc mem_st file concur_sym_map false pe >>= fun pe' ->
                        E.return <| th_st with arena= Epure pe' |>
                      )
                end
          | Nothing ->
              error (Pp.stringFromCore_expr e) (* TODO: better error message *)
        end
  end





























































(* BEGIN silly *)
(* Dummy function doing nothing, but required to typecheck *)
val     convert_expr: forall 'a. Core.expr 'a -> Core.expr core_run_annotation
let rec convert_expr expr =
  match expr with
    | Epure pe ->
        Epure pe
    | Ememop memop pes ->
        Ememop memop pes
(*
    | Eraise h ->
        Eraise h
    | Eregister h nm ->
        Eregister h nm
*)
    | Eskip ->
        Eskip
    | Elet sym pe1 e2 ->
        Elet sym pe1 (convert_expr e2)
    | Eif pe1 e2 e3 ->
        Eif pe1 (convert_expr e2) (convert_expr e3)
    | Ecase pe pat_es ->
        Ecase pe (List.map (fun (pat, e) -> (pat, convert_expr e)) pat_es)
    | Eproc _ pe pes ->
        Eproc empty_annotation pe pes
    | Eaction pact ->
        Eaction (convert_paction pact)
    | Eunseq es ->
        Eunseq (List.map convert_expr es)
    | Ewseq _as e1 e2 ->
        Ewseq _as (convert_expr e1) (convert_expr e2)
    | Esseq _as e1 e2 ->
        Esseq _as (convert_expr e1) (convert_expr e2)
    | Easeq sym_opt act1 pact2 ->
        Easeq sym_opt (convert_action act1) (convert_paction pact2)
    | Eindet i e ->
        Eindet i (convert_expr e)
    | Ebound i e ->
        Ebound i (convert_expr e)
    | Esave ksym sym_tys e ->
        Esave ksym sym_tys (convert_expr e)
    | Erun _ ksym sym_pes ->
        Erun empty_annotation ksym sym_pes
    | Ereturn pe ->
        Ereturn pe
    | End es ->
        End (List.map convert_expr es)
    | Epar es ->
        Epar (List.map convert_expr es)
    | Ewait tid ->
        Ewait tid
    | Eloc loc e ->
        Eloc loc (convert_expr e)
  end

and convert_paction pact =
  match pact with
    | Paction p act ->
        Paction p (convert_action act)
  end

and convert_action act =
  match act with
    | Action loc _ act_ -> Action loc empty_annotation act_
  end



val convert_file: forall 'a. file 'a -> file core_run_annotation
let convert_file file =
  let convert_fun_map_decl = function
    | Fun bTy params pe ->
        Fun bTy params pe
    | Proc bTy params e ->
        Proc bTy params (convert_expr e)
  end in

 <|
  main=   file.main;
  stdlib= Map.map convert_fun_map_decl file.stdlib;
  impl=   file.impl;
  globs=  List.map (fun (sym, bTy, e) -> (sym, bTy, convert_expr e)) file.globs;
  funs=   Map.map convert_fun_map_decl file.funs;
 |>
(* END silly *)





val initial_io_state: io_state
let initial_io_state = <|
  stdout= Dlist.nil;
|>

val initial_core_state: core_state
let initial_core_state = <|
  thread_states= [];
  io= initial_io_state;
(*  handlers= Map.empty;*)
|>


(*
val init: Core.file core_run_annotation -> core_runM core_state
let init file =
  match Map.lookup file.main file.funs with
    | Nothing ->
        SEU.fail (Illformed_program "couldn't find the startup function")
    | Just (_, _, expr) ->
        SEU.return expr
  end >>= fun expr ->
  
  SEU.runS (spawn_thread Nothing <|
    arena= expr;
    stack= push_empty_continuation empty_stack;
    labels= Map.empty
  |> initial_core_state) >>= fun (_, st') ->
  
  SEU.return st'
*)



val initial_core_run_state: core_run_state
let initial_core_run_state = <|
  tid_supply=    UniqueId.new_supply;
  symbol_supply= UniqueId.new_supply;
  aid_supply=    UniqueId.new_supply;
  
  step_counter= 0;
|>
