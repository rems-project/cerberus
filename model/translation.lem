(* TODO: for now everything is mapped to nonatomics. The translation to atomics
         still needs to be defined *)

open Global

open Implementation_

module A    = AilSyntax
module Aaux = AilSyntaxAux
module Aty  = AilTypes

module C    = Core
module Caux = Core_aux
module U    = Undefined

open Translation_effect
open Translation_aux


val     translate_lvalue: C.fun_map zero -> A.program Location.t GenTypes.genTypeCategory -> A.expression GenTypes.genTypeCategory -> t (C.expr zero)
let rec translate_lvalue stdlib program a_exp =
  let f = translate_expression stdlib program in
  if Aaux.null_pointer_constant a_exp then
    return C.Enull
  else
    let A.AnnotatedExpression _ exp = a_exp in
    match exp with
      | A.Var id ->
          return (C.Esym id)
      
      | A.Unary A.Indirection e ->
          E.fresh_symbol >>= fun a_e    ->
          f e            >>= fun core_e ->
          (* TODO: the checks *)
          return core_e
      
(*
    | A.UNARY A.INDIRECTION e ->
        f e >>= fun (a, m) ->
        let t = T.base_of_pointer (T.pointer_convert (Annotate.exp_type_of e)) in
        let ill_aligned = C.neg (Tc.is_aligned t a) in
        let null = C.eq a C.null in
        let c = C.implies (C.disj null ill_aligned) C.undef in
        return (a, m +& c)


    | _ ->
        C.fresh >>= fun a ->
        return (a, Me.null)
*)
end


and translate_function_designator (A.AnnotatedExpression _ expr) =
  match expr with
    | A.Var fid -> return $ C.Econst (C.Cfunction fid)
  end


(*  translate_expression: C.fun_map zero -> A.program Location.t GenTypes.genTypeCategory -> A.expression GenTypes.genTypeCategory -> 
                          t (C.expr zero) *)
and translate_expression stdlib program a_expr =
  let f e = translate_expression stdlib program e in
  let mk_stdcall fname = mk_stdcall stdlib fname in
  let conv             = mk_stdcall "conv"             in
  let conv_int         = mk_stdcall "conv_int"         in
  let overflow         = mk_stdcall "overflow"         in
  let ctype_width      = mk_stdcall "ctype_width"      in
  let exp              = mk_stdcall "exp"              in
  let is_representable = mk_stdcall "is_representable" in
  let usual_arithmetic = mk_stdcall "usual_arithmetic" in
  let usual_arithmetic_conv e ty1 ty2 =
    conv [Caux.mk_ctype ty1; usual_arithmetic [Caux.mk_ctype ty1; Caux.mk_ctype ty2]; e] in
  
  
  let A.AnnotatedExpression _ expr = a_expr in
  (* TODO: we do a match instead of a let, because of a bug in Lem *)
  let ty = match GenTypesAux.interpret_genTypeCategory tmp_implementation
                   (Annotation.type_of Annotation.concrete_annotation a_expr) with
             | Some (AilTypes.LValueType _ z) -> z
             | Some (AilTypes.RValueType z)   -> z
           end in
  
  if AilTypesAux.pointer ty && Aaux.null_pointer_constant a_expr then
    return C.Enull
  else
    match expr with
        (* NOTE: this is not enought *)
      | A.Var id ->
          if AilTypesAux.is_function ty then
            return (C.Econst (C.Cfunction id))
          else
            return $ Caux.pload (Caux.mk_ctype ty) (C.Esym id) Cmm.NA
      
      | A.Unary A.Plus e ->
          f e >>= fun core_e ->
          return (promote_value core_e)
      
      | A.Unary A.Minus e ->
          E.fresh_symbol >>= fun a_e    ->
          f e            >>= fun core_e ->
          return $
            C.Ewseq [Some a_e] core_e
              (C.Eop C.OpSub Caux.zero (promote_value $ C.Esym a_e))
      
      | A.Unary A.Bnot e ->
          E.fresh_symbol >>= fun a_e    ->
          f e            >>= fun core_e ->
          return $
            C.Ewseq [Some a_e] core_e (
              if is_unsigned_integer_type ty then
                C.Eop C.OpSub (C.ctype_max $ Caux.mk_ctype ty) (promote_value $ C.Esym a_e)
              else
                C.bitwise_complement (promote_value $ C.Esym a_e)
            )
      
      | A.Unary A.Address (A.AnnotatedExpression _ (A.Unary A.Indirection e)) ->
          f e
      
      | A.Unary A.Address e ->
          if AilTypesAux.object_ ty then
            translate_lvalue stdlib program e
          else
            translate_function_designator e
      
      | A.Unary A.Indirection e ->
          (* TODO: temporary  *)
          E.fresh_symbol       >>= fun a_e    ->
          f e >>= fun core_e ->
          (* shouldn't be a real load ? *)
          return $ C.Ewseq [Some a_e] core_e
                     (Caux.pload (Caux.mk_ctype ty) (C.Esym a_e) Cmm.NA)
      
      | A.Unary A.PostfixIncr e ->
          E.fresh_symbol                    >>= fun a_lvalue ->
          E.fresh_symbol                    >>= fun a_load   ->
          translate_lvalue stdlib program e >>= fun core_e   ->
          (* TODO: qualifiers temporarily not dealt with *)
          let core_ty_e = Caux.mk_ctype $ AilTypesAux.pointer_conversion (snd (from_lvalue_type e)) in
          return $
            C.Ewseq [Some a_lvalue] core_e
              (C.Easeq (Some a_load)
                 ({}, C.Load core_ty_e (C.Esym a_lvalue) Cmm.NA)
                 (C.Neg, ({}, C.Store core_ty_e
                                        (C.Esym a_lvalue)
                                        (conv_int [Caux.mk_ctype (exp_type_of e); (C.Eop C.OpAdd (C.Esym a_load) Caux.one)])
                                        Cmm.NA
                                      )
                 )
              )
      
      (* TODO: "atomicity" of the load-store pair *)
      | A.Unary A.PostfixDecr e ->
          E.fresh_symbol                    >>= fun a_lvalue ->
          E.fresh_symbol                    >>= fun a_load   ->
          translate_lvalue stdlib program e >>= fun core_e   ->
          let core_ty_e = Caux.mk_ctype $ AilTypesAux.pointer_conversion (snd (from_lvalue_type e)) in
          return $
            C.Ewseq [Some a_lvalue] core_e
              (C.Ewseq [Some a_load] (Caux.pload core_ty_e (C.Esym a_lvalue) Cmm.NA)
                 (C.Ewseq [] (Caux.pstore core_ty_e
                                          (C.Esym a_lvalue)
                                          (conv_int [Caux.mk_ctype (exp_type_of e); (C.Eop C.OpSub (C.Esym a_load) Caux.one)])
                                          Cmm.NA
                             )
                    (C.Esym a_load)
                 )
              )
      
      | A.Binary e1 (A.Arithmetic A.Mul) e2 ->
          E.fresh_symbol        >>= fun a_e1     ->
          E.fresh_symbol        >>= fun a_e2     ->
          f e1 >>= fun core_e1  ->
          f e2 >>= fun core_e2  ->
          E.fresh_symbol        >>= fun a_mul    ->
          let mul_ctx x =
            C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
              (C.Elet a_mul (C.Eop C.OpMul (C.Esym a_e1) (C.Esym a_e2))
                 x) in
          if AilTypesAux.is_signed_integer_type (exp_type_of a_expr) then
            return $ mul_ctx (overflow [Caux.mk_ctype (exp_type_of a_expr); C.Esym a_mul])
          else
            return $ mul_ctx (conv_int [Caux.mk_ctype (exp_type_of a_expr); C.Esym a_mul])
      
      | A.Binary e1 (A.Arithmetic A.Div) e2 ->
          E.fresh_symbol        >>= fun a_e1    ->
          E.fresh_symbol        >>= fun a_e2    ->
          f e1 >>= fun core_e1 ->
          f e2 >>= fun core_e2 ->
          (* TODO[check] usual arithmetic conversions *)
          let core_e1' = usual_arithmetic_conv (C.Esym a_e1) (exp_type_of e1) (exp_type_of e2) in
          let core_e2' = usual_arithmetic_conv (C.Esym a_e2) (exp_type_of e1) (exp_type_of e2) in
          
          (* TODO[check]: When integers are divided, the result of the / operator is the algebraic
                          quotient with any fractional part discarded.105) If the quotient a/b is
                          representable, the expression (a/b)*b + a%b shall equal a; otherwise, the
                          behavior of both a/b and a%b is undefined. *)
          return $
            C.Ewseq [Some a_e1; Some a_e2] (Caux.mk_unseq [core_e1; core_e2])
              (* if the value of the second operand is zero, the behavior is undefined. *)
              (C.Eif (C.Eop C.OpEq (C.Esym a_e2) Caux.zero)
                 (C.Eundef Undefined.Division_by_zero)
                 (C.Eop C.OpDiv core_e1' core_e2')
              )
      
      | A.Binary e1 (A.Arithmetic A.Mod) e2 ->
          E.fresh_symbol >>= fun a_e1    ->
          E.fresh_symbol >>= fun a_e2    ->
          f e1           >>= fun core_e1 ->
          f e2           >>= fun core_e2 ->
          (* TODO[check] usual arithmetic conversions *)
          let core_e1' = usual_arithmetic_conv (C.Esym a_e1) (exp_type_of e1) (exp_type_of e2) in
          let core_e2' = usual_arithmetic_conv (C.Esym a_e2) (exp_type_of e1) (exp_type_of e2) in
          
          (* TODO[check]: When integers are divided, the result of the / operator is the algebraic
                          quotient with any fractional part discarded.105) If the quotient a/b is
                          representable, the expression (a/b)*b + a%b shall equal a; otherwise, the
                          behavior of both a/b and a%b is undefined. *)
          return $
            C.Ewseq [Some a_e1; Some a_e2] (Caux.mk_unseq [core_e1; core_e2])
              (* if the value of the second operand is zero, the behavior is undefined. *)
              (C.Eif (C.Eop C.OpEq (C.Esym a_e2) Caux.zero)
                 (C.Eundef Undefined.Modulo_by_zero)
                 (C.Eop C.OpMod core_e1' core_e2')
              )
      
      | A.Binary e1 (A.Arithmetic A.Add) e2 ->
          let ctype_e1 = exp_type_of e1 in
          let ctype_e2 = exp_type_of e2 in
          E.fresh_symbol >>= fun a_e1    ->
          E.fresh_symbol >>= fun a_e2    ->
          f e1           >>= fun core_e1 ->
          f e2           >>= fun core_e2 ->
          
          if AilTypesAux.arithmetic ctype_e1 && AilTypesAux.arithmetic ctype_e2 then
            (* (ยง6.5.6#4) If both operands have arithmetic type, the usual arithmetic conversions are
                          performed on them. *)
            let common_ty = Option.from_some $ AilTypesAux.usual_arithmetic tmp_implementation (exp_type_of e1) (exp_type_of e2) in
            let conv_e1 = conv_int [Caux.mk_ctype common_ty; C.Esym a_e1] in
            let conv_e2 = conv_int [Caux.mk_ctype common_ty; C.Esym a_e2] in
            
            return $
              C.Ewseq [Some a_e1; Some a_e2] (Caux.mk_unseq [core_e1; core_e2])
                (if AilTypesAux.is_signed_integer_type (exp_type_of a_expr) then
                   (* if the return type is signed, then there is an undefined behaviour
                      in the presence of an arithmetic overflow *)
                   overflow [Caux.mk_ctype (exp_type_of a_expr); C.Eop C.OpAdd conv_e1 conv_e2]
                 else
                   (* otherwise, bring back the value from Z to the result type *)
                   conv_int [Caux.mk_ctype (exp_type_of a_expr); C.Eop C.OpAdd conv_e1 conv_e2])
          else
            (* otherwise, we have some pointer arithmetic *)
            E.fresh_symbol        >>= fun a_e1    ->
            E.fresh_symbol        >>= fun a_e2    ->
            E.fresh_symbol        >>= fun a_shift ->
            f e1 >>= fun core_e1 ->
            f e2 >>= fun core_e2 ->
            
            if AilTypesAux.pointer (exp_type_of e1) then
              (* TODO: temporary hack *)
              return $
                C.Esseq [Some a_e1; Some a_e2] (Caux.mk_unseq [core_e1; core_e2])
                  (C.Elet a_shift (C.Eshift a_e1 (C.Eop C.OpMul (C.Esym a_e2) (C.sizeof $ Caux.mk_ctype (exp_type_of e1))))
                     (C.Esseq [] (C.Esame (C.Esym a_e1) (C.Esym a_shift))
                        (C.Esym a_shift)))
            else
              Boot.assert_false "[Translation.translate_expression] #A.BINARY (A.ARITHMETIC A.ADD) e1 e2 <pointer case>: TODO"
      
      | A.Binary e1 (A.Arithmetic A.Sub) e2 ->
          if AilTypesAux.arithmetic (exp_type_of e1) && AilTypesAux.arithmetic (exp_type_of e2) then
            E.fresh_symbol >>= fun a_e1     ->
            E.fresh_symbol >>= fun a_e2     ->
            f e1           >>= fun core_e1  ->
            f e2           >>= fun core_e2  ->
            E.fresh_symbol >>= fun a_sub    ->
            let sub_ctx x =
              C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
                (C.Elet a_sub (C.Eop C.OpSub (C.Esym a_e1) (C.Esym a_e2))
                   x) in
            if AilTypesAux.is_signed_integer_type (exp_type_of a_expr) then
              return $ sub_ctx (overflow [Caux.mk_ctype (exp_type_of a_expr); C.Esym a_sub])
            else
              return $ sub_ctx (conv_int [Caux.mk_ctype (exp_type_of a_expr); C.Esym a_sub])
          
          else (*if T.is_integer_type (Annotate.exp_type_of e2) then*)
            (* Pointer arithmetic. *)
            (* TODO: pointer arith *)
            Boot.assert_false "[Translation.translate_expression] #A.BINARY (A.ARITHMETIC A.SUB) e1 e2 <pointer case>: TODO"
      
      | A.Binary e1 (A.Arithmetic A.Shl) e2 -> (* DONE (check) *)
          E.fresh_symbol             >>= fun a_e1          ->
          E.fresh_symbol             >>= fun a_e2          ->
          E.fresh_symbol             >>= fun a_res         ->
          f e1      >>= fun core_e1       ->
          f e2      >>= fun core_e2       ->
          
          return $
            C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
            (* if a_e2 < 0 then undef *)
            (C.Eif (C.Eop C.OpLt (C.Esym a_e2) Caux.zero)
               (C.Eundef Undefined.Negative_shift)
            
            (* if width{ty} <= a_e2 then undef *)
            (* TODO: [ty] should be the promoted type of [e1] *)
            (C.Eif (C.Eop C.OpOr (C.Eop C.OpLt (ctype_width [Caux.mk_ctype ty]) (C.Esym a_e2))
                                 (C.Eop C.OpEq (ctype_width [Caux.mk_ctype ty]) (C.Esym a_e2))) (* TODO: check the test about the width *)
               (C.Eundef Undefined.Shift_too_large)
            
            (* else [...] *)
               (if AilTypesAux.is_unsigned_integer_type (ctype_of e1) then
                  (* mod (a_e1 * exp(2, a_e2)) (max{ty}+1) *)
                   C.Eop C.OpMod (C.Eop C.OpMul (C.Esym a_e1) (exp [C.Econst (C.Cint $ Int.int 2); C.Esym a_e2]))
                                 (C.Eop C.OpAdd (C.ctype_max $ Caux.mk_ctype ty) Caux.one)
                else (* e1 has a signed type *)
                  (* if a_e2 < 0 then undef *)
                  (C.Eif (C.Eop C.OpLt (C.Esym a_e2) Caux.zero)
                     (C.Eundef Undefined.Negative_left_shift)
                     (* let a_res = mod (a_e1 * exp(2, a_e2)) (max{ty}+1) in [...] *)
                     (C.Elet a_res (C.Eop C.OpMod (C.Eop C.OpMul (C.Esym a_e1) (exp [C.Econst (C.Cint $ Int.int 2); C.Esym a_e2]))
                                                  (C.Eop C.OpAdd (C.ctype_max $ Caux.mk_ctype ty) Caux.one))
                        (* not representable(ty, a_res) then undef *)
                        (C.Eif (C.Enot (is_representable [Caux.mk_ctype ty; C.Esym a_res]))
                           (C.Eundef Undefined.Negative_left_shift)
                        (* else  *)
                           (C.Esym a_res)
                        )
                     )
                  )
               )
            )
            )
      
      | A.Binary e1 (A.Arithmetic A.Shr) e2 -> 
          Boot.assert_false "[Translation.translate_expression] #A.BINARY (A.ARITHMETIC A.SHR) e1 e2: TODO(has an implementation defined case)"
      
      | A.Binary e1 (A.Arithmetic A.Band) e2 ->
          Boot.assert_false "[Translation.translate_expression] #A.BINARY (A.ARITHMETIC A.BAND) e1 e2: TODO(has an implementation defined case)"
      
      | A.Binary e1 (A.Arithmetic A.Xor) e2 ->
          Boot.assert_false "[Translation.translate_expression] #A.BINARY (A.ARITHMETIC A.XOR) e1 e2: TODO(has an implementation defined case)"
      
      | A.Binary e1 (A.Arithmetic A.Bor) e2 ->
          Boot.assert_false "[Translation.translate_expression] #A.BINARY (A.ARITHMETIC A.BOR) e1 e2: TODO(has an implementation defined case)"
      
      | A.Binary e1 A.Comma e2 ->
          f e1 >>= fun core_e1 ->
          f e2 >>= fun core_e2 ->
          return $ C.Esseq [] core_e1 core_e2
      
      | A.Binary e1 A.And e2 ->
          E.fresh_symbol >>= fun a_e1    ->
          E.fresh_symbol >>= fun a_e2    ->
          f e1           >>= fun core_e1 ->
          f e2           >>= fun core_e2 ->
          return $
            C.Ewseq [Some a_e1] core_e1
              (C.Eif (C.Eop C.OpEq (C.Esym a_e1) Caux.zero)
                     Caux.zero
                     (C.Ewseq [Some a_e2] core_e2
                       (C.Eif (C.Eop C.OpEq (C.Esym a_e2) Caux.zero) Caux.zero Caux.one)
                     )
              )
      
      | A.Binary e1 A.Or e2 ->
          E.fresh_symbol >>= fun a_e1    ->
          E.fresh_symbol >>= fun a_e2    ->
          f e1           >>= fun core_e1 ->
          f e2           >>= fun core_e2 ->
          return $
            C.Ewseq [Some a_e1] core_e1
              (C.Eif (C.Enot (C.Eop C.OpEq (C.Esym a_e1) Caux.zero))
                     Caux.one
                     (C.Ewseq [Some a_e2] core_e2
                       (C.Eif (C.Eop C.OpEq (C.Esym a_e2) Caux.zero) Caux.zero Caux.one)
                     )
              )
      
      | A.Binary e1 A.Lt e2 ->
          if AilTypesAux.arithmetic (exp_type_of e1) && AilTypesAux.arithmetic (exp_type_of e2) then
            E.fresh_symbol >>= fun a_e1    ->
            E.fresh_symbol >>= fun a_e2    ->
            f e1           >>= fun core_e1 ->
            f e2           >>= fun core_e2 ->
            let common_ty = Option.from_some $ AilTypesAux.usual_arithmetic tmp_implementation (exp_type_of e1) (exp_type_of e2) in
            let conv_e1 = conv_int [Caux.mk_ctype common_ty; C.Esym a_e1] in
            let conv_e2 = conv_int [Caux.mk_ctype common_ty; C.Esym a_e2] in
            return $
              C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
                (C.Eif (C.Eop C.OpLt conv_e1 conv_e2) Caux.one Caux.zero)
          else
            Boot.assert_false "[Translation.translate_expression] #A.BINARY A.LT e1 e2 <pointers case>: TODO"
      
      | A.Binary e1 A.Gt e2 ->
          if AilTypesAux.arithmetic (exp_type_of e1) && AilTypesAux.arithmetic (exp_type_of e2) then
            E.fresh_symbol >>= fun a_e1    ->
            E.fresh_symbol >>= fun a_e2    ->
            f e1           >>= fun core_e1 ->
            f e2           >>= fun core_e2 ->
            return $
              C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
                (C.Eif (C.Enot (C.Eop C.OpOr (C.Eop C.OpLt (C.Esym a_e1) (C.Esym a_e2)) (C.Eop C.OpEq (C.Esym a_e1) (C.Esym a_e2))))
                   Caux.one
                   Caux.zero
                )
          else
            Boot.assert_false "[Translation.translate_expression] #A.BINARY A.LT e1 e2 <pointers case>: TODO"
      
      | A.Binary e1 A.Le e2 ->
          if AilTypesAux.arithmetic (exp_type_of e1) && AilTypesAux.arithmetic (exp_type_of e2) then
            E.fresh_symbol >>= fun a_e1    ->
            E.fresh_symbol >>= fun a_e2    ->
            f e1           >>= fun core_e1 ->
            f e2           >>= fun core_e2 ->
            return $
              C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
                (C.Eif (C.Eop C.OpOr (C.Eop C.OpLt (C.Esym a_e1) (C.Esym a_e2)) (C.Eop C.OpEq (C.Esym a_e1) (C.Esym a_e2)))
                       Caux.one
                       Caux.zero
                )
          else (* MUST BE: both operands are pointers to qualified or unqualified versions of compatible object types. *)
            Boot.assert_false "[Translation.translate_expression] #A.BINARY A.LE e1 e2 <pointers case>: TODO"
    
      (* TODO: not doing the typing stuff for now *)
      | A.Binary e1 A.Ge e2 ->
          if AilTypesAux.arithmetic (exp_type_of e1) && AilTypesAux.arithmetic (exp_type_of e2) then
            E.fresh_symbol >>= fun a_e1    ->
            E.fresh_symbol >>= fun a_e2    ->
            f e1           >>= fun core_e1 ->
            f e2           >>= fun core_e2 ->
            return $
              C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
                (C.Eif (C.Eop C.OpLt (C.Esym a_e2) (C.Esym a_e1))
                       Caux.one
                       Caux.zero
                )
          else
            Boot.assert_false "[Translation.translate_expression] #A.BINARY A.GE e1 e2 <pointers case>: TODO"
      
      | A.Binary e1 A.Eq e2 ->
          if AilTypesAux.arithmetic (exp_type_of e1) && AilTypesAux.arithmetic (exp_type_of e2) then
            E.fresh_symbol >>= fun a_e1    ->
            E.fresh_symbol >>= fun a_e2    ->
            f e1           >>= fun core_e1 ->
            f e2           >>= fun core_e2 ->
            return $
              C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
                (C.Eif (C.Eop C.OpEq (C.Esym a_e1) (C.Esym a_e2)) Caux.one Caux.zero)
          else if AilTypesAux.pointer (exp_type_of e1) && AilTypesAux.pointer (exp_type_of e2) then
            Boot.assert_false "[Translation.translate_expression] #A.BINARY A.EQ e1 e2 <both pointers case>: TODO"
          else if Aaux.null_pointer_constant e1 then
            Boot.assert_false "[Translation.translate_expression] #A.BINARY A.EQ e1 e2 <both pointers case, and e1 null constant>: TODO"
          else
            Boot.assert_false "[Translation.translate_expression] #A.BINARY A.EQ e1 e2 <both pointers case, and e1 NOT null constant>: TODO"
      
      | A.Binary e1 A.Ne e2 ->
          if AilTypesAux.arithmetic (exp_type_of e1) && AilTypesAux.arithmetic (exp_type_of e2) then
            E.fresh_symbol >>= fun a_e1    ->
            E.fresh_symbol >>= fun a_e2    ->
            f e1           >>= fun core_e1 ->
            f e2           >>= fun core_e2 ->
            return $
              C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
                (C.Eif (C.Eop C.OpEq (C.Esym a_e1) (C.Esym a_e2))
                       Caux.zero
                       Caux.one
                )
          else
            Boot.assert_false "[Translation.translate_expression] #A.BINARY A.NE e1 e2 <not both of arithmetic type>: TODO"
      
      | A.Assign e1 e2 ->
          E.fresh_symbol                     >>= fun a_e1    ->
          E.fresh_symbol                     >>= fun a_e2    ->
          translate_lvalue stdlib program e1 >>= fun core_e1 ->
          f e2                               >>= fun core_e2 ->
          let core_ty_e1 = Caux.mk_ctype $ AilTypesAux.pointer_conversion (snd (from_lvalue_type e1)) in
          return $
            C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
              (C.Ewseq [] (C.Eaction (C.Pos, ({}, C.Store core_ty_e1
                                                (C.Esym a_e1)
                                                (conv [Caux.mk_ctype (exp_type_of e1); Caux.mk_ctype (exp_type_of e2); C.Esym a_e2])
                                                Cmm.NA
                                             )
                                     )
                          )
                         (C.Esym a_e2))
      
      (* TODO: yes this is morally reprehensible.
         
         (std: A compound assignment of the form E1 op = E2 is equivalent to the simple assignment
         expression E1 = E1 op (E2), except that the lvalue E1 is evaluated only once, and with respect
         to an indeterminately-sequenced function call, the operation of a compound) *)
      | A.CompoundAssign e1 aop e2 ->
          Boot.assert_false "f (Annotate.type_of expr, A.Assign e1 (Annotate.type_of e2, A.Binary (A.Arithmetic aop) e1 e2))"
      
      (* TODO: conv_int on e2 and e2 !!!!!!! *)
      | A.Conditional e1 e2 e3 ->
          if AilTypesAux.arithmetic (exp_type_of e1) && AilTypesAux.arithmetic (exp_type_of e2) then
            E.fresh_symbol >>= fun a_e1    ->
            E.fresh_symbol >>= fun a_e2    ->
            E.fresh_symbol >>= fun a_e3    ->
            f e1           >>= fun core_e1 ->
            f e2           >>= fun core_e2 ->
            f e3           >>= fun core_e3 ->
            return $
              C.Ewseq [Some a_e1] core_e1
                (C.Eif (C.Eop C.OpEq (C.Esym a_e1) Caux.zero)
                       core_e2
                       core_e3)
          else
            Boot.assert_false "[Translation.translate_expression] #A.CONDTIONAL e1 e2 e3 <pointers case>: TODO"
      
      | A.Cast qs ty e ->
          E.fresh_symbol >>= fun a_e    ->
          f e            >>= fun core_e ->
          return $
            C.Ewseq [Some a_e] core_e
              (conv [Caux.mk_ctype (exp_type_of e); Caux.mk_ctype ty; C.Esym a_e])
      
      (* TODO:
           * (ยง6.5.2.2#6) since we don't support prototype-less functions, we don't do
                          "default argument promotions"
       *)
      | A.Call e es ->
          E.fresh_symbol >>= fun a_e    ->
          f e            >>= fun core_e ->
          match e with
            | A.AnnotatedExpression _ (A.Var fid) ->
                if List.length es = 0 then
                  (* if there are no arguments, we don't need all the temporary object creation stuff *)
                  return $ C.Eproc {} fid []
                else
                  let (return_ty, binds) = fst $ List.assoc fid (snd program) in
                  let n = List.length es in
                  
                  (* symbolic names for the temporary objects and init value *)
                  E.replicateM n E.fresh_symbol >>= fun as_tmp  ->
                  
                  (* create actions for the temporary objects *)
                  let core_creates =
                    List.map (fun (_, (_, ty)) -> Caux.pcreate (Caux.mk_ctype ty) []) binds in
                  
                  (* their initialisations *)
                  E.mapM (fun (a, (_, (_, ty)), e) ->
                    E.fresh_symbol >>= fun a_init ->
                    f e            >>= fun core_e ->
		    return $
                      C.Ewseq [Some a_init] core_e
		      (Caux.pstore (Caux.mk_ctype ty) (C.Esym a) (C.Esym a_init) Cmm.NA)
                  ) (zip3 as_tmp binds es) >>= fun core_inits ->
                  
                  (* their kill actions *)
                  let core_kills = List.map (Caux.pkill -| C.Esym) as_tmp in
                  
                  (* symbolic name for the call result *)
                  E.fresh_symbol >>= fun a_call ->
                  return $
                    C.Ewseq (List.map Some as_tmp) (Caux.mk_unseq core_creates)
                    (C.Ewseq [] (Caux.mk_unseq core_inits)
                       (C.Ewseq [Some a_call] (C.Eindet $ C.Eproc {} fid (List.map C.Esym as_tmp))
                          (C.Ewseq [] (Caux.mk_unseq core_kills)
                             (C.Esym a_call)
                          )
                       )
                    )
	      | _ -> Boot.assert_false "[Translation.translate_exp, A.CALL e es] a function id is declared with a non-function type"
	    end 
      
      | A.Constant (A.ConstantInteger (i, _)) ->
          return (C.Econst $ C.Cint i)
      
      
      | A.SizeOf qs (Aty.Basic (Aty.Integer Aty.Char))                 -> return Caux.one
      | A.SizeOf qs (Aty.Basic (Aty.Integer (Aty.Signed Aty.Ichar)))   -> return Caux.one
      | A.SizeOf qs (Aty.Basic (Aty.Integer (Aty.Unsigned Aty.Ichar))) -> return Caux.one
      | A.SizeOf qs ty ->
          return (C.sizeof $ Caux.mk_ctype ty)
      
      | A.AlignOf qs ty ->
          return (C.alignof $ Caux.mk_ctype ty)

(*
  TODO: need to bring them back to the new Ail
      | A.MEMBEROF e x ->
      | A.MEMBEROFPTR e x ->

      | A.EXPR_SIZEOF e ->
          return (C.sizeof $ Caux.mk_ctype (Annotate.ctype_of e))

    | A.StringLiteral lit ->

    | A.Malloc e ->
        E.fresh_symbol >>= fun a_e    ->
        f e            >>= fun core_e ->
        return $ C.Ewseq [Some a_e] core_e (Caux.palloc (C.Esym a_e) [])
    
    | A.Free e ->
        E.fresh_symbol >>= fun a_e    ->
        f e            >>= fun core_e ->
        return $ C.Ewseq [Some a_e] core_e (Caux.pkill (C.Esym a_e))
    
    | A.Memcmp e1 e2 e3 ->
    | A.Memcpy e1 e2 e3 ->
    
    | A.Assert e ->
        E.fresh_symbol >>= fun a_e    ->
        f e            >>= fun core_e ->
        return $
          C.Ewseq [Some a_e] core_e
            (C.Eif (C.Eop C.OpEq (C.Esym a_e) Caux.zero) C.Eerror C.Eskip)
    
    | A.ConstArray es ->
    | A.ConstStructUnion field_es ->
    | A.Offsetof ty x ->
*)
    end



module St = State
open St.Operators

type collect_cases_state = <|
  found_default: bool;
  cases: list AilSyntax.integerConstant
|>

val     collect_cases_: A.statement Location.t GenTypes.genTypeCategory -> St.t unit collect_cases_state
let rec collect_cases_ (A.AnnotatedStatement _ stmt) =
  let register_case n =
    St.update (fun s -> <| s with cases= n :: s.cases |>) in
  let register_default =
    St.update (fun s -> <| s with found_default= true |>) in
  match stmt with
    | A.Skip ->
        St.return ()
    | A.Expression _ ->
        St.return ()
    | A.Block _ ss ->
        St.mapM_ collect_cases_ ss
    | A.If _ s1 s2 ->
        collect_cases_ s1 >> collect_cases_ s2
    | A.While _ s ->
        collect_cases_ s
    | A.Do s _ ->
        collect_cases_ s
    | A.Break ->
        St.return ()
    | A.Continue ->
        St.return ()
    | A.ReturnVoid ->
        St.return ()
    | A.Return _ ->
        St.return ()
    | A.Switch _ _ ->
        St.return ()
    | A.Case n s ->
        register_case n >> collect_cases_ s
    | A.Default s ->
        register_default >> collect_cases_ s
    | A.Label _ s ->
        collect_cases_ s
    | A.Goto _ ->
        St.return ()
    | A.Declaration _ ->
        St.return ()
(*    | PAR of list (statement_l 'a) *)
  end


let collect_cases s =
  snd $ St.run (collect_cases_ s) <| found_default= false; cases= [] |>




open Translation_effect

(*
val     translate_stmt: C.fun_map zero -> A.program Location.t zero ->
                        option Symbol.t -> option Symbol.t -> option Symbol.t -> option Symbol.t ->
                        A.statement Location.t zero -> t (C.expr zero)
*)
let rec translate_stmt stdlib program f d_default d_cases d_loop d_break (A.AnnotatedStatement _ stmt) : t (C.expr zero) =
  let translate_stmt_ s = translate_stmt stdlib program f d_default d_cases d_loop d_break s in
  let mk_stdcall fname = mk_stdcall stdlib fname   in
  let conv_int         = mk_stdcall "conv_int" in
  match stmt with
    | A.Skip ->
        return C.Eskip
    | A.Expression e ->
        translate_expression stdlib program e
    
    | A.Block binds ss ->
        let ids = [id | forall ((id, _) MEM binds) | true] in
        let decls = [(id,ty) | forall ((id, (qs, ty)) MEM binds) | true] in
        
        (* the symbolic names and create actions for the local variables *)
        let (a_ids, core_creates) =
          mapUnzip (fun (a, ty) -> (Some a, Caux.pcreate (Caux.mk_ctype ty) [f; a])) decls in
        
        E.push_block_objects ids >>
        
        (* TODO: doing the kills here is now redundant if there is are returns before all exit point.
                 but it may be nasty to the check.
                 For non-void function however we know (?) that the must be these returns ?? so we could drop the kills here *)
        (* the kill actions for the local variables *)
        let (core_kills) =
          List.map (Caux.pkill -| C.Esym -| fst) decls in
        
(*
      E.fresh_symbol >>= fun a_last ->
      E.mapWithLastM (fun s -> translate_stmt program f d_loop d_break (a_last :: lasts) s >>= fun core_s ->
                               return ([], core_s))
                     (* TODO: adding the a_last here is pretty disgusting *)
                     (fun s -> translate_stmt program f d_loop d_break (a_last :: lasts) s >>= fun core_s ->
                               return ([Some a_last], core_s))
                     ss >>= fun a_opts_core_ss ->
*)
        E.mapM (fun s -> translate_stmt_ s >>= fun core_s -> return core_s) ss >>= fun core_ss ->
        
        E.pop_block_objects >>
        
        return
          (C.Esseq a_ids (Caux.mk_unseq core_creates)
             (List.fold_right (fun core_s acc -> C.Esseq [] core_s acc) core_ss (Caux.mk_unseq core_kills))
          )
(*

(*      (* add the block local variables to the environment (fresh symbolic names are assigned) *)
      update_env env ids >>= fun env' ->
*)
      let n     = List.length decls in

      (* prepare the code creating the objects for the block local variables. *)
      let creates_ctx: C.expr zero -> C.expr zero =
        let (syms, xs) = mapUnzip (fun (a, ty) -> (Some a, Caux.pcreate (Caux.mk_ctype ty) [])) (List.rev decls) in
        match n with
          | 0 -> fun x -> x
          | 1 -> C.Ewseq syms (List.hd xs)
          | _ -> C.Ewseq syms (C.Eunseq xs)
        end in
      
      (* prepare the code killing the objects. *)
      let kills_ctx = let xs = List.map (fun (a, _) -> Caux.pkill (C.Esym a)) decls in
                      match n with
                        | 0 -> fun x -> x
                        | 1 -> C.Ewseq [] (List.hd xs)
                        | _ -> C.Ewseq [] (C.Eunseq xs)
                      end in
      
      (* translate the statements with a symbolic name bound to the result of the last statement *)
      E.fresh_symbol >>= fun a_last ->
      E.mapWithLastM (fun s -> translate_stmt_ s >>= fun core_s ->
                               return ([], core_s))
                     (fun s -> translate_stmt_ s >>= fun core_s ->
                               return ([Some a_last], core_s))
                     ss >>= fun core_ss ->
      
      (* connecting everything an returning that symbolic name bounded to the result of last statement *)
      return $ creates_ctx
                 (List.fold_left (fun acc (_as, stmt) ->
                   if Caux.is_pure stmt then (match _as with
                                | [Some a] -> C.Elet a stmt acc
                                | []       -> acc
                                | _  -> Boot.outOfHomeomorphism "BOOM" end)
                   else C.Ewseq _as stmt acc)
                    (kills_ctx (if List.length ss = 0 then C.Eskip else C.Esym a_last))
                    (List.rev core_ss))

*)  



    | A.If e s1 s2 ->
        E.fresh_symbol                        >>= fun a_test  ->
        translate_expression stdlib program e >>= fun core_e  ->
        translate_stmt_ s1                    >>= fun core_s1 ->
        translate_stmt_ s2                    >>= fun core_s2 ->
        return $ C.Ewseq [Some a_test] core_e
                   (C.Eif (C.Enot (C.Eop C.OpEq (C.Esym a_test) Caux.zero)) core_s1 core_s2)
    
    | A.While e s ->
        E.fresh_symbol                                                                   >>= fun a_e     ->
        E.fresh_named_symbol "loop"                                                      >>= fun d_loop  ->
        E.fresh_named_symbol "break"                                                     >>= fun d_break ->
        translate_expression stdlib program e                                            >>= fun core_e  ->
        translate_stmt stdlib program f d_default d_cases (Some d_loop) (Some d_break) s >>= fun core_s  ->
        E.get_visible_objects                                                            >>= fun _as     ->
        (* TODO: the types of the annotations in Esave are dummy, but this is not observable for now *)
        return $
          C.Esave d_loop [ (a, C.Void)  | forall (a MEM _as) | true ]
            (C.Esseq [Some a_e] core_e
               (C.Eif (C.Enot (C.Eop C.OpEq (C.Esym a_e) Caux.zero))
                  (C.Esseq [] core_s (C.Erun {} d_loop [ (a, C.Esym a) | forall (a MEM _as) | true ]))
                  (C.Esave d_break [ (a, C.Void)  | forall (a MEM _as) | true ] C.Eskip)
               )
            )
    
    | A.Do s e ->
        E.fresh_symbol                                                                   >>= fun d_loop  ->
        E.fresh_symbol                                                                   >>= fun d_break ->
        translate_stmt stdlib program f d_default d_cases (Some d_loop) (Some d_break) s >>= fun core_s  ->
        translate_expression stdlib program e                                            >>= fun core_e  ->
        E.fresh_symbol                                                                   >>= fun a       ->
        E.get_visible_objects                                                            >>= fun _as     ->
        (* TODO: the types of the annotations in Esave are dummy, but this is not observable for now *)
        return $
          C.Esave d_loop [ (a, C.Void)  | forall (a MEM _as) | true ]
            (C.Esseq [] core_s
               (C.Esseq [Some a] core_e
                  (C.Eif (C.Eop C.OpEq (C.Esym a) Caux.zero)
                     (C.Esave d_break [ (a, C.Void)  | forall (a MEM _as) | true ] C.Eskip)
                     (C.Erun {} d_loop [ (a, C.Esym a) | forall (a MEM _as) | true ])
                  )
               )
            )
    
    | A.Break ->
        E.get_visible_objects >>= fun _as ->
        return (C.Erun {} (from_Some d_break) [ (a, C.Esym a) | forall (a MEM _as) | true ])
    
    | A.Continue ->
        E.get_visible_objects >>= fun _as ->
        return (C.Erun {} (from_Some d_loop) [ (a, C.Esym a) | forall (a MEM _as) | true ])
    
    | A.ReturnVoid ->
        E.get_visible_objects >>= fun _as ->
        let (core_kills) = List.map (Caux.pkill -| C.Esym) _as in
        return (C.Esseq [] (Caux.mk_unseq core_kills) (C.Eret C.Eskip))
    
    | A.Return e ->
        translate_expression stdlib program e >>= fun core_e ->
        let A.AnnotatedExpression ty _ = e in
        let (return_ty, _) = fst $ List.assoc f (snd program) in
        E.fresh_symbol           >>= fun a_e ->
        E.get_visible_objects    >>= fun _as ->
        let (core_kills) = List.map (Caux.pkill -| C.Esym) _as in
        return $
          C.Esseq [Some a_e] core_e
            (C.Esseq [] (Caux.mk_unseq core_kills)
               (C.Eret (conv_int [Caux.mk_ctype return_ty; C.Esym a_e]))
            )
    
    (* Need to do the promotions *)
    (* TODO: the types of the annotations in Esave are dummy, but this is not observable for now *)
    | A.Switch e s ->
        translate_expression stdlib program e >>= fun core_e ->
        E.fresh_symbol                        >>= fun a_e    ->
        (* TODO: should properly interpret the integer constants *)
        let ((found_default, ns) : bool * list int) =
          let x = collect_cases s in
          (x.found_default, List.map (fun (z, _) -> z) x.cases) in
        E.replicateM (List.length ns) (E.fresh_named_symbol "case") >>= fun (ds : list C.ksym) ->
        let d_cases' = List.fold_left (fun acc (n, d) ->
          Pmap.add n d acc) Pmap.empty (List.combine ns ds) in
        E.fresh_named_symbol "default" >>= fun d_default' ->
        (if found_default then
          E.fresh_named_symbol "break"
        else
            return d_default') >>= fun d_break' ->
        E.get_visible_objects  >>= fun _as      ->
        let run_as = [ (a, C.Esym a) | forall (a MEM _as) | true ] in
        translate_stmt stdlib program f (Some d_default') (Some d_cases') d_loop (Some d_break') s >>= fun core_s ->
        return $
          C.Ewseq [Some a_e] core_e
            (List.fold_left (fun acc (n, d) ->
              C.Eif (C.Eop C.OpEq (C.Esym a_e) (C.Econst $ C.Cint n))
                (C.Erun {} d run_as)
                acc
             )
               (C.Ewseq [] (C.Erun {} d_default' run_as)
                  (C.Ewseq [] core_s
                     (C.Esave d_break' [ (a, C.Void) | forall (a MEM _as) | true ] C.Eskip)
                  )
               )
               $ Pmap.bindings d_cases')
    
    (* Need to do the promotions *)
    | A.Case n s ->
        translate_stmt_ s     >>= fun core_s ->
        E.get_visible_objects >>= fun _as    ->
        (* TODO: should properly interpret the integer constant *)
        return (C.Esave (Pmap.find ((fun (z, _) -> z) n) (from_Some d_cases)) [ (a, C.Void) | forall (a MEM _as) | true ] core_s)
    
    | A.Default s ->
        translate_stmt_ s     >>= fun core_s ->
        E.get_visible_objects >>= fun _as    ->
        return (C.Esave (from_Some d_default) [ (a, C.Void)  | forall (a MEM _as) | true ] core_s)
    
    | A.Label l s ->
        translate_stmt_ s     >>= fun core_s ->
        E.get_visible_objects >>= fun _as    ->
        (* TODO: the types of the annotations in Esave are dummy, but this is not observable for now *)
        return (C.Esave l [ (a, C.Void)  | forall (a MEM _as) | true ] core_s)
    
    | A.Goto l ->
        E.get_visible_objects >>= fun _as ->
        return (C.Erun {} l [ (a, C.Esym a) | forall (a MEM _as) | true ])
    
    | A.Declaration [] ->
        return C.Eskip
    
    | A.Declaration defns ->
        (* This pass translate the declarations *)
        E.mapM (fun (id, e) ->
          E.fresh_symbol                        >>= fun a      ->
          translate_expression stdlib program e >>= fun core_e ->
          return $ C.Esseq [Some a] core_e
                       (Caux.pstore (Caux.mk_ctype (exp_type_of e)) (C.Esym id) (conv_int [Caux.mk_ctype (exp_type_of e); C.Esym a]) Cmm.NA)
        ) defns >>=
        
        (* This pass combine the translated declerations *)
        E.foldl1M (fun x y -> return  $ Caux.concat_sseq x y)
  

(*
  TODO: need to bring them back to the new Ail

  | A.PAR ss ->
      E.mapM (translate_stmt_) ss >>= fun core_ss ->
      return $ C.Eunseq core_ss
*)
  end


(* Run the translator on different functions *)
val translate_program: C.fun_map zero -> A.program Location.t GenTypes.genTypeCategory -> t (C.fun_map zero)
let translate_program stdlib program =
  E.foldlM (fun acc (fun_id, ((_, fun_args), fun_body)) ->
    (* making the argument variables visible *)
    E.push_block_objects (List.map fst fun_args) >>
    
    (* translate the body to Core *)
    translate_stmt stdlib program fun_id None None None None fun_body >>= fun core_body ->
    (* removing the argument variables from the "visibles" *)
    E.pop_block_objects >>
    (return $ Pmap.add fun_id (
                                C.TyEffect C.Integer (* TODO: this should de address for pointer type *),
                                List.map (fun (arg, _) -> (arg, C.Address (* TODO: check *))) fun_args,
                                core_body
                               ) acc)
  ) Pmap.empty (snd program)


(* This is the entry function (called from main.ml) *)
val translate: C.fun_map zero -> C.impl zero -> A.program Location.t GenTypes.genTypeCategory -> C.file zero
let translate stdlib impl prog =
  (* TODO: this is ugly, we shouldn't expose the internals and properly use the Undefined *)
  match (translate_program stdlib prog) E.init with
    | U.Defined (cfuns, _) -> <| C.main= fst prog; C.stdlib= stdlib; C.impl= impl; C.funs= cfuns |>
    | _                    -> Boot.assert_false "[Translation.translate #_] error in the elaboration"
  end
