open Global

open Implementation

module A    = Ail
module C    = Core
module Caux = Core_aux
module T    = Ail_typing_aux
module U    = Undefined

open Translation_effect
open Translation_aux

(* TODO: now everything is mapped to nonatomics. The translation to atomics still
   needs to be defined *)

(* val     translate_lvalue: C.file ->  *)
let rec translate_lvalue stdlib file exp =
  let f = translate_expr stdlib file in
  match Annotate.exp_of exp with
    (* TODO: may be temporary *)
    | A.NULL -> return C.Enull

    | A.VARIABLE id -> return (C.Esym id)
    
    | A.UNARY A.INDIRECTION e ->
        E.fresh_symbol       >>= fun a_e    ->
        f e >>= fun core_e ->
        (* TODO: the checks *)
        return core_e
(*
    | A.UNARY A.INDIRECTION e ->
        f e >>= fun (a, m) ->
        let t = T.base_of_pointer (T.pointer_convert (Annotate.exp_type_of e)) in
        let ill_aligned = C.neg (Tc.is_aligned t a) in
        let null = C.eq a C.null in
        let c = C.implies (C.disj null ill_aligned) C.undef in
        return (a, m +& c)


    | _ ->
        C.fresh >>= fun a ->
        return (a, Me.null)
*)

   (* ------------------------------------------------------------------------------------------- *)
  end 



and translate_function_designator expr =
  match Annotate.exp_of expr with
    | A.VARIABLE fid -> return $ C.Econst (C.Cfunction fid)
  end







(* ---------------------------------------------------------------------------------------------- *)

and translate_expr stdlib file expr =
  let f e = translate_expr stdlib file e in
  let mk_stdcall fname = mk_stdcall stdlib fname in
  (* TODO: this is silly *)
  let conv             = mk_stdcall "conv"             in
  let conv_int         = mk_stdcall "conv_int"         in
  let overflow         = mk_stdcall "overflow"         in
  let ctype_width      = mk_stdcall "ctype_width"      in
  let exp              = mk_stdcall "exp"              in
  let is_representable = mk_stdcall "is_representable" in
  let usual_arithmetic = mk_stdcall "usual_arithmetic" in
  
  (* TODO: see if this right
       usual_arithmetic_conv e ty1 ty2 == performed the value conversion on the expression of type ty1 following the usual arith of ty1 and ty2
   *)
  let usual_arithmetic_conv e ty1 ty2 =
    conv [Caux.mk_ctype ty1; usual_arithmetic [Caux.mk_ctype ty1; Caux.mk_ctype ty2]; e] in
  
  
  let ty = Annotate.ctype_of expr in
  match Annotate.exp_of expr with
    (* DONE *)
    | A.NULL ->
        return C.Enull
    
    | A.STRING_LITERAL lit ->
        Boot.assert_false "TODO: Translation.translate_expr A.STRING_LITERAL"
    
    (* DONE *)
    | A.UNARY A.PLUS e ->
        f e >>= fun core_e ->
        return (promote_value core_e)
    
    (* DONE *)
    | A.UNARY A.MINUS e ->
        E.fresh_symbol >>= fun a_e    ->
        f e            >>= fun core_e ->
        return $
          C.Ewseq [Some a_e] core_e
            (C.Eop C.OpSub Caux.zero (promote_value $ C.Esym a_e))
    
    (* DONE *)
    | A.UNARY A.BNOT e ->
        E.fresh_symbol >>= fun a_e    ->
        f e            >>= fun core_e ->
        return $
          C.Ewseq [Some a_e] core_e (
            if Ail_typing_aux.is_unsigned_integer_type ty then
              C.Eop C.OpSub (C.ctype_max $ Caux.mk_ctype ty) (promote_value $ C.Esym a_e)
            else
              C.bitwise_complement (promote_value $ C.Esym a_e)
          )
    
    (* DONE *)
    | A.UNARY A.ADDRESS (_, (A.UNARY A.INDIRECTION e)) ->
        f e
    
    (* DONE *)
    | A.UNARY A.ADDRESS e ->
        if Ail_typing_aux.is_object_type (Annotate.ctype_of e) then
          translate_lvalue stdlib file e
        else
          translate_function_designator e
    
    (* TODO: function designator *)
    | A.UNARY A.INDIRECTION e ->
        (* TODO: temporary hack  *)
        E.fresh_symbol       >>= fun a_e    ->
        f e >>= fun core_e ->
        (* shouldn't be a real load ? *)
        return $ C.Ewseq [Some a_e] core_e
                     (Caux.pload (Caux.mk_ctype ty) (C.Esym a_e) Cmm.NA)
    









    
    | A.UNARY A.POSTFIX_INCR e ->
        E.fresh_symbol                 >>= fun a_lvalue ->
        E.fresh_symbol                 >>= fun a_load   ->
        translate_lvalue stdlib file e >>= fun core_e   ->
        return $
          C.Ewseq [Some a_lvalue] core_e
            (C.Easeq (Some a_load)
               ({}, C.Load (Caux.mk_ctype (Annotate.lvalue_type_of e)) (C.Esym a_lvalue) Cmm.NA)
               (C.Neg, ({}, C.Store (Caux.mk_ctype (Annotate.lvalue_type_of e))
                                      (C.Esym a_lvalue)
                                      (conv_int [Caux.mk_ctype (Annotate.exp_type_of e); (C.Eop C.OpAdd (C.Esym a_load) Caux.one)])
                                      Cmm.NA
                                    ))
            )
    
    (* TODO: "atomicity" of the load-store pair *)
    | A.UNARY A.POSTFIX_DECR e ->
        E.fresh_symbol          >>= fun a_lvalue ->
        E.fresh_symbol          >>= fun a_load   ->
        translate_lvalue stdlib file e >>= fun core_e   ->
        return $
          C.Ewseq [Some a_lvalue] core_e
            (C.Ewseq [Some a_load] (Caux.pload (Caux.mk_ctype (Annotate.lvalue_type_of e)) (C.Esym a_lvalue) Cmm.NA)
               (C.Ewseq [] (Caux.pstore (Caux.mk_ctype (Annotate.lvalue_type_of e))
                                        (C.Esym a_lvalue)
                                        (conv_int [Caux.mk_ctype (Annotate.exp_type_of e); (C.Eop C.OpSub (C.Esym a_load) Caux.one)])
                                        Cmm.NA
                           )
                  (C.Esym a_load)
               )
            )
    
    (* TODO: check *)
    | A.BINARY (A.ARITHMETIC A.MUL) e1 e2 ->
        E.fresh_symbol        >>= fun a_e1     ->
        E.fresh_symbol        >>= fun a_e2     ->
        f e1 >>= fun core_e1  ->
        f e2 >>= fun core_e2  ->
        E.fresh_symbol        >>= fun a_mul    ->
        let mul_ctx x =
          C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
            (C.Elet a_mul (C.Eop C.OpMul (C.Esym a_e1) (C.Esym a_e2))
               x) in
        if T.is_signed_integer_type (Annotate.exp_type_of expr) then
          return $ mul_ctx (overflow [Caux.mk_ctype (Annotate.exp_type_of expr); C.Esym a_mul])
        else
          return $ mul_ctx (conv_int [Caux.mk_ctype (Annotate.exp_type_of expr); C.Esym a_mul])
    
    (* TODO *)
    | A.BINARY (A.ARITHMETIC A.DIV) e1 e2 ->
        E.fresh_symbol        >>= fun a_e1    ->
        E.fresh_symbol        >>= fun a_e2    ->
        f e1 >>= fun core_e1 ->
        f e2 >>= fun core_e2 ->
        (* TODO[check] usual arithmetic conversions *)
        let core_e1' = usual_arithmetic_conv (C.Esym a_e1) (Annotate.exp_type_of e1) (Annotate.exp_type_of e2) in
        let core_e2' = usual_arithmetic_conv (C.Esym a_e2) (Annotate.exp_type_of e1) (Annotate.exp_type_of e2) in
        
        (* TODO[check]: When integers are divided, the result of the / operator is the algebraic
                        quotient with any fractional part discarded.105) If the quotient a/b is
                        representable, the expression (a/b)*b + a%b shall equal a; otherwise, the
                        behavior of both a/b and a%b is undefined. *)
        return $
          C.Ewseq [Some a_e1; Some a_e2] (Caux.mk_unseq [core_e1; core_e2])
            (* if the value of the second operand is zero, the behavior is undefined. *)
            (C.Eif (C.Eop C.OpEq (C.Esym a_e2) Caux.zero)
               (C.Eundef Undefined.Division_by_zero)
               (C.Eop C.OpDiv core_e1' core_e2')
            )
    
    (* TODO: check *)
    | A.BINARY (A.ARITHMETIC A.MOD) e1 e2 ->
        E.fresh_symbol        >>= fun a_e1    ->
        E.fresh_symbol        >>= fun a_e2    ->
        f e1 >>= fun core_e1 ->
        f e2 >>= fun core_e2 ->
        (* TODO[check] usual arithmetic conversions *)
        let core_e1' = usual_arithmetic_conv (C.Esym a_e1) (Annotate.exp_type_of e1) (Annotate.exp_type_of e2) in
        let core_e2' = usual_arithmetic_conv (C.Esym a_e2) (Annotate.exp_type_of e1) (Annotate.exp_type_of e2) in
        
        (* TODO[check]: When integers are divided, the result of the / operator is the algebraic
                        quotient with any fractional part discarded.105) If the quotient a/b is
                        representable, the expression (a/b)*b + a%b shall equal a; otherwise, the
                        behavior of both a/b and a%b is undefined. *)
        return $
          C.Ewseq [Some a_e1; Some a_e2] (Caux.mk_unseq [core_e1; core_e2])
            (* if the value of the second operand is zero, the behavior is undefined. *)
            (C.Eif (C.Eop C.OpEq (C.Esym a_e2) Caux.zero)
               (C.Eundef Undefined.Modulo_by_zero)
               (C.Eop C.OpMod core_e1' core_e2')
            )

    (* TODO *)
    | A.BINARY (A.ARITHMETIC A.ADD) e1 e2 ->
        let ctype_e1 = Annotate.exp_type_of e1 in
        let ctype_e2 = Annotate.exp_type_of e2 in
        E.fresh_symbol          >>= fun a_e1     ->
        E.fresh_symbol          >>= fun a_e2     ->
        f e1   >>= fun core_e1  ->
        f e2   >>= fun core_e2  ->
        
        if T.is_arithmetic_type ctype_e1 && T.is_arithmetic_type ctype_e2 then
          (* (§6.5.6#4) If both operands have arithmetic type, the usual arithmetic conversions are
                        performed on them. *)
          let common_ty = T.usual_arithmetic (Annotate.exp_type_of e1) (Annotate.exp_type_of e2) in
(*
          let conv_e1 = conv [Caux.mk_ctype (Annotate.exp_type_of e1); Caux.mk_ctype (Annotate.exp_type_of exp); C.Esym a_e1] in
          let conv_e2 = conv [Caux.mk_ctype (Annotate.exp_type_of e2); Caux.mk_ctype (Annotate.exp_type_of exp); C.Esym a_e2] in
*)
          let conv_e1 = conv_int [Caux.mk_ctype common_ty; C.Esym a_e1] in
          let conv_e2 = conv_int [Caux.mk_ctype common_ty; C.Esym a_e2] in
          
          return $
            C.Ewseq [Some a_e1; Some a_e2] (Caux.mk_unseq [core_e1; core_e2])
              (if T.is_signed_integer_type (Annotate.exp_type_of expr) then
                 (* if the return type is signed, then there is an undefined behaviour
                    in the presence of an arithmetic overflow *)
                 overflow [Caux.mk_ctype (Annotate.exp_type_of expr); C.Eop C.OpAdd conv_e1 conv_e2]
               else
                 (* otherwise, bring back the value from Z to the result type *)
                 conv_int [Caux.mk_ctype (Annotate.exp_type_of expr); C.Eop C.OpAdd conv_e1 conv_e2])
        else
          (* otherwise, we have some pointer arithmetic *)
          E.fresh_symbol        >>= fun a_e1    ->
          E.fresh_symbol        >>= fun a_e2    ->
          E.fresh_symbol        >>= fun a_shift ->
          f e1 >>= fun core_e1 ->
          f e2 >>= fun core_e2 ->

          if T.is_pointer_type (Annotate.exp_type_of e1) then
            (* TODO: temporary hack *)
            return $
              C.Esseq [Some a_e1; Some a_e2] (Caux.mk_unseq [core_e1; core_e2])
                (C.Elet a_shift (C.Eshift a_e1 (C.Eop C.OpMul (C.Esym a_e2) (C.sizeof $ Caux.mk_ctype (Annotate.exp_type_of e1))))
                   (C.Esseq [] (C.Esame (C.Esym a_e1) (C.Esym a_shift))
                      (C.Esym a_shift)))

          else
            Boot.assert_false "[Translation.translate_expr] #A.BINARY (A.ARITHMETIC A.ADD) e1 e2 <pointer case>: TODO"
      
      | A.BINARY (A.ARITHMETIC A.SUB) e1 e2 ->
          if T.is_arithmetic_type (Annotate.exp_type_of e1) && T.is_arithmetic_type (Annotate.exp_type_of e2) then
            E.fresh_symbol        >>= fun a_e1     ->
            E.fresh_symbol        >>= fun a_e2     ->
            f e1 >>= fun core_e1  ->
            f e2 >>= fun core_e2  ->
            E.fresh_symbol        >>= fun a_sub    ->
            let sub_ctx x =
              C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
                (C.Elet a_sub (C.Eop C.OpSub (C.Esym a_e1) (C.Esym a_e2))
                   x) in
            if T.is_signed_integer_type (Annotate.exp_type_of expr) then
              return $ sub_ctx (overflow [Caux.mk_ctype (Annotate.exp_type_of expr); C.Esym a_sub])
            else
              return $ sub_ctx (conv_int [Caux.mk_ctype (Annotate.exp_type_of expr); C.Esym a_sub])
          
          else (*if T.is_integer_type (Annotate.exp_type_of e2) then*)
            (* Pointer arithmetic. *)
            (* TODO: pointer arith *)
            Boot.assert_false "[Translation.translate_expr] #A.BINARY (A.ARITHMETIC A.SUB) e1 e2 <pointer case>: TODO"
    
    
    
    
    
    
    
    
    
    
   
    
    (* TODO: e1 - e2 *)
    

    | A.BINARY (A.ARITHMETIC A.SHL) e1 e2 -> (* DONE (check) *)
        E.fresh_symbol             >>= fun a_e1          ->
        E.fresh_symbol             >>= fun a_e2          ->
        E.fresh_symbol             >>= fun a_res         ->
        f e1      >>= fun core_e1       ->
        f e2      >>= fun core_e2       ->
        
        return $
          C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
          (* if a_e2 < 0 then undef *)
          (C.Eif (C.Eop C.OpLt (C.Esym a_e2) Caux.zero)
             (C.Eundef Undefined.Negative_shift)
          
          (* if width{ty} <= a_e2 then undef *)
          (* TODO: [ty] should be the promoted type of [e1] *)
          (C.Eif (C.Eop C.OpOr (C.Eop C.OpLt (ctype_width [Caux.mk_ctype ty]) (C.Esym a_e2))
                               (C.Eop C.OpEq (ctype_width [Caux.mk_ctype ty]) (C.Esym a_e2))) (* TODO: check the test about the width *)
             (C.Eundef Undefined.Shift_too_large)
          
          (* else [...] *)
             (if Ail_typing_aux.is_unsigned_integer_type (Annotate.ctype_of e1) then
                (* mod (a_e1 * exp(2, a_e2)) (max{ty}+1) *)
                 C.Eop C.OpMod (C.Eop C.OpMul (C.Esym a_e1) (exp [C.Econst (C.Cint $ Int.int 2); C.Esym a_e2]))
                               (C.Eop C.OpAdd (C.ctype_max $ Caux.mk_ctype ty) Caux.one)
              else (* e1 has a signed type *)
                (* if a_e2 < 0 then undef *)
                (C.Eif (C.Eop C.OpLt (C.Esym a_e2) Caux.zero)
                   (C.Eundef Undefined.Negative_left_shift)
                   (* let a_res = mod (a_e1 * exp(2, a_e2)) (max{ty}+1) in [...] *)
                   (C.Elet a_res (C.Eop C.OpMod (C.Eop C.OpMul (C.Esym a_e1) (exp [C.Econst (C.Cint $ Int.int 2); C.Esym a_e2]))
                                                (C.Eop C.OpAdd (C.ctype_max $ Caux.mk_ctype ty) Caux.one))
                      (* not representable(ty, a_res) then undef *)
                      (C.Eif (C.Enot (is_representable [Caux.mk_ctype ty; C.Esym a_res]))
                         (C.Eundef Undefined.Negative_left_shift)
                      (* else  *)
                         (C.Esym a_res)
                      )
                   )
                )
             )
          )
          )


    (* TODO *)
    | A.BINARY (A.ARITHMETIC A.SHR) e1 e2 -> 
        Boot.assert_false "[Translation.translate_expr] #A.BINARY (A.ARITHMETIC A.SHR) e1 e2: TODO(has an implementation defined case)"
    

    (* TODO *)
    | A.BINARY (A.ARITHMETIC A.BAND) e1 e2 ->
        Boot.assert_false "[Translation.translate_expr] #A.BINARY (A.ARITHMETIC A.BAND) e1 e2: TODO(has an implementation defined case)"
    
    

    (* TODO *)
    | A.BINARY (A.ARITHMETIC A.XOR) e1 e2 ->
        Boot.assert_false "[Translation.translate_expr] #A.BINARY (A.ARITHMETIC A.XOR) e1 e2: TODO(has an implementation defined case)"
    

    (* TODO *)
    | A.BINARY (A.ARITHMETIC A.BOR) e1 e2 ->
        Boot.assert_false "[Translation.translate_expr] #A.BINARY (A.ARITHMETIC A.BOR) e1 e2: TODO(has an implementation defined case)"
    

    | A.BINARY A.COMMA e1 e2 -> (* DONE (maybe not, be careful when mixing with assignments) *)
        f e1 >>= fun core_e1 ->
        f e2 >>= fun core_e2 ->
        return $ C.Esseq [] core_e1 core_e2
    
    

    | A.BINARY A.AND e1 e2 -> (* DONE *)
        E.fresh_symbol        >>= fun a_e1    ->
        E.fresh_symbol        >>= fun a_e2    ->
        f e1 >>= fun core_e1 ->
        f e2 >>= fun core_e2 ->
        return $
          C.Ewseq [Some a_e1] core_e1
            (C.Eif (C.Eop C.OpEq (C.Esym a_e1) Caux.zero)
                   Caux.zero
                   (C.Ewseq [Some a_e2] core_e2
                     (C.Eif (C.Eop C.OpEq (C.Esym a_e2) Caux.zero) Caux.zero Caux.one)
                   )
            )
    

    | A.BINARY A.OR e1 e2 -> (* DONE *)
        E.fresh_symbol        >>= fun a_e1    ->
        E.fresh_symbol        >>= fun a_e2    ->
        f e1 >>= fun core_e1 ->
        f e2 >>= fun core_e2 ->
        return $
          C.Ewseq [Some a_e1] core_e1
            (C.Eif (C.Enot (C.Eop C.OpEq (C.Esym a_e1) Caux.zero))
                   Caux.one
                   (C.Ewseq [Some a_e2] core_e2
                     (C.Eif (C.Eop C.OpEq (C.Esym a_e2) Caux.zero) Caux.zero Caux.one)
                   )
            )
    

    (* TODO *)
    | A.BINARY A.LT e1 e2 ->
        if T.is_arithmetic_type (Annotate.exp_type_of e1) && T.is_arithmetic_type (Annotate.exp_type_of e2) then
          E.fresh_symbol        >>= fun a_e1    ->
          E.fresh_symbol        >>= fun a_e2    ->
          f e1 >>= fun core_e1 ->
          f e2 >>= fun core_e2 ->
          return $
            C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
              (C.Eif (C.Eop C.OpLt (C.Esym a_e1) (C.Esym a_e2)) Caux.one Caux.zero)
        else
          Boot.assert_false "[Translation.translate_expr] #A.BINARY A.LT e1 e2 <pointers case>: TODO"
    
    
    (* TODO *)
    | A.BINARY A.GT e1 e2 ->
        if T.is_arithmetic_type (Annotate.exp_type_of e1) && T.is_arithmetic_type (Annotate.exp_type_of e2) then
          E.fresh_symbol        >>= fun a_e1    ->
          E.fresh_symbol        >>= fun a_e2    ->
          f e1 >>= fun core_e1 ->
          f e2 >>= fun core_e2 ->
          return $
            C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
              (C.Eif (C.Enot (C.Eop C.OpOr (C.Eop C.OpLt (C.Esym a_e1) (C.Esym a_e2)) (C.Eop C.OpEq (C.Esym a_e1) (C.Esym a_e2))))
                 Caux.one
                 Caux.zero
              )
        else
          Boot.assert_false "[Translation.translate_expr] #A.BINARY A.LT e1 e2 <pointers case>: TODO"
    
    
    (* TODO *)
    | A.BINARY A.LE e1 e2 ->
        if T.is_arithmetic_type (Annotate.exp_type_of e1) && T.is_arithmetic_type (Annotate.exp_type_of e2) then
          E.fresh_symbol        >>= fun a_e1    ->
          E.fresh_symbol        >>= fun a_e2    ->
          f e1 >>= fun core_e1 ->
          f e2 >>= fun core_e2 ->
          return $
            C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
              (C.Eif (C.Eop C.OpOr (C.Eop C.OpLt (C.Esym a_e1) (C.Esym a_e2)) (C.Eop C.OpEq (C.Esym a_e1) (C.Esym a_e2)))
                     Caux.one
                     Caux.zero
              )
        else (* MUST BE: both operands are pointers to qualified or unqualified versions of compatible object types. *)
          Boot.assert_false "[Translation.translate_expr] #A.BINARY A.LE e1 e2 <pointers case>: TODO"
    
    
    (* TODO: not doing the typing stuff for now *)
    | A.BINARY A.GE e1 e2 ->
        if T.is_arithmetic_type (Annotate.exp_type_of e1) && T.is_arithmetic_type (Annotate.exp_type_of e2) then
          E.fresh_symbol        >>= fun a_e1    ->
          E.fresh_symbol        >>= fun a_e2    ->
          f e1 >>= fun core_e1 ->
          f e2 >>= fun core_e2 ->
          return $
            C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
              (C.Eif (C.Eop C.OpLt (C.Esym a_e2) (C.Esym a_e1))
                     Caux.one
                     Caux.zero
              )
        else
          Boot.assert_false "[Translation.translate_expr] #A.BINARY A.GE e1 e2 <pointers case>: TODO"
    

    | A.BINARY A.EQ e1 e2 ->
        if T.is_arithmetic_type (Annotate.exp_type_of e1) && T.is_arithmetic_type (Annotate.exp_type_of e2) then
          E.fresh_symbol        >>= fun a_e1    ->
          E.fresh_symbol        >>= fun a_e2    ->
          f e1 >>= fun core_e1 ->
          f e2 >>= fun core_e2 ->
          return $
            C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
              (C.Eif (C.Eop C.OpEq (C.Esym a_e1) (C.Esym a_e2)) Caux.one Caux.zero)
        else if T.is_pointer_type (Annotate.exp_type_of e1) && T.is_pointer_type (Annotate.exp_type_of e2) then
          Boot.assert_false "[Translation.translate_expr] #A.BINARY A.EQ e1 e2 <both pointers case>: TODO"
        else if Ail_typing.is_null_pointer_constant e1 then
          Boot.assert_false "[Translation.translate_expr] #A.BINARY A.EQ e1 e2 <both pointers case, and e1 null constant>: TODO"
        else
          Boot.assert_false "[Translation.translate_expr] #A.BINARY A.EQ e1 e2 <both pointers case, and e1 NOT null constant>: TODO"
    
    
   (* ------------------------------------------------------------------------------------------- *)
    | A.BINARY A.NE e1 e2 ->
        if T.is_arithmetic_type (Annotate.exp_type_of e1) && T.is_arithmetic_type (Annotate.exp_type_of e2) then
          E.fresh_symbol        >>= fun a_e1    ->
          E.fresh_symbol        >>= fun a_e2    ->
          f e1 >>= fun core_e1 ->
          f e2 >>= fun core_e2 ->
          return $
            C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
              (C.Eif (C.Eop C.OpEq (C.Esym a_e1) (C.Esym a_e2))
                     Caux.zero
                     Caux.one
              )
        else
          Boot.assert_false "[Translation.translate_expr] #A.BINARY A.NE e1 e2 <not both of arithmetic type>: TODO"
    
    
   (* ------------------------------------------------------------------------------------------- *)
    | A.ASSIGN None e1 e2 ->
        E.fresh_symbol           >>= fun a_e1    ->
        E.fresh_symbol           >>= fun a_e2    ->
        translate_lvalue stdlib file e1 >>= fun core_e1 ->
        f e2 >>= fun core_e2 ->
        return $
          C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
            (C.Ewseq [] (C.Eaction (C.Pos, ({}, C.Store (Caux.mk_ctype (Annotate.lvalue_type_of e1))
                                              (C.Esym a_e1)
                                              (conv [Caux.mk_ctype (Annotate.exp_type_of e1); Caux.mk_ctype (Annotate.exp_type_of e2); C.Esym a_e2])
                                              Cmm.NA
                                           )
                                   )
                        )
                       (C.Esym a_e2))
    
    
    (* TODO: yes this is morally reprehensible.

(std: A compound assignment of the form E1 op = E2 is equivalent to the simple assignment
      expression E1 = E1 op (E2), except that the lvalue E1 is evaluated only once, and with respect
       to an indeterminately-sequenced function call, the operation of a compound) *)
    | A.ASSIGN (Some op) e1 e2 ->
      f (Annotate.type_of expr, A.ASSIGN None e1 (Annotate.type_of e2, A.BINARY (A.ARITHMETIC op) e1 e2))
      (* return (C.DEBUG "TODO: A.ASSIGN (Some _) e1 e2") *)
    
    

    (* TODO: conv_int on e2 and e2 !!!!!!! *)
    | A.CONDITIONAL e1 e2 e3 ->
        if T.is_arithmetic_type (Annotate.exp_type_of e1) && T.is_arithmetic_type (Annotate.exp_type_of e2) then
          E.fresh_symbol        >>= fun a_e1    ->
          E.fresh_symbol        >>= fun a_e2    ->
          E.fresh_symbol        >>= fun a_e3    ->
          f e1 >>= fun core_e1 ->
          f e2 >>= fun core_e2 ->
          f e3 >>= fun core_e3 ->
          return $
            C.Ewseq [Some a_e1] core_e1
              (C.Eif (C.Eop C.OpEq (C.Esym a_e1) Caux.zero)
                     core_e2
                     core_e3)
        else
          Boot.assert_false "[Translation.translate_expr] #A.CONDTIONAL e1 e2 e3 <pointers case>: TODO"
    
    
    (* ------------------------------------------------------------------------------------------ *)
    | A.CAST ty e ->
        E.fresh_symbol       >>= fun a_e    ->
        f e >>= fun core_e ->
        return $
          C.Ewseq [Some a_e] core_e
            (conv [Caux.mk_ctype (Annotate.exp_type_of e); Caux.mk_ctype ty; C.Esym a_e])
    




    (* TODO:
         * (§6.5.2.2#6) since we don't support prototype-less functions, we don't do
                        "default argument promotions"
     *)
    | A.CALL e es ->
        E.fresh_symbol >>= fun a_e    ->
        f e            >>= fun core_e ->
        match es with
          | [] ->
              (* if there are no arguments, we don't need all the temporary object creation stuff *)
              return $ C.Esseq [Some a_e] core_e (C.Eproc {} a_e [])
          | _ ->
              Boot.assert_false "TODO"
        end




(*
        match Annotate.exp_of e with
          | A.VARIABLE fid ->
              (* if there are no arguments, we don't need all the temporary object creation stuff *)
              match es with
                | [] -> return $ C.Eproc {} fid []
                | _  ->
    	            match fst $ Pmap.find fid file.A.id_map with
	              | A.FUNCTION retTy Tys ->
                          let n = List.length es in
                          
                          (* symbolic names for the temporary objects and init value *)
                          E.replicateM n E.fresh_symbol >>= fun as_tmp  ->
                          
                          (* create actions for the temporary objects *)
                          let core_creates =
                            List.map (fun ty -> Caux.pcreate (Caux.mk_ctype ty) []) Tys in
                          
                          (* their initialisations *)
                          E.mapM (fun (a, ty, e) ->
                            E.fresh_symbol       >>= fun a_init ->
                            f e >>= fun core_e ->
			    return $
                              C.Ewseq [Some a_init] core_e
			        (Caux.pstore (Caux.mk_ctype ty) (C.Esym a) (C.Esym a_init))
                          ) (zip3 as_tmp Tys es) >>= fun core_inits ->
                          
                          (* their kill actions *)
                          let core_kills = List.map (Caux.pkill -| C.Esym) as_tmp in
                          
                          (* symbolic name for the call result *)
                          E.fresh_symbol >>= fun a_call ->

                          return $
                            C.Ewseq (List.map Some as_tmp) (Caux.mk_unseq core_creates)
                              (C.Ewseq [] (Caux.mk_unseq core_inits)
                                 (C.Ewseq [Some a_call] (C.Eindet $ C.Eproc {} fid (List.map C.Esym as_tmp))
                                    (C.Ewseq [] (Caux.mk_unseq core_kills)
                                       (C.Esym a_call)
                                    )
                                 )
                              )

	            end
	    | _ -> Boot.outOfHomeomorphism "[Translation.translate_exp, A.CALL e es] a function id is declared with a non-function type"
	  end




      | _ ->
        (* TODO: looks like we need a "null" constant of type address in Core *)
        Boot.assert_false "[Translation.translate_expr] #A.CALL e es <function pointer>: TODO"
      end
*)

    
    
    
    (* *** MEMBEROF *** *)
    | A.MEMBEROF e x ->
        Boot.assert_false "[Translation.translate_expr] #A.MEMBEROF e x: TODO"
    
    
    
    (* *** MEMBEROFPTR *** *)
    | A.MEMBEROFPTR e x ->
        Boot.assert_false "[Translation.translate_expr] #A.MEMBEROFPTR e x: TODO"
    
    
    
    (* ------------------------------------------------------------------------------------------ *)
    | A.CONSTANT (A.CONST_INT (i, _, _)) -> (* DONE *)
          return (C.Econst $ C.Cint i)
    
    
    | A.CONSTANT (A.CONST_FLOAT _) -> Boot.assert_false "[Translation.translate_expr] #A.CONSTANT (A.CONST_FLOAT _): TODO"
    | A.CONSTANT (A.CONST_CHAR _) -> Boot.assert_false "[Translation.translate_expr] #A.CONSTANT (A.CONST_CHAR _): TODO"
    | A.CONSTANT (A.CONST_ENUM _)  -> Boot.assert_false "[Translation.translate_expr] #A.CONSTANT (A.CONST_ENUM _): TODO"
    
    
    (* WARNING: this is not enought (DEBUG FOR NOW) *)
    | A.VARIABLE id ->
        let (t, _) = Pmap.find id file.A.id_map in
        if T.is_function_type t then
          return (C.Econst (C.Cfunction id))
        else
          return $ Caux.pload (Caux.mk_ctype (Annotate.lvalue_type_of expr)) (C.Esym id) Cmm.NA
    
    (* TODO *)
    | A.EXPR_SIZEOF e ->
        return (C.sizeof $ Caux.mk_ctype (Annotate.ctype_of e))
    
    | A.SIZEOF (A.BASIC _ A.CHAR)                           -> return Caux.one
    | A.SIZEOF (A.BASIC _ (A.INTEGER (A.SIGNED A.ICHAR)))   -> return Caux.one
    | A.SIZEOF (A.BASIC _ (A.INTEGER (A.UNSIGNED A.ICHAR))) -> return Caux.one
    
    | A.SIZEOF ty ->
        return (C.sizeof $ Caux.mk_ctype ty)
    
    
    | A.ALIGNOF ty ->
        return (C.alignof $ Caux.mk_ctype ty)
    
    | A.MALLOC e ->
        E.fresh_symbol >>= fun a_e    ->
        f e            >>= fun core_e ->
        return $ C.Ewseq [Some a_e] core_e (Caux.palloc (C.Esym a_e) [])
    
    | A.FREE e ->
        E.fresh_symbol >>= fun a_e    ->
        f e            >>= fun core_e ->
        return $ C.Ewseq [Some a_e] core_e (Caux.pkill (C.Esym a_e))
    
    (* TODO *)
    | A.MEMCMP e1 e2 e3 ->
        Boot.assert_false "[Translation.translate_expr] #A.MEMCMP: TODO"
    
    (* TODO *)
    | A.MEMCPY e1 e2 e3 ->
        Boot.assert_false "[Translation.translate_expr] #A.MEMCPY: TODO"
    
    | A.ASSERT e ->
        E.fresh_symbol >>= fun a_e    ->
        f e            >>= fun core_e ->
        return $
          C.Ewseq [Some a_e] core_e
            (C.Eif (C.Eop C.OpEq (C.Esym a_e) Caux.zero) C.Eerror C.Eskip)
    
    (* TODO *)
    | A.CONST_ARRAY es ->
        Boot.assert_false "[Translation.translate_expr] #A.CONST_ARRAY: TODO"
    
    (* TODO *)
    | A.CONST_STRUCT_UNION field_es ->
        Boot.assert_false "[Translation.translate_expr] #A.CONST_STRUCT_UNION: TODO"
    
    (* TODO *)
    | A.OFFSETOF ty x ->
        Boot.assert_false "[Translation.translate_expr] #A.OFFSETOF: TODO"
  end















(* -------------------------------------------------------------------------- *)

(* translate_stmt Pmap.empty file file.A.main C.Constants.return s *)

(* TODO[über HACK] `lasts' is the last of symbolic names saving the last statement for each block we are in
                   we need to remember them to annotate Erun/Esave coming from a C label/goto because these symbols
                   MAY (the fact it is a may is pretty disgusting) be in the continuations of the generated Esave (...)

RAAAAAAAAHHH: this doesn't work when the label is in a block the goto doesn't belong to ......
*)

module St = State
open St.Operators

type collect_cases_state = <|
  found_default: bool;
  cases: list Ail.integer_constant
|>

let rec collect_cases_ (_, stmt) : St.t unit collect_cases_state =
  let register_case n =
    St.update (fun s -> <| s with cases= n :: s.cases |>) in
  let register_default =
    St.update (fun s -> <| s with found_default= true |>) in
  match stmt with
    | A.SKIP ->
        St.return ()
    | A.EXPRESSION _ ->
        St.return ()
    | A.BLOCK _ ss ->
        St.mapM_ collect_cases_ ss
    | A.IF _ s1 s2 ->
        collect_cases_ s1 >> collect_cases_ s2
    | A.WHILE _ s ->
        collect_cases_ s
    | A.DO _ s ->
        collect_cases_ s
    | A.BREAK ->
        St.return ()
    | A.CONTINUE ->
        St.return ()
    | A.RETURN_VOID ->
        St.return ()
    | A.RETURN_EXPRESSION _ ->
        St.return ()
    | A.SWITCH _ _ ->
        St.return ()
    | A.CASE n s ->
        register_case n >> collect_cases_ s
    | A.DEFAULT s ->
        register_default >> collect_cases_ s
    | A.LABEL _ s ->
        collect_cases_ s
    | A.GOTO _ ->
        St.return ()
    | A.DECLARATION _ ->
        St.return ()
(*    | PAR of list (statement_l 'a) *)
  end


let collect_cases s =
  snd $ St.run_impl (collect_cases_ s) <| found_default= false; cases= [] |>




open Translation_effect
let rec translate_stmt stdlib file f d_default d_cases d_loop d_break (_, stmt) : t (C.expr zero) =
  let translate_stmt_ s = translate_stmt stdlib file f d_default d_cases d_loop d_break s in
  
  
  (* val conv: Ail.ctype -> Ail.ctype -> Core.expr zero -> t (Core.expr zero) *)
  let conv ty1 ty2 core_e =
  if Ail_typing_aux.eq ty1 ty2 then
    return core_e
  else
    E.fresh_symbol >>= fun a_e ->
    return $ C.Ewseq [Some a_e] core_e (mk_stdcall stdlib "conv" [Caux.mk_ctype ty1; Caux.mk_ctype ty2; C.Esym a_e]) in
  
  
  
  
  
  (* return the type of a given identifier. (TODO: why is this a local function?) *)
  let lookup_type id = fst (Pmap.find id file.A.id_map) in
  
  match stmt with
  | A.SKIP ->
      return C.Eskip
  
  | A.EXPRESSION e ->
      translate_expr stdlib file e
  
  | A.BLOCK ids ss ->
      (* retrieve the declarations of these variables *)
      let decls = [(id, lookup_type id) | forall (id MEM ids) | true] in
      
      (* the symbolic names and create actions for the local variables *)
      let (a_ids, core_creates) =
        mapUnzip (fun (a, ty) -> (Some a, Caux.pcreate (Caux.mk_ctype ty) [f; a])) decls in
      
      E.push_block_objects ids >>
      
      (* TODO: doing the kills here is now redundant if there is are returns before all exit point.
               but it may be nasty to the check.
               For non-void function however we know (?) that the must be these returns ?? so we could drop the kills here *)
      (* the kill actions for the local variables *)
      let (core_kills) =
        List.map (Caux.pkill -| C.Esym -| fst) decls in
      
(*
      E.fresh_symbol >>= fun a_last ->
      E.mapWithLastM (fun s -> translate_stmt file f d_loop d_break (a_last :: lasts) s >>= fun core_s ->
                               return ([], core_s))
                     (* TODO: adding the a_last here is pretty disgusting *)
                     (fun s -> translate_stmt file f d_loop d_break (a_last :: lasts) s >>= fun core_s ->
                               return ([Some a_last], core_s))
                     ss >>= fun a_opts_core_ss ->
*)
      E.mapM (fun s -> translate_stmt_ s >>= fun core_s -> return core_s) ss >>= fun core_ss ->
      
      E.pop_block_objects >>
      
      return
        (C.Esseq a_ids (Caux.mk_unseq core_creates)
           (List.fold_right (fun core_s acc -> C.Esseq [] core_s acc) core_ss (Caux.mk_unseq core_kills))
        )

(*

(*      (* add the block local variables to the environment (fresh symbolic names are assigned) *)
      update_env env ids >>= fun env' ->
*)
      let n     = List.length decls in

      (* prepare the code creating the objects for the block local variables. *)
      let creates_ctx: C.expr zero -> C.expr zero =
        let (syms, xs) = mapUnzip (fun (a, ty) -> (Some a, Caux.pcreate (Caux.mk_ctype ty) [])) (List.rev decls) in
        match n with
          | 0 -> fun x -> x
          | 1 -> C.Ewseq syms (List.hd xs)
          | _ -> C.Ewseq syms (C.Eunseq xs)
        end in
      
      (* prepare the code killing the objects. *)
      let kills_ctx = let xs = List.map (fun (a, _) -> Caux.pkill (C.Esym a)) decls in
                      match n with
                        | 0 -> fun x -> x
                        | 1 -> C.Ewseq [] (List.hd xs)
                        | _ -> C.Ewseq [] (C.Eunseq xs)
                      end in
      
      (* translate the statements with a symbolic name bound to the result of the last statement *)
      E.fresh_symbol >>= fun a_last ->
      E.mapWithLastM (fun s -> translate_stmt_ s >>= fun core_s ->
                               return ([], core_s))
                     (fun s -> translate_stmt_ s >>= fun core_s ->
                               return ([Some a_last], core_s))
                     ss >>= fun core_ss ->
      
      (* connecting everything an returning that symbolic name bounded to the result of last statement *)
      return $ creates_ctx
                 (List.fold_left (fun acc (_as, stmt) ->
                   if Caux.is_pure stmt then (match _as with
                                | [Some a] -> C.Elet a stmt acc
                                | []       -> acc
                                | _  -> Boot.outOfHomeomorphism "BOOM" end)
                   else C.Ewseq _as stmt acc)
                    (kills_ctx (if List.length ss = 0 then C.Eskip else C.Esym a_last))
                    (List.rev core_ss))

*)  

  | A.IF e s1 s2 ->
      E.fresh_symbol       >>= fun a_test  ->
      translate_expr stdlib file e >>= fun core_e  ->
      translate_stmt_ s1   >>= fun core_s1 ->
      translate_stmt_ s2   >>= fun core_s2 ->
      return $ C.Ewseq [Some a_test] core_e
                   (C.Eif (C.Enot (C.Eop C.OpEq (C.Esym a_test) Caux.zero)) core_s1 core_s2)
  
  | A.WHILE e s ->
      E.fresh_symbol                                                         >>= fun a_e     ->
      E.fresh_named_symbol "loop"                                            >>= fun d_loop  ->
      E.fresh_named_symbol "break"                                           >>= fun d_break ->
      translate_expr stdlib file e                                                   >>= fun core_e  ->
      translate_stmt stdlib file f d_default d_cases (Some d_loop) (Some d_break) s >>= fun core_s  ->
      E.get_visible_objects                                                  >>= fun _as     ->
      return $
        C.Esave d_loop [ (a, (* TODO: HACK *) C.VOID)  | forall (a MEM _as) | true ]
          (C.Ewseq [Some a_e] core_e
             (C.Eif (C.Enot (C.Eop C.OpEq (C.Esym a_e) Caux.zero))
                (C.Ewseq [] core_s (C.Erun {} d_loop [ (a, C.Esym a) | forall (a MEM _as) | true ]))
                (C.Esave d_break [(* TODO *)] C.Eskip)
             )
          )


(*
      let free_as = Set.to_list $ Caux.free_syms core_s in
      E.get_current_block_objects >>= fun _as ->
      return $
        C.Esave d_loop free_as [(* TODO *)]
          (C.Ewseq [Some a_e] core_e
             (C.Eif (C.Enot (C.Eop C.OpEq (C.Esym a_e) (C.Econst 0)))
                (C.Ewseq [] core_s (C.Erun d_loop (List.map C.Esym free_as) []))
                (C.Esave d_break _as [(* TODO *)] C.Eskip)
             )
          )
*)
  
  | A.DO e s ->
      E.fresh_symbol                                                         >>= fun d_loop  ->
      E.fresh_symbol                                                         >>= fun d_break ->
      translate_stmt stdlib file f d_default d_cases (Some d_loop) (Some d_break) s >>= fun core_s  ->
      translate_expr stdlib file e                                                   >>= fun core_e  ->
      E.fresh_symbol                                                         >>= fun a       ->
      return $
        C.Esave d_loop [(* TODO *)]
          (C.Ewseq [] core_s
             (C.Ewseq [Some a] core_e
                (C.Eif (C.Eop C.OpEq (C.Esym a) Caux.zero)
                   C.Eskip
                   (C.Erun {} d_loop [(* TODO *)])
                )
             )
          )
  
  | A.BREAK ->
      E.get_visible_objects >>= fun _as ->
      return (C.Erun {} (from_Some d_break) [ (a, C.Esym a) | forall (a MEM _as) | true ])
  
  | A.CONTINUE ->
      return (C.Erun {} (from_Some d_loop) [(* TODO *)])
  
  
  | A.RETURN_VOID ->
      E.get_visible_objects >>= fun _as ->
      let (core_kills) =
        List.map (Caux.pkill -| C.Esym) _as in
      return $
        C.Esseq [] (Caux.mk_unseq core_kills) (C.Eret C.Eskip)
  
  
  (* ------------------------------------------------------------------------------------------------------ *)
  | A.RETURN_EXPRESSION e ->
      translate_expr stdlib file e                                             >>= fun core_e      ->
      conv (Annotate.exp_type_of e) (T.function_return $ lookup_type f) core_e >>= fun core_conv_e ->
      E.fresh_symbol                                                           >>= fun a_e         ->
      E.get_visible_objects                                                    >>= fun _as         ->
      let (core_kills) =
        List.map (Caux.pkill -| C.Esym) _as in
      return $
        C.Esseq [Some a_e] (core_conv_e)
          (C.Esseq [] (Caux.mk_unseq core_kills)
             (C.Eret (C.Esym a_e))
          )
  
  
  (* TODO: the promotions *)
  | A.SWITCH e s ->
      translate_expr stdlib file e >>= fun core_e ->
      E.fresh_symbol       >>= fun a_e    ->
      (* TODO: should properly interpret the integer constants *)
      let ((found_default, ns) : bool * list int) =
        let x = collect_cases s in
        (x.found_default, List.map (fun (z, _, _) -> z) x.cases) in
      E.replicateM (List.length ns) (E.fresh_named_symbol "case") >>= fun (ds : list C.ksym) ->
      let d_cases' = List.fold_left (fun acc (n, d) ->
        Pmap.add n d acc) Pmap.empty (List.combine ns ds) in
      E.fresh_named_symbol "default"                         >>= fun d_default' ->
      (if found_default then
        E.fresh_named_symbol "break"
      else
        return d_default')                                 >>= fun d_break'   ->
      E.get_visible_objects                                  >>= fun _as        ->
      let run_as = [ (a, C.Esym a) | forall (a MEM _as) | true ] in
      translate_stmt stdlib file f (Some d_default') (Some d_cases') d_loop (Some d_break') s >>= fun core_s ->

      return $
        C.Ewseq [Some a_e] core_e
          (List.fold_left (fun acc (n, d) ->
            C.Eif (C.Eop C.OpEq (C.Esym a_e) (C.Econst $ C.Cint n))
              (C.Erun {} d run_as)
              acc
           )
             (C.Ewseq [] (C.Erun {} d_default' run_as)
                (C.Ewseq [] core_s
                   (C.Esave d_break' [ (a, Caux.proj_ctype $ lookup_type a) | forall (a MEM _as) | true ] C.Eskip)
                )
             )
             $ Pmap.bindings d_cases')
  
  
  (* TODO: the promotions *)
  | A.CASE n s ->
      translate_stmt_ s     >>= fun core_s ->
      E.get_visible_objects >>= fun _as    ->
      (* TODO: should properly interpret the integer constant *)
      return (C.Esave (Pmap.find ((fun (z, _, _) -> z) n) (from_Some d_cases)) [ (a, Caux.proj_ctype $ lookup_type a) | forall (a MEM _as) | true ] core_s)
  
  (* TODO *)
  | A.DEFAULT s ->
      translate_stmt_ s     >>= fun core_s ->
      E.get_visible_objects >>= fun _as    ->
      return (C.Esave (from_Some d_default) [ (a, Caux.proj_ctype $ lookup_type a) | forall (a MEM _as) | true ] core_s)

  
  
  (* TODO *)
  | A.LABEL l s ->
      translate_stmt_ s     >>= fun core_s ->
      E.get_visible_objects >>= fun _as    ->
      return (C.Esave l [ (a, Caux.proj_ctype $ lookup_type a) | forall (a MEM _as) | true ] core_s)
  
  
  (* TODO *)
  | A.GOTO l ->
      E.get_visible_objects >>= fun _as ->
      return (C.Erun {} l [ (a, C.Esym a) | forall (a MEM _as) | true ])
  
  
  (* ------------------------------------------------------------------------------------------------------ *)
  | A.DECLARATION []    -> return C.Eskip
  | A.DECLARATION defns ->
      (* This pass translate the declarations *)
      E.mapM (fun (id, e) ->
        E.fresh_symbol                                        >>= fun a           ->
        translate_expr stdlib file e                          >>= fun core_e      ->
        conv (Annotate.exp_type_of e) (lookup_type id) core_e >>= fun core_conv_e ->
        return $ C.Ewseq [Some a] core_conv_e
                     (Caux.pstore (Caux.mk_ctype (lookup_type id)) (C.Esym id) (C.Esym a) Cmm.NA) (* TODO: the id is probably wrong *)
      ) defns >>=
      
      (* This pass combine the translated declerations *)
      E.foldl1M (fun x y -> return  $ Caux.concat_wseq x y)
  
  | A.PAR ss ->
      E.mapM (translate_stmt_) ss >>= fun core_ss ->
      return $ C.Eunseq core_ss
  end


(* Run the translator on different functions *)
let translate_file stdlib (file: A.file _) : t (C.fun_map zero) =
  E.foldlM
    (fun acc (name, (args, body)) ->
       (* translate the body to Core *)
       translate_stmt stdlib file name None None None None body >>= fun core_body ->
       (return $ Pmap.add name (C.TyEffect C.Integer (* TODO: address for pointer type? *),
                                 List.map (fun arg -> (arg, C.Address (* TODO: check *))) args,
                                 core_body) acc))
    Pmap.empty
    (Pmap.bindings file.A.fn_map)


(* This is the entry function (called from main.ml) *)
let translate stdlib impl (file: A.file _) : C.file zero =
  (* TODO: this is a hack, we shouldn't expose the internals and properly use the Undefined *)
  match (translate_file stdlib file) E.init with
    | U.Defined (cfuns, _) -> <| C.main= file.A.main; C.stdlib= stdlib; C.impl= impl; C.funs= cfuns |>
    | _                    -> Boot.assert_false "[Translation.translate #_] TODO"
  end
