(* TODO: for now everything is mapped to nonatomics. The translation to atomics
         still needs to be defined *)

open import Pervasives Utils Global Loc String_extra Num

import State Translation_effect Loc List_extra
open import Translation_aux
import Cmm_csem Mem

import Decode
import Core_typing

import AilSyntax AilSyntaxAux AilTypes AilTypesAux
import GenTypes
import Core Core_aux Undefined

module A    = AilSyntax
module Aaux = AilSyntaxAux
module Aty  = AilTypes


module C    = Core
module Cty  = struct 
  include import Core_ctype
  include import Core_ctype_aux
end
module Caux = Core_aux
module U    = Undefined

module Cmm = Cmm_csem


module E = Translation_effect
module Operators = struct
  let inline (>>=)      = E.bind
  let inline (>>) m f   = E.bind m (fun _ -> f)
  let inline (<$>) f ma = E.bind ma (fun a -> E.return (f a))
  let inline (<*>) mf m = E.bind mf (fun f -> f <$> m)
end

open Operators


val illTypedAil: forall 'a. Loc.t -> string -> 'a
let illTypedAil loc debug_str =
  error ("[Translation => '" ^ debug_str ^ "'] fatal error, the Ail program was ill-typed")


(*
(* Return the core_object_type that the elaboration of an ail expression of a
   given ctype will have *)
val     core_type_of_expr_ctype: Aty.ctype -> either C.core_base_type C.core_object_type
let rec core_type_of_expr_ctype ty =
  match ty with
    | Aty.Void ->
        Left C.BTy_unit
    | Aty.Basic (Aty.Integer _) ->
        Right C.OTy_integer
    | Aty.Basic (Aty.Floating _) ->
        Right C.OTy_floating
    | Aty.Array _ _ ->
        Right C.OTy_pointer
(*
    | Aty.Function of (AilTypes.qualifiers * ctype) * list (AilTypes.qualifiers * ctype) * bool (*isVariadic*) ->
*)      
    | Aty.Pointer _ _ ->
        Right C.OTy_pointer
    | Aty.Atomic atom_ty ->
        core_type_of_expr_ctype atom_ty
    | Aty.Struct tag_ident ->
        Right (C.OTy_struct tag_ident)
    | Aty.Union tag_ident ->
        Right (C.OTy_union tag_ident)
    | Aty.Builtin str ->
        error "TODO: Translation.core_object_type_of_expr_ctype"
  end
*)


let force_core_object_type_of_ctype ty =
  match Caux.core_object_type_of_ctype ty with
    | Just oTy ->
        oTy
    | (*BISECT-IGNORE*) Nothing ->
        error "Translation.force_core_object_type_of_ctype: Nothing"
  end

val signedInt_gty: GenTypes.genType
let signedInt_gty =
  GenTypes.GenBasic (GenTypes.GenInteger (GenTypes.Concrete (Aty.Signed Aty.Int_)))




(* STD §6.5.13#3, sentence 1 *)
(* STD §6.5.14#3, sentence 1 *)
(* STD §6.5.15#4, sentence 2 *)
(* STD §6.7.10#2 *)
(* STD §6.8.4.1#2, sentence 1-2 *)
(* STD §6.8.5#4, sentence 1 *)
(* Some C constructs perform tests on scalar expression, with dynamic semantics
   varying on wether its value "compares equal to 0". The semantics of the quoted
   sentence implicitly refers to that of the C binary equality operator.
   This function turns a [e] scalar expression into a [e == 0], so that elaboration
   of the equality operator can be reused *)

type test_operator =
  | TestEq
  | TestNe

val mkTestExpression: forall 'a. test_operator -> A.expression GenTypes.genTypeCategory -> A.expression GenTypes.genTypeCategory
let mkTestExpression op (A.AnnotatedExpression gty annots _ _ as a_expr) =
  let loc = locOf a_expr in
  let gtc =
    (* STD §6.5.9#3, sentence 1 *)
    GenTypes.GenRValueType signedInt_gty in
  
  let bop = match op with
    | TestEq -> A.Eq
    | TestNe -> A.Ne
  end in
  let zero_const =
    if AilTypesAux.is_integer (ctype_of a_expr) then
      A.ConstantInteger (A.IConstant 0 A.Octal Nothing)
    else if AilTypesAux.is_floating (ctype_of a_expr) then
      A.ConstantFloating ("0.0", Nothing)
    else if AilTypesAux.is_pointer (ctype_of a_expr) then
      A.ConstantNull
    else
      (*BISECT-IGNORE*) error "[Translation.mkTestExpression] must be called on scalar expression" in
  A.AnnotatedExpression gtc annots loc
    (A.AilEbinary a_expr bop (A.AnnotatedExpression gty annots loc (A.AilEconst zero_const)))


val zeroAil_tau: A.expression GenTypes.genTypeCategory
let zeroAil_tau =
  A.AnnotatedExpression
    (GenTypes.GenRValueType signedInt_gty) [] Loc.unknown
    (A.AilEconst (A.ConstantInteger (A.IConstant 0 A.Octal Nothing)))

val oneAil_tau: A.expression GenTypes.genTypeCategory
let oneAil_tau =
  A.AnnotatedExpression
    (GenTypes.GenRValueType signedInt_gty) [] Loc.unknown
    (A.AilEconst (A.ConstantInteger (A.IConstant 1 A.Decimal Nothing)))


(* ========================================================================== *)


(*
val shiftPathFromMember: A.program GenTypes.genTypeCategory -> Symbol.sym -> Cabs.cabs_identifier -> C.shift_path
let shiftPathFromMember program tag ident =
  match List.lookup tag (snd program).A.tag_definitions with
    | Just (A.StructDef ident_tys) ->
        let sh = fromRight $ List.foldl (fun acc_ (ident', ty) ->
          match acc_ with
            | Left acc ->
                if ident = ident' then
                  if List.null acc then
                    Right [(Caux.proj_ctype ty, Caux.mk_integer_pe 0)]
                  else
                    Right acc
                else
                  Left ((Caux.proj_ctype ty, Caux.mk_integer_pe 1) :: acc)
            | Right acc ->
                Right acc
          end
        ) (Left []) ident_tys in
        sh
    | Just (A.UnionDef ident_tys) ->
        [(Caux.proj_ctype (fromJust "Translation.shiftPathFromMember" $ List.lookup ident ident_tys), Caux.mk_integer_pe 0)]
    
    | Nothing ->
        error ("Translation.shiftPathFromMember: couldn't find a definition for `" ^ show tag ^ "'")
  end
*)


val translate_integerConstant: A.integerConstant -> C.pexpr
let translate_integerConstant iCst =
  C.Pexpr [] () (C.PEval (C.Vobject (C.OVinteger (
    match iCst with
      | A.IConstant n _ _ ->
          Mem.integer_ival n
      | A.IConstantMax ity ->
          Mem.max_ival ity
      | A.IConstantMin ity ->
          Mem.min_ival ity
    end
  ))))

val translate_memory_order: A.expression GenTypes.genTypeCategory -> Cmm.memory_order
let translate_memory_order (A.AnnotatedExpression _ _ _ expr as a_expr) =
  match expr with
    | A.AilEconst (A.ConstantInteger (A.IConstant n _ _)) ->
        match natFromInteger n with
          | 0 -> Cmm.Relaxed
          | 1 -> Cmm.Consume
          | 2 -> Cmm.Acquire
          | 3 -> Cmm.Release
          | 4 -> Cmm.Acq_rel
          | 5 -> Cmm.Seq_cst
          | (*BISECT-IGNORE*) _ ->
              error ("Translation.translate_memory_order: " ^ show n)
        end
    | (*BISECT-IGNORE*) _ ->
        error ("Translation.translate_memory_order: " ^ Pp.stringFromAil_expression a_expr)
  end





val     translate_constant: A.constant -> C.pexpr
let rec translate_constant cst =
  match cst with
    | A.ConstantIndeterminate ty ->
        (* NOTE: we assume the lack of trap representation *)
        Caux.mk_value_pe (C.Vloaded (C.LVunspecified (Caux.proj_ctype ty)))
    | A.ConstantNull ->
        (* TODO: should make the Ail ctor take a ctype? *)
        Caux.mk_specified_pe (Caux.mk_nullptr_pe Cty.Void)
    | A.ConstantInteger (A.IConstant n _ _) ->
        (* TODO: suffix/basis? + check *)
        Caux.mk_value_pe (C.Vloaded (C.LVspecified (C.OVinteger (Mem.integer_ival n))))
    | A.ConstantInteger (A.IConstantMax ity) ->
        Caux.mk_value_pe (C.Vloaded (C.LVspecified (C.OVinteger (Mem.max_ival ity))))
    | A.ConstantInteger (A.IConstantMin ity) ->
        Caux.mk_value_pe (C.Vloaded (C.LVspecified (C.OVinteger (Mem.min_ival ity))))
    | A.ConstantFloating (str, _) ->
        (* TODO: suffix *)
        Caux.mk_value_pe (C.Vloaded (C.LVspecified (C.OVfloating (Mem.str_fval str))))
    | A.ConstantCharacter (_, str) ->
        (* TODO: prefix? *)
        (* TODO: making an implementation fix here (ASCII) *)
        Caux.mk_value_pe (C.Vloaded (C.LVspecified (C.OVinteger (Mem.integer_ival (Decode.decode_character_constant str)))))
    | A.ConstantArray _ csts ->
        Caux.mk_specified_pe (Caux.mk_array_pe (List.map translate_constant csts))
    | A.ConstantStruct tag_sym xs ->
        Caux.mk_specified_pe begin
          Caux.mk_struct_pe tag_sym begin
            List.map (fun (memb_ident, cst) -> (memb_ident, translate_constant cst)) xs
          end
        end
    | A.ConstantUnion tag_sym memb_ident pe ->
        Caux.mk_specified_pe (Caux.mk_union_pe tag_sym memb_ident (translate_constant pe))
  end



type expr_ctx =
  | ECTX_glob of Symbol.sym * Symbol.sym
  | ECTX_other


let rec translate_function_designator ctx variadic_env stdlib tagDefs (A.AnnotatedExpression _ _ _ expr as a_expr) =
  let (Aty.Ctype _ cty as ty) = ctype_of a_expr in
  match (cty, expr) with
    | (Aty.Function has_proto _ params is_variadic, A.AilEunary A.Indirection e) ->
        let () = Debug.print_debug 1 [] (fun () -> "FUNTION POINTERS: UNARY INDIRECTION") in
        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (fun_sym, fun_sym_pat, fun_sym_pe) ->
        translate_expression ctx variadic_env stdlib tagDefs e >>= fun core_e ->
        E.return $ Caux.mk_sseq_e fun_sym_pat core_e (Caux.mk_pure_e (Caux.mk_sym_pe fun_sym))
    | (Aty.Function has_proto _ params is_variadic, A.AilEident fid) ->
        let fid_pe = match fid with
          | Symbol.Symbol _ _ (Just str) ->
              match Map.lookup str stdlib.ailnames with
                | Just sym ->
                    Caux.mk_value_pe (Core.Vloaded (C.LVspecified (Core.OVpointer (Mem.fun_ptrval sym))))
                | Nothing ->
                    Caux.mk_value_pe (Core.Vloaded (C.LVspecified (Core.OVpointer (Mem.fun_ptrval fid))))
              end
          | _ ->
              Caux.mk_value_pe (Core.Vloaded (C.LVspecified (Core.OVpointer (Mem.fun_ptrval fid))))
        end in
        E.return $ Caux.mk_pure_e fid_pe
    | (*BISECT-IGNORE*) _ ->
        error ("[Translation.translate_function_designator] wildcard case ==> " ^
               Pp.stringFromAil_expression a_expr ^ " and type= " ^ Pp.stringFromAil_ctype Aty.no_qualifiers ty)
  end


(* STD §6.5.5 Multiplicative operators *)
and translate_mul_operator loc self usual_arithmetic_conversion stdlib result_ty e1 e2 =
  let oTy1 = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
  let oTy2 = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e2)) in
  self e1                                    >>= fun core_e1                               ->
  self e2                                    >>= fun core_e2                               ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy1) >>= fun (e1_sym  , e1_sym_pat  , e1_sym_pe  ) ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy2) >>= fun (e2_sym  , e2_sym_pat  , e2_sym_pe  ) ->
  E.wrapped_fresh_symbol (C.BTy_object oTy1) >>= fun (obj1_sym, obj1_sym_pat, obj1_sym_pe) ->
  E.wrapped_fresh_symbol (C.BTy_object oTy2) >>= fun (obj2_sym, obj2_sym_pat, obj2_sym_pe) ->
  let (promoted1_pe, promoted2_pe) = Caux.mk_std_pair_pe "§6.5.5#3" $
    usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe in
  E.return $
    C.Expr [Annot.Astd "§6.5.5"] (
      C.Ewseq (Caux.mk_tuple_pat [ e1_sym_pat; e2_sym_pat ]) (Caux.mk_unseq [core_e1; core_e2]) (
        Caux.mk_pure_e (
          Caux.mk_case_pe (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
            [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_sym_pat
                                 ; Caux.mk_specified_pat obj2_sym_pat ],
               (* Both operand are specified *)
               let core_mul = Caux.mk_std_pe "§6.5.5#4" $ Caux.mk_op_pe C.OpMul promoted1_pe promoted2_pe in
               Caux.mk_specified_pe $
if AilTypesAux.is_signed_integer_type result_ty then
                 stdlib.mkcall_catch_exceptional_condition result_ty core_mul
else if AilTypesAux.is_integer result_ty then
                 stdlib.mkcall_wrapI result_ty core_mul
else
                 core_mul )
            ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy1; C.BTy_loaded oTy2]),
               (* If either operand is unspecified, the result is also unspecified is the
                  result type of unsigned. Otherwise it is undef, since the multiplication
                  may overflow *)
if AilTypesAux.is_unsigned_integer_type result_ty then
               Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)
else
               Caux.mk_undef_exceptional_condition loc) ]
        )
      )
    )


and translate_div_mod_operator loc self usual_arithmetic_conversion stdlib result_ty aop e1 e2 =
  (* STD "§6.5.5" *)
  let oTy1    = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
  let oTy2    = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e2)) in
  let oTy_res = force_core_object_type_of_ctype (Caux.proj_ctype result_ty)     in
  let zero_pe = match oTy_res with
    | C.OTy_integer ->
        Caux.mk_integer_pe 0
    | C.OTy_floating ->
        Caux.mk_floating_value_pe Mem.zero_fval
    | (*BISECT-IGNORE*) _ ->
      illTypedAil Loc.unknown "AilEbinary Div, Mod"
  end in
  self e1                                       >>= fun core_e1                                  ->
  self e2                                       >>= fun core_e2                                  ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy1)    >>= fun (e1_sym   , e1_sym_pat   , e1_sym_pe   ) ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy2)    >>= fun (e2_sym   , e2_sym_pat   , e2_sym_pe   ) ->
  E.wrapped_fresh_symbol (C.BTy_object oTy1)    >>= fun (obj1_sym , obj1_sym_pat , obj1_sym_pe ) ->
  E.wrapped_fresh_symbol (C.BTy_object oTy2)    >>= fun (obj2_sym , obj2_sym_pat , obj2_sym_pe ) ->
  E.wrapped_fresh_symbol (C.BTy_object oTy_res) >>= fun (conv1_sym, conv1_sym_pat, conv1_sym_pe) ->
  E.wrapped_fresh_symbol (C.BTy_object oTy_res) >>= fun (conv2_sym, conv2_sym_pat, conv2_sym_pe) ->
  let (promoted1_pe, promoted2_pe) = Caux.mk_std_pair_pe "§6.5.5#3" $
    usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe in
  let (ub, core_pe) = match aop with
    | A.Div ->
        (Undefined.UB045a_division_by_zero,
         Caux.mk_op_pe C.OpDiv promoted1_pe conv2_sym_pe)
    | A.Mod ->
        (Undefined.UB045b_modulo_by_zero,
(*         Caux.mk_if_pe (Caux.mk_op_pe C.OpLt conv1_sym_pe (Caux.mk_integer_pe 0)) *)
           (Caux.mk_op_pe C.OpRem_t conv1_sym_pe conv2_sym_pe)
(*           (Caux.mk_op_pe C.OpRem_t (Caux.mk_op_pe C.OpAdd conv1_sym_pe conv2_sym_pe) conv2_sym_pe) *))
    | (*BISECT-IGNORE*) _ ->
        error "[Translation.translate_div_mod_operator], 'aop' must be multiplicative"
  end in
  (* TODO[check]: When integers are divided, the result of the / operator is the algebraic
                  quotient with any fractional part discarded.105) If the quotient a/b is
                  representable, the expression (a/b)*b + a%b shall equal a; otherwise, the
                  behavior of both a/b and a%b is undefined. *)
    E.return $
      C.Expr [Annot.Astd "§6.5.5"] (
        C.Ewseq (Caux.mk_tuple_pat [ e1_sym_pat; e2_sym_pat ]) (Caux.mk_unseq [core_e1; core_e2]) (
          Caux.mk_pure_e (
            Caux.mk_case_pe (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
              [ ( Caux.mk_tuple_pat [ Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                                   ; Caux.mk_empty_pat (C.BTy_loaded oTy2) ]
                ,
if AilTypesAux.is_signed_integer_type result_ty then
                  Caux.mk_undef_exceptional_condition loc
else
                  Caux.mk_unspecified_pe (Caux.proj_ctype result_ty) )

              ; ( Caux.mk_tuple_pat [ Caux.mk_empty_pat (C.BTy_loaded oTy1)
                                    ; Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype) ]
                , Caux.mk_std_undef_pe loc "§6.5.5#5, sentence 2" ub )

              ; ( Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_sym_pat
                                    ; Caux.mk_specified_pat obj2_sym_pat ]
                , Caux.mk_let_pe conv1_sym_pat promoted1_pe (
                    Caux.mk_let_pe conv2_sym_pat promoted2_pe (
                      Caux.mk_if_pe (Caux.mk_op_pe C.OpEq conv2_sym_pe zero_pe)
                        (Caux.mk_std_undef_pe loc "§6.5.5#5, sentence 2" ub)
                        (* if a/b is representable *)
                        (Caux.mk_if_pe (stdlib.mkcall_is_representable (Caux.mk_op_pe C.OpDiv promoted1_pe conv2_sym_pe) result_ty)
                           begin
                             Caux.mk_specified_pe (Caux.mk_std_pe "§6.5.5#5, sentence 1" $
                               if AilTypesAux.is_signed_integer_type result_ty then
                                 stdlib.mkcall_catch_exceptional_condition result_ty core_pe
                               else if AilTypesAux.is_integer result_ty then
                                 stdlib.mkcall_wrapI result_ty core_pe
                               else
                                 core_pe)
                           end
                           (Caux.mk_undef_pe loc Undefined.UB045c_quotient_not_representable))
                      )
                    ) ) ]
          )
        )
      )


(* STD §6.5.8 Relational operators *)
and translate_relational_operator self usual_arithmetic_conversion result_ty bop e1 e2 =
  (* STD "§6.5.8" *)
  let oTy1    = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
  let oTy2    = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e2)) in
  (* let oTy_res = force_core_object_type_of_ctype (Caux.proj_ctype result_ty)     in *)
  self e1                                    >>= fun core_e1                                  ->
  self e2                                    >>= fun core_e2                                  ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy1) >>= fun (e1_sym   , e1_sym_pat   , e1_sym_pe   ) ->
  E.wrapped_fresh_symbol (C.BTy_loaded oTy2) >>= fun (e2_sym   , e2_sym_pat   , e2_sym_pe   ) ->
  E.wrapped_fresh_symbol (C.BTy_object oTy1) >>= fun (obj1_sym , obj1_sym_pat , obj1_sym_pe ) ->
  E.wrapped_fresh_symbol (C.BTy_object oTy2) >>= fun (obj2_sym , obj2_sym_pat , obj2_sym_pe ) ->
  (* TODO: restrict this to the ptr vs ptr case *)
  E.wrapped_fresh_symbol C.BTy_boolean >>= fun (memop_sym, memop_sym_pat, memop_sym_pe) ->
  (* The object type on which the Core operator is going to work on. *)
  (* By typing it is enough to look at the type of one of the operand (see STD §6.5.8#2) *)
  let real_bop = match bop with
    | A.Lt -> C.OpLt
    | A.Gt -> C.OpGt
    | A.Le -> C.OpLe
    | A.Ge -> C.OpGe
    | (*BISECT-IGNORE*) _ -> error "[Translation.translate_relational_operator], 'bop' must be relational"
  end in
  E.return $
    C.Expr [Annot.Astd "§6.5.8"] (
      C.Ewseq (Caux.mk_tuple_pat [ e1_sym_pat; e2_sym_pat ]) (Caux.mk_unseq [core_e1; core_e2]) (
        C.Expr [] (
          C.Ecase (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
              [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_sym_pat
                                   ; Caux.mk_specified_pat obj2_sym_pat ],
(if AilTypesAux.is_real (ctype_of e1) then
                 let (promoted1_pe, promoted2_pe) = Caux.mk_std_pair_pe "§6.5.8#3" $ usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe in
                 C.Expr [Annot.Astd "§6.5.8#6"] (
                   C.Epure (
                     Caux.mk_if_pe (Caux.mk_op_pe real_bop promoted1_pe promoted2_pe)
                       (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
                       (Caux.mk_specified_pe (Caux.mk_integer_pe 0))
                   )
                 )
else
                 let memop = match bop with
                   | A.Lt -> Mem_common.PtrLt
                   | A.Gt -> Mem_common.PtrGt
                   | A.Le -> Mem_common.PtrLe
                   | A.Ge -> Mem_common.PtrGe
                   | (*BISECT-IGNORE*) _ -> error "[Translation.translate_relational_operator], 'bop' must be relational"
                 end in
                 C.Expr [] (
                   C.Ewseq memop_sym_pat (C.Expr [] (C.Ememop memop [obj1_sym_pe; obj2_sym_pe])) (
                     C.Expr [Annot.Astd "§6.5.8#6"] (
                       C.Epure (
                         Caux.mk_if_pe memop_sym_pe
                           (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
                           (Caux.mk_specified_pe (Caux.mk_integer_pe 0))
                       )
                     )
                   )
                 )
               ))
              ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy1; C.BTy_loaded oTy2]),
                 (* TODO: check with Peter *)
                 Caux.mk_pure_e (Caux.mk_unspecified_pe (Caux.proj_ctype result_ty))) ]
        )
      )
    )


(* STD §6.5.9 Equality operators *)
and translate_equality_operator loc translate usual_arithmetic_conversion result_ty bop e1 e2 =
    (* STD §6.5.9 *)
if    Aaux.is_null_pointer_constant e1 && AilTypesAux.is_pointer (ctype_of e2)
   || AilTypesAux.is_pointer (ctype_of e1) && Aaux.is_null_pointer_constant e2 then
  let e = if Aaux.is_null_pointer_constant e1 then e2 else e1 in
  let nullptr_pe = Caux.mk_std_pe "§6.5.9#5, sentence 2" $ Caux.mk_nullptr_pe (Caux.proj_ctype (ctype_of e)) in
  
  translate e                                         >>= fun core_e                             ->
  E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (e_sym  , e_sym_pat  , e_sym_pe  ) ->
  E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (obj_sym, obj_sym_pat, obj_sym_pe) ->
  let memop_sym = Symbol.fresh () in
  let memop_sym_pe = Caux.mk_sym_pe memop_sym in
  let memop = match bop with
    | A.Eq -> Mem_common.PtrEq
    | A.Ne -> Mem_common.PtrNe
    | (*BISECT-IGNORE*) _ -> error "[Translation.translate_equality_operator], 'bop' must be an equality operator"
  end in
  
  E.return (
    Caux.mk_wseq_e e_sym_pat core_e (
      Caux.mk_case_e e_sym_pe
  [ (Caux.mk_specified_pat obj_sym_pat,
           Caux.mk_wseq_e (Caux.mk_sym_pat memop_sym C.BTy_boolean) (C.Expr [] (C.Ememop memop [obj_sym_pe; nullptr_pe])) (
             C.Expr [Annot.Astd "§6.5.9#3"] $ C.Epure (
               Caux.mk_if_pe memop_sym_pe
                 (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
                 (Caux.mk_specified_pe (Caux.mk_integer_pe 0))
             )
    ))
    ; (Caux.mk_empty_pat (C.BTy_loaded C.OTy_pointer),
       (* TODO: check with Peter *)
       Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY ("Elab. equality operator (ptr vs NULL) ==> " ^ Loc.stringFromLocation loc)))) ]
    )
  )
  
else (* both operands have arithmetic or pointer types *)
  translate e1 >>= fun core_e1       ->
  translate e2 >>= fun core_e2       ->
  let e1_sym   = Symbol.fresh () in
  let e2_sym   = Symbol.fresh () in
  let obj1_sym = Symbol.fresh () in
  let obj2_sym = Symbol.fresh () in
  (* The object type on which the Core operator is going to work on. *)
  let oTy1 = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
  let oTy2 = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e2)) in
  let e1_sym_pe   = Caux.mk_sym_pe e1_sym   in
  let e2_sym_pe   = Caux.mk_sym_pe e2_sym   in
  let obj1_sym_pe = Caux.mk_sym_pe obj1_sym in
  let obj2_sym_pe = Caux.mk_sym_pe obj2_sym in
  
  (* TODO: could case this only for the pointer case *)
  let memop_sym    = Symbol.fresh () in
  let memop_sym_pe = Caux.mk_sym_pe memop_sym in
  
  E.return $
    Caux.mk_wseq_e (Caux.mk_tuple_pat [ Caux.mk_sym_pat e1_sym (C.BTy_loaded oTy1)
                                      ; Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy2) ]) (Caux.mk_unseq [core_e1; core_e2]) (
      
if AilTypesAux.is_arithmetic (ctype_of e1) && AilTypesAux.is_arithmetic (ctype_of e2) then
  let mk_op_pe = match bop with
    | A.Eq -> Caux.mk_op_pe C.OpEq
    | A.Ne -> fun x y -> Caux.mk_not_pe (Caux.mk_op_pe C.OpEq x y)
    | (*BISECT-IGNORE*) _ -> error "[Translation.translate_equality_operator], 'bop' must be relational"
  end in
      Caux.mk_pure_e (
        C.Pexpr [] () (
          C.PEcase (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
            [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy1))
                                 ; Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy2)) ],
               let (promoted1_pe, promoted2_pe) = Caux.mk_std_pair_pe "§6.5.9#4, sentence 1" $ usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe in
               Caux.mk_std_pe "§6.5.9#3" $ Caux.mk_if_pe (Caux.mk_std_pe "§6.5.9#4, sentence 3" $ mk_op_pe promoted1_pe promoted2_pe)
                 (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
                 (Caux.mk_specified_pe (Caux.mk_integer_pe 0)))
            ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy1; C.BTy_loaded oTy2]),
               (* TODO: check with Peter *)
               Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)) ]
                )
              )

else (* both operand have pointer type *)
  (* TODO: should have a case for 6.5.9#5 sentence 3 ? *)
      Caux.mk_case_e (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
            [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy1))
                                 ; Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy2)) ],
  let memop = match bop with
    | A.Eq -> Mem_common.PtrEq
    | A.Ne -> Mem_common.PtrNe
    | (*BISECT-IGNORE*) _ -> error "[Translation.translate_equality_operator], 'bop' must be relational"
  end in
               Caux.mk_wseq_e (Caux.mk_sym_pat memop_sym C.BTy_boolean) (C.Expr [] (C.Ememop memop [obj1_sym_pe; obj2_sym_pe])) (
                 Caux.mk_pure_e (
                   Caux.mk_std_pe "§6.5.9#3" $ Caux.mk_if_pe memop_sym_pe
                     (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
                     (Caux.mk_specified_pe (Caux.mk_integer_pe 0))
                   )
                 ) )
            ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy1; C.BTy_loaded oTy2]),
               (* TODO: check with Peter *)
               Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY "Elab. equality operator (both arith or ptr)"))) ]
            )


(* STD §6.5.10  Bitwise AND operator          *)
(* STD §6.5.11  Bitwise exclusive OR operator *)
(* STD §6.5.12  Bitwise inclusive OR operator *)
and translate_bitwise_operator loc translate usual_arithmetic_conversion stdlib result_ty aop e1 e2 =
  let (std_id, stdlib_call) = match aop with
    | A.Band -> ("§6.5.10", (fun ty pe1 pe2 -> C.Pexpr [] () (C.PEctor C.CivAND [Caux.mk_ail_ctype_pe ty; pe1; pe2])))
    | A.Bxor -> ("§6.5.11", (fun ty pe1 pe2 -> C.Pexpr [] () (C.PEctor C.CivXOR [Caux.mk_ail_ctype_pe ty; pe1; pe2])))
    | A.Bor  -> ("§6.5.12", (fun ty pe1 pe2 -> C.Pexpr [] () (C.PEctor C.CivOR [Caux.mk_ail_ctype_pe ty; pe1; pe2])))
    | (*BISECT-IGNORE*) _ -> error "[Translation.translate_bitwise_operator], 'bop' must be a bitwise operator"
  end in
  let e1_sym    = Symbol.fresh () in
  let e2_sym    = Symbol.fresh () in
  let obj1_sym  = Symbol.fresh () in
  let obj2_sym  = Symbol.fresh () in
  let sym_conv1 = Symbol.fresh () in
  let sym_conv2 = Symbol.fresh () in
  translate e1   >>= fun core_e1   ->
  translate e2   >>= fun core_e2   ->
  let oTy = C.OTy_integer in
  let e1_sym_pe   = Caux.mk_sym_pe e1_sym   in
  let e2_sym_pe   = Caux.mk_sym_pe e2_sym   in
  let obj1_sym_pe = Caux.mk_sym_pe obj1_sym in
  let obj2_sym_pe = Caux.mk_sym_pe obj2_sym in
  let (promoted1_pe, promoted2_pe) =
    Caux.mk_std_pair_pe (std_id ^ "#3") $
    usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe in
  E.return $
    C.Expr [Annot.Astd std_id] (
      C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat e1_sym (C.BTy_loaded oTy)
                                 ; Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy) ]) (Caux.mk_unseq_e [core_e1; core_e2]) (
        Caux.mk_pure_e (
          C.Pexpr [] () (
            C.PEcase (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
              [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy))
                                   ; Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy)) ],
                 (* Both operand are specified *)
                Caux.mk_specified_pe $ Caux.mk_std_pe (std_id ^ "#4") (stdlib_call result_ty promoted1_pe promoted2_pe))
              ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy; C.BTy_loaded oTy]),
                 Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)) ]
          )
        )
      )
    )










and translate_expression ctx variadic_env stdlib (tagDefs : Core.core_tag_definitions) a_expr : E.elabM (C.expr unit) =
  let self = translate_expression ctx variadic_env stdlib tagDefs in
  let is_lvalue = match GenTypes.genTypeCategoryOf a_expr with
    | GenTypes.GenLValueType _ _ _ ->
        true
    | GenTypes.GenRValueType _ ->
        false
  end in
  (* TODO !!!! *)
  let integer_promotion (ty: Aty.ctype) (e: C.pexpr) : C.pexpr =
    let promoted_ty = fromJust "Translation_aux.integer_promotion" (AilTypesAux.promotion tmp_implementation ty) in
    stdlib.mkcall_conv_int promoted_ty e in
  
  (* STD §6.3.1.8 *)
  let usual_arithmetic_conversion (ty1: Aty.ctype) (ty2: Aty.ctype) (e1: C.pexpr) (e2: C.pexpr) : C.pexpr * C.pexpr =
    match (AilTypesAux.corresponding_real_type ty1, AilTypesAux.corresponding_real_type ty2) with
      (* TODO: Convert (long double, double and float) to Ocaml float! This is not the standard behaviour! *)
      | (Just _, Just _) ->
          (e1, e2)
      | (Just _, _) ->
          (e1, C.Pexpr [] () (C.PEctor C.Cfvfromint [e2]))
      | (_, Just _) ->
          (C.Pexpr [] () (C.PEctor C.Cfvfromint [e1]), e2)
      | (Nothing, Nothing) ->
          (* TODO: this is so readable ... *)
          (* STD §6.3.1.8#1, bullet 4 *)
          match (AilTypesAux.promotion tmp_implementation ty1, AilTypesAux.promotion tmp_implementation ty2) with
            | (Just (Aty.Ctype _ (Aty.Basic (Aty.Integer ity1')) as ty1'), Just (Aty.Ctype _ (Aty.Basic (Aty.Integer ity2')) as ty2')) ->
                (* "If both operants have the same type, then no further conversion is needed." *)
                if ty1' = ty2' then
                  (stdlib.mkcall_conv_int ty1' e1, stdlib.mkcall_conv_int ty2' e2)

                (* "Otherwise, if both operands have signed integer types or both have unsigned integer types,
                    the operand with the type of lesser integer conversion rank is converted to the type
                    of the operand with greater rank." *)
                else if   (AilTypesAux.is_signed_integer_type ty1' && AilTypesAux.is_signed_integer_type ty2')
                       || (AilTypesAux.is_unsigned_integer_type ty1' && AilTypesAux.is_unsigned_integer_type ty2') then
                  if AilTypesAux.lt_integer_rank ity1' ity2' then
                    (stdlib.mkcall_conv_int ty2' e1, stdlib.mkcall_conv_int ty2' e2)
                  else
                    (stdlib.mkcall_conv_int ty1' e1, stdlib.mkcall_conv_int ty1' e2)

                (* "Otherwise, if the operand that has unsigned type has rank greater or equal to the rank of the
                    rank of the type of the other operand, then the operand with signed integer type is converted
                    to the type of the operand with unsigned integer type." *)
                else if AilTypesAux.is_unsigned_integer_type ty1' && AilTypesAux.ge_integer_rank ity1' ity2' then
                  (stdlib.mkcall_conv_int ty1' e1, stdlib.mkcall_conv_int ty1' e2)
                else if AilTypesAux.is_unsigned_integer_type ty2' && AilTypesAux.ge_integer_rank ity2' ity1' then
                  (stdlib.mkcall_conv_int ty2' e1, stdlib.mkcall_conv_int ty2' e2)

                (* "Otherwise, if the type of the operand with signed integer type can represent all of the values
                    of the type of the operand with unsigned integer type, then the operand with unsigned integer
                    type is converted to the type of the operand with signed integer type." *)
                else if AilTypesAux.is_signed_integer_type ty1' then
(*
                  (Caux.mk_if_pe (stdlib.mkcall_is_representable e2 ty1')
                     (stdlib.mkcall_conv_int ty1' e1)
                     (stdlib.mkcall_conv_int (Aty.Basic (Aty.Integer (AilTypesAux.make_corresponding_unsigned ity1'))) e1)
                  ,
                   Caux.mk_if_pe (stdlib.mkcall_is_representable e2 ty1')
                     (stdlib.mkcall_conv_int ty1' e2)
                     (stdlib.mkcall_conv_int (Aty.Basic (Aty.Integer (AilTypesAux.make_corresponding_unsigned ity1'))) e2)
                  )
*)
                  (Caux.mk_if_pe (stdlib.mkcall_all_values_representable_in ty2' ty1')
                     (stdlib.mkcall_conv_int ty1' e1)
                     (* "Otherwise, both operands are converted to the unsigned integer type corresponding to the type
                         of the operand with signed integer type". *)
                     (stdlib.mkcall_conv_int (Aty.Ctype [] (Aty.Basic (Aty.Integer (AilTypesAux.make_corresponding_unsigned ity1')))) e1)
                  ,
                  Caux.mk_if_pe (stdlib.mkcall_all_values_representable_in ty2' ty1')
                     (stdlib.mkcall_conv_int ty1' e2)
                     (stdlib.mkcall_conv_int (Aty.Ctype [] (Aty.Basic (Aty.Integer (AilTypesAux.make_corresponding_unsigned ity1')))) e2)
                  )

                  (* ASK: Should you not check that ty2 is signed ? Can we delete the previous code? *)
                else (* if AilTypesAux.is_signed_integer_type ty2' then *)
(*
                  (Caux.mk_if_pe (stdlib.mkcall_is_representable e2 ty2')
                     (stdlib.mkcall_conv_int ty2' e1)
                     (stdlib.mkcall_conv_int (Aty.Basic (Aty.Integer (AilTypesAux.make_corresponding_unsigned ity2'))) e1)
                  ,
                  Caux.mk_if_pe (stdlib.mkcall_is_representable e2 ty2')
                     (stdlib.mkcall_conv_int ty2' e2)
                     (stdlib.mkcall_conv_int (Aty.Basic (Aty.Integer (AilTypesAux.make_corresponding_unsigned ity2'))) e2)
                  )
*)
                  (Caux.mk_if_pe (stdlib.mkcall_all_values_representable_in ty1' ty2')
                     (stdlib.mkcall_conv_int ty2' e1)
                     (stdlib.mkcall_conv_int (Aty.Ctype [] (Aty.Basic (Aty.Integer (AilTypesAux.make_corresponding_unsigned ity2')))) e1)
                  ,
                  Caux.mk_if_pe (stdlib.mkcall_all_values_representable_in ty1' ty2')
                     (stdlib.mkcall_conv_int ty2' e2)
                     (stdlib.mkcall_conv_int (Aty.Ctype [] (Aty.Basic (Aty.Integer (AilTypesAux.make_corresponding_unsigned ity2')))) e2)
                  )

            | _ ->
                let () = Debug.print_debug 1 [] (fun () ->
                  "is_arithmetic ty1: " ^ (if AilTypesAux.is_arithmetic ty1 then "true" else "false")
                ) in
                let () = Debug.print_debug 1 [] (fun () ->
                  "is_arithmetic ty2: " ^ (if AilTypesAux.is_arithmetic ty2 then "true" else "false")
                ) in
                let () = Debug.print_debug 1 [] (fun () ->
                  "ty1: " ^ Pp.stringFromAil_ctype AilTypes.no_qualifiers ty1 ^
                  ", ty2: " ^ Pp.stringFromAil_ctype AilTypes.no_qualifiers ty2 ^
                  ", e1: " ^ Pp.stringFromCore_pexpr e1 ^
                  ", e2: " ^ Pp.stringFromCore_pexpr e2
                ) in
                error "Translation.usual_arithmetic_conversion: not (integer vs integer)"
          end
      end in
  
  let result_ty = ctype_of a_expr in
  
  if AilTypesAux.is_pointer result_ty && Aaux.is_null_pointer_constant a_expr then
    (* TODO: this is a bit tasteless as it makes the case AilEconst, ConstantNull unreachable *)
    E.return $ Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_nullptr_pe (Caux.proj_ctype result_ty)))
  else
    let A.AnnotatedExpression annot std_annots loc expr = a_expr in
    Caux.add_loc loc <$> match expr with
      (* CHECKED IN APR2016 *)
      | A.AilEunary A.Plus e ->
          (* STD §6.5.3.3#2 *)
          let (oTy, mk_conversion) =
            if AilTypesAux.is_integer result_ty then
              (C.OTy_integer, integer_promotion (ctype_of e))
            else
              (C.OTy_floating, fun z -> z) in
          let obj_sym = Symbol.fresh () in
          let e_sym   = Symbol.fresh () in
          self e    >>= fun core_e  ->
          E.return $
            C.Expr [Annot.Astd "§6.5.3.3#2"] (
              C.Ewseq (Caux.mk_sym_pat e_sym (C.BTy_loaded oTy)) core_e (
                C.Expr [] (
                  C.Epure (
                    C.Pexpr [] () (
                      C.PEcase (Caux.mk_sym_pe e_sym)
                        [ (Caux.mk_specified_pat (Caux.mk_sym_pat obj_sym (C.BTy_object oTy)),
                           Caux.mk_specified_pe (mk_conversion (Caux.mk_sym_pe obj_sym)))
                        ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                           (* TODO: check that result_ty = promoted (ctype_of e) *)
                           Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)) ]
                    )
                  )
                )
              )
            )
      
      (* CHECKED IN APR2016 *)
      | A.AilEunary A.Minus e ->
          (* STD §6.5.3.3#3 *)
          let (oTy, zero_pe, mk_conversion) =
            if AilTypesAux.is_integer result_ty then
              (C.OTy_integer, Caux.mk_integer_pe 0, integer_promotion (ctype_of e))
            else
              (C.OTy_floating, Caux.mk_floating_value_pe Mem.zero_fval, fun z -> z) in
          let obj_sym = Symbol.fresh () in
          let e_sym   = Symbol.fresh () in
          self e    >>= fun core_e  ->
          E.return $
            C.Expr [Annot.Astd "§6.5.3.3#3"] (
              C.Ewseq (Caux.mk_sym_pat e_sym (C.BTy_loaded oTy)) core_e (
                C.Expr [] (
                  C.Epure (
                    C.Pexpr [] () (
                      C.PEcase (Caux.mk_sym_pe e_sym)
                        [ (C.Pattern [] (C.CaseCtor C.Cspecified [Caux.mk_sym_pat obj_sym (C.BTy_object oTy)]),
                           let expr =
                             Caux.mk_op_pe C.OpSub zero_pe (mk_conversion (Caux.mk_sym_pe obj_sym)) in
                           Caux.mk_specified_pe (
if AilTypesAux.is_signed_integer_type result_ty then
                             stdlib.mkcall_catch_exceptional_condition result_ty expr
else if AilTypesAux.is_integer result_ty then
                             stdlib.mkcall_wrapI result_ty expr
else
                             expr))
                        ; (C.Pattern [] (C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype]),
                           (* TODO: check that result_ty = promoted (ctype_of e) *)
                           Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)) ]
                    )
                  )
                )
              )
            )
      
      (* CHECKED IN APR2016 *)
      | A.AilEunary A.Bnot e ->
          (* STD §6.5.3.3#4 *)
          let obj_sym = Symbol.fresh () in
          let e_sym   = Symbol.fresh () in
          self e    >>= fun core_e  ->
          let oTy = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e)) in
          E.return $
            C.Expr [Annot.Astd "§6.5.3.3#4"] (
              C.Ewseq (Caux.mk_sym_pat e_sym (C.BTy_loaded oTy)) core_e (
                C.Expr [] (
                  C.Epure (
                    C.Pexpr [] () (
                      C.PEcase (Caux.mk_sym_pe e_sym)
                        [ (C.Pattern [] (C.CaseCtor C.Cspecified [Caux.mk_sym_pat obj_sym (C.BTy_object oTy)]),
                           let promoted_e = Caux.mk_std_pe "§6.5.3.3#4, sentence 2" $ integer_promotion (ctype_of e) (Caux.mk_sym_pe obj_sym) in
                           (* NOTE: result_ty == promoted type of e *)
                           Caux.mk_specified_pe (if AilTypesAux.is_unsigned_integer_type result_ty then
                             (* STD §6.5.3.3#4, sentence 3 *)
                             Caux.mk_std_pe "§6.5.3.3#4, sentence 3" $ Caux.mk_op_pe C.OpSub (Caux.mk_ivmax_pe (Caux.mk_ail_ctype_pe result_ty)) promoted_e
                           else
                             Caux.bitwise_complement_pe (Caux.mk_ail_ctype_pe result_ty) promoted_e))
                        ; (C.Pattern [] (C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype]),
                           (* TODO: check that result_ty = promoted (ctype_of e) *)
                           Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)) ]
                    )
                  )
                )
              )
            )
      
      (* CHECKED IN APR2016 *)
      | A.AilEunary A.Address (A.AnnotatedExpression _ _ _ (A.AilEunary A.Indirection e)) ->
          (* STD §6.5.3.2#3, sentence 3 *)
          (* NOTE: footnote 102 makes it clear that this is valid even if 'e' evaluates to a null pointer *)
          self e >>= fun (C.Expr annot core_expr_) ->
          E.return (C.Expr (Annot.Astd "§6.5.3.2#3, sentence 3" :: annot) core_expr_)
      
      (* CHECKED IN APR2016 *)
      | A.AilEunary A.Address e ->
          (* STD §6.5.3.2#3, sentence 5 *)
          if AilTypesAux.is_object (ctype_of e) then
            let _ = Debug.print_debug 1 [] (fun _ -> "aileunary adress, result type: " ^ Pp.stringFromAil_ctype Aty.no_qualifiers result_ty) in
             let sym = Symbol.fresh () in
             self e >>= fun core_e ->
             E.return $
               C.Expr [Annot.Astd "§6.5.3.2#3, sentence 5"] (
                 C.Ewseq (Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer)) core_e (
                   C.Expr [] (
                     C.Epure (Caux.mk_specified_pe (Caux.mk_sym_pe sym))
                   )
                 )
               )
          else
            let _ = Debug.print_debug 1 [] (fun _ -> "call to function designator through aileunary adress") in
            translate_function_designator ctx variadic_env stdlib tagDefs e
      
      (* TODO: promotion? + atomicity *)
      | A.AilEunary A.PostfixIncr e ->
          (* STD §6.5.2.4 *)
          let () = if AilTypesAux.is_atomic (ctype_of e) then
            Debug.warn [Debug.DB_elaboration] (fun () -> "TODO: elaboration is wrong for atomic types")
          else
            () in
          
          self e >>= fun core_e ->
          let () = Debug.print_debug 1 [Debug.DB_elaboration] (fun () -> "TODO: needs to fix this") in
          let ty  = AilTypesAux.rvalue_coercion (snd (from_lvalue_type e)) in
          let oTy = force_core_object_type_of_ctype (Caux.proj_ctype ty)    in
          let core_ty_e = Caux.mk_ail_ctype_pe ty in
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (lvalue_sym, lvalue_sym_pat, lvalue_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_loaded oTy)           >>= fun (load_sym,   load_sym_pat,   load_sym_pe)   ->
          E.wrapped_fresh_symbol (C.BTy_object oTy)           >>= fun (obj_sym,    obj_sym_pat,    obj_sym_pe)    ->
          
          E.return (
            C.Expr [Annot.Astd "§6.5.2.4"; Annot.Astd "§6.5.2.4#2, sentence 1"; Annot.Astd "§6.5.2.4#2, sentence 3"] (
              C.Ewseq lvalue_sym_pat core_e (
                C.Expr [Annot.Astd "§6.5.2.4#2, sentence 4"] (
                  C.Easeq ((load_sym, C.BTy_loaded oTy))
                    (C.Action loc default (C.Load core_ty_e lvalue_sym_pe Cmm.NA))
                    (C.Paction C.Neg (C.Action loc default (C.Store false(* not locking *)
                       core_ty_e
                       lvalue_sym_pe
                       (Caux.mk_case_pe load_sym_pe
                          [ ( Caux.mk_specified_pat obj_sym_pat
                            , Caux.mk_specified_pe $ Caux.mk_std_pe "§6.5.2.4#2, sentence 2"
match AilTypesAux.unatomic ty with
  | Aty.Basic (Aty.Integer _) ->
(*
                              stdlib.mkcall_conv_int (ctype_of e) (Caux.mk_op_pe C.OpAdd obj_sym_pe (Caux.mk_integer_pe 1))
*)
                          (* TODO: check again *)
                          let core_incr = Caux.mk_op_pe C.OpAdd obj_sym_pe (Caux.mk_integer_pe 1) in
      if AilTypesAux.is_signed_integer_type result_ty then
                          stdlib.mkcall_catch_exceptional_condition result_ty core_incr
      else (* is unsigned *)
                          stdlib.mkcall_wrapI result_ty core_incr
  | Aty.Basic (Aty.Floating (Aty.RealFloating _)) ->
                          (* TODO: not correct semantics for float *)
                          Caux.mk_op_pe C.OpAdd obj_sym_pe (Caux.mk_floating_value_pe Mem.one_fval)
                              (*error "AilEunary PostfixIncr, floating type"*)
  | Aty.Pointer _ ref_ty ->
                              Caux.mk_array_shift obj_sym_pe (Caux.proj_ctype ref_ty) (Caux.mk_integer_pe 1)
  | (*BISECT-IGNORE*) _ ->
      illTypedAil loc "AilEunary PostfixIncr"
end
                            )
                          ; ( C.Pattern [] (C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype])
                            , Caux.mk_unspecified_pe (Caux.proj_ctype ty)(*TODO:check*) )
                          ] )
                       Cmm.NA)))
                )
              )
            )
          )
      
      (* TODO: promotion? + atomicity *)
      (* TODO: factorise with PostfixIncr !!! *)
      | A.AilEunary A.PostfixDecr e ->
          (* STD §6.5.2.4 *)
          let () = if AilTypesAux.is_atomic (ctype_of e) then
            Debug.warn [Debug.DB_elaboration] (fun () -> "TODO: elaboration is wrong for atomic types")
          else
            () in
          (* TODO: qualifiers temporarily not dealt with *)
          let lvalue_sym = Symbol.fresh () in
          let load_sym   = Symbol.fresh () in
          let obj_sym    = Symbol.fresh () in
          self e         >>= fun core_e     ->
          let ty  = AilTypesAux.rvalue_coercion (snd (from_lvalue_type e)) in
          let oTy = force_core_object_type_of_ctype (Caux.proj_ctype ty)    in
          let core_ty_e = Caux.mk_ail_ctype_pe ty in
          
          let lvalue_sym_pe = Caux.mk_sym_pe lvalue_sym in
          let load_sym_pe   = Caux.mk_sym_pe load_sym             in
          let obj_sym_pe    = Caux.mk_sym_pe obj_sym              in
          
          E.return $
            C.Expr [Annot.Astd "§6.5.2.4#3"] (
              C.Ewseq (Caux.mk_sym_pat lvalue_sym (C.BTy_object C.OTy_pointer)) core_e (
                C.Expr [] (
                  C.Easeq ((load_sym, C.BTy_loaded oTy))
                    (C.Action loc default (C.Load core_ty_e lvalue_sym_pe Cmm.NA))
                    (C.Paction C.Neg (C.Action loc default (C.Store false(* not locking *)
                       core_ty_e
                       lvalue_sym_pe
                       (C.Pexpr [] () begin
                          C.PEcase load_sym_pe
                            [ ( Caux.mk_specified_pat (Caux.mk_sym_pat obj_sym (C.BTy_object oTy))
                              , Caux.mk_specified_pe
match AilTypesAux.unatomic ty with
  | Aty.Basic (Aty.Integer _) ->
                          (* TODO: check again *)
                          let core_decr = Caux.mk_op_pe C.OpSub obj_sym_pe (Caux.mk_integer_pe 1) in
      if AilTypesAux.is_signed_integer_type result_ty then
                          stdlib.mkcall_catch_exceptional_condition result_ty core_decr
      else (* is unsigned *)
                          stdlib.mkcall_wrapI result_ty core_decr
  | Aty.Basic (Aty.Floating (Aty.RealFloating _)) ->
                          (* TODO: not correct semantics for float *)
                          Caux.mk_op_pe C.OpSub obj_sym_pe (Caux.mk_floating_value_pe Mem.one_fval)
  | Aty.Pointer _ ref_ty ->
                                   (* TODO: check again *)
                                   Caux.mk_array_shift obj_sym_pe (Caux.proj_ctype ref_ty) (Caux.mk_integer_pe (0 - 1))
  | (*BISECT-IGNORE*) _ ->
      illTypedAil loc "AilEunary PostfixIncr"
end
                             )
                            ; ( C.Pattern [] (C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype])
                              , Caux.mk_unspecified_pe (Caux.proj_ctype ty)(*TODO:check*) )
                            ]
                       end)
                       Cmm.NA)))
                )
              )
            )
      
      | A.AilEunary A.Indirection e ->
          (* TODO: if e is a pointer to a function *)
if AilTypesAux.is_pointer_to_function (ctype_of e) then
          (* STD 6.5.3.2#4 *)
          (* maybe need the ailrvalue stuff *)
          translate_function_designator ctx variadic_env stdlib tagDefs e
          (* error "WIP: Elaboration, A.Indirection, function designator" *)
else match AilTypesAux.referenced_type (ctype_of e) with
  | (*BISECT-IGNORE*) Nothing ->
      illTypedAil loc "AilEunary Indirection, not a pointer type"
  | Just ref_ty ->
          let e_sym    = Symbol.fresh () in
          let obj_sym  = Symbol.fresh () in
          let test_sym = Symbol.fresh () in (* symbol for the PtrValidForDeref test *)
          self e         >>= fun core_e   ->
          E.return $
            C.Expr [Annot.Astd "§6.5.3.2"] (
              C.Ewseq (Caux.mk_sym_pat e_sym (C.BTy_loaded C.OTy_pointer)) core_e (
                C.Expr [] (
                  C.Ecase (Caux.mk_sym_pe e_sym)
                    [ ( Caux.mk_specified_pat (Caux.mk_sym_pat obj_sym (C.BTy_object C.OTy_pointer))
                      , C.Expr [] (
                          C.Ewseq (Caux.mk_sym_pat test_sym C.BTy_boolean)
                            (C.Expr [] (C.Ememop Mem_common.PtrValidForDeref [Caux.mk_ail_ctype_pe ref_ty; Caux.mk_sym_pe obj_sym])) (
                              C.Expr [] (
                                C.Eif (Caux.mk_sym_pe test_sym)
                                  begin
                                    let obj_sym_pe = 
                                      Caux.mk_sym_pe obj_sym in
(*                             Caux.pload loc (Caux.mk_ail_ctype_pe result_ty) obj_sym_pe Cmm.NA *)
                                    C.Expr [] (C.Epure (obj_sym_pe))
                                  end
                                  (C.Expr [] (C.Epure (Caux.mk_std_undef_pe loc "§6.5.3.3#4, sentence 4" Undefined.UB043_indirection_invalid_value)))
                              )
                            )
                        ) )
                    ; ( C.Pattern [] (C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype])
                      , C.Expr [] (C.Epure (Caux.mk_std_undef_pe loc "§6.5.3.3#4, sentence 4" Undefined.UB043_indirection_invalid_value(*TODO:check*))) )
                    ]
                )
              )
            )
end

(*
The unary * operator denotes indirection.

If the operand points to a function, the result is a function designator; if it points to an object, the result is an lvalue designating the object.

If the operand has type ‘‘pointer to type’’, the result has type ‘‘type’’.

If an invalid value has been assigned to the pointer, the behavior of the unary * operator is undefined.
*)

      
      | A.AilEbinary e1 (A.Arithmetic A.Shl) e2 ->
          (* STD §6.5.7 *)
          self e1        >>= fun core_e1       ->
          self e2        >>= fun core_e2       ->
          let e1_sym        = Symbol.fresh () in
          let e2_sym        = Symbol.fresh () in
          let obj1_sym      = Symbol.fresh () in
          let obj2_sym      = Symbol.fresh () in
          let promoted1_sym = Symbol.fresh () in
          let promoted2_sym = Symbol.fresh () in
          let res_sym       = Symbol.fresh () in
          let e1_sym_pe        = Caux.mk_sym_pe e1_sym        in
          let e2_sym_pe        = Caux.mk_sym_pe e2_sym        in
          let obj1_sym_pe      = Caux.mk_sym_pe obj1_sym      in
          let obj2_sym_pe      = Caux.mk_sym_pe obj2_sym      in
          let promoted1_sym_pe = Caux.mk_sym_pe promoted1_sym in
          let promoted2_sym_pe = Caux.mk_sym_pe promoted2_sym in
          let res_sym_pe       = Caux.mk_sym_pe res_sym       in
          E.return $
            C.Expr  [Annot.Astd "§6.5.7"] (
              C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat e1_sym (C.BTy_loaded C.OTy_integer)
                                         ; Caux.mk_sym_pat e2_sym (C.BTy_loaded C.OTy_integer) ]) (Caux.mk_unseq [core_e1; core_e2]) (
                C.Expr [] (
                  C.Epure (
                    C.Pexpr [] () (
                      C.PEcase (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
                        [ (Caux.mk_tuple_pat [ Caux.mk_empty_pat (C.BTy_loaded C.OTy_integer)
                                             ; C.Pattern [] (C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype ]) ],
                           Caux.mk_undef_exceptional_condition loc)
                        ; (Caux.mk_tuple_pat [ C.Pattern [] (C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype])
                                             ; Caux.mk_empty_pat (C.BTy_loaded C.OTy_integer) ],
(if AilTypesAux.is_unsigned_integer_type (ctype_of e1) then
                           Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)
else
                           Caux.mk_undef_exceptional_condition loc
)
                          )
                        ; (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object C.OTy_integer))
                                             ; Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object C.OTy_integer)) ],
                           Caux.mk_let_pe (Caux.mk_sym_pat promoted1_sym (C.BTy_object C.OTy_integer))
                             (Caux.mk_std_pe "§6.5.7#3, sentence 1" $ integer_promotion (ctype_of e1) obj1_sym_pe)
                           (Caux.mk_let_pe (Caux.mk_sym_pat promoted2_sym (C.BTy_object C.OTy_integer))
                             (Caux.mk_std_pe "§6.5.7#3, sentence 1" $ integer_promotion (ctype_of e2) obj2_sym_pe)
                           (* (§6.5.7#2) if promoted2 < 0 then undef *)
                           (Caux.mk_if_pe (Caux.mk_op_pe C.OpLt promoted2_sym_pe (Caux.mk_integer_pe 0))
                             (Caux.mk_std_undef_pe loc "§6.5.7#3, sentence 3" Undefined.UB051a_negative_shift)
                           (* ctype_width(result_ty) <= promoted2 *)
                           (Caux.mk_if_pe (Caux.mk_op_pe C.OpOr (Caux.mk_op_pe C.OpLt (stdlib.mkcall_ctype_width result_ty) promoted2_sym_pe)
                                                                (Caux.mk_op_pe C.OpEq (stdlib.mkcall_ctype_width result_ty) promoted2_sym_pe))
                              (Caux.mk_std_undef_pe loc "§6.5.7#4, sentence 3" Undefined.UB51b_shift_too_large)
(if AilTypesAux.is_unsigned_integer_type (ctype_of e1) then
                           (Caux.mk_specified_pe (Caux.mk_std_pe "§6.5.7#4, sentence 2" (
                              Caux.mk_op_pe C.OpRem_t (Caux.mk_op_pe C.OpMul promoted1_sym_pe (Caux.mk_op_pe C.OpExp (Caux.mk_integer_pe 2) promoted2_sym_pe))
                                                      (Caux.mk_op_pe C.OpAdd (Caux.mk_ivmax_pe (Caux.mk_ail_ctype_pe result_ty)) (Caux.mk_integer_pe 1))
                            )))
else
                           Caux.mk_std_pe "§6.5.7#4, sentence 3" $
                           (Caux.mk_if_pe (Caux.mk_op_pe C.OpLt promoted1_sym_pe (Caux.mk_integer_pe 0))
                             (Caux.mk_std_undef_pe loc "§6.5.7#3, sentence 3" Undefined.UB052a_negative_left_shift)
                           (Caux.mk_let_pe (Caux.mk_sym_pat res_sym (C.BTy_object C.OTy_integer))
                             (Caux.mk_op_pe C.OpMul promoted1_sym_pe (Caux.mk_op_pe C.OpExp (Caux.mk_integer_pe 2) promoted2_sym_pe))
                           (Caux.mk_if_pe (stdlib.mkcall_is_representable res_sym_pe result_ty)
                              (Caux.mk_specified_pe res_sym_pe)
                            (Caux.mk_std_undef_pe loc "§6.5.7#3, sentence 3" Undefined.UB052b_non_representable_left_shift))))
)
                           )))) ]
                    )
                  )
                )
              )
            )
      
      | A.AilEbinary e1 (A.Arithmetic A.Shr) e2 ->
          (* STD §6.5.7 *)
          self e1        >>= fun core_e1       ->
          self e2        >>= fun core_e2       ->
          let e1_sym        = Symbol.fresh () in
          let e2_sym        = Symbol.fresh () in
          let obj1_sym      = Symbol.fresh () in
          let obj2_sym      = Symbol.fresh () in
          let promoted1_sym = Symbol.fresh () in
          let promoted2_sym = Symbol.fresh () in
          let res_sym       = Symbol.fresh () in
          let e1_sym_pe        = Caux.mk_sym_pe e1_sym        in
          let e2_sym_pe        = Caux.mk_sym_pe e2_sym        in
          let obj1_sym_pe      = Caux.mk_sym_pe obj1_sym      in
          let obj2_sym_pe      = Caux.mk_sym_pe obj2_sym      in
          let promoted1_sym_pe = Caux.mk_sym_pe promoted1_sym in
          let promoted2_sym_pe = Caux.mk_sym_pe promoted2_sym in
          (*let res_sym_pe       = Caux.mk_sym_pe res_sym       in*)
          E.return $
            C.Expr [Annot.Astd "§6.5.7"] (
              C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat e1_sym (C.BTy_loaded C.OTy_integer)
                                         ; Caux.mk_sym_pat e2_sym (C.BTy_loaded C.OTy_integer) ]) (Caux.mk_unseq [core_e1; core_e2]) (
                C.Expr [] (
                  C.Epure (
                    C.Pexpr [] () (
                      C.PEcase (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
                        [ (Caux.mk_tuple_pat [ Caux.mk_empty_pat (C.BTy_loaded C.OTy_integer)
                                             ; C.Pattern [] (C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype ]) ],
                           Caux.mk_undef_exceptional_condition loc)
                        ; (Caux.mk_tuple_pat [ C.Pattern [] (C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype])
                                             ; Caux.mk_empty_pat (C.BTy_loaded C.OTy_integer) ],
                           Caux.mk_unspecified_pe (Caux.proj_ctype result_ty))
                        ; (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object C.OTy_integer))
                                             ; Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object C.OTy_integer)) ],
                           Caux.mk_let_pe (Caux.mk_sym_pat promoted1_sym (C.BTy_object C.OTy_integer))
                             (integer_promotion (ctype_of e1) obj1_sym_pe)
                           (Caux.mk_let_pe (Caux.mk_sym_pat promoted2_sym (C.BTy_object C.OTy_integer))
                             (integer_promotion (ctype_of e2) obj2_sym_pe)
                           (* (§6.5.7#2) if promoted2 < 0 then undef *)
                           (Caux.mk_if_pe (Caux.mk_op_pe C.OpLt promoted2_sym_pe (Caux.mk_integer_pe 0))
                             (Caux.mk_std_undef_pe loc "§6.5.7#3, sentence 3" Undefined.UB051a_negative_shift)
                           
                           (* ctype_width(result_ty) <= promoted2 *)
                           (Caux.mk_if_pe (Caux.mk_op_pe C.OpOr (Caux.mk_op_pe C.OpLt (stdlib.mkcall_ctype_width result_ty) promoted2_sym_pe)
                                                                (Caux.mk_op_pe C.OpEq (stdlib.mkcall_ctype_width result_ty) promoted2_sym_pe))
                              (Caux.mk_std_undef_pe loc "§6.5.7#3, sentence 3" Undefined.UB51b_shift_too_large)
                              (let expr = Caux.mk_op_pe C.OpDiv obj1_sym_pe (Caux.mk_op_pe C.OpExp (Caux.mk_integer_pe 2) promoted2_sym_pe) in
                               Caux.mk_specified_pe $
if AilTypesAux.is_unsigned_integer_type (ctype_of e1) then
                               Caux.mk_std_pe "6.5.7#5, sentence 2" expr
else
                               Caux.mk_std_pe "6.5.7#5, sentence 3" $ Caux.mk_if_pe (Caux.mk_op_pe C.OpGe promoted1_sym_pe (Caux.mk_integer_pe 0))
                                 expr
                                 (C.Pexpr [] () (
                                    C.PEcall (C.Impl Implementation_.SHR_signed_negative) [Caux.mk_ail_ctype_pe (ctype_of e1) ; promoted1_sym_pe; promoted2_sym_pe]
                                 ))))))) ]
                    )
                  )
                )
              )
            )
      
      | A.AilEident id ->
          let id_sym_pe = match ctx with
            | ECTX_other ->
                  Caux.mk_sym_pe id
            | ECTX_glob glob_sym sym' ->
                if id = glob_sym then
                  Caux.mk_sym_pe sym'
                else
                  Caux.mk_sym_pe id
          end in
          E.return (C.Expr [] (C.Epure id_sym_pe))

        (* NOTE: this is not enough *)
(*
            E.return $
              if AilTypesAux.is_array result_ty then
                (* STD §6.3.2.1# *) (* TODO check *)
                C.Epure ((*Caux.mk_specified_pe*)id_sym_pe)
              else if is_lvalue then
                C.Epure ((*Caux.mk_specified_pe*)id_sym_pe)
              else
                Caux.pload loc (Caux.mk_ail_ctype_pe result_ty) id_sym_pe Cmm.NA
*)
      
      | A.AilEcast _ cast_ty e ->
          let e_ty = ctype_of e in
          let oTy = force_core_object_type_of_ctype (Caux.proj_ctype e_ty) in
          E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun (e_sym,   e_sym_pat,   e_sym_pe  ) ->
          E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun (obj_sym, obj_sym_pat, obj_sym_pe) ->
          (* STD §6.3.2.1#2 "lvalue conversion" *)
(*          E._STD "§6.3.2.1#2" $ (* TODO: what it this std refering too? *) *)
          self e    >>= fun core_e  ->
          let let_sym = Symbol.fresh () in
          E.return $
            Caux.add_std "§6.5.4" (
if AilTypesAux.is_void cast_ty then
              Caux.mk_wseq_e e_sym_pat core_e
                Caux.mk_skip_e

else if AilTypesAux.is_pointer cast_ty && Aaux.is_null_pointer_constant e then
  match AilTypesAux.referenced_type cast_ty with
    | (*BISECT-IGNORE*) Nothing ->
              illTypedAil loc "AilEcast, pointer vs null_pointer_constant"
    | Just ref_ty ->
              Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_nullptr_pe (Caux.proj_ctype ref_ty)))
  end

else if AilTypesAux.is_arithmetic cast_ty && AilTypesAux.is_arithmetic e_ty then
  if AilTypesAux.is_integer cast_ty then
    if AilTypesAux.is_integer e_ty then
              (* TODO: check *)
              Caux.mk_wseq_e e_sym_pat core_e (
                Caux.mk_pure_e (stdlib.mkcall_conv_loaded_int cast_ty e_sym_pe)
              )
    else (* cast_ty is floating since it is an arithmetic type *)
              (* TODO: this is wrong ==> need to pattern match the Specified *)
              Caux.mk_wseq_e e_sym_pat core_e (
                Caux.mk_pure_e (stdlib.mkcall_loaded_ivfromfloat cast_ty e_sym_pe)
              )
  else
    if AilTypesAux.is_integer e_ty then
              (* TODO: this is wrong ==> need to pattern match the Specified *)
              Caux.mk_wseq_e e_sym_pat core_e (
                Caux.mk_pure_e (stdlib.mkcall_loaded_fvfromint cast_ty e_sym_pe)
              )
    else (* cast_ty is floating since it is an arithmetic type *)
           (* TODO: should convert floating types *)
              let () = Debug.warn [Debug.DB_elaboration] (fun () ->
                "TODO: casts between floating types is currently a NOP"
              ) in
             core_e

else if AilTypesAux.is_pointer cast_ty && AilTypesAux.is_arithmetic e_ty then
            (* making a pointer from an integer *)
              let ref_ty = fromJust "Translation.translate_expression, AilEcast 1" $ AilTypesAux.referenced_type cast_ty in
              Caux.mk_wseq_e e_sym_pat core_e (
                Caux.mk_case_e e_sym_pe
                  [ ( Caux.mk_specified_pat obj_sym_pat
                    , Caux.mk_wseq_e (Caux.mk_sym_pat let_sym (C.BTy_object C.OTy_pointer))
                        (C.Expr [] (C.Ememop Mem_common.PtrFromInt [Caux.mk_ail_ctype_pe e_ty; Caux.mk_ail_ctype_pe ref_ty; obj_sym_pe]))
                        (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_sym_pe let_sym))) )
                  ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                    , (* Casting an unspecified integer to a pointer type gives an unspecified pointer *)
                      Caux.mk_pure_e (Caux.mk_unspecified_pe (Caux.proj_ctype cast_ty)) ) ]
              )

else if AilTypesAux.is_arithmetic cast_ty && AilTypesAux.is_pointer e_ty then
              (* making an integer from a pointer *)
              let ref_ty = fromJust "Translation.translate_expression, AilEcast 2" $ AilTypesAux.referenced_type e_ty in
              Caux.mk_wseq_e e_sym_pat core_e (
                  Caux.mk_case_e e_sym_pe
                    [ ( Caux.mk_specified_pat obj_sym_pat
                      , Caux.mk_wseq_e (Caux.mk_sym_pat let_sym (C.BTy_object C.OTy_integer))
                          (C.Expr [] (C.Ememop Mem_common.IntFromPtr [Caux.mk_ail_ctype_pe ref_ty; Caux.mk_ail_ctype_pe cast_ty; obj_sym_pe]))
                          (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_sym_pe let_sym))) )
                    ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                      , (* Casting an unspecified pointer to an integer type gives an unspecified integer *)
                        Caux.mk_pure_e (Caux.mk_unspecified_pe (Caux.proj_ctype cast_ty)) ) ]
              )

else (* pointer <-> pointer cast *)
              let () = Debug.warn [Debug.DB_elaboration] (fun () ->
                "NOTE: the elaboration does the identity for casts between pointer types (this is different from ISO)"
              ) in
              let ub_pe = Caux.mk_undef_pe loc Undefined.UB025_misaligned_pointer_conversion in
              match AilTypesAux.referenced_type cast_ty with
                | Just cast_ref_ty ->
  if AilTypesAux.is_void cast_ref_ty || AilTypesAux.is_function cast_ref_ty then
                    core_e
  else
                    Caux.mk_wseq_e (Caux.mk_sym_pat e_sym (C.BTy_loaded oTy)) core_e begin
                      Caux.mk_case_e e_sym_pe
                        [ ( Caux.mk_specified_pat obj_sym_pat
                          , Caux.mk_wseq_e (Caux.mk_sym_pat let_sym C.BTy_boolean)
                              (C.Expr [] (C.Ememop Mem_common.PtrWellAligned [Caux.mk_ail_ctype_pe cast_ref_ty; obj_sym_pe]))
                              (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_if_pe (Caux.mk_sym_pe let_sym) obj_sym_pe ub_pe))) )
                        ; ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                          , (* we are being daemonic (case where the resulting pointer would be misaligned) *)
                            Caux.mk_pure_e ub_pe ) ]
                    end
                | _ ->
                    error "Translation AilEcast, ptr vs ptr: just should be impossible"
              end
            )
      
      | A.AilEbinary e1 (A.Arithmetic A.Mul) e2 ->
          translate_mul_operator loc self usual_arithmetic_conversion stdlib
            result_ty e1 e2
      | A.AilEbinary e1 (A.Arithmetic (A.Div as aop)) e2 ->
          translate_div_mod_operator loc self usual_arithmetic_conversion stdlib
            result_ty aop e1 e2
      | A.AilEbinary e1 (A.Arithmetic (A.Mod as aop)) e2 ->
          translate_div_mod_operator loc self usual_arithmetic_conversion stdlib
            result_ty aop e1 e2
      
      | A.AilEbinary e1 (A.Arithmetic A.Add) e2 ->
          self e1 >>= fun core_e1 ->
          self e2 >>= fun core_e2 ->
if AilTypesAux.is_arithmetic (ctype_of e1) && AilTypesAux.is_arithmetic (ctype_of e2) then
            let oTy1 = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
            let oTy2 = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e2)) in
            E.wrapped_fresh_symbol (C.BTy_loaded oTy1) >>= fun (e1_sym  , e1_sym_pat  , e1_sym_pe  ) ->
            E.wrapped_fresh_symbol (C.BTy_loaded oTy2) >>= fun (e2_sym  , e2_sym_pat  , e2_sym_pe  ) ->
            E.wrapped_fresh_symbol (C.BTy_object oTy1) >>= fun (obj1_sym, obj1_sym_pat, obj1_sym_pe) ->
            E.wrapped_fresh_symbol (C.BTy_object oTy2) >>= fun (obj2_sym, obj2_sym_pat, obj2_sym_pe) ->
            let (promoted1_pe, promoted2_pe) = Caux.mk_std_pair_pe "§6.5.6#4" $ usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe in
            E.return $
              C.Expr [Annot.Astd "§6.5.6"] (
                C.Ewseq (Caux.mk_tuple_pat [ e1_sym_pat; e2_sym_pat ]) (Caux.mk_unseq [core_e1; core_e2]) (
                Caux.mk_pure_e (
                  Caux.mk_case_pe (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
                    [ ( Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_sym_pat
                                          ; Caux.mk_specified_pat obj2_sym_pat ]
                      , (* Both operand are specified *)
                        let core_add = Caux.mk_std_pe "§6.5.6#5" $ Caux.mk_op_pe C.OpAdd promoted1_pe promoted2_pe in
                        Caux.mk_specified_pe $
  if AilTypesAux.is_signed_integer_type result_ty then
                          stdlib.mkcall_catch_exceptional_condition result_ty core_add
  else if AilTypesAux.is_integer result_ty then
                          stdlib.mkcall_wrapI result_ty core_add
  else
                          core_add )
                    
                    ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy1; C.BTy_loaded oTy2])
                      , (* If either operand is unspecified, the result is also unspecified is the
                           result type of unsigned. Otherwise it is undef, since the addition
                           may overflow *)
  if AilTypesAux.is_unsigned_integer_type result_ty then
                        Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)
  else
                        Caux.mk_undef_exceptional_condition loc) ]
                )
              )
            )
else
          (* Here one of the operand is pointer *)
          let (ptr_ty, ptr_core_e, integer_core_e) =
if AilTypesAux.is_arithmetic (ctype_of e1) then
            (ctype_of e2, core_e2, core_e1)
else
            (ctype_of e1, core_e1, core_e2) in
          
          let ref_ty = match AilTypesAux.referenced_type ptr_ty with
            | (*BISECT-IGNORE*) Nothing ->
                illTypedAil loc "A.AilEbinary (A.Arithmetic A.Add), one is pointer"
            | Just ref_ty ->
                ref_ty
          end in
          
            let ptr_sym         = Symbol.fresh () in
            let integer_sym     = Symbol.fresh () in
            let ptr_obj_sym     = Symbol.fresh () in
            let integer_obj_sym = Symbol.fresh () in
            let ptr_sym_pe         = Caux.mk_sym_pe ptr_sym         in
            let ptr_obj_sym_pe     = Caux.mk_sym_pe ptr_obj_sym     in
            let integer_sym_pe     = Caux.mk_sym_pe integer_sym     in
            let integer_obj_sym_pe = Caux.mk_sym_pe integer_obj_sym in
            E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (res_sym, res_sym_pat, res_sym_pe) ->
            E.return $
              C.Expr [Annot.Astd "§6.5.6"] (
                C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat ptr_sym     (C.BTy_loaded C.OTy_pointer)
                                           ; Caux.mk_sym_pat integer_sym (C.BTy_loaded C.OTy_integer) ]) (Caux.mk_unseq [ptr_core_e; integer_core_e]) (
                  Caux.mk_case_e (Caux.mk_tuple_pe [ptr_sym_pe; integer_sym_pe])
                    [ ( Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat ptr_obj_sym (C.BTy_object C.OTy_pointer))
                                          ; Caux.mk_specified_pat (Caux.mk_sym_pat integer_obj_sym (C.BTy_object C.OTy_integer)) ]
                      , (* Both operand are specified *)
if Global.has_switch Global.SW_strict_pointer_arith then
                        Caux.mk_wseq_e res_sym_pat
                          (C.Expr [] (C.Ememop Mem_common.PtrArrayShift [ptr_obj_sym_pe; Caux.mk_ail_ctype_pe ref_ty; integer_obj_sym_pe]))
                          (Caux.mk_pure_e (Caux.mk_specified_pe res_sym_pe))
else
                        Caux.mk_pure_e $ Caux.mk_specified_pe (
                          Caux.mk_std_pe "§6.5.6#8, sentences 2-3" $ Caux.mk_array_shift ptr_obj_sym_pe (Caux.proj_ctype ref_ty) integer_obj_sym_pe
                        ) )
                    ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded C.OTy_pointer; C.BTy_loaded C.OTy_integer])
                      , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY "unspecified array_shift (addr)")) ) ]
                )
              )
      
      (* TODO: check + try to factorise with A.Add *)
      | A.AilEbinary e1 (A.Arithmetic A.Sub) e2 ->
          self e1 >>= fun core_e1 ->
          self e2 >>= fun core_e2 ->
if AilTypesAux.is_arithmetic (ctype_of e1) && AilTypesAux.is_arithmetic (ctype_of e2) then
          let oTy1 = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
          let oTy2 = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e2)) in
          E.wrapped_fresh_symbol (C.BTy_loaded oTy1) >>= fun (e1_sym, e1_sym_pat, e1_sym_pe)       ->
          E.wrapped_fresh_symbol (C.BTy_loaded oTy2) >>= fun (e2_sym, e2_sym_pat, e2_sym_pe)       ->
          E.wrapped_fresh_symbol (C.BTy_object oTy1) >>= fun (obj1_sym, obj1_sym_pat, obj1_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_object oTy2) >>= fun (obj2_sym, obj2_sym_pat, obj2_sym_pe) ->
          let (promoted1_pe, promoted2_pe) = Caux.mk_std_pair_pe "§6.5.6#4" $
            usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe in
          E.return $
            C.Expr [Annot.Astd "§6.5.6"] (
              C.Ewseq (Caux.mk_tuple_pat [e1_sym_pat; e2_sym_pat]) (Caux.mk_unseq [core_e1; core_e2]) (
                Caux.mk_pure_e (
                  Caux.mk_case_pe (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
                    [ ( Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_sym_pat
                                          ; Caux.mk_specified_pat obj2_sym_pat ]
                      , (* Both operand are specified *)
                        let core_sub = Caux.mk_std_pe "§6.5.6#6" $ Caux.mk_op_pe C.OpSub promoted1_pe promoted2_pe in
                        Caux.mk_specified_pe $
  if AilTypesAux.is_signed_integer_type result_ty then
                          stdlib.mkcall_catch_exceptional_condition result_ty core_sub
  else if AilTypesAux.is_integer result_ty then
                          stdlib.mkcall_wrapI result_ty core_sub
  else
                          core_sub )
                    ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy1; C.BTy_loaded oTy2])
                      , (* If either operand is unspecified, the result is also unspecified is the
                           result type of unsigned. Otherwise it is undef, since the addition
                           may overflow *)
  if AilTypesAux.is_signed_integer_type result_ty then
                        Caux.mk_undef_exceptional_condition loc
  else
                        Caux.mk_unspecified_pe (Caux.proj_ctype result_ty) ) ]
                )
              )
            )

else if AilTypesAux.is_pointer (ctype_of e1) && AilTypesAux.is_pointer (ctype_of e2) then
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (e1_sym, e1_sym_pat, e1_sym_pe)          ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (e2_sym, e2_sym_pat, e2_sym_pe)          ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (obj1_sym, obj1_sym_pat, obj1_sym_pe)    ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (obj2_sym, obj2_sym_pat, obj2_sym_pe)    ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (memop_sym, memop_sym_pat, memop_sym_pe) ->
          
          (* NOTE: by Ail typing we can just use the referenced type of either operand *)
          (* TODO: check that, we "only" know that their referenced types are compatible *)
          let diff_ty_pe = match (ctype_of e1) with
            | Aty.Ctype _ (Aty.Pointer _ ref_ty1) ->
                Caux.mk_ail_ctype_pe ref_ty1
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "ptrdiff"
          end in
          E.return $
            C.Expr [Annot.Astd "§6.5.6"] (
              C.Ewseq (Caux.mk_tuple_pat [e1_sym_pat; e2_sym_pat]) (Caux.mk_unseq [core_e1; core_e2]) (
                Caux.mk_case_e (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
                  [ ( Caux.mk_tuple_pat [ Caux.mk_specified_pat obj1_sym_pat
                                        ; Caux.mk_specified_pat obj2_sym_pat ]
                    , (* Both operand are specified *)
                      Caux.mk_wseq_e memop_sym_pat
                        (C.Expr [] (C.Ememop Mem_common.Ptrdiff [diff_ty_pe; obj1_sym_pe; obj2_sym_pe]))
                        begin
                          Caux.mk_pure_e begin
                            Caux.mk_if_pe (stdlib.mkcall_is_representable memop_sym_pe Aty.ptrdiff_t)
                              (Caux.mk_specified_pe memop_sym_pe)
                              (Caux.mk_undef_pe loc Undefined.UB050_pointers_subtraction_not_representable)
                          end
                        end )
                  ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded C.OTy_pointer; C.BTy_loaded C.OTy_pointer])
                    , Caux.mk_pure_e (Caux.mk_undef_pe loc Undefined.UB050_pointers_subtraction_not_representable) ) ]
              )
            )

else
            (* Here one of the operand is pointer *)
            let (ptr_ty, ptr_core_e, integer_core_e) =
              if AilTypesAux.is_arithmetic (ctype_of e1) then
                (ctype_of e2, core_e2, core_e1)
              else
                (ctype_of e1, core_e1, core_e2) in
            
            let ref_ty = match AilTypesAux.referenced_type ptr_ty with
              | (*BISECT-IGNORE*) Nothing ->
                  illTypedAil loc "A.AilEbinary (A.Arithmetic A.Sub), one is pointer"
              | Just ref_ty ->
                  ref_ty
            end in
            
            let ptr_sym = Symbol.fresh () in
            let integer_sym = Symbol.fresh () in
            let ptr_obj_sym = Symbol.fresh () in
            let integer_obj_sym = Symbol.fresh () in
            let ptr_sym_pe         = Caux.mk_sym_pe ptr_sym         in
            let ptr_obj_sym_pe     = Caux.mk_sym_pe ptr_obj_sym     in
            let integer_sym_pe     = Caux.mk_sym_pe integer_sym     in
            let integer_obj_sym_pe = Caux.mk_sym_pe integer_obj_sym in
            E.return $
              C.Expr [Annot.Astd "§6.5.6"] (
                C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat ptr_sym     (C.BTy_loaded C.OTy_pointer)
                                           ; Caux.mk_sym_pat integer_sym (C.BTy_loaded C.OTy_integer) ])
                  (Caux.mk_unseq [ptr_core_e; integer_core_e]) (
                  Caux.mk_pure_e (
                    Caux.mk_case_pe (Caux.mk_tuple_pe [ptr_sym_pe; integer_sym_pe])
                        [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat ptr_obj_sym (C.BTy_object C.OTy_pointer))
                                           ; Caux.mk_specified_pat (Caux.mk_sym_pat integer_obj_sym (C.BTy_object C.OTy_integer)) ],
                         (* Both operand are specified *)
                         Caux.mk_specified_pe (
                           Caux.mk_std_pe "§6.5.6#8, sentences 2-3" $ Caux.mk_array_shift ptr_obj_sym_pe (Caux.proj_ctype ref_ty) (Caux.mk_neg_pe integer_obj_sym_pe)
                         ))
                        ; ( Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded C.OTy_pointer; C.BTy_loaded C.OTy_integer])
                          , Caux.mk_undef_pe loc (Undefined.DUMMY "unspecified array_shift (sub)") ) ]
                  )
                )
              )
      
      | A.AilEbinary e1 (A.Lt as bop) e2 ->
          translate_relational_operator
            self usual_arithmetic_conversion
            result_ty bop e1 e2
      | A.AilEbinary e1 (A.Gt as bop) e2 ->
          translate_relational_operator
            self usual_arithmetic_conversion
            result_ty bop e1 e2
      | A.AilEbinary e1 (A.Le as bop) e2 ->
          translate_relational_operator
            self usual_arithmetic_conversion
            result_ty bop e1 e2
      | A.AilEbinary e1 (A.Ge as bop) e2 ->
          translate_relational_operator
            self usual_arithmetic_conversion
            result_ty bop e1 e2
      
      | A.AilEbinary e1 (A.Eq as bop) e2 ->
          translate_equality_operator loc
            self usual_arithmetic_conversion
            result_ty bop e1 e2
      | A.AilEbinary e1 (A.Ne as bop) e2 ->
          translate_equality_operator loc
            self usual_arithmetic_conversion
            result_ty bop e1 e2
      
      | A.AilEbinary e1 (A.Arithmetic (A.Band as aop)) e2 ->
          translate_bitwise_operator
            loc self usual_arithmetic_conversion stdlib
            result_ty aop e1 e2
      | A.AilEbinary e1 (A.Arithmetic (A.Bxor as aop)) e2 ->
          translate_bitwise_operator
            loc self usual_arithmetic_conversion stdlib
            result_ty aop e1 e2
      | A.AilEbinary e1 (A.Arithmetic (A.Bor as aop)) e2 ->
          translate_bitwise_operator
            loc self usual_arithmetic_conversion stdlib
            result_ty aop e1 e2
      
      | A.AilEbinary e1 A.And e2 ->
          (* TODO: this is hackish, but on the other hand it factorise code ... *)
          (* Also it follows the phrasing of the std *)
          (* Desugaring e1 && e2 ===> (e1 == 0) ? 0 : (e2 != 0) *)
          self begin
            A.AnnotatedExpression
              (GenTypes.GenRValueType signedInt_gty) [] loc
              (A.AilEcond (mkTestExpression TestEq e1) zeroAil_tau (mkTestExpression TestNe e2))
          end
(*
          let () = Debug.warn [Debug.DB_elaboration] (fun () -> "TODO: make the elab of A.And use mkTestExpression") in
          self e1        >>= fun core_e1  ->
          self e2        >>= fun core_e2  ->
          E.fresh_symbol >>= fun e1_sym   ->
          E.fresh_symbol >>= fun e2_sym   ->
          E.fresh_symbol >>= fun obj1_sym ->
          E.fresh_symbol >>= fun obj2_sym ->
          (* The object type on which the Core operator is going to work on. *)
          (* By typing it is enough to look at the type of one of the operand (see STD §6.5.8#2) *)
          let oTy = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
          let e1_sym_pe        = Caux.mk_sym_pe e1_sym        in
          let e2_sym_pe        = Caux.mk_sym_pe e2_sym        in
          let obj1_sym_pe      = Caux.mk_sym_pe obj1_sym      in
          let obj2_sym_pe      = Caux.mk_sym_pe obj2_sym      in
          E.return $
            C.Expr [Annot.Astd "§6.5.13"] (
              C.Ewseq (Caux.mk_sym_pat e1_sym (C.BTy_loaded oTy)) core_e1 (
                Caux.mk_case_e e1_sym_pe
                  [ ( Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy))
                    , C.Expr [Annot.Astd "§6.5.13#4"] (
                        C.Eif (Caux.mk_op_pe C.OpEq obj1_sym_pe (Caux.mk_integer_pe 0))
                          (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_integer_pe 0)))
                          begin
                            Caux.mk_wseq_e (Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy)) core_e2 (
                              Caux.mk_pure_e (
                                Caux.mk_case_pe e2_sym_pe
                                  [ ( Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy))
                                    , Caux.mk_specified_pe (
                                        Caux.mk_std_pe "§6.5.13#3" $
                                          Caux.mk_if_pe (Caux.mk_op_pe C.OpEq obj2_sym_pe (Caux.mk_integer_pe 0))
                                            (Caux.mk_integer_pe 0) (Caux.mk_integer_pe 1)
                                      ) )
                                  ; ( Caux.mk_empty_pat (C.BTy_loaded oTy)
                                    , (* TODO: check with Peter *)
                                      Caux.mk_unspecified_pe (Caux.proj_ctype result_ty) ) ]
                              )
                            )
                          end
                      ) )
                  ; ( Caux.mk_empty_pat (C.BTy_loaded oTy)
                    , (* TODO: check with Peter *)
                      Caux.mk_pure_e (Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)) ) ]
              )
            )
*)
      
      | A.AilEbinary e1 A.Or e2 ->
          (* TODO: this is hackish, but on the other hand it factorise code ... *)
          (* Also it follows the phrasing of the std *)
          (* Desugaring e1 || e2 ===> (e1 == 0) ? (e2 != 0) : 0 *)
          self begin
            A.AnnotatedExpression
              (GenTypes.GenRValueType signedInt_gty) [] loc
              (A.AilEcond (mkTestExpression TestEq e1) (mkTestExpression TestNe e2) oneAil_tau)
          end
(*
          let () = Debug.warn [Debug.DB_elaboration] (fun () -> "TODO: make the elab of A.Or use mkTestExpression") in
          self e1        >>= fun core_e1  ->
          self e2        >>= fun core_e2  ->
          E.fresh_symbol >>= fun e1_sym   ->
          E.fresh_symbol >>= fun e2_sym   ->
          E.fresh_symbol >>= fun obj1_sym ->
          E.fresh_symbol >>= fun obj2_sym ->
          (* The object type on which the Core operator is going to work on. *)
          (* By typing it is enough to look at the type of one of the operand (see STD §6.5.8#2) *)
          let oTy = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
          let e1_sym_pe        = Caux.mk_sym_pe e1_sym        in
          let e2_sym_pe        = Caux.mk_sym_pe e2_sym        in
          let obj1_sym_pe      = Caux.mk_sym_pe obj1_sym      in
          let obj2_sym_pe      = Caux.mk_sym_pe obj2_sym      in
          E.return $
            C.Expr [Annot.Astd "§6.5.14"] (
              C.Ewseq (Caux.mk_sym_pat e1_sym (C.BTy_loaded oTy)) core_e1 (
                Caux.mk_case_e e1_sym_pe
                  [ ( Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy))
                    , C.Expr [Annot.Astd "§6.5.14#4"] (
                        C.Eif (Caux.mk_not_pe (Caux.mk_op_pe C.OpEq obj1_sym_pe (Caux.mk_integer_pe 0)))
                          (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_integer_pe 1)))
                          begin
                            Caux.mk_wseq_e (Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy)) core_e2 (
                              Caux.mk_pure_e (
                                Caux.mk_case_pe e2_sym_pe
                                  [ ( Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy))
                                    , Caux.mk_specified_pe (
                                        Caux.mk_std_pe "§6.5.14#3" $
                                          Caux.mk_if_pe (Caux.mk_op_pe C.OpEq obj2_sym_pe (Caux.mk_integer_pe 0))
                                            (Caux.mk_integer_pe 0) (Caux.mk_integer_pe 1)
                                      ) )
                                  ; ( Caux.mk_empty_pat (C.BTy_loaded oTy)
                                    , (* TODO: check with Peter *)
                                      Caux.mk_unspecified_pe (Caux.proj_ctype result_ty) ) ]
                              )
                            )
                          end
                      ) )
                ; ( Caux.mk_empty_pat (C.BTy_loaded oTy)
                  , (* TODO: check with Peter *)
                    Caux.mk_pure_e (Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)) ) ]
              )
            )
*)
      
      | A.AilEcond e1 e2 e3 ->
          (* STD §6.5.15 *)
          let () = Debug.warn [Debug.DB_elaboration] (fun () -> "TODO: make the elab of AilEcond use mkTestExpression") in
          
          let e1_oTy =
            (* NOTE: [e1] must be a scalar *)
            force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
          
          let res_bTy =
            if AilTypesAux.is_void result_ty then
              C.BTy_unit
            else
              C.BTy_loaded (force_core_object_type_of_ctype (Caux.proj_ctype result_ty)) in
          
          E.wrapped_fresh_symbol (C.BTy_loaded e1_oTy) >>= fun (_, e1_sym_pat  , e1_sym_pe  ) ->
          E.wrapped_fresh_symbol (C.BTy_object e1_oTy) >>= fun (_, obj1_sym_pat, obj1_sym_pe) ->
          E.wrapped_fresh_symbol res_bTy               >>= fun (_, res_sym_pat , res_sym_pe ) ->
          self e1 >>= fun core_e1 ->
          self e2 >>= fun core_e2 ->
          self e3 >>= fun core_e3 ->
          
          E.return $ C.Expr [Annot.Astd "§6.5.15#4, sentence 1"]
            (* STD (§6.5.15#4, sentence 2) says there is a sequenced point between the
               evaluation of e1 and the e2/e3. Hence the strong sequencing *)
            (C.Esseq e1_sym_pat core_e1
            begin
              Caux.mk_wseq_e res_sym_pat begin
                Caux.mk_case_e e1_sym_pe
                  [ (Caux.mk_specified_pat obj1_sym_pat,
                     let core_test =
                       if AilTypesAux.is_integer (ctype_of e1) then
                         Caux.mk_not_pe (Caux.mk_op_pe C.OpEq obj1_sym_pe (Caux.mk_integer_pe 0))
                       else
                         error ("WIP: " ^ (Loc.stringFromLocation (Loc.locOf a_expr)) ^ " : AilEcond, pointer e1") in
                     C.Expr [Annot.Astd "§6.5.15#4, sentence 2"] (
                       C.Eif core_test core_e2 core_e3
                     ) )
                    (* non-deterministic branching if the test expression had unspecified value *)
                  ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                     C.Expr [] (C.End [core_e2; core_e3]) ) ]
              end (
              if AilTypesAux.is_integer result_ty then
                Caux.mk_pure_e (stdlib.mkcall_conv_loaded_int result_ty res_sym_pe)
              else
                let () = Debug.warn [Debug.DB_elaboration] (fun () -> "Translation, AilEcond ==> TODO: the conversions for e2 and e3") in
                (* TODO: conversions *)
                Caux.mk_pure_e res_sym_pe
             )
            end)
      
      | A.AilEassign e1 e2 ->
          (* STD §6.5.16 *)
          let () = Debug.warn [Debug.DB_elaboration] (fun () -> "TODO: AilEassign overlap UB (see §6.5.16.1#3)") in
          self e1                                             >>= fun core_e1                          ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (e1_sym, e1_sym_pat, e1_sym_pe)  ->
          let core_ty_pe1 = Caux.mk_ail_ctype_pe $ AilTypesAux.rvalue_coercion (snd (from_lvalue_type e1)) in
          
          let e2_sym = Symbol.fresh () in
          begin
if AilTypesAux.is_arithmetic (ctype_of e1) && AilTypesAux.is_arithmetic (ctype_of e2) then
            self e2 >>= fun core_e ->
            E.return (
              force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e2)),
              core_e,
              conv_loaded_arith stdlib (ctype_of e2) (ctype_of e1)
            )

else if AilTypesAux.is_struct_or_union (ctype_of e1) then
            (* TODO(check): I don't think that any conversion is needed here. *)
            (* TODO2: if we have multiple translation units, then maybe there should be a conversion? *)
            self e2 >>= fun core_e ->
            E.return (
              force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e2)),
              core_e,
              fun z -> z
            )

else match AilTypesAux.referenced_type (ctype_of e1) with
  | Just ref_ty ->
        if Aaux.is_null_pointer_constant e2 then
            E.return (
              C.OTy_pointer,
              Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_nullptr_pe (Caux.proj_ctype ref_ty))),
              fun z -> z
            )
        else
            self e2 >>= fun core_e ->
            E.return (
              force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e2)),
              core_e,
              fun z -> z
           )
  | Nothing ->
        (* By Ail typing, e1 must have type _Bool and e2 must be a pointer *)
        let _ = Debug.print_debug 1 [] (fun _ -> "E2 can have type function: " ^ Pp.stringFromAil_ctype Aty.no_qualifiers (ctype_of e2)) in
        self e2 >>= fun core_e2 ->
        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (_, e2_sym_pat, e2_sym_pe) ->
        E.return (
          C.OTy_integer,
          Caux.mk_wseq_e e2_sym_pat core_e2 (stdlib.mkproc_loaded_pointer_to_Bool e2_sym_pe),
          fun z -> z
        )
end
          end >>= fun (oTy2, core_e2, mk_stored_pe) ->
          
          let object_pe =
            Caux.mk_std_pe "§6.5.16#3, sentence 1" e1_sym_pe in
          let stored_pe =
            Caux.mk_std_pe "§6.5.16.1#2, conversion" (
              mk_stored_pe (Caux.mk_sym_pe e2_sym)
            ) in
          
          E.return $
            C.Expr [Annot.Astd "§6.5.16#3, sentence 4"] (
              C.Ewseq (Caux.mk_tuple_pat [ e1_sym_pat
                                         ; Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy2) ])
                (C.Expr [Annot.Astd "§6.5.16#3, sentence 5"] (C.Eunseq [core_e1; core_e2])) (
                Caux.mk_wseq_e (Caux.mk_empty_pat C.BTy_unit)
                   (C.Expr [Annot.Astd "§6.5.16.1#2, store"] (
                     C.Eaction (C.Paction C.Neg (C.Action loc default (C.Store false(* not locking *) core_ty_pe1 object_pe stored_pe Cmm.NA)))
                   ))
                   (Caux.mk_pure_e stored_pe)
              )
            )
      
      | A.AilEbinary e1 A.Comma e2 ->
          (* STD §6.5.17 *)
          self e1 >>= fun core_e1 ->
          self e2 >>= fun core_e2 ->
          let oTy = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
          (* STD (§6.5.17, sentence 2) says there is a sequence point between the
             evaluation of the two operand. Hence the strong sequencing *)
          E.return $
            C.Expr [Annot.Astd "§6.5.17#2, sentence 2"] (
              C.Esseq (Caux.mk_empty_pat (C.BTy_loaded oTy)) core_e1 core_e2
          )





      | A.AilEcompoundAssign e1 aop e2 ->
          let () = Debug.print_debug 1 [] (fun () ->
            "HACK!!!! => AilEcompoundAssign is WIP and only doing +="
          ) in
          (* TODO: check sequencing with respect to indet function calls *)
          self e1 >>= fun core_e1 ->
          self e2 >>= fun core_e2 ->
          let lvalue_ty = AilTypesAux.rvalue_coercion (snd (from_lvalue_type e1)) in
          let lvalue_oTy = force_core_object_type_of_ctype (Caux.proj_ctype lvalue_ty) in
          
          (*let oTy1 = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e2)) in*)
          let oTy2 = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e2)) in
          
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, l1_sym_pat   , l1_sym_pe  ) ->
          E.wrapped_fresh_symbol (C.BTy_loaded lvalue_oTy)    >>= fun (_, v1_sym_pat   , v1_sym_pe  ) ->
          E.wrapped_fresh_symbol (C.BTy_loaded oTy2)          >>= fun (_, v2_sym_pat   , v2_sym_pe  ) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, z1_sym_pat   , z1_sym_pe  ) ->
          E.wrapped_fresh_symbol (C.BTy_loaded lvalue_oTy)    >>= fun (_, z2_sym_pat   , z2_sym_pe  ) ->

          let lvalue_ty_pe = Caux.mk_ail_ctype_pe lvalue_ty in
          
          E.wrapped_fresh_symbol (C.BTy_object lvalue_oTy)    >>= fun (_, obj1_sym_pat   , obj1_sym_pe  ) ->
          E.wrapped_fresh_symbol (C.BTy_object oTy2)          >>= fun (_, obj2_sym_pat   , obj2_sym_pe  ) ->
          let stored_pe =
            Caux.mk_case_pe (Caux.mk_tuple_pe [v1_sym_pe; v2_sym_pe])
              [ ( Caux.mk_tuple_pat [Caux.mk_specified_pat obj1_sym_pat; Caux.mk_specified_pat obj2_sym_pat]
                , Caux.mk_specified_pe (Caux.mk_op_pe C.OpAdd obj1_sym_pe obj2_sym_pe) ) ] in
          
          E.return begin
            Caux.mk_wseq_e (Caux.mk_tuple_pat [Caux.mk_tuple_pat [l1_sym_pat; v1_sym_pat]; v2_sym_pat]) begin
              Caux.mk_unseq_e
                [ Caux.mk_wseq_e z1_sym_pat core_e1 begin
                    Caux.mk_wseq_e z2_sym_pat (Caux.pload loc lvalue_ty_pe z1_sym_pe Cmm.NA)
                      (Caux.mk_pure_e (Caux.mk_tuple_pe [z1_sym_pe; z2_sym_pe]))
                  end
                ; core_e2 ]
            end
            begin
              C.Expr []
                (C.Eaction (C.Paction C.Neg (C.Action loc default (C.Store false(* not locking *) lvalue_ty_pe l1_sym_pe stored_pe Cmm.NA))))
            end
          end



(*
          E.return begin
            Caux.mk_wseq_e (Caux.mk_tuple_pat ) begin
              Caux.mk_unseq_e
                [ Caux.mk_wseq_e e1_sym_pat core_e1 begin
                    Caux.mk_wseq_e load_sym_pat (Caux.pload loc lvalue_ty_pe e1_sym_pe Cmm.NA) begin
                      Caux.mk_pure_e (Caux.mk_tuple_pe [e1_sym_pe; load_sym_pe])
                    end
                  end
                ; core_e2 ]
            end
            match aop with
              | A.Mul ->
                  (* translate_mul_operator *)
              | A.Div | A.Mod ->
                  (* translate_div_mod_operator *)
              | A.Add ->
                  
              | A.Sub ->
                  
              | Shl ->
                  
              | Shr ->
                  
              | Band | Bxor | Bor ->
                  translate_bitwise_operator
            end


              C.Expr []
                (C.Eaction (C.Paction C.Neg (C.Action loc default (C.Store lvalue_ty_pe object_pe stored_pe Cmm.NA))))
            end
          end
          *)
(*
(*      
      (*
         (std: A compound assignment of the form E1 op = E2 is equivalent to the simple assignment
         expression E1 = E1 op (E2), except that the lvalue E1 is evaluated only once, and with respect
         to an indeterminately-sequenced function call, the operation of a compound) *)
      | A.AilEcompoundAssign e1 aop e2 ->
          (* TODO: this is a TEMPORARY HACK *)
          let A.AnnotatedExpression annot2 loc' _ = e2 in
          self $
            A.AnnotatedExpression annot loc (A.AilEassign e1 (A.AnnotatedExpression annot2 loc' (A.AilEbinary e1 (A.Arithmetic aop) e2)))
*)
      
      (* TODO: conv_int on e2 and e2 !!!!!!! *)
      
*)

(*
      | A.AilEcompoundAssign e1 aop e2 ->
          self e1 >>= fun core_e1 ->
          self e2 >>= fun core_e2 ->
          E.return $
            C.Ewseq (Caux.mk_tuple_pat [e1_sym_pat; e2_sym_pat]) (C.Eunseq [core_e1; core_e2]) (
              C.Easeq (Just (atom_sym, bTy) (Caux.pstore loc TODO_ty_pe e1_sym_pe))
            )
*)

(*
 | Easeq of maybe ('sym * core_base_type) * (generic_action 'a 'bty 'sym) * (generic_paction 'a 'bty 'sym) (* atomic sequencing *)
*)
      






      
(*
      (* TODO: a bit hackish *)
      | A.AilEcall (A.AnnotatedExpression _ (A.AilEbuiltin str)) es ->
          match (str, es) with
            | ("atomic_load_explicit", [object_e; order_e]) ->
                (* TODO: for now we don't allow complicated expressions for order_e *)
                E.return $
                  E.fresh_symbol >>= fun a_object ->
                  self e
                  C.
          end
*)
     | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin "atomic_store_explicit")) [lobject_e; desired_e; order_e] ->
         (* TODO: be more permissive for the memory order *)
         let mo = translate_memory_order order_e in
         let ref_ty = match ctype_of lobject_e with
           | Aty.Ctype _ (Aty.Pointer _ ref_ty) ->
               ref_ty
           | (*BISECT-IGNORE*) _ ->
               illTypedAil loc "AilEcall atomic_store_explicit"
         end in
         let oTy = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of desired_e)) in
         self lobject_e >>= fun lobject_core_e  ->
         self desired_e >>= fun desired_core_e ->
         E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (_, loaded_sym_pat, loaded_sym_pe)   ->
         E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, object_sym_pat, object_sym_pe)   ->
         E.wrapped_fresh_symbol (C.BTy_loaded oTy)           >>= fun (_, desired_sym_pat, desired_sym_pe) ->
         E.return begin
           Caux.mk_sseq_e (Caux.mk_tuple_pat [loaded_sym_pat; desired_sym_pat])
             begin
               Caux.mk_unseq_e [lobject_core_e; desired_core_e]
             end
             begin
               Caux.mk_case_e loaded_sym_pe
                 [ (Caux.mk_specified_pat object_sym_pat,
                    Caux.pstore loc (Caux.mk_ail_ctype_pe ref_ty) object_sym_pe desired_sym_pe mo)
                 ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                    Caux.mk_pure_e (Caux.mk_undef_pe loc Undefined.UB_unspecified_lvalue)) ]
             end
         end
     
     | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEbuiltin "atomic_load_explicit")) [lobject_e; order_e] ->
         (* TODO: be more permissive for the memory order *)
         let mo = translate_memory_order order_e in
         let ref_ty = match ctype_of lobject_e with
           | Aty.Ctype _ (Aty.Pointer _ ref_ty) ->
               ref_ty
           | (*BISECT-IGNORE*) _ ->
               illTypedAil loc "AilEcall atomic_load_explicit"
         end in
         self lobject_e  >>= fun lobject_core_e  ->
         E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (_, loaded_sym_pat, loaded_sym_pe) ->
         E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, object_sym_pat, object_sym_pe) ->
         E.return begin
           Caux.mk_sseq_e loaded_sym_pat lobject_core_e
             begin
               Caux.mk_case_e loaded_sym_pe
                 [ (Caux.mk_specified_pat object_sym_pat,
                    Caux.pload loc (Caux.mk_ail_ctype_pe ref_ty) object_sym_pe mo)
                 ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                    Caux.mk_pure_e (Caux.mk_undef_pe loc Undefined.UB_unspecified_lvalue)) ]
             end
         end
     
     (* TODO: allow non trivial call to atomic_thread_fence() ... *)
     | A.AilEcall (A.AnnotatedExpression _ _ _ (A.AilEident (Symbol.Symbol _ _ (Just "atomic_thread_fence")))) [order_e] ->
         (* TODO: be more permissive for the memory order *)
         let mo = translate_memory_order order_e in
         E.return $
           C.Expr [] (C.Eaction (C.Paction C.Pos (C.Action loc () (C.Fence mo))))






      
(*
     | A.AilEcall (A.AnnotatedExpression _ _ (A.AilEbuiltin "atomic_compare_exchange_strong_explicit")) [object_e; expected_e; desired_e; order_success_e; order_failure_e] ->
         let mo_success = translate_memory_order order_success_e in
         let mo_failure = translate_memory_order order_failure_e in
         let ty = match ctype_of object_e with
           | Aty.Pointer _ ty ->
               ty
           | _ ->
               error "Translation.translate_expression, AilEcall atomic_compare_exchange_strong_explicit: Ail type error"
         end in
         
         error "WIP: atomic_compare_exchange_strong_explicit"
(*
         E.fresh_symbol              >>= fun sym_object       ->
         E.fresh_symbol              >>= fun sym_expected_ptr ->
         E.fresh_symbol              >>= fun sym_expected_val ->
         E.fresh_symbol              >>= fun sym_desired      ->
         self object_e   >>= fun core_object_e    ->
         self expected_e >>= fun core_expected_e  ->
         self desired_e  >>= fun core_desired_e   ->
         E.return $
           (* TODO: weak or strong seq? *)
           C.Esseq [Just sym_object; Just sym_expected_ptr; Just sym_desired] (C.Eunseq [core_object_e; core_expected_e; core_desired_e])
             (C.Esseq [Just sym_expected_val] (Caux.pload loc (Caux.mk_ail_ctype_pe (AilTypesAux.unatomic ty)) (C.PEsym sym_expected_ptr) Cmm.NA)
                (Caux.prmw loc (Caux.mk_ail_ctype_pe (AilTypesAux.unatomic ty)) (C.PEsym sym_object) (C.PEsym sym_expected_val) (C.PEsym sym_desired)
                   mo_success mo_failure)
             )
*)

(*
             (C.Eaction (C.Paction C.Pos (C.Action loc ()
               (C.CompareExchangeStrong (Caux.mk_ail_ctype_pe ty) (C.PEsym sym_object) (C.PEsym sym_expected) (C.PEsym sym_desired) mo_success mo_failure))))
*)


      (* TODO:
           * (§6.5.2.2#6) since we don't support prototype-less functions, we don't do
                          "default argument promotions"
       *)

      | A.AilEcall (A.AnnotatedExpression _ _ (A.AilEident (Symbol.Symbol _ (Just "malloc")))) [e] ->
          self e >>= fun core_e ->
          E.fresh_typed_symbol true (ctype_of e) >>= fun sym_ty_e ->
          E.return $
            C.Esseq [Just sym_ty_e] core_e
              (C.Eaction (C.Paction C.Pos (C.Action loc () (
                C.Alloc (C.PEval (C.Vobject (C.OVinteger (Mem.alignof_ival Cty.unsigned_char)))) (C.PEsym sym_ty_e) (Symbol.PrefOther "malloc")
              ))))

*)

(* TODO ==> FUNCTION CALLS

  §6.5.2.2#6 is very stange, in particular this bit:
    
    "If the function is defined with a type that includes a prototype, and either the prototype ends with an ellipsis (, ...) or the types of the arguments after promotion are not compatible with the types of the parameters, the behavior is undefined."
    
    apparently this has to do with old-style function declaration which we don't
    support (doesn't even parse). So the elab doesn't need to do anything here ? (CHECK !!!)


TODO: check the prototype vs no prototype stufff (ARGGGGGG)

TODO: #9
*)
      (* LAST nov2016 *)
      | A.AilEcall e [] -> (* NOTE: if there are no arguments, we don't need all the temporary object creation stuff *)
          (* STD §6.5.2.2 *)
          let ret_ty = match ctype_of e with
            | Aty.Ctype _ (Aty.Pointer _ (Aty.Ctype _ (Aty.Function _ (_, ret_ty) params isVariadic))) ->
                if List.length params = 0 && (not isVariadic) then
                  ret_ty
                else
                  illTypedAil loc "AilEcall"
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "AilEcall"
          end in
          self e >>= fun core_e ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (fun_sym, fun_sym_pat, fun_sym_pe) ->
          E.wrapped_fresh_symbol C.BTy_ctype >>= fun (ret_sym, ret_sym_pat, ret_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_list C.BTy_ctype) >>= fun (params_sym, params_sym_pat, params_sym_pe) ->
          E.return $
            Caux.mk_sseq_e fun_sym_pat core_e
            (Caux.mk_sseq_e
              (Caux.mk_tuple_pat [ret_sym_pat; params_sym_pat; Caux.mk_empty_pat C.BTy_boolean; Caux.mk_empty_pat C.BTy_boolean])
              (Caux.mk_pure_e (Caux.mk_cfunction_pe fun_sym_pe))
              (Caux.mk_if_e
                (Caux.mk_op_pe C.OpEq (stdlib.mkcall_params_length params_sym_pe) (Caux.mk_integer_pe 0))
                (Caux.mk_if_e
                  (Caux.mk_are_compatible (Caux.mk_ail_ctype_pe ret_ty) ret_sym_pe)
                  (Caux.mk_ccall_e (Caux.mk_ail_ctype_pe (ctype_of e)) fun_sym_pe [])
                  (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#9" Undefined.UB041_function_not_compatible))
                )
                (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#6, sentence 3" Undefined.UB038_number_of_args))
              )
            )
      
      | A.AilEcall e es ->
          (* TODO: This is ignoring has_proto, §6.5.2.2#6 is not being considered! *)
          (* STD §6.5.2.2 *)
          let (expect_ret_ty, expect_params, expect_is_variadic) = match ctype_of e with
            | Aty.Ctype _ (Aty.Pointer _ (Aty.Ctype _ (Aty.Function _ (_, ret_ty) qs_tys is_variadic))) ->
                (ret_ty, qs_tys, is_variadic)
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "AilEcall"
          end in
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (fun_sym, fun_sym_pat, fun_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (call_sym, call_sym_pat, call_sym_pe) ->
          E.wrapped_fresh_symbol C.BTy_ctype >>= fun (ret_sym, ret_sym_pat, ret_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_list C.BTy_ctype) >>= fun (params_sym, params_sym_pat, params_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (nparams_sym, nparams_sym_pat, nparams_sym_pe)    ->
          E.wrapped_fresh_symbol C.BTy_boolean >>= fun (is_variadic_sym, is_variadic_sym_pat, is_variadic_sym_pe) ->
          E.wrapped_fresh_symbol C.BTy_boolean >>= fun (has_proto_sym, has_proto_sym_pat, has_proto_sym_pe) ->
          (* elaborate expression that denotes the called function *)
          self e >>= fun core_e ->
          (* symbolic names for the arguments temporary objects *)
          let n_args = List.length es in
          let arg_ptr_syms = list_init n_args (fun _ -> Symbol.fresh ()) in
          let arg_ptr_sym_pats = match arg_ptr_syms with
            | [sym] -> Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer)
            | _ -> Caux.mk_tuple_pat $ List.map (fun sym -> Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer)) arg_ptr_syms
          end in
          let arg_ptr_sym_pes = List.map Caux.mk_sym_pe arg_ptr_syms in
          (* elaborate each argument *)
          E.foldlM (fun (arg_sym_pats, core_arg_es, args_info) arg_e ->
            let arg_bTy = C.BTy_loaded (force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of arg_e))) in
            E.wrapped_fresh_symbol arg_bTy >>= fun (_, arg_sym_pat, arg_sym_pe) ->
            self arg_e >>= fun core_arg_e ->
            E.return (arg_sym_pat :: arg_sym_pats, core_arg_e :: core_arg_es
                     , (ctype_of arg_e, Aaux.is_null_pointer_constant arg_e, arg_sym_pe) :: args_info)
          ) ([], [], []) es >>= fun (rev_arg_sym_pats, rev_core_arg_es, rev_args_info) ->
          (* create parameters and convert them *)
          let (args_info, variadic_args_info) = List.splitAt (List.length expect_params) (List.reverse rev_args_info) in
          (* standard arguments *)
          E.foldlM (fun (n, rev_core_creates) ((_, expect_param_ty, _), (arg_ty, arg_is_null, arg_sym_pe)) ->
            E.wrapped_fresh_symbol C.BTy_ctype >>= fun (param_ty_sym, param_ty_sym_pat, param_ty_sym_pe) ->
            E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, arg_ptr_sym_pat, arg_ptr_sym_pe) ->
            E.return $
              (n+1,
                (Caux.mk_let_e param_ty_sym_pat (stdlib.mkcall_params_nth params_sym_pe (Caux.mk_integer_pe n))
                (Caux.mk_if_e
                  (Caux.mk_not_pe (Caux.mk_are_compatible (Caux.mk_ail_ctype_pe expect_param_ty) param_ty_sym_pe))
                  (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#9" Undefined.UB041_function_not_compatible))
                  (let conv_value =
                      (* NOTE: since expected type is compatible with the parameter type, if one is an integer or
                        floating, the other one must also be an integer or floating (respectively) *)
                      if AilTypesAux.is_integer expect_param_ty then
                        if AilTypesAux.is_integer arg_ty then
                          stdlib.mkcall_conv_loaded_int_ param_ty_sym_pe arg_sym_pe
                        else
                          stdlib.mkcall_loaded_ivfromfloat_ param_ty_sym_pe arg_sym_pe
                      else if AilTypesAux.is_floating expect_param_ty then
                        if AilTypesAux.is_integer arg_ty then
                          stdlib.mkcall_loaded_fvfromint_ param_ty_sym_pe arg_sym_pe
                        else
                          arg_sym_pe
                      else if AilTypesAux.is_pointer expect_param_ty && arg_is_null then (*TODO: probably not completely right*)
                        Caux.mk_specified_pe (Caux.mk_nullptr_pe (Caux.proj_ctype expect_param_ty))
                      else
                        arg_sym_pe in
                    (Caux.add_std "§6.5.2.2#7, sentence 1"
                      (Caux.mk_wseq_e arg_ptr_sym_pat
                        (Caux.pcreate loc (Caux.mk_alignof_pe param_ty_sym_pe) param_ty_sym_pe (Symbol.PrefOther ("arg" ^ show n)))
                        (Caux.mk_wseq_e (Caux.mk_empty_pat C.BTy_unit)
                          (Caux.pstore loc param_ty_sym_pe arg_ptr_sym_pe conv_value Cmm.NA)
                          (Caux.mk_pure_e arg_ptr_sym_pe)
                        )
                      )
                    )
                  )
                )) :: rev_core_creates
              )
          ) (0,[]) (List.zip expect_params args_info) >>= fun (_, rev_core_creates) ->
          (* variadic arguments *)
          E.foldlM (fun (rev_arg_ty_pes, rev_variadic_core_creates) (arg_ty, arg_is_null, arg_sym_pe) ->
            let (conv_ty, conv_value) =
              if AilTypesAux.is_integer arg_ty then
                let prom_ty = fromJust "translation: default arguments promotion" (AilTypesAux.promotion tmp_implementation arg_ty) in
                (prom_ty, stdlib.mkcall_conv_loaded_int prom_ty arg_sym_pe)
              else if AilTypesAux.is_floating arg_ty then
                (Aty.Ctype [] (Aty.Basic (Aty.Floating (Aty.RealFloating Aty.Double))), arg_sym_pe) (* TODO: convert this to double *)
              else (* TODO: should I add the case for pointers as well? *)
                (arg_ty, arg_sym_pe)
            in E.return (Caux.mk_ail_ctype_pe arg_ty :: rev_arg_ty_pes
                        , (Caux.add_std "§6.5.2.2#7, sentences 2 and 3" $
                            stdlib.mkproc_create_and_store (Caux.mk_ail_ctype_pe conv_ty) conv_value
                          ) :: rev_variadic_core_creates)
          ) ([],[]) variadic_args_info >>= fun (rev_arg_ty_pes, rev_variadic_core_creates) ->
          (* function call result *)
          let call_bTy = maybe C.BTy_unit C.BTy_loaded (Caux.core_object_type_of_ctype (Caux.proj_ctype expect_ret_ty)) in
          E.wrapped_fresh_symbol call_bTy >>= fun (call_ret_sym, call_ret_sym_pat, call_ret_sym_pe) ->
          (* kill temporary objects *)
          let killall_pat =
            if List.length arg_ptr_syms < 2 then
              Caux.mk_empty_pat C.BTy_unit
            else
              Caux.mk_empty_pat $ C.BTy_tuple (List.replicate (List.length arg_ptr_syms) C.BTy_unit)
          in
          (* STD (§6.5.2.2#10, sentence 1) says there is sequence "point after the
           evaluations of the function designator and the actual arguments but before
           the actual call." *)
          E.return $
            Caux.add_std "§6.5.2.2#10, sentence 1"
            (Caux.mk_wseq_e
              (Caux.mk_tuple_pat $
                (Caux.mk_tuple_pat [call_sym_pat; Caux.mk_tuple_pat [ret_sym_pat; params_sym_pat; is_variadic_sym_pat;
                                                                     has_proto_sym_pat]])
                :: (List.reverse rev_arg_sym_pats)
              )
              (Caux.add_std "§6.5.2.2#4, sentence 2" $
                Caux.mk_unseq_e
                (Caux.mk_sseq_e fun_sym_pat core_e
                  (Caux.mk_pure_e (Caux.mk_tuple_pe [fun_sym_pe; Caux.mk_cfunction_pe fun_sym_pe]))
                  :: (List.reverse rev_core_arg_es))
              )
begin if expect_is_variadic then
              (* check number of parameters *)
              (Caux.mk_if_e
                (Caux.mk_not_pe (Caux.mk_op_pe C.OpLe (stdlib.mkcall_params_length params_sym_pe)
                                                      (Caux.mk_integer_pe (integerFromNat n_args))))
                (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#6, sentence 3" Undefined.UB038_number_of_args))
                (* check if function types are compatible *)
                (Caux.mk_if_e
                  (Caux.mk_op_pe C.OpOr (Caux.mk_not_pe is_variadic_sym_pe)
                                 (Caux.mk_not_pe (Caux.mk_are_compatible (Caux.mk_ail_ctype_pe expect_ret_ty) ret_sym_pe)))
                  (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#9" Undefined.UB041_function_not_compatible))
                  (Caux.mk_sseq_e arg_ptr_sym_pats
                    (* create temporary object *)
                    (Caux.mk_unseq $ List.reverse rev_core_creates ++ List.reverse rev_variadic_core_creates)
                    (Caux.mk_sseq_e call_ret_sym_pat
                      (* do the function call *)
                      (Caux.mk_ccall_e (Caux.mk_ail_ctype_pe (ctype_of e)) call_sym_pe
                        (let (arg_pes, vararg_pes) = List.splitAt (List.length expect_params) arg_ptr_sym_pes in
                         let varargs_ty_pes =
                            List.map (fun (ty_pe, pe) -> Caux.mk_tuple_pe [ty_pe; pe])
                                     (List.zip (List.reverse rev_arg_ty_pes) vararg_pes)
                         in arg_pes ++ [Caux.mk_list_pe varargs_ty_pes]
                        )
                      )
                      (Caux.mk_sseq_e killall_pat
                        (* kill temporary objects *)
                        (Caux.mk_unseq (List.map (fun sym -> Caux.pkill loc false (Caux.mk_sym_pe sym)) arg_ptr_syms))
                        (* return function call result *)
                        (Caux.mk_pure_e call_ret_sym_pe)
                      )
                    )
                  )
                )
              )
else
              (* check number of parameters *)
              (Caux.mk_if_e
                (Caux.mk_not_pe (Caux.mk_op_pe C.OpEq (stdlib.mkcall_params_length params_sym_pe)
                                                      (Caux.mk_integer_pe (integerFromNat n_args))))
                (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#6, sentence 3" Undefined.UB038_number_of_args))
                (* check if function types are compatible *)
                (Caux.mk_if_e
                  (Caux.mk_op_pe C.OpOr is_variadic_sym_pe
                                 (Caux.mk_not_pe (Caux.mk_are_compatible (Caux.mk_ail_ctype_pe expect_ret_ty) ret_sym_pe)))
                  (Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.5.2.2#9" Undefined.UB041_function_not_compatible))
                  (Caux.mk_sseq_e arg_ptr_sym_pats
                    (* create temporary object *)
                    (Caux.mk_unseq $ List.reverse rev_core_creates)
                    (Caux.mk_sseq_e call_ret_sym_pat
                      (* do the function call *)
                      (Caux.mk_ccall_e (Caux.mk_ail_ctype_pe (ctype_of e)) call_sym_pe arg_ptr_sym_pes)
                      (Caux.mk_sseq_e killall_pat
                        (* kill temporary objects *)
                        (Caux.mk_unseq (List.map (fun sym -> Caux.pkill loc false (Caux.mk_sym_pe sym)) arg_ptr_syms))
                        (* return function call result *)
                        (Caux.mk_pure_e call_ret_sym_pe)
                      )
                    )
                  )
                )
              )
end
            )
      
      | A.AilEassert e ->
          (* TODO: this is temporary *)
          (* TODO: should do something more sensible when the expression is unspecified *)
          let oTy = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e)) in
          E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun (_, e_sym_pat    , e_sym_pe    ) ->
          E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun (_, obj_sym_pat  , obj_sym_pe  ) ->
          E.wrapped_fresh_symbol C.BTy_boolean      >>= fun (_, memop_sym_pat, memop_sym_pe) ->
          self e         >>= fun core_e  ->
          E.return $
            Caux.mk_sseq_e e_sym_pat core_e (
if AilTypesAux.is_arithmetic (ctype_of e) then
              let zero_pe =
                if AilTypesAux.is_integer (ctype_of e) then
                  Caux.mk_integer_pe 0
                else
                  Caux.mk_floating_value_pe Mem.zero_fval in
              Caux.mk_pure_e (
                Caux.mk_case_pe e_sym_pe
                  [ (Caux.mk_specified_pat obj_sym_pat,
                     Caux.mk_if_pe (Caux.mk_op_pe C.OpEq obj_sym_pe zero_pe)
                       (Caux.mk_error_pe "assert() failure" Caux.mk_unit_pe)
                      Caux.mk_unit_pe
                     )
                  ; (Caux.mk_empty_pat (C.BTy_loaded oTy),
                     Caux.mk_error_pe "assert() unspecified" Caux.mk_unit_pe) ]
              )
else (* is_pointer *)
              Caux.mk_case_e e_sym_pe
                [ (Caux.mk_specified_pat obj_sym_pat,
                   Caux.mk_wseq_e memop_sym_pat
                     (C.Expr [] (C.Ememop Mem_common.PtrEq [obj_sym_pe; Caux.mk_nullptr_pe Cty.Void]))
                     begin
                       Caux.mk_pure_e begin
                         Caux.mk_if_pe memop_sym_pe
                           (Caux.mk_error_pe "assert() failure" Caux.mk_unit_pe)
                           Caux.mk_unit_pe
                       end
                     end)
                ; (Caux.mk_empty_pat (C.BTy_loaded oTy),
                   Caux.mk_pure_e (Caux.mk_error_pe "assert() unspecified" Caux.mk_unit_pe)) ]
            )
      | A.AilEoffsetof ty membr_ident ->
          let tag_sym = match ty with
            | Aty.Ctype _ (Aty.Struct x) ->
                x
            | Aty.Ctype _ (Aty.Union x) ->
                x
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "AilEoffsetof"
          end in
          E.return $
            Caux.mk_pure_e (C.Pexpr [] () (C.PEval (C.Vloaded
              (C.LVspecified (C.OVinteger (Mem.offsetof_ival tag_sym membr_ident))))))
      
      | A.AilEgeneric _ _ ->
          error ((Loc.stringFromLocation (Loc.locOf a_expr)) ^ ": C11 generics not yet supported")
      
      | A.AilEarray _ _ e_opts ->
          let elem_ty = match result_ty with
            | Aty.Ctype _ (Aty.Array ty _) ->
                ty
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "AilEarray"
          end in
          E.foldlM (fun (acc, mk_expr) e_opt ->
             match e_opt with
               | Just e ->
                   let e_sym = Symbol.fresh () in
                   self e >>= fun core_e ->
                   let bTy =
                     C.BTy_loaded (force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e))) in
                   let elem_pe =
                     if AilTypesAux.is_pointer elem_ty && Aaux.is_null_pointer_constant e then
                       (* the member is a null pointer constant *)
                       match Caux.proj_ctype elem_ty with
                         | Cty.Pointer _ ref_ty ->
                             Caux.mk_specified_pe (Caux.mk_nullptr_pe ref_ty)
                         | (*BISECT-IGNORE*) _ ->
                             illTypedAil loc "AilEarray, Just null_pointer_constant"
                       end
                     (* TODO: check + std quote *)
                     else if AilTypesAux.is_arithmetic elem_ty && AilTypesAux.is_arithmetic (ctype_of e) then
                       conv_loaded_arith stdlib (ctype_of e) elem_ty (Caux.mk_sym_pe e_sym)
                     else
                       (* TODO: other conversions? *)
                       Caux.mk_sym_pe e_sym in 
                   E.return
                     (elem_pe :: acc, (Caux.mk_wseq_e (Caux.mk_sym_pat e_sym bTy) core_e) -| mk_expr)
               | Nothing ->
                   E.return
                     (Caux.mk_unspecified_pe (Caux.proj_ctype elem_ty) :: acc, mk_expr)
             end
          ) ([], id) e_opts >>= fun (rev_pes, mk_expr) ->
          E.return $
             mk_expr (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_array_pe (List.reverse rev_pes))))
      
      | A.AilEstruct tag_sym ident_e_opts ->
          let ident_tys = match Map.lookup tag_sym tagDefs with
            | Just (Cty.StructDef z) ->
                z
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "AilEstruct"
          end in
          E.foldlM (fun (acc, mk_core) (ident, e_opt) ->
            match e_opt with
              | Just e ->
                  let memb_ty = fromJust "Translation.translate_expression, AilEstruct 2" $ List.lookup ident ident_tys in
                  let oTy = force_core_object_type_of_ctype memb_ty in
                  begin
                    if AilTypesAux.is_pointer (Caux.unproj_ctype memb_ty) && Aaux.is_null_pointer_constant e then
                      (* the member is a null pointer constant *)
                      match memb_ty with
                        | Cty.Pointer _ ref_ty ->
                            E.return (
                              (ident, Caux.mk_specified_pe (Caux.mk_nullptr_pe ref_ty)) :: acc,
                              mk_core
                            )
                        | (*BISECT-IGNORE*) _ ->
                            illTypedAil loc "AilEstruct, Just null_pointer_constant"
                      end
                    else
                      E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun (_, e_sym_pat, e_sym_pe) ->
                      self e                                    >>= fun core_e                   ->
                      E.return (
                        ( ident
                        , let memb_ty = (*TODO: ahem*)Caux.unproj_ctype memb_ty in
                          if AilTypesAux.is_integer memb_ty then
                            stdlib.mkcall_conv_loaded_int memb_ty e_sym_pe
                          else
                            e_sym_pe ) :: acc ,
                        fun z -> Caux.mk_sseq_e e_sym_pat core_e (mk_core z)
                      )
                  end
              | Nothing ->
                  let ty = fromJust "Translation.translate_expression, AilEstruct 3" $ List.lookup ident ident_tys in
                  E.return (
                    (ident, Caux.mk_unspecified_pe ty) :: acc,
                    mk_core
                  )
            end
          ) ([], fun z -> z) ident_e_opts >>= fun (core_xs_rev, mk_core) ->
          E.return $
            mk_core (Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_struct_pe tag_sym (List.reverse core_xs_rev))))
      
      | A.AilEcompound qs ty e ->
          (* TODO: only using weak sequencing for now, not sure about this *)
          (* TODO: what if the type is atomic? *)
          let core_ty = Caux.mk_ail_ctype_pe ty in
          let oTy = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e)) in
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, obj_sym_pat, obj_sym_pe) ->
          E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun (_, e_sym_pat, e_sym_pe) ->
          self e >>= fun core_e ->
          let () = Debug.print_debug 1 [] (fun () ->
             "TODO!!!! the lifetime of block scoped AilEcompound ends with the block (right now there is no kill)"
          ) in
          (* STD §6.5.2.5#3 *)
          E.return begin
            Caux.mk_wseq_e obj_sym_pat
              (* TODO: if qs has const, we must probably use a create_readonly *)
              (Caux.pcreate loc (Caux.mk_alignof_pe core_ty) core_ty (Symbol.PrefOther "compound literal")) begin
            (* TODO: probably needs a conversion *)
            Caux.mk_wseq_e e_sym_pat core_e begin
            Caux.mk_wseq_e (Caux.mk_empty_pat C.BTy_unit) (Caux.pstore loc core_ty obj_sym_pe e_sym_pe Cmm.NA) begin
              (* STD §6.5.2.5#5, sentence 1 *)
              Caux.mk_pure_e obj_sym_pe
            end end end
          end
      
      | A.AilEunion tag_sym memb_ident e_opt ->
          match Map.lookup tag_sym tagDefs with
            | (*BISECT-IGNORE*) Nothing ->
                illTypedAil loc "AilEunion: couldn't find the definition"
            | (*BISECT-IGNORE*) Just (Cty.StructDef ident_tys) ->
                illTypedAil loc "AilEunion: found a struct definition"
            | Just (Cty.UnionDef ident_tys) ->
                match List.lookup memb_ident ident_tys with
                  | (*BISECT-IGNORE*) Nothing ->
                      illTypedAil loc "AilEunion: couldn't find a union definition"
                  | Just memb_ty ->
                      let oTy = force_core_object_type_of_ctype memb_ty in
                      match e_opt with
                        | Nothing ->
                            E.return (
                              Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_union_pe tag_sym memb_ident (Caux.mk_unspecified_pe memb_ty)))
                            )
                        | Just e ->
                            E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun (_, e_sym_pat, e_sym_pe) ->
                            self e                                    >>= fun core_e                   ->
                            E.return $
                              Caux.mk_wseq_e e_sym_pat core_e (
                                Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_union_pe tag_sym memb_ident e_sym_pe))
                              )
                            
                      end
                 end
          end
      
(* TODO: atomic undef *)
      | A.AilEmemberof e ident ->
          (* STD §6.5.2.3 *)
          let (tag_sym, oTy) = match ctype_of e with
            | Aty.Ctype _ (Aty.Struct tag_sym) ->
                (tag_sym, C.OTy_struct tag_sym)
            | Aty.Ctype _ (Aty.Union tag_sym) ->
                (tag_sym, C.OTy_union tag_sym)
            | (*BISECT-IGNORE*) _ ->
                illTypedAil loc "AilEmemberof"
          end in
          E.wrapped_fresh_symbol (if is_lvalue then C.BTy_object C.OTy_pointer else C.BTy_loaded oTy)
             >>= fun (e_sym, e_sym_pat, e_sym_pe) ->
          self e >>= fun core_e ->
          
          if not is_lvalue then
             E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun (obj_sym, obj_sym_pat, obj_sym_pe) ->
             E.return begin
               Caux.mk_sseq_e e_sym_pat core_e begin
                 Caux.mk_pure_e begin
                   Caux.mk_case_pe e_sym_pe
                     [ ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                       , Caux.mk_undef_pe loc (Undefined.DUMMY "Elab, rvalue AilEmemberof (unspec)") ) (* TODO: better undef *) (* TODO: check with P *)
                     ; ( Caux.mk_specified_pat obj_sym_pat
                       , Caux.mk_memberof_pe tag_sym ident obj_sym_pe ) ]
                 end
               end
             end
          else
            E.return begin
              C.Expr [Annot.Astd "§6.5.2.3#3, sentence 2"] (
                C.Esseq e_sym_pat core_e (
                  Caux.mk_pure_e (Caux.mk_member_shift_pe e_sym_pe tag_sym ident)
                )
              )
            end
      
      | A.AilEmemberofptr e ident ->
          (* STD §6.5.2.3 *)
          let (ref_ty, tag_sym) = match ctype_of e with
            | Aty.Ctype _ (Aty.Pointer _ (Aty.Ctype _ (Aty.Struct tag_sym) as ref_ty)) -> (ref_ty, tag_sym)
            | Aty.Ctype _ (Aty.Pointer _ (Aty.Ctype _ (Aty.Union tag_sym) as ref_ty))  -> (ref_ty, tag_sym)
            | (*BISECT-IGNORE*) _ -> illTypedAil loc "AilEmemberofptr"
          end in
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_pointer) >>= fun (_, e_sym_pat   , e_sym_pe   ) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, obj_sym_pat , obj_sym_pe ) ->
          E.wrapped_fresh_symbol C.BTy_boolean                >>= fun (_, test_sym_pat, test_sym_pe) ->
          self e >>= fun core_e ->
          E.return begin
            Caux.add_std "§6.5.2.3#4, sentence 2" $
              Caux.mk_sseq_e e_sym_pat core_e begin
                Caux.mk_case_e e_sym_pe
                  [ ( Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                    , Caux.mk_pure_e (Caux.mk_undef_pe loc (Undefined.DUMMY "Elab, AilEmemberofptr")) ) (* TODO: better undef *)
                  ; ( Caux.mk_specified_pat obj_sym_pat
                    , if has_switch SW_strict_pointer_arith then
                        Caux.mk_wseq_e test_sym_pat
                          (Caux.mk_memop_e Mem_common.PtrValidForDeref [Caux.mk_ail_ctype_pe ref_ty; obj_sym_pe])
                          begin
                            Caux.mk_pure_e begin
                              Caux.mk_if_pe test_sym_pe
                                (Caux.mk_member_shift_pe obj_sym_pe tag_sym ident)
                                (* TODO: make a new UB for this particular case *)
                                (Caux.mk_std_undef_pe loc "§6.5.3.3#4, sentence 4" Undefined.UB043_indirection_invalid_value)
                            end
                          end
                      else
                        (* NON-ISO: allowing member_shift on "invalid pointer values" *)
                        Caux.mk_pure_e (Caux.mk_member_shift_pe obj_sym_pe tag_sym ident) ) ]
              end
          end
      
      | A.AilEconst cst ->
          E.return (Caux.mk_pure_e (translate_constant cst))
      
      | A.AilEbuiltin str ->
          (* TODO: the redundance with Builtins.lem is wrong *)
          E.return $ Caux.mk_pure_e match str with
(*
            | "INT8_MIN" ->
                Caux.mk_ivmin_pe (Caux.mk_ctype_pe (Cty.Basic (Aty.Integer (Aty.Signed (Aty.IntN_t 8)))))
            | "INT16_MIN" ->
                Caux.mk_ivmin_pe (Caux.mk_ctype_pe (Cty.Basic (Aty.Integer (Aty.Signed (Aty.IntN_t 16)))))
            | "INT32_MIN" ->
                Caux.mk_ivmin_pe (Caux.mk_ctype_pe (Cty.Basic (Aty.Integer (Aty.Signed (Aty.IntN_t 32)))))
            | "INT64_MIN" ->
                Caux.mk_ivmin_pe (Caux.mk_ctype_pe (Cty.Basic (Aty.Integer (Aty.Signed (Aty.IntN_t 64)))))
            | "INT8_MAX" ->
                Caux.mk_ivmax_pe (Caux.mk_ctype_pe (Cty.Basic (Aty.Integer (Aty.Signed (Aty.IntN_t 8)))))
            | "INT16_MAX" ->
                Caux.mk_ivmax_pe (Caux.mk_ctype_pe (Cty.Basic (Aty.Integer (Aty.Signed (Aty.IntN_t 16)))))
            | "INT32_MAX" ->
                Caux.mk_ivmax_pe (Caux.mk_ctype_pe (Cty.Basic (Aty.Integer (Aty.Signed (Aty.IntN_t 32)))))
            | "INT64_MAX" ->
                Caux.mk_ivmax_pe (Caux.mk_ctype_pe (Cty.Basic (Aty.Integer (Aty.Signed (Aty.IntN_t 64)))))
            | "UINT8_MAX" ->
                Caux.mk_ivmax_pe (Caux.mk_ctype_pe (Cty.Basic (Aty.Integer (Aty.Unsigned (Aty.IntN_t 8)))))
            | "UINT16_MAX" ->
                Caux.mk_ivmax_pe (Caux.mk_ctype_pe (Cty.Basic (Aty.Integer (Aty.Unsigned (Aty.IntN_t 16)))))
            | "UINT32_MAX" ->
                Caux.mk_ivmax_pe (Caux.mk_ctype_pe (Cty.Basic (Aty.Integer (Aty.Unsigned (Aty.IntN_t 32)))))
            | "UINT64_MAX" ->
                Caux.mk_ivmax_pe (Caux.mk_ctype_pe (Cty.Basic (Aty.Integer (Aty.Unsigned (Aty.IntN_t 64)))))
            | "CHAR_BIT" ->
                C.PEimpl Implementation_.Characters__bits_in_byte
*)
            | _ ->
                error ( "WIP: Translation.translate_expr, AilEbuiltin: " ^ str)
          end
      
      (* TODO: prefix + check, §6.4.5#6 *)
      | A.AilEstr (pref_opt, strs) ->
          let elem_ty = match pref_opt with
            | Nothing ->
                (* STD §6.4.5#6, sentence 3 *)
                Cty.Basic (Aty.Integer Aty.Char)
            | Just A.Enc_u8 ->
                (* STD §6.4.5#6, sentence 4 *)
                Cty.Basic (Aty.Integer Aty.Char)
            | Just A.Enc_u ->
                (* STD §6.4.5#6, sentence 6 *)
                Cty.char16_t
            | Just A.Enc_U ->
                (* STD §6.4.5#6, sentence 6 *)
                Cty.char32_t
            | Just A.Enc_L ->
                (* STD §6.4.5#6, sentence 5 *)
                Cty.Builtin "whcar_t"
          end in
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (lit_sym, _, lit_sym_pe) ->
          (* TODO: making an implementation fix here (ASCII), not doing prefix properly *)
(*
          let elem_lvals = List.map (fun c_str ->
            C.LVspecified (C.OVinteger (Mem.integer_ival (Decode.decode_character_constant c_str)))
          ) strs ++ [C.LVspecified (C.OVinteger (Mem.integer_ival 0))] in
          E.register_string_literal loc lit_sym (Cty.Array elem_ty (Just (integerFromNat $ List.length elem_lvals)))
            (C.Pexpr [] () (C.PEval (C.Vloaded (C.LVspecified (C.OVarray elem_lvals))))) >>
*)
          (* TODO(check): here we convert the string elements to the type of the array *)
          let elem_pes = List.map (fun c_str ->
             Caux.mk_specified_pe (
               stdlib.mkcall_conv_int (Caux.unproj_ctype elem_ty)
                 (Caux.mk_integer_pe (Decode.decode_character_constant c_str))
             )
          ) strs ++ [Caux.mk_specified_pe (Caux.mk_integer_pe 0)] in
          E.register_string_literal loc lit_sym (Cty.Array elem_ty (Just (integerFromNat $ List.length elem_pes)))
            (Caux.mk_specified_pe (Caux.mk_array_pe elem_pes))  >>
          E.return (
            Caux.mk_pure_e lit_sym_pe
          )
(*

(*

n := | str |

let strong a  = create("char[n+1]", <alignof>("char[n+1]")) in
store("char[n+1]", a, array(...)) ;
a


          E.return (C.Econst $ C.Cstring (String.toCharList str)) (* TODO: this is a hack, this should be a pointer to a global char pointer *)
*)
      
      
*)
      | A.AilEsizeof _ (Aty.Ctype _ (Aty.Basic (Aty.Integer Aty.Char))) ->
          E.return $
            C.Expr [Annot.Astd "§6.5.3.4#4, sentence 1"] (
              C.Epure (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
            )
      | A.AilEsizeof _ (Aty.Ctype _ (Aty.Basic (Aty.Integer (Aty.Signed Aty.Ichar)))) ->
          E.return $
            C.Expr [Annot.Astd "§6.5.3.4#4, sentence 1"] (
              C.Epure (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
            )
      | A.AilEsizeof _ (Aty.Ctype _ (Aty.Basic (Aty.Integer (Aty.Unsigned Aty.Ichar)))) ->
          E.return $
            C.Expr [Annot.Astd "§6.5.3.4#4, sentence 1"] (
              C.Epure (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
            )
      | A.AilEsizeof _ ty ->
          E.return $
            Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_sizeof_pe (Caux.mk_ail_ctype_pe ty)))
      
      | A.AilEsizeof_expr e ->
          (* TODO: check qualifiers *)
          self (A.AnnotatedExpression annot std_annots loc (A.AilEsizeof Aty.no_qualifiers (ctype_of e)))
      
      | A.AilEalignof _ ty ->
          E.return $
            Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_alignof_pe $ Caux.mk_ail_ctype_pe ty))
      
      | A.AilEannot _ e ->
          self e
      
      | A.AilEva_start _ last_sym ->
          let (variadic_sym, last_arg_sym) =
            match variadic_env with
            | (Just var_sym, Just last_sym) -> (var_sym, last_sym)
            | _ -> error ((Loc.stringFromLocation (Loc.locOf a_expr)) ^ ": va_start not in a variadic function")
            end in
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, va_sym_pat, va_sym_pe ) ->
          E.return $
            if last_sym = last_arg_sym then
              Caux.mk_sseq_e va_sym_pat (C.Expr [] (C.Ememop Mem_common.Va_start [Caux.mk_sym_pe variadic_sym]))
                (Caux.mk_pure_e (Caux.mk_specified_pe va_sym_pe))
            else
              error ((Loc.stringFromLocation (Loc.locOf a_expr)) ^ " : " ^ show last_sym ^ " is not the last argument") (* it should be UB I think *)
      
      | A.AilEva_arg e ty ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun (_, e_sym_pat, e_sym_pe ) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer) >>= fun (_, ptr_sym_pat, ptr_sym_pe ) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, case_sym_pat, case_sym_pe) ->
          self e >>= fun core_e ->
          E.return $
            Caux.mk_sseq_e e_sym_pat core_e
              (Caux.mk_sseq_e ptr_sym_pat
                (Caux.mk_case_e e_sym_pe
                  [ (Caux.mk_specified_pat case_sym_pat,
                      (C.Expr [] (C.Ememop Mem_common.Va_arg [case_sym_pe; Caux.mk_ail_ctype_pe ty])))
                  ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                      Caux.mk_pure_e (Caux.mk_undef_exceptional_condition loc)) ] )
                (Caux.pload loc (Caux.mk_ail_ctype_pe ty) ptr_sym_pe Cmm.NA))
      
      | A.AilEva_end e ->
          E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun (_, e_sym_pat, e_sym_pe ) ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, case_sym_pat, case_sym_pe) ->
          self e >>= fun core_e ->
          E.return $
            Caux.mk_sseq_e e_sym_pat core_e
              (Caux.mk_case_e e_sym_pe
                [ (Caux.mk_specified_pat case_sym_pat,
                    (C.Expr [] (C.Ememop Mem_common.Va_end [case_sym_pe])))
                ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                    Caux.mk_pure_e (Caux.mk_undef_exceptional_condition loc)) ] )
      
      | A.AilEprint_type e ->
          let (qs, ty) = qualified_ctype_of e in
          let () = Debug.print_debug 1 [] (fun () ->
            "PRINT_TYPE: " ^ Loc.stringFromLocation loc ^ " -- " ^ Pp.stringFromAil_ctype qs ty
          ) in
          self e
      
      | A.AilErvalue e ->
          (* TODO: check + I don't like have a wseq here *)
          self e >>= fun core_e ->
          E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer)
            >>= fun (_, e_sym_pat, e_sym_pe ) ->
          E.return (
            C.Expr [] (
              C.Ewseq ( (* Caux.mk_specified_pat *) e_sym_pat) core_e (
                Caux.pload loc (Caux.mk_ail_ctype_pe result_ty) e_sym_pe Cmm.NA
              )
            )
          )
      | A.AilEarray_decay e ->
          match GenTypes.genTypeCategoryOf e with
            | GenTypes.GenLValueType _ _ _ ->
                (* by Ail typing, [e] is a lvalue. Hence the corresponding Core has a non-loaded type *)
                self e >>= fun core_e ->
                E.wrapped_fresh_symbol (C.BTy_object C.OTy_pointer)
                  >>= fun (_, e_sym_pat, e_sym_pe ) ->
                E.return (
                  Caux.mk_wseq_e e_sym_pat core_e (
                    match AilTypesAux.referenced_type result_ty with
                      | (*BISECT-IGNORE*) Nothing ->
                          illTypedAil loc "AilEarray_decay, result_ty not a pointer"
                      | Just ref_ty ->
                          C.Expr [Annot.Astd "§6.3.2.1#3"] (
                            C.Epure (
                              Caux.mk_specified_pe (Caux.mk_array_shift e_sym_pe
                                (Caux.proj_ctype ref_ty) (Caux.mk_integer_pe 0)
                              )
                            )
                          )
                    end
                  )
                )
            | GenTypes.GenRValueType _ ->
                error "TODO: AilEarray_decay, rvalue"
          end
      | A.AilEfunction_decay e ->
          translate_function_designator ctx variadic_env stdlib tagDefs e
    end







(* translate_stmt Pmap.empty ail_sigma program.A.main C.Constants.return s *)

(* TODO[über HACK] `lasts' is the last of symbolic names saving the last statement for each block we are in
                   we need to remember them to annotate Erun/Esave coming from a C label/goto because these symbols
                   MAY (the fact it is a may is pretty disgusting) be in the continuations of the generated Esave (...)

RAAAAAAAAHHH: this doesn't work when the label is in a block the goto doesn't belong to ......
*)

module St = State
let inline (>>=) = St.bind
let inline (>>) m1 m2 = St.bind m1 (fun _ -> m2)
let inline (<$>) = State.fmap
let inline (<*>) = State.app

type collect_cases_state = <|
  found_default: bool;
  case_csts: list A.integerConstant;
|>

val     collect_cases_: A.statement GenTypes.genTypeCategory -> St.stateM unit collect_cases_state
let rec collect_cases_ (A.AnnotatedStatement loc stmt) =
  let register_case n =
    St.update (fun s -> <| s with case_csts= n :: s.case_csts |>) in
  let register_default =
    St.update (fun s -> <| s with found_default= true |>) in
  match stmt with
    | A.AilSskip ->
        St.return ()
    | A.AilSexpr _ ->
        St.return ()
    | A.AilSblock binds ss ->
        St.mapM_ collect_cases_ ss
    | A.AilSif _ s1 s2 ->
        collect_cases_ s1 >> collect_cases_ s2
    | A.AilSwhile _ s ->
        collect_cases_ s
    | A.AilSdo s _ ->
        collect_cases_ s
    | A.AilSbreak ->
        St.return ()
    | A.AilScontinue ->
        St.return ()
    | A.AilSreturnVoid ->
        St.return ()
    | A.AilSreturn _ ->
        St.return ()
    | A.AilSswitch _ _ ->
        St.return ()
    | A.AilScase n s ->
        register_case n >> collect_cases_ s
    | A.AilSdefault s ->
        register_default >> collect_cases_ s
    | A.AilSlabel _ s ->
        collect_cases_ s
    | A.AilSgoto _ ->
        St.return ()
    | A.AilSdeclaration _ ->
        St.return ()
    | A.AilSpar ss ->
        (* TODO: check *)
        St.mapM_ collect_cases_ ss
  end
let collect_cases s =
  snd $ St.runStateM (collect_cases_ s) <| found_default= false; case_csts= [] |>


type collect_visibles_state = <|
  visible_syms: list (Symbol.sym * Aty.ctype);
  goto_visibles_:  map Symbol.sym (list (Symbol.sym * Aty.ctype));
  label_visibles_: map Symbol.sym (list (Symbol.sym * Aty.ctype));
|>



type erase_loop_control_state = <|
  elc_continue: maybe Symbol.sym;
  elc_break: maybe Symbol.sym;
|>

val     erase_loop_control_aux: A.statement GenTypes.genTypeCategory -> St.stateM (A.statement GenTypes.genTypeCategory) erase_loop_control_state
let rec erase_loop_control_aux (A.AnnotatedStatement loc stmt_) =
  let with_fresh_labels mf =
    fun st ->
      let continue_sym = Symbol.fresh_pretty_with_id (fun x -> "continue_" ^ show x) in
      let break_sym    = Symbol.fresh_pretty_with_id (fun x -> "break_" ^ show x) in
      let (ret, st')   = mf <| elc_continue= Just continue_sym; elc_break= Just break_sym |> in
      ((continue_sym, break_sym, ret), st) in 
  A.AnnotatedStatement loc <$> match stmt_ with
    | A.AilSskip ->
        St.return stmt_
    | A.AilSexpr _ ->
        St.return stmt_
    | A.AilSblock binds ss ->
        A.AilSblock binds <$> St.mapM erase_loop_control_aux ss
    | A.AilSif e s1 s2 ->
        A.AilSif e <$> erase_loop_control_aux s1 <*> erase_loop_control_aux s2
    | A.AilSwhile e s ->
        (* STD §6.8.6.2#2 and §6.8.6.3#2 *)
        with_fresh_labels (erase_loop_control_aux s) >>= fun (continue_sym, break_sym, s') ->
        St.return $
          A.AilSblock []
            [ A.AnnotatedStatement loc (A.AilSwhile e (A.AnnotatedStatement loc (A.AilSblock []
                [s'; A.AnnotatedStatement loc (A.AilSlabel continue_sym (A.AnnotatedStatement loc A.AilSskip))])))
            ; A.AnnotatedStatement loc (A.AilSlabel break_sym (A.AnnotatedStatement loc A.AilSskip)) ]

    | A.AilSdo s e ->
        (* STD §6.8.6.2#2 and §6.8.6.3#2 *)
        with_fresh_labels (erase_loop_control_aux s) >>= fun (continue_sym, break_sym, s') ->
        St.return $
          A.AilSblock []
            [ A.AnnotatedStatement loc (A.AilSdo (A.AnnotatedStatement loc (A.AilSblock []
                [s'; A.AnnotatedStatement loc (A.AilSlabel continue_sym (A.AnnotatedStatement loc A.AilSskip))])) e)
            ; A.AnnotatedStatement loc (A.AilSlabel break_sym (A.AnnotatedStatement loc A.AilSskip)) ]
    | A.AilSbreak ->
        St.get >>= function
          | <| elc_break= Just break_sym |> ->
             St.return (A.AilSgoto break_sym)
          | (*BISECT-IGNORE*) _ ->
              illTypedAil loc "AilSbreak"
        end
    | A.AilScontinue ->
        St.get >>= function
          | <| elc_continue= Just continue_sym |> ->
             St.return (A.AilSgoto continue_sym)
          | (*BISECT-IGNORE*) _ ->
              illTypedAil loc "AilScontinue"
        end
    | A.AilSreturnVoid ->
        St.return stmt_
    | A.AilSreturn _ ->
        St.return stmt_
    | A.AilSswitch e s ->
        with_fresh_labels (erase_loop_control_aux s) >>= fun (_, break_sym, s') ->
        St.return $
          A.AilSblock []
            [ A.AnnotatedStatement loc (A.AilSswitch e (A.AnnotatedStatement loc (A.AilSblock []
                [ A.AnnotatedStatement loc (A.AilSgoto break_sym); s' ])))
            ; A.AnnotatedStatement loc (A.AilSlabel break_sym (A.AnnotatedStatement loc A.AilSskip)) ]
    | A.AilScase iCst s ->
        A.AilScase iCst <$> erase_loop_control_aux s
    | A.AilSdefault s ->
        A.AilSdefault <$> erase_loop_control_aux s
        (* TODO: not sure about this
        error "WIP: erase_loop_control_aux, AilSdefault" *)
    | A.AilSlabel sym s ->
        A.AilSlabel sym <$> erase_loop_control_aux s
    | A.AilSgoto _ ->
        St.return stmt_
    | A.AilSdeclaration _ ->
        St.return stmt_
    | A.AilSpar ss ->
        A.AilSpar <$> St.mapM erase_loop_control_aux ss
  end


let erase_loop_control stmt =
  let (stmt', _) = State.runStateM (erase_loop_control_aux stmt) <|
    elc_continue= Nothing;
    elc_break= Nothing;
  |> in stmt'



val     collect_visibles_: A.statement GenTypes.genTypeCategory -> St.stateM unit collect_visibles_state
let rec collect_visibles_ (A.AnnotatedStatement loc stmt) =
  match stmt with
    | A.AilSskip ->
        St.return ()
    | A.AilSexpr _ ->
        St.return ()
    | A.AilSblock binds ss ->
        St.get >>= fun st ->
        let saved_syms = st.visible_syms in
        St.update (fun st ->
          <| st with visible_syms= List.map (fun (sym, (_, _, ty)) -> (sym ,ty)) binds ++ st.visible_syms |>
        ) >>
        St.mapM_ collect_visibles_ ss >>
        St.update (fun st ->
          <| st with visible_syms= saved_syms |>
        )
    | A.AilSif _ s1 s2 ->
        collect_visibles_ s1 >> collect_visibles_ s2
    | A.AilSwhile _ s ->
        collect_visibles_ s
    | A.AilSdo s _ ->
        collect_visibles_ s
    | A.AilSbreak ->
        St.return ()
    | A.AilScontinue ->
        St.return ()
    | A.AilSreturnVoid ->
        St.return ()
    | A.AilSreturn _ ->
        St.return ()
    | A.AilSswitch _ s ->
        collect_visibles_ s
    | A.AilScase _ s ->
        collect_visibles_ s
    | A.AilSdefault s ->
        collect_visibles_ s
    | A.AilSlabel label s ->
        St.update (fun st -> <| st with
          label_visibles_= Map.insert label st.visible_syms st.label_visibles_
        |>) >>
        collect_visibles_ s
    | A.AilSgoto label ->
        St.update (fun st -> <| st with
          goto_visibles_= Map.insert label st.visible_syms st.goto_visibles_
        |>) >>
        St.return ()
    | A.AilSdeclaration _ ->
        St.return ()
    | A.AilSpar ss ->
        (* TODO: check *)
        St.mapM_ collect_visibles_ ss
  end

val collect_visibles: A.statement GenTypes.genTypeCategory -> collect_visibles_state
let collect_visibles stmt =
    snd $ State.runStateM (collect_visibles_ stmt) <|
      visible_syms= []
    ; goto_visibles_= Map.empty
    ; label_visibles_= Map.empty |>





(* TODO: morally the kills and creates should be unseq() *)
val mk_run_e: Loc.t -> Symbol.sym -> list Symbol.sym -> list (Symbol.sym * Aty.ctype) -> list C.pexpr -> C.expr unit
let translation_mk_run_e loc sym visibles_before visibles_after pes =
  let killed_syms =
    List.filter (fun sym ->
      Maybe.isNothing (List.lookup sym visibles_after)
    ) visibles_before in
  
  let mk_kills_e =
    Caux.mk_unit_sseq (
      List.map (fun sym ->
        Caux.pkill loc false (Caux.mk_sym_pe sym)
      ) killed_syms
    ) in
  
  let created_sym_tys =
    List.filter (fun (sym, _) ->
      not (List.elem sym visibles_before)
    ) visibles_after in
  
  let mk_creates_e =
    Caux.mk_sseqs $
      List.map (fun (sym, ty) ->
        (C.Pattern [] (C.CaseBase (Just sym, C.BTy_object C.OTy_pointer)),
         let core_ty = Caux.mk_ail_ctype_pe ty in
         Caux.pcreate loc (Caux.mk_alignof_pe core_ty) core_ty (Symbol.PrefSource loc [(*f; *)sym]))
      ) created_sym_tys in
  mk_kills_e (mk_creates_e (Caux.mk_run_e sym ((List.map (fun (sym, _) -> Caux.mk_sym_pe sym) visibles_after) ++ pes)))
let inline mk_run_e = translation_mk_run_e


open Operators

type translate_stmt_env = <|
  return_ty: Aty.ctype;
  is_Noreturn: bool;
  
  variadic_sym_opt: maybe Symbol.sym;
  last_arg_sym_opt: maybe Symbol.sym;

  return_lab  : C.ksym;
  default_lab : maybe C.ksym;
  case_labs   : list (A.integerConstant * C.ksym);
  
  (* The lists are the objects visible from the loop and break labels *)
  loop:  maybe (
             Symbol.sym (* loop continuation symbol *)
           * Symbol.sym (* continue continuation symbol *)
           * Symbol.sym (* break continuation symbol *)
           * list (Symbol.sym * Aty.ctype)
  );
  break: maybe (Symbol.sym * list (Symbol.sym * Aty.ctype));
  
  goto_visibles:  map Symbol.sym (list (Symbol.sym * Aty.ctype));
  label_visibles: map Symbol.sym (list (Symbol.sym * Aty.ctype));
|>


val translate_stmt:
  translation_stdlib -> C.core_tag_definitions -> A.identifier -> translate_stmt_env ->
  A.statement GenTypes.genTypeCategory ->
  E.elabM (C.core_base_type * C.expr unit)


let rec translate_stmt2 stdlib tagDefs f env (A.AnnotatedStatement loc stmt) : E.elabM (C.expr unit) =
  let translate_expression = translate_expression ECTX_other (env.variadic_sym_opt, env.last_arg_sym_opt) stdlib tagDefs in
  let translate_cases_block case_labs default_lab =
      translate_stmt2 stdlib tagDefs f <| env with case_labs=   case_labs;
                                                   default_lab= default_lab |>
  in
  let self = translate_stmt2 stdlib tagDefs f env in
  
  Caux.add_loc loc <$> match stmt with
    | A.AilSskip ->
        E.return Caux.mk_skip_e
    
    | A.AilSexpr e ->
        (* TODO: the indirection is temporary hack in order to
           generate well typed core. The better solution would be to have the elab of AilSblock
           not always use the unit type in the bindings of the sseq operators. *)
        (* TODO: the index *)
(*
        let bTy = match Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e)) with
          | DDD
        end in
*)
        translate_expression e >>= fun core_e ->
        E.return (
          (* ASK: this annotation looks wrong!! is this really implementing 6.5#2 ? *)
          C.Expr [Annot.Astd "§6.5#2"] $
          C.Esseq (Caux.mk_empty_pat (maybe C.BTy_unit C.BTy_loaded (Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e)))))
            (* TODO: Ebound index *)
            (C.Expr [] (C.Ebound 0 core_e))
            (Caux.mk_pure_e Caux.mk_unit_pe)
          )
    
    | A.AilSblock [] ss ->
        E.mapM self ss >>= fun core_ss ->
        E.return $
          Caux.mk_unit_sseq core_ss Caux.mk_skip_e
    
    | A.AilSblock [(sym, ((ident_loc, _, _), qs, ty))] ss ->
        let c_ty = Caux.mk_ail_ctype_pe ty in
        E.with_block_objects [(sym, (qs, ty))] $
          E.mapM self ss >>= fun core_ss ->
        E.return $
          Caux.mk_sseq_e (Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer))
             (Caux.pcreate loc (Caux.mk_alignof_pe c_ty) c_ty (Symbol.PrefSource ident_loc [f; sym])) (
            List.foldr (fun core_s acc ->
              Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit) core_s acc
            ) (Caux.pkill loc false (Caux.mk_sym_pe sym)) core_ss
          )
    
    | A.AilSblock binds ss ->
        let decls_with_loc = [ (sym, ident_loc, (qs, ty)) | forall ((sym, ((ident_loc, _, _), qs, ty)) MEM binds ) | true ] in
        let decls = List.map (fun (sym, _, qs_ty) -> (sym, qs_ty)) decls_with_loc in
        (* the symbolic names and create actions for the local variables *)
        let (pats, core_creates) : list C.pattern * list (C.expr unit) =
          mapUnzip (fun (sym, ident_loc, (qs, ty)) ->
            let c_ty = Caux.mk_ail_ctype_pe ty in
            (Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer), Caux.pcreate loc (Caux.mk_alignof_pe c_ty) c_ty (Symbol.PrefSource ident_loc [f; sym]))
          ) decls_with_loc in
        E.with_block_objects decls $
          (* TODO: doing the kills here is now redundant if there is are returns before all exit point.
                   but it may be nasty to the check.
                   For non-void function however we know (?) that the must be these returns ?? so we could drop the kills here *)
          (* the kill actions for the local variables *)
          let core_kills : list (C.expr unit) =
            List.map (Caux.pkill loc false -| (Caux.mk_sym_pe) -| fst) decls in
          E.mapM self ss >>= fun core_ss ->
        
        E.return (
          let () = Debug.warn [Debug.DB_elaboration] (fun () -> "Translation, AilSblock: sequencing the creates and kills") in
(*        C.Esseq (Caux.mk_tuple_pat pats) (Caux.mk_unseq core_creates)
            (foldr (fun core_s acc -> C.Esseq (C.CaseBase Nothing) core_s acc) (Caux.mk_unseq core_kills) core_ss)
        ) *)
          Caux.mk_sseqs (List.zip pats core_creates) $
            Caux.mk_unit_sseq (core_ss ++ core_kills)
              Caux.mk_skip_e
        )
    
    | A.AilSif e s1 s2 ->
        E.wrapped_fresh_symbol C.BTy_boolean                >>= fun (_, do_then_sym_pat, do_then_sym_pe) ->
        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun (_, test_sym_pat, test_sym_pe)       ->
        E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, case_sym_pat, case_sym_pe)       ->
        translate_expression (mkTestExpression TestEq e)    >>= fun core_test                            ->
        self s1                                             >>= fun core_s1                              ->
        self s2                                             >>= fun core_s2                              ->
        (* NOTE: here we fix the strictness of unspecified values *)
        E.return $
          (* NOTE: the case-of producing a boolean (instead of directly doing the control
             with the case) is to prevent possible combinatorial explosions of the generated Core code *)
          Caux.mk_sseq_e test_sym_pat core_test begin
            Caux.mk_sseq_e do_then_sym_pat begin
              Caux.mk_case_e test_sym_pe
                [ (Caux.mk_specified_pat case_sym_pat,
                   Caux.mk_pure_e begin
                     Caux.mk_if_pe (Caux.mk_not_pe (Caux.mk_op_pe C.OpEq case_sym_pe (Caux.mk_integer_pe 1)))
                       (Caux.mk_boolean_pe true) (Caux.mk_boolean_pe false)
                   end)
                  (* non-deterministic branching if the test expression had unspecified value *)
                ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                   Caux.mk_nd_e [Caux.mk_pure_e (Caux.mk_boolean_pe true); Caux.mk_pure_e (Caux.mk_boolean_pe false)]) ]
            end
            (Caux.mk_if_e do_then_sym_pe core_s1 core_s2)
          end
    
    | A.AilSwhile e s ->
        (* NOTE: the object type is OTy_integer since we are using mkTestExpression which turns [e] into [e == 0] *)
        let sym_loop = Symbol.fresh_pretty_with_id (fun x ->  "while_" ^ show x) in
        E.wrapped_fresh_symbol C.BTy_boolean                >>= fun (_, do_loop_sym_pat, do_loop_sym_pe) ->
        E.wrapped_fresh_symbol (C.BTy_loaded C.OTy_integer) >>= fun (_, test_sym_pat, test_sym_pe)       ->
        E.wrapped_fresh_symbol (C.BTy_object C.OTy_integer) >>= fun (_, case_sym_pat, case_sym_pe)       ->
        translate_expression (mkTestExpression TestEq e)    >>= fun core_test                            ->
        self s                                              >>= fun core_s                               ->
        E.get_visible_objects                               >>= fun visible_syms                         ->
        (* TODO: the types of the annotations in Esave are dummy, but this is not observable for now *)
        let core_s_loop =
          Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit) core_s
            (Caux.mk_run_e (*default*) sym_loop [ Caux.mk_sym_pe sym | forall (sym MEM visible_syms) | true ]) in
       E.return $
          Caux.mk_save_e (sym_loop, C.BTy_unit)
             (List.map (fun sym ->
               (sym, (C.BTy_object C.OTy_pointer, Caux.mk_sym_pe sym))
             ) visible_syms) (
(*
            Caux.mk_sseq_e test_sym_pat core_test (
              Caux.mk_case_e test_sym_pe
                [ (Caux.mk_specified_pat case_sym_pat,
                   Caux.mk_if_e (Caux.mk_not_pe (Caux.mk_op_pe C.OpEq case_sym_pe (Caux.mk_integer_pe 1)))
                     core_s_loop Caux.mk_skip_e)
                  (* non-deterministic branching if the test expression had unspecified value *)
                ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                   Caux.mk_nd_e [core_s_loop; Caux.mk_skip_e]) ]
               )
            )
*)
            Caux.mk_sseq_e test_sym_pat core_test begin
              Caux.mk_sseq_e do_loop_sym_pat begin
                Caux.mk_case_e test_sym_pe
                  [ (Caux.mk_specified_pat case_sym_pat,
                     Caux.mk_pure_e begin
                       Caux.mk_if_pe (Caux.mk_not_pe (Caux.mk_op_pe C.OpEq case_sym_pe (Caux.mk_integer_pe 1)))
                         (Caux.mk_boolean_pe true) (Caux.mk_boolean_pe false)
                     end)
                    (* non-deterministic branching if the test expression had unspecified value *)
                  ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                     Caux.mk_nd_e [Caux.mk_pure_e (Caux.mk_boolean_pe true); Caux.mk_pure_e (Caux.mk_boolean_pe false)]) ]
              end
              (Caux.mk_if_e do_loop_sym_pe core_s_loop Caux.mk_skip_e)
            end
          )
    
    | A.AilSdo s e ->
        let () = Debug.warn [Debug.DB_elaboration] (fun () -> "TODO: make the elab of AilSdo use mkTestExpression") in
        let sym_loop = Symbol.fresh_pretty_with_id (fun x ->  "do_" ^ show x) in
        let sym_case = Symbol.fresh () in
        let sym_e    = Symbol.fresh () in
        translate_expression e    >>= fun core_e       ->
        self s                    >>= fun core_s       ->
        E.get_visible_objects     >>= fun visible_syms ->
        
        let core_loop =
          Caux.mk_run_e sym_loop [ Caux.mk_sym_pe sym | forall (sym MEM visible_syms) | true ] in
        E.return $
          Caux.mk_save_e (sym_loop, C.BTy_unit) (
             List.map (fun sym ->
               (sym, (C.BTy_object C.OTy_pointer, Caux.mk_sym_pe sym))
             ) visible_syms) (
            (* loop body *)
            Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit) core_s
              (* controlling expression *)
              begin
                Caux.mk_sseq_e (Caux.mk_sym_pat sym_e (C.BTy_loaded C.OTy_integer)) core_e (
                  Caux.mk_case_e (Caux.mk_sym_pe sym_e)
                    [ (Caux.mk_specified_pat (Caux.mk_sym_pat sym_case (C.BTy_object C.OTy_integer)),
                       Caux.mk_if_e (Caux.mk_not_pe (Caux.mk_op_pe C.OpEq (Caux.mk_sym_pe sym_case) (Caux.mk_integer_pe 0)))
                         core_loop Caux.mk_skip_e)
                      (* non-deterministic branching if the test expression had unspecified value *)
                    ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                       Caux.mk_nd_e [core_loop; Caux.mk_skip_e]) ]
                   )
              end
          )
    
    | (*BISECT-IGNORE*) A.AilSbreak ->
        (* erase_loop_control must be called first, so this case is impossible. *)
        error "Translation.translate_stmt, found a break"
    
    | (*BISECT-IGNORE*) A.AilScontinue ->
        (* erase_loop_control must be called first, so this case is impossible. *)
        error "Translation.translate_stmt, found a continue"
    
    | A.AilSreturnVoid ->
        E.get_visible_objects >>= fun visible_syms ->
        E.return $ begin
          if env.is_Noreturn then
            Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.7.4#8" Undefined.UB071_noreturn)
          else
            let bTy =
              if List.length visible_syms < 2 then
                C.BTy_unit
              else
                C.BTy_tuple (List.replicate (List.length visible_syms) C.BTy_unit) in
            Caux.mk_sseq_e (Caux.mk_empty_pat bTy)
              (Caux.mk_unseq $ List.map (fun sym -> Caux.pkill loc false (Caux.mk_sym_pe sym)) visible_syms)
              (* TODO: check the symbols *)
              (Caux.mk_run_e env.return_lab [Caux.mk_unit_pe])
        end
    
    | A.AilSreturn e ->
        let oTy = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e)) in
        translate_expression e                    >>= fun core_e                       ->
        E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun (e_sym, e_sym_pat, e_sym_pe) ->
        E.get_visible_objects                     >>= fun visible_syms                 ->

        
        (* TODO: typing is not enough (should do like assignments) *)
        let ret_pe =
          if AilTypesAux.is_arithmetic env.return_ty && AilTypesAux.is_arithmetic (ctype_of e) then
             conv_loaded_arith stdlib (ctype_of e) env.return_ty e_sym_pe

          else if AilTypesAux.is_pointer env.return_ty && Aaux.is_null_pointer_constant e then
            Caux.mk_specified_pe (Caux.mk_nullptr_pe (Caux.proj_ctype env.return_ty))
          else
            e_sym_pe in
        
        (* All the visible objects from the current function need to be killed. *)
        (* TODO: Ebound index *)

        E.return $ begin
          if env.is_Noreturn then
            Caux.mk_pure_e (Caux.mk_std_undef_pe loc "§6.7.4#8" Undefined.UB071_noreturn)
          else
            Caux.mk_sseq_e e_sym_pat (C.Expr [] (C.Ebound 0 core_e)) (
              mk_run_e loc env.return_lab visible_syms [] [ret_pe]
            )
        end

    | A.AilSswitch e s ->
        (* Translate controlling expression *)
        translate_expression e >>= fun core_e ->
        let oTy = force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e)) in
        E.wrapped_fresh_symbol (C.BTy_loaded oTy) >>= fun (e_sym, e_pat, e_sym_pe) ->
        (* Case in specified values *)
        E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun (control_sym, control_pat, control_sym_pe) ->
        (* Integer promotion *)
        (* STD §6.8.4.2#5, sentence 1 *)
        (* TODO: check if this is a correct integer promotion *)
        E.wrapped_fresh_symbol (C.BTy_object oTy) >>= fun (promoted_sym, promoted_pat, promoted_sym_pe) ->
        let promoted_pe =
          Caux.mk_std_pe "§6.8.4.2#5, sentence 1" (
            stdlib.mkcall_conv_int (fromJust "Translation.translate_stmt2: switch expr promotion"
              (AilTypesAux.promotion tmp_implementation (ctype_of e))) control_sym_pe
          ) in
        (* Create case symbols and translate cases block *)
        let cases    = collect_cases s in
        let nb_cases = List.length cases.case_csts in
        let case_syms = list_init nb_cases (fun _ -> Symbol.fresh_pretty_with_id (fun x -> "case_" ^ show x)) in
        let default_sym = Symbol.fresh_pretty_with_id (fun x -> "default_" ^ show x) in
        let case_labs = List.zip cases.case_csts case_syms in
        translate_cases_block case_labs (Just default_sym) s >>= fun core_s ->
        E.get_visible_objects >>= fun visible_syms ->
        let visible_pes = List.map (fun sym -> Caux.mk_sym_pe sym) visible_syms in
        let unit_pat = Caux.mk_empty_pat C.BTy_unit in
        (* Build translated switch *)
        (* TODO: not sure if Ewseqs or Esseqs *)
        E.return
          (* Get control expression *)
          (Caux.mk_sseq_e e_pat core_e
            (* Check if unspecified *)
            (Caux.mk_case_e e_sym_pe [
              (Caux.mk_specified_pat control_pat,
                (* Do integer promotion *)
                (Caux.mk_sseq_e promoted_pat (Caux.mk_pure_e promoted_pe)
                  (* For every case.... *)
                  (List.foldl (fun acc (iC, case_lab) ->
                    Caux.mk_sseq_e unit_pat
                      (* Check if equal to the constant expression *)
                      (Caux.mk_if_e (Caux.mk_op_pe C.OpEq promoted_sym_pe (translate_integerConstant iC))
                        (* TODO: not sure if the visible afters are the same *)
                        (Caux.mk_run_e case_lab visible_pes)
                        (Caux.mk_skip_e)
                      )
                      acc)
                    (* default branch *)
                    (Caux.mk_sseq_e unit_pat 
                      (if cases.found_default then Caux.mk_run_e default_sym visible_pes
                       else Caux.mk_skip_e) core_s)
                  case_labs)))
            ; (* UB if unspecified *)
              (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype), Caux.mk_pure_e (Caux.mk_undef_exceptional_condition loc))
            ]))
    
    | A.AilScase iCst s ->
        self s                >>= fun core_s ->
        E.get_visible_objects >>= fun visible_syms ->
        let visible_pes = List.map (fun sym ->
            (sym, (C.BTy_object C.OTy_pointer, Caux.mk_sym_pe sym))
          ) visible_syms
        in
        match List.lookup iCst env.case_labs with
        | Just lab ->
          E.return $ Caux.mk_save_e (lab, C.BTy_unit) visible_pes core_s
        | (*BISECT-IGNORE*) Nothing ->
          error "Translation.translate_stmt2: case label not found."
        end
    
    | A.AilSdefault s ->
        self s                >>= fun core_s ->
        match env.default_lab with
        | Just lab ->
          E.return $ Caux.mk_save_e (lab, C.BTy_unit) [] core_s
        | (*BISECT-IGNORE*) Nothing ->
          error "Translation.translate_stmt2: default label not found."
        end
    
    | A.AilSlabel sym s ->
        self s                >>= fun core_s       ->
        E.get_visible_objects >>= fun visible_syms ->
        E.return $
          Caux.mk_save_e (sym, C.BTy_unit) (List.map (fun sym ->
            (sym, (C.BTy_object C.OTy_pointer, Caux.mk_sym_pe sym))
          ) visible_syms) core_s
    
    | A.AilSgoto sym ->
        E.get_visible_objects >>= fun visible_syms ->
        let visibles_after = fromJust "Translation.translation_statement, AilSgoto" (Map.lookup sym env.label_visibles) in
        E.return $
          mk_run_e loc sym visible_syms visibles_after []
    
    | A.AilSdeclaration sym_es ->
        (* This pass translate the declarations *)
        E.mapM (fun (ptr_sym, e) ->
          E.resolve_object_type ptr_sym >>= fun (qs, ty) ->
          let e_bTy = C.BTy_loaded (force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of e))) in
          E.wrapped_fresh_symbol e_bTy >>= fun (e_sym, e_sym_pat, e_sym_pe) ->
          match AilTypesAux.unatomic ty with
            | Aty.Pointer _ ref_ty ->
                let mk_store =
                  if qs.Aty.const then Caux.pstore_lock else Caux.pstore in
                if Aaux.is_null_pointer_constant e then
                  E.return (
                    mk_store loc (Caux.mk_ail_ctype_pe ty) (Caux.mk_sym_pe ptr_sym)
                      (Caux.mk_specified_pe (Caux.mk_nullptr_pe (Caux.proj_ctype ref_ty))) Cmm.NA
                  )
                  else
                    translate_expression e >>= fun core_e ->
                    E.return (
                      Caux.mk_sseq_e (Caux.mk_sym_pat e_sym e_bTy) core_e
                        (mk_store loc (Caux.mk_ail_ctype_pe ty) (Caux.mk_sym_pe ptr_sym) e_sym_pe Cmm.NA)
                    )
            | ty ->
                let mk_store =
                  if qs.Aty.const then Caux.pstore_lock else Caux.pstore in
                (* we are not dealing with a pointer initialisation *)
(*
                E.fresh_typed_symbol true (ctype_of e) >>= fun (e_sym, e_bTy) ->
                let e_sym_pe = Caux.mk_sym_pe e_sym in
*)
                let cty = Aty.Ctype [] ty in
                translate_expression e >>= fun core_e ->
                E.return (
                  Caux.mk_sseq_e (Caux.mk_sym_pat e_sym e_bTy) core_e
                    (mk_store loc (Caux.mk_ail_ctype_pe cty) (Caux.mk_sym_pe ptr_sym)
                      (if AilTypesAux.is_arithmetic cty then conv_loaded_arith stdlib (ctype_of e) cty e_sym_pe else e_sym_pe) Cmm.NA)
                )
          end
        ) sym_es >>= fun z ->
        
        (* This pass combines the translated declarations *)
        match z with
          | [] ->
              E.return Caux.mk_skip_e
          | z::zs' ->
              E.foldlM (fun x y -> E.return $ Caux.concat_sseq x y) z zs'
        end
    
    | A.AilSpar ss ->
          E.mapM self ss >>= fun core_ss ->
          E.return begin
            Caux.mk_wseq_e (Caux.mk_empty_pat (C.BTy_tuple (List.replicate (List.length ss) C.BTy_unit)))
              (C.Expr [] (C.Epar core_ss))
              Caux.mk_skip_e
          end
  end


val translate_tag_definitions: Context.context A.identifier A.tag_definition -> C.core_tag_definitions
let translate_tag_definitions ctx =
  Map.fromList $ List.map (function
    | (sym, A.StructDef tagDef) ->
        let () = Debug.warn [] (fun () -> "Translate_tag_definitions is removing the qualifiers!") in
        (sym, Cty.StructDef (List.map (fun (ident, (_, ty)) -> (ident, Caux.proj_ctype ty)) tagDef))
    | (sym, A.UnionDef tagDef) ->
        let () = Debug.warn [] (fun () -> "Translate_tag_definitions is removing the qualifiers!") in
        (sym, Cty.UnionDef (List.map (fun (ident, (_, ty)) -> (ident, Caux.proj_ctype ty)) tagDef))
  end) ctx

(* val translate_program:
  translation_stdlib -> A.ail_program GenTypes.genTypeCategory ->
  E.elabM (C.core_tag_definitions * list (C.sym * C.core_base_type * C.expr unit) * C.fun_map unit)
  *)
let translate_program stdlib (startup_sym_opt, sigm) =
  let core_tagDefs = translate_tag_definitions sigm.A.tag_definitions in
  (*let () = Core_ctype_aux.set_tagDefs core_tagDefs in*)
  
  E.foldlM (fun (gacc, facc, finfoacc) (sym, (loc, decl)) ->
    (* for each Ail declaration *)
    match decl with
      | A.Decl_object _ qs ty ->
          (* TODO: qualifiers? *)
          (* elaboration of a global variables *)
          let core_ty     = Caux.mk_ail_ctype_pe ty in
          let core_create = Caux.pcreate loc (Caux.mk_alignof_pe core_ty) core_ty (Symbol.PrefSource loc [sym]) in
          let sym_global  = Symbol.fresh () in
          
          let () = Debug.print_debug 2 [Debug.DB_elaboration] (fun () -> "(translate_program) CREATE for " ^ show sym_global) in
          match Context.lookup (=) sigm.A.object_definitions sym with
            | Nothing ->
                E.return ( (sym, C.GlobalDecl (C.BTy_object C.OTy_pointer)) :: gacc, facc, finfoacc )
              (*
                (* if the global has no initialisation expression, we set it to (sort of) zero *)
                (* TODO: find the std quote *)
                E.return begin
                  (
                    ( sym
                    , C.BTy_object C.OTy_pointer
                    , Caux.mk_sseq_e (Caux.mk_sym_pat sym_global (C.BTy_object C.OTy_pointer)) core_create (
                        Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit)
                          (* TODO: proper memory order *)
                          (Caux.pstore (Loc.other "global init to zero") core_ty (Caux.mk_sym_pe sym_global)
                             (Caux.zeros core_tagDefs (Caux.proj_ctype ty)) Cmm.NA)
                          (Caux.mk_pure_e (Caux.mk_sym_pe sym_global))
                      ) ) :: gacc
                  , facc, finfoacc )
                end
            *)
            
            | Just expr ->
                (* otherwise we evaluate that expression and store it's value to the global (duh) *)
                let e_sym = Symbol.fresh () in
                begin
                  if AilTypesAux.is_pointer ty && Aaux.is_null_pointer_constant expr then
                    E.return (
                      C.BTy_loaded C.OTy_pointer,
                      Caux.mk_pure_e (Caux.mk_specified_pe (Caux.mk_nullptr_pe (Caux.proj_ctype ty)))
                    )
                  else
                    translate_expression (ECTX_glob sym sym_global) ((Nothing: maybe Symbol.sym), (Nothing: maybe Symbol.sym)) stdlib core_tagDefs expr >>= fun core ->
                    E.return (
                      C.BTy_loaded (force_core_object_type_of_ctype (Caux.proj_ctype (ctype_of expr))),
                      core
                    )
                end >>= fun (e_bTy, core_e) ->
                let core_init_e =
                  if AilTypesAux.is_integer ty || AilTypesAux.is_floating ty then
                    conv_loaded_arith stdlib (ctype_of expr) ty (Caux.mk_sym_pe e_sym)
                  else
                    (* TODO: check, might need some pointer to pointer conversion *)
                    Caux.mk_sym_pe e_sym in
                let core_e =
                  Caux.add_loc (locOf core_e) $
                    Caux.mk_sseq_e (Caux.mk_sym_pat sym_global (C.BTy_object C.OTy_pointer)) core_create (
                      Caux.mk_sseq_e (Caux.mk_sym_pat e_sym e_bTy) core_e (
                       Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit)
                         (* TODO: proper memory order *)
                         (Caux.pstore (Loc.other "global init with value") core_ty (Caux.mk_sym_pe sym_global)
                            core_init_e Cmm.NA)
                         (Caux.mk_pure_e (Caux.mk_sym_pe sym_global))
                      )) in
                E.return
                  ( (sym, C.GlobalDef (C.BTy_object C.OTy_pointer) core_e) :: gacc
                  , facc, finfoacc )
          end
      
      | A.Decl_function has_proto (_, return_ty) params is_variadic is_inline is_Noreturn ->
          (* elaboration of an Ail function *)
          let ret_bTy =
            if AilTypesAux.is_void return_ty then
              C.BTy_unit
            else
              C.BTy_loaded (force_core_object_type_of_ctype (Caux.proj_ctype return_ty)) in
          let finfo =
            (Caux.proj_ctype return_ty
            (* TODO: check if we need qualifiers too *)
            , List.map (fun (_, ty, _) -> Caux.proj_ctype ty) params
            , is_variadic, has_proto) in
          match Context.lookup (=) sigm.A.function_definitions sym with
            | Nothing ->
                (* if the function has no definition,
                   we create Core procedure declaration *)
                E.return
                  ( gacc
                  , Map.insert sym (C.ProcDecl loc ret_bTy (List.map (fun _ -> C.BTy_object C.OTy_pointer) params)) facc
                    (* get the correct symbol if a proxy exists *)
                  , match sym with
                     | Symbol.Symbol _ _ (Just str) ->
                       match Map.lookup str stdlib.ailnames with
                         | Just sym_proxy -> Map.insert sym_proxy finfo finfoacc
                         | Nothing -> Map.insert sym finfo finfoacc
                       end
                     | _ -> Map.insert sym finfo finfoacc
                  end)
            
            | Just (loc, param_syms, stmt) ->
                (* making the argument variables visible *)
(* TODO: WIP                E.with_block_objects param_syms *)

                let ret_label = Symbol.fresh_pretty_with_id (fun x -> "ret_" ^ show x) in
                let ret_sym = Symbol.fresh () in
                let stmt = erase_loop_control stmt in
                let visibles = collect_visibles stmt in
                let (variadic_sym_opt, last_arg_sym_opt) =
                  if is_variadic then
                    match List.reverse param_syms with
                    | [] -> error "variadic functions need to have at least one parameter"
                    | sym::_ -> (Just (Symbol.fresh ()), Just sym)
                    end
                  else
                    (Nothing, Nothing)
                in
(*
                (snd <$> translate_stmt stdlib program sym <|
                           return_ty= return_ty;
                           return_lab= ret_label;
                           default_lab= Nothing;
                           case_labs= [];
                           loop= Nothing;
                           break= Nothing;
                           goto_visibles= visibles.goto_visibles_;
                           label_visibles= visibles.label_visibles_;
                         |> stmt
*)
                (translate_stmt2 stdlib core_tagDefs sym <|
                   return_ty= return_ty;
                   return_lab= ret_label;
                   variadic_sym_opt= variadic_sym_opt;
                   last_arg_sym_opt= last_arg_sym_opt;
                   is_Noreturn= is_Noreturn;
                   default_lab= Nothing;
                   case_labs= [];
                   loop= Nothing;
                   break= Nothing;
                   goto_visibles= visibles.goto_visibles_;
                   label_visibles= visibles.label_visibles_;
                 |> stmt) >>= fun core_body ->
                
(*              let core_return =
                  if startup_sym = sym then
                    (* §5.1.2.2.3#1 sentence 1*)
                    (* TODO: "If the return type is not compatible with int" *)
                    C.Ereturn (Caux.mk_specified_pe (Caux.mk_integer_pe 0))
                  else if return_ty = Aty.Void then
                    C.Ereturn Caux.mk_unit_pe
                  else
                    (* §6.9.1#12 *)
                    C.Epure (Caux.mk_undef_pe Undefined.UB088_reached_end_of_function) in *)
                
                let core_return =
                  let ret_pe =
                    if startup_sym_opt = Just sym then
                      (* STD §5.1.2.2.3#1 sentence 1*)
                      (* TODO: "If the return type is not compatible with int" *)
                      Caux.mk_specified_pe (Caux.mk_integer_pe 0)
                    else if AilTypesAux.is_void return_ty && is_Noreturn then
                      Caux.mk_std_undef_pe loc "§6.7.4#8" Undefined.UB071_noreturn
                    else if AilTypesAux.is_void return_ty then
                      Caux.mk_unit_pe
                    else
                      Caux.mk_std_undef_pe loc "§6.9.1#12" Undefined.UB088_reached_end_of_function in
                  Caux.mk_save_e (ret_label, ret_bTy) [(ret_sym, (ret_bTy, ret_pe))]
                    (Caux.mk_pure_e (Caux.mk_sym_pe ret_sym))

(*
                  let run_e =
                    if startup_sym = sym then
                      (* STD §5.1.2.2.3#1 sentence 1 *)
                      (* TODO: "If the return type is not compatible with int" *)
                      C.Erun () ret_label [Caux.mk_specified_pe (Caux.mk_integer_pe 0)]
                    else if return_ty = Aty.Void then
                      C.Erun () ret_label [Caux.mk_unit_pe]
                    else
                      (* §6.9.1#12 *)
                      C.Epure (Caux.mk_undef_pe Undefined.UB088_reached_end_of_function) in
                  
                  C.Esseq (Caux.mk_empty_pat bTy) run_e
                    begin
                      (* TODO: might be able to replace the earlier UB088 by a Eskip *)
                      C.Esave ret_label [(ret_sym, (bTy, Caux.mk_undef_pe Undefined.UB088_reached_end_of_function))]
                        (C.Epure (Caux.mk_sym_pe bTy ret_sym))
                    end
*)
                in
                let variadic_arg_type =
                  match variadic_sym_opt with
                  | Just sym -> [(sym, C.BTy_list (C.BTy_tuple [C.BTy_ctype; C.BTy_object C.OTy_pointer]))]
                  | Nothing -> []
                  end
                in
                E.return
                  (gacc
                  , Map.insert sym
                     (C.Proc loc (ret_bTy (* C.BTy_loaded (if AilTypesAux.is_pointer return_ty then C.OTy_pointer else C.OTy_integer)*))
                             (List.map (fun sym -> (sym, C.BTy_object C.OTy_pointer)) param_syms ++ variadic_arg_type)
                             (Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit) core_body core_return)
                     ) facc
                  , Map.insert sym finfo finfoacc)
          end
    end
  ) ([], Map.empty, Map.empty) (List.reverse sigm.A.declarations) >>= fun (globs, cfuns, funinfo) ->
  
  (* adding string literals *)
  E.get_string_literals >>= fun xs ->
  E.foldlM (fun acc (loc, sym, ty, e_init) ->
    let sym_lit = Symbol.fresh () in
    let expr =
      Caux.pcreate_readonly loc
        (Caux.mk_alignof_pe (Caux.mk_ctype_pe ty))
        (Caux.mk_ctype_pe ty)
        e_init
        (Symbol.PrefOther "string literal")
(*
      Caux.mk_sseq_e (Caux.mk_sym_pat sym_lit (C.BTy_object C.OTy_pointer)) (Caux.pcreate loc (Caux.mk_alignof_pe (Caux.mk_ctype_pe ty)) (Caux.mk_ctype_pe ty) (Symbol.PrefOther "string literal"))
        (Caux.mk_sseq_e (Caux.mk_empty_pat C.BTy_unit) (Caux.pstore loc (Caux.mk_ctype_pe ty) (Caux.mk_sym_pe sym_lit) e_init Cmm.NA)
          (Caux.mk_pure_e (Caux.mk_sym_pe sym_lit))) 
*)
in
      E.return $ (sym, C.GlobalDef (C.BTy_object C.OTy_pointer) expr) :: acc
  ) globs (List.reverse xs) >>= fun globs' ->
  E.return (core_tagDefs, globs', cfuns, funinfo)
(*

  E.foldlM (fun acc (fun_sym, <| A.fun_return_ty=   ret_ty;
                                A.fun_bindings=    fun_args;
                                A.fun_is_variadic= is_variadic;
                                A.fun_body=        fun_body_opt |>) ->
    match fun_body_opt with
      | Just fun_body ->
          (* making the argument variables visible *)
          E.push_block_objects (List.map fst fun_args) >>
          
          (* translate the body to Core *)
          translate_stmt program fun_sym Nothing Nothing Nothing Nothing fun_body >>= fun core_body ->
          (* removing the argument variables from the "visibles" *)
          E.pop_block_objects >>
          
          (* If we are elaborating the startup function, then we add at the beginning of the body
             the allocations/initialisations of the global variables *)
          
          let e_ret =
            if startup_sym = fun_sym then
              (* §5.1.2.2.3#1 sentence 1 *)
              (* TODO: "If the return type is not compatible with int" *)
              C.Ereturn (Caux.mk_integer_pe_pe 0)
            
            else if ret_ty = Aty.Void then
              C.Ereturn (C.PEval (C.Vunit))
            else
              (* §6.9.1#12 *)
              C.PEundef Undefined.Reached_end_of_function in
          
          (E.return $ Map.insert fun_sym (
                                        C.TyEffect C.BTy_integer (* TODO: this should de address for pointer type *),
                                        List.map (fun (arg, _) -> (arg, C.BTy_pointer (* TODO: check *))) fun_args,
                                        (C.Esseq [] core_body e_ret)
                                      ) acc)
      | Nothing ->
          (* TODO: this corresponds to an Ail function a prototype but no implementation ==> std lib function *)
          E.return acc
    end
  ) Map.empty funs >>= fun cfuns ->
  E.return (cglobs, cfuns)
*)

let translate_extern_map (_, sigm) =
  Map.map (fun (sym, kind) ->
    match kind with
    | A.IK_declaration -> ([sym], C.LK_none)
    | A.IK_tentative -> ([sym], C.LK_tentative sym)
    | A.IK_definition -> ([sym], C.LK_normal sym)
    end) sigm.A.extern_idmap

(* This is the entry function (called from main.ml) *)
val translate:
    (map string Symbol.sym) * C.fun_map unit ->
    C.impl -> A.ail_program GenTypes.genTypeCategory ->
    C.file unit

let translate (ailnames, stdlib_fun_map) impl prog =
  let translation_stdlib = mk_translation_stdlib (ailnames, stdlib_fun_map) in
  
  (* TODO: this is ugly, we shouldn't expose the internals and properly use the Undefined *)
  (* TODO2: not sure what that comment is refering too ... *)
  let ((core_tagDefs, cglobs, (*cdecls, *) cfuns, funinfo), st) =
    E.runStateM (translate_program translation_stdlib prog) (E.elab_init ())
  in
  <|C.main= fst prog;
    C.tagDefs= core_tagDefs;
    C.stdlib= stdlib_fun_map;
    C.impl= impl;
    C.globs= cglobs;
    C.funs= cfuns;
    C.extern = translate_extern_map prog;
    C.funinfo= funinfo;
  |>
