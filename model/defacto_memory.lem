(* De-facto C11 memory model *)
open import Pervasives
import Set_helpers (* fold *)

open import Global

import Symbolic Thread Cabs AilTypes Dlist

open import Mem_common Defacto_memory_types Core_ctype Core_ctype_aux


val print_debug: nat -> string -> unit
declare ocaml target_rep function print_debug = `Debug.print_debug`


val stringFromCtype: ctype -> string
declare ocaml target_rep function stringFromCtype = `String_core_ctype.string_of_ctype`


(* Semantic switches *)
type mode =
  | Mode_ISO
    (* the bools are: "-no-strict-aliasing", multiple-provenance,
       pointer-lifetime-zap *)
  | Mode_Defacto of bool * bool * bool


(* Basic representation:
     assuming 8-bit bytes and two's complement arithmetic.
 *)


(* Constraints solving stuff *)
type constraints
val initial_constraints: unit -> constraints
val is_unsat: string -> bool
val add_constraint: mem_constraint -> constraints -> constraints (* Left => unsat *)
val check_sat: mem_constraint -> constraints -> maybe bool
val declare_address: address -> constraints -> constraints

declare ocaml target_rep type     constraints         = `Sat_solving.assertions`
declare ocaml target_rep function initial_constraints = `Sat_solving.initial_assertions`
declare ocaml target_rep function is_unsat            = `Sat_solving.is_unsat`
declare ocaml target_rep function add_constraint      = `Sat_solving.add_mem_constraint`
declare ocaml target_rep function check_sat           = `Sat_solving.check`
declare ocaml target_rep function declare_address     = `Sat_solving.declare_address`


type write_event =
  WriteEvent of ctype * pointer_value * mem_value


type mem_state = <|
  (* this is read-only *)
  flags: list memory_flag;
  
  (* machinery stuff *)
  allocation_id_suppl: UniqueId.supply allocation_id;
  suppl:    UniqueId.supply nat;
  
  (* the semantic stuff starts here *)
  allocations:         map allocation_id (allocation * mem_value);
  dead_allocations:    set allocation_id;
  addresses:           set address;
  constraints:         constraints;
|>


(* TODO: only for the concurrency *)
let fake_pointer_value_eq (PV _ ptr_val_1 sh1) (PV _ ptr_val_2 sh2) =
  match (ptr_val_1, ptr_val_2) with
    | (PVbase alloc_id1 _, PVbase alloc_id2 _) ->
        alloc_id1 = alloc_id2
    | _ ->
        error "DON'T USE Eq for pointer_value"
  end
instance (Eq pointer_value)
  let (=) = fake_pointer_value_eq
  let (<>) ptr_val1 ptr_val2 = not (fake_pointer_value_eq ptr_val1 ptr_val2)
end

let rec fake_mem_value_eq mval1 mval2 =
  match (mval1, mval2) with
    | (MVsymbolic symb1, MVsymbolic symb2) ->
        symb1 = symb2
    | (MVinteger _ (IV _ (IVconcrete n1)), MVinteger _ (IV _ (IVconcrete n2))) ->
        n1 = n2
    | (MVarray mvals1, MVarray mvals2) ->
        List.all (uncurry fake_mem_value_eq) (zip mvals1 mvals2)
    | _ ->
        error "DON'T USE Eq for mem_value"

(*
    | MVsymbolic of Symbolic.symbolic (* symbolicity coming from the concurrency *)
    | MVunspecified of ctype (* INVARIANT: the ctype must be base or union type *)
    | MVinteger of AilTypes.integerType * integer_value
    | MVfloating of AilTypes.floatingType * string
    | MVpointer of ctype * pointer_value (* the first parameter is the referenced type of the pointer value *)
    | MVarray of list mem_value (* TODO: list (maybe mem_value) *)
    | MVstruct of Symbol.t * list (Cabs.cabs_identifier * mem_value)
    | MVunion of Symbol.t * Cabs.cabs_identifier * mem_value (* the symbols are respectively the tag and the member *)
*)
end

instance (Eq mem_value)
  let (=) = fake_mem_value_eq
  let (<>) mval1 mval2 = not (fake_mem_value_eq mval1 mval2)
end


(* BEGIN string conversion functions ============================================================ *)
instance (Show mem_value)
  let show x = "WIP: show mem_value"
end

instance (Show pointer_value)
  let show x = "WIP: show pointer_value"
end

val stringFromPointer_value: pointer_value -> string
val stringFromMem_value: mem_value -> string
val stringFromShift_path: shift_path -> string (* DEBUG *)

declare ocaml target_rep function stringFromPointer_value = `String_defacto_memory.string_of_pointer_value`
declare ocaml target_rep function stringFromMem_value = `String_defacto_memory.string_of_mem_value`
declare ocaml target_rep function stringFromShift_path = `String_defacto_memory.string_of_shift_path` (* DEBUG *)











(* BEGIN effect ================================================================================= *)

(*
type memM_action 'a =
  | MemMval of 'a * mem_state
  | MemMerr of mem_error
  | MemMif of Symbolic.symbolic * memM_action 'a * memM_action 'a
  | MemMnd of list (maybe Symbolic.symbolic * memM_action 'a)

type memM 'a =
  mem_state -> memM_action 'a
*)








type memM 'a =
  | MemM of (mem_state -> list (either mem_error ('a * mem_state)))



val return: forall 'a. 'a -> memM 'a
let return x =
  MemM (fun st -> [Right (x, st)])


val bind: forall 'a 'b. memM 'a -> ('a -> memM 'b) -> memM 'b
let bind (MemM m) f =
  MemM (
    fun st ->
      concatMap (
        either
          (fun err -> [Left err])
          (fun (z, st') ->  let MemM m' = f z in m' st')
      ) (m st)
  )

(*
  fun st ->
    concatMap (either (fun z -> [Left z]) (fun (z, st') -> f z st')) (m st)
*)

let inline (>>=)      = bind
let inline (>>) m1 m2 = bind m1 (fun _ -> m2)

let inline (<$>) f m =
  m >>= return -| f


(* TODO: debug *)
val wip: forall 'a. string -> memM 'a (* DEBUG *)
let wip str =                         (* DEBUG *)
  MemM (                              (* DEBUG *)
    fun _ ->                          (* DEBUG *)
      [Left (MerrWIP str)]            (* DEBUG *)
  )                                   (* DEBUG *)


val fail: forall 'a. mem_error -> memM 'a
let fail err =
  MemM (fun st -> [Left err])


val get: memM mem_state
let get =
  MemM (fun st -> [Right (st, st)])

val put: mem_state -> memM unit
let put st =
  MemM (fun _ -> [Right ((), st)])




val fresh_address: Symbol.prefix -> memM address
let fresh_address pref =
  get >>= fun mem_st ->
  let (n, suppl') = UniqueId.fresh_id mem_st.suppl in
  let addr = Address pref n in
  put <| mem_st with
    suppl= suppl';
    constraints= declare_address addr mem_st.constraints;
    addresses= Set.insert addr mem_st.addresses |> >>
  return addr


val fresh_allocation_id: memM allocation_id
let fresh_allocation_id =
  get >>= fun mem_st ->
  let (id, suppl') = UniqueId.fresh_id mem_st.allocation_id_suppl in
  put <| mem_st with allocation_id_suppl= suppl' |> >>
  return id


val register_allocation: allocation_id -> (allocation * mem_value) -> memM unit
let register_allocation alloc_id alloc_mval =
  get >>= fun mem_st ->
  put <| mem_st with allocations=
    Map.insert alloc_id alloc_mval mem_st.allocations
  |>


val allocation_is_dead: allocation_id -> memM bool
let allocation_is_dead alloc_id =
  get >>= fun mem_st ->
  return (alloc_id IN mem_st.dead_allocations)

val resolve_allocation: allocation_id -> memM (allocation * mem_value)
let resolve_allocation alloc_id =
  get >>= fun mem_st ->
  maybe (fail (MerrInternal ("failed to resolve allocation: " ^ show alloc_id))) return
    (Map.lookup alloc_id mem_st.allocations)

(* END effect =================================================================================== *)

val mzero: forall 'a. memM 'a
let mzero =
  MemM (fun st -> [])






(*
val add_constraints: list mem_constraint -> memM unit
let add_constraints xs =
  get >>= fun st ->
  put <| st with constraints= xs ++ st.constraints |> >>
  constraints_are_unsat >>= function
    | true  -> mzero
    | false -> return ()
  end
*)


let integer_value_baseSimpl ival_ =
  ival_

let integer_value_baseEquality ival_1 ival_2 =
  Nothing





val     simplify_integer_value_base: integer_value_base -> either integer integer_value_base
let rec simplify_integer_value_base ival_ =
  match ival_ with
    | IVconcrete n ->
        Left n
    | IVop iop ival_s ->
        let op = match iop with
          | IntAdd ->
              fun x y -> x + y
          | IntSub ->
              fun x y -> x - y
          | IntMul ->
              fun x y -> x * y
          | IntDiv ->
              fun x y -> if y = 0 then 0 else x / y
          | IntMod ->
              fun x y -> if y = 0 then 0 else x mod y
          | IntExp ->
              fun x y -> x ** natFromInteger y
        end in
        match List.map simplify_integer_value_base ival_s with
          | [Left n1; Left n2] ->
              Left (op n1 n2)
          | [Left n1; Right ival_2] ->
              match iop with
                | IntAdd ->
                    if n1 = 0 then
                      Right ival_2
                    else
                      Right (IVop iop [IVconcrete n1; ival_2])
                | _ ->
                    Right (IVop iop [IVconcrete n1; ival_2])
              end
          | [Right ival_1; Left n2] ->
              match iop with
                | IntAdd ->
                    if n2 = 0 then
                      Right ival_1
                    else
                      Right (IVop iop [ival_1; IVconcrete n2])
                | _ ->
                    Right (IVop iop [ival_1; IVconcrete n2])
              end
          | [Right ival_1; Right ival_2] ->
              Right (IVop iop [ival_1; ival_2])
          | _ ->
              error "Mem.simplify_integer_value_base"
        end
    | IVfromptr ref_ty (PVfromint ival_') ->
        simplify_integer_value_base ival_'
    
    
    | IVsizeof ty ->
        match ty with
          | Core_ctype.Basic (AilTypes.Integer (AilTypes.Char)) ->
              Left 1
          | Core_ctype.Basic (AilTypes.Integer (AilTypes.Signed AilTypes.Ichar)) ->
              Left 1
          | Core_ctype.Basic (AilTypes.Integer (AilTypes.Unsigned AilTypes.Ichar)) ->
              Left 1
          | Core_ctype.Basic (AilTypes.Integer (AilTypes.Signed (AilTypes.IBBuiltin "int8_t"))) ->
              Left 1
          | Core_ctype.Basic (AilTypes.Integer (AilTypes.Unsigned (AilTypes.IBBuiltin "int8_t"))) ->
              Left 1
          | Core_ctype.Basic (AilTypes.Integer (AilTypes.Signed (AilTypes.IBBuiltin "int16_t"))) ->
              Left 2
          | Core_ctype.Basic (AilTypes.Integer (AilTypes.Unsigned (AilTypes.IBBuiltin "int16_t"))) ->
              Left 2
          | Core_ctype.Basic (AilTypes.Integer (AilTypes.Signed (AilTypes.IBBuiltin "int32_t"))) ->
              Left 4
          | Core_ctype.Basic (AilTypes.Integer (AilTypes.Unsigned (AilTypes.IBBuiltin "int32_t"))) ->
              Left 4
          | Core_ctype.Basic (AilTypes.Integer (AilTypes.Signed (AilTypes.IBBuiltin "int64_t"))) ->
              Left 8
          | Core_ctype.Basic (AilTypes.Integer (AilTypes.Unsigned (AilTypes.IBBuiltin "int64_t"))) ->
              Left 8

        (* TODO !!!!, fixing impl for testing purpose *)
          | Core_ctype.Basic (AilTypes.Integer (AilTypes.Signed AilTypes.Int_)) ->
              Left 4
          | Core_ctype.Basic (AilTypes.Integer (AilTypes.Unsigned AilTypes.Int_)) ->
              Left 4
          | Core_ctype.Basic (AilTypes.Integer (AilTypes.Signed AilTypes.Long)) ->
              Left 8
          | Core_ctype.Basic (AilTypes.Integer (AilTypes.Unsigned AilTypes.Long)) ->
              Left 8
          | _ ->
              Right ival_
        end
    
    
    | _ ->
        (* TODO: can probably do much more *)
        Right ival_
  end



val eval_integer_value_base: integer_value_base -> maybe integer
let eval_integer_value_base ival_ =
  either (fun n -> Just n) (fun _ -> Nothing) (simplify_integer_value_base ival_)

(*
  match ival_ with
    | IVconcrete n ->
        Just n
    | IVop iop ival_s ->
        let op = match iop with
          | IntAdd ->
              fun x y -> x + y
          | IntSub ->
              fun x y -> x - y
          | IntMul ->
              fun x y -> x * y
          | IntDiv ->
              fun x y -> if y = 0 then 0 else x / y
          | IntMod ->
              fun x y -> if y = 0 then 0 else x mod y
          | IntExp ->
              fun x y -> x ** natFromInteger y
        end in
        match (iop, List.map eval_integer_value_base ival_s) with
          | (_, [Just n1; Just n2]) ->
              Just (op n1 n2)
          | _ ->
              Nothing
        end
    | IVfromptr ref_ty (PVfromint ival_') ->
        eval_integer_value_base ival_'
    
    | _ ->
        (* TODO: can probably do much more *)
        Nothing
  end
*)


(*
val negate_constraint: mem_constraint -> mem_constraint
let negate_constraint = function
  | MC_eqIV ival1_ ival2_ ->
      MC_neIV ival1_ ival2_
  | MC_neIV ival1_ ival2_ ->
      MC_eqIV ival1_ ival2_
  | MC_leIV ival1_ ival2_ ->
      MC_gtIV ival1_ ival2_

  | MC_addr_distinct of address_id * set address_id  (* the first address is distinct for the addresses in the set *)
  | MC_addr_equals of address_id * integer_value_base (* the address is equal to a specific integer value *)
  
end
*)


val ifFlag: forall 'a. memory_flag -> memM 'a -> memM 'a -> memM 'a
let ifFlag flag (MemM m_then) (MemM m_else) =
  MemM (fun mem_st ->
    (if List.elem flag mem_st.flags then m_then else m_else) mem_st
  )




val ifM: forall 'a. mem_constraint -> memM 'a -> memM 'a -> memM 'a
let ifM constr (MemM m_then) (MemM m_else) =
  match constr with
    | MC_eqIV debug_str ival_1 ival_2 ->
        let ival_1' = either (fun z -> IVconcrete z) id (simplify_integer_value_base ival_1) in
        let ival_2' = either (fun z -> IVconcrete z) id (simplify_integer_value_base ival_2) in
        match (ival_1', ival_2') with
          | (IVconcrete n1, IVconcrete n2) ->
              MemM (if n1 = n2 then m_then else m_else)
          | _ ->
              MemM (fun mem_st ->
                match check_sat (MC_eqIV debug_str ival_1' ival_2') mem_st.constraints with
                  | Just true ->
                      (* TODO: check, but it doesn't seem useful to add the constraint *)
                      (m_then <| mem_st with constraints= add_constraint (MC_eqIV ("ifM(then)[" ^ debug_str ^ "]") ival_1' ival_2') mem_st.constraints |>)
                  | Just false ->
                      (* TODO: check, but it doesn't seem useful to add the constraint *)
                      (m_else <| mem_st with constraints= add_constraint (MC_neIV ival_1' ival_2') mem_st.constraints |>)
                  | Nothing ->
                      (m_then <| mem_st with constraints= add_constraint (MC_eqIV ("ifM(then)[" ^ debug_str ^ "]") ival_1' ival_2') mem_st.constraints |>) ++
                      (m_else <| mem_st with constraints= add_constraint (MC_neIV ival_1' ival_2') mem_st.constraints |>)
                end
              )
        end
  | MC_neIV _ _ ->
      wip "ifM, MC_neIV"
  | MC_leIV _ _ ->
      wip "ifM, MC_leIV"
  | MC_addr_distinct _ _ ->
      wip "ifM, MC_addr_distrinct"
(*
  | MC_addr_equals addr_expr1 addr_expr2 ->
      wip "ifM, MC_addr_equals"
*)
  end




val condM: mem_constraint -> memM bool
let condM constr =
  ifM constr (return true) (return false)


(*
  match constr with
    | MC_eqIV ival_1 ival_2 ->
        let ival_1' = integer_value_baseSimpl ival_1 in
        let ival_2' = integer_value_baseSimpl ival_2 in
        match integer_value_baseEquality ival_1' ival_2' with
          | Just b ->
              if b then m_then else m_else
          | Nothing ->
              mplus
                (with_constraints [MC_eqIV ival_1' ival_2'] m_then)
                (with_constraints [MC_neIV ival_1' ival_2'] m_else)


              fun st ->
                let (xs1, z1) = m_then st in
                let (xs2, z2) = m_else st in
                [ (MC_eqIV ival_1' ival_2' :: xs1, z1)
                ; (MC_neIV ival_1' ival_2' :: xs2, z2)
                ]
        end
  end
*)




(* ============================================================================================== *)

val print_debugM: nat -> string -> memM unit
let print_debugM n str =
  MemM (fun st ->
    let _ = print_debug n str in
    [Right ((), st)]
  )



val debug_check: string -> bool -> memM unit
let debug_check str = function
  | true ->
      return ()
  | false ->
      fail (MerrInternal ("debug_check failed ==> " ^ str))
end






(*
  | Prov_wildcard
  | Prov_none
  | Prov_device
  | Prov_some of set provenance_id (* INVARIANT: non empty set *)
*)
(*
val share_common: provenance -> provenance -> bool
let share_common prov1 prov2 =
  match (prov1, prov2) with
    | 
  end
*)













(* TODO: (not sure at all) currently Prov_some has priority *)
val prov_union: provenance -> provenance -> provenance
let prov_union prov1 prov2 =
  match (prov1, prov2) with
    | (Prov_some ids1, Prov_some ids2) ->
        Prov_some (ids1 union ids2)
    | (Prov_some ids, _) ->
        Prov_some ids
    | (_, Prov_some ids) ->
        Prov_some ids
    | (Prov_none, Prov_none) ->
        Prov_none
(*
    | (Prov_none, Prov_some ids) ->
        Prov_some ids
    | (Prov_some ids, Prov_some ids) ->
        Prov_some ids
*)
    | _ ->
        error "WIP: prov_union"
  end












(* Wellformedness predicates (following the comments in the definitions of the related types). *)
val wf_pointer_value: pointer_value -> bool
let wf_pointer_value = function
  | PV Prov_none (PVnull _) _ ->
      true
  | PV _ (PVnull _) _ ->
      false
  | _ ->
      true (* TODO !!!! error "WIP: wf_pointer_value" *)
end





(* Returns whether a given allocation has reached the end of its lifetime *)
val is_dead: allocation_id -> memM bool
let is_dead alloc_id =
  get >>= fun mem_st ->
  return (Set.member alloc_id mem_st.dead_allocations)


(* TODO: why is that effectfull? *)
val     explicitAllocationIdFromPointer_value_aux: pointer_value_base -> memM (maybe allocation_id)
let rec explicitAllocationIdFromPointer_value_aux ptr_val_ =
  match ptr_val_ with
    | PVnull _ ->
        return Nothing
    | PVfunction _ ->
        return Nothing
    | PVbase alloc_id _ ->
        return (Just alloc_id)
    | PVfromint ival_ ->
        explicitAllocationIdFromInteger_value_aux ival_
  end

and explicitAllocationIdFromInteger_value_aux  ival_ =
  match ival_ with
    | IVconcrete n ->
        return Nothing
    | IVaddress _ ->
        return Nothing
    | IVfromptr _ ptr_val_ ->
        explicitAllocationIdFromPointer_value_aux ptr_val_
    | IVop _ _ ->
        return Nothing
    | IVmin _ ->
        return Nothing
    | IVmax _->
        return Nothing
    | IVsizeof _->
        return Nothing
    | IValignof _->
        return Nothing
    | IVoffsetof _ _->
        return Nothing
    | IVptrdiff _ _->
        return Nothing
    | IVbyteof _ _->
        return Nothing
  end




(* Making an indirection here, so that future crazy optimisations won't be duplicated all over. *)
let mk_op_ival_ iop ival_1 ival_2 =
  either (fun z -> IVconcrete z) id (simplify_integer_value_base $ IVop iop [ival_1; ival_2])



val integer_value_baseFromShift_path: shift_path -> integer_value_base
let integer_value_baseFromShift_path sh =
  List.foldl (fun acc spe ->
    let spe_ival_ = match spe with
      | SPE_array ty ival_ ->
          mk_op_ival_ IntMul (IVsizeof ty) ival_
      | SPE_member tag_sym memb_ident ->
          IVoffsetof tag_sym memb_ident
    end in
    mk_op_ival_ IntAdd spe_ival_ acc
  ) (IVconcrete 0) sh






(*
  | IVconcrete of integer (* of Symbolic.symbolic *)
  | IVfromptr of ctype * pointer_value_base (* the first parameter is the referenced type of the pointer value *)
  | IVop of integer_operator * list integer_value_base
  | IVsizeof of ctype
  | IVoffsetof of Symbol.t * Cabs.cabs_identifier
  | IVptrdiff of pointer_value_base * pointer_value_base
*)
















let prettyStringFromMem_value mval =
  error "WIP: prettyStringFromMem_value"



(*
type memM 'a =
  mem_state -> list (list Symbolic.symbolic * either mem_error ('a * mem_state))
*)
let runMem (MemM m) st =
  let xs = m st in
  if List.null xs then
    error "runMem: empty"
  else
    xs


let initial_mem_state = <|
  flags= [];
  allocation_id_suppl= UniqueId.new_supply;
  suppl= UniqueId.new_supply;
  
  allocations= Map.empty;
  dead_allocations= Set.empty;
  addresses= Set.empty;
  constraints= initial_constraints ();
(*  writes= []; *)
|>




val get_allocation_id: pointer_value_base -> maybe allocation_id
let rec get_allocation_id ptr_val_ =
  match ptr_val_ with
    | PVnull ty ->
        Nothing
    | PVbase alloc_id _ ->
        Just alloc_id
    | PVfromint (IVfromptr ref_ty ptr_val_') ->
        get_allocation_id ptr_val_'
    | _ ->
        error "TODO: get_allocation_id, wildcard"
  end



(* Make a given address disjoint to all other existing address *)
val register_distinctness_constraints: address -> memM unit
let register_distinctness_constraints addr =
  get >>= fun mem_st ->
  put <| mem_st with
    constraints= add_constraint (MC_addr_distinct addr
                                   (Set.filter (fun addr' -> addr <> addr') mem_st.addresses)) mem_st.constraints
  |>
         
(*  wip "add_constraints [MC_addr_distinct addr_id (Set.filter (fun addr_id' -> addr_id <> addr_id') (Map.domain mem_st.addresses))]" *)






val     mkUnspec: ctype -> mem_value
let rec mkUnspec ty =
  match ty with
    | (Basic _ as ty) ->
        MVunspecified ty
    | Array ty (Just n) ->
        MVarray $ replicate (natFromInteger n) (mkUnspec ty)
    | (Pointer _ _ as ty) ->
        MVunspecified ty
    | (Atomic _ as ty) ->
        MVunspecified ty
    | Struct tag ->
        MVstruct tag $ map (fun (ident, ty) -> (ident, mkUnspec ty)) (get_membersDefs tag)
    | (Union _ as ty) ->
        MVunspecified ty
    | (Builtin _ as ty) ->
        MVunspecified ty
    | _ ->
        error "Mem.mkUnspec: invalid type"
  end



(*
val     traverse_with_shift_path: tag_definitions -> mem_value -> shift_path -> (mem_value -> mem_value)
let rec traverse_with_shift_path tagDefs mval sh =
  match (mval, sh) with
    | (_, []) ->
        fun z -> z
    | (MVarray mvals, (SPE_array _ ival_) :: sh') ->
        match simplify_integer_value_base ival_ with
          | IVconcrete n ->
              (* TODO: check here for ooba? *)
              fun z ->
                MVarray (list_index_update (natFromInteger n) (fun x -> traverse_with_shift_path tagDefs x sh' z) mvals)
          | _ ->
              error "traverse_with_shift_path: non-concrete array shift"
        end
(*
    | (MVstruct mval_tag_sym xs, (SPE_member spe_tag_sym memb_ident) :: sh') ->
        if mval_tag_sym = spe_tag_sym then
          let Just ident_tys = Map.lookup mval_tag_sym tagDefs in
          
        else
          error "traverse_with_shift_path: wrong struct tag"
*)
    | _ ->
        error ("traverse_with_shift_path: " ^ stringFromMem_value mval ^ ", " ^ stringFromList stringFromShift_path_element sh)
end
*)


(*
and shift_path_element =
  | SPE_array of ctype * integer_value_base
(*  | SPE_member of ctype * integer (*TODO: bring back symbolic *) *)
  | SPE_member of Symbol.t (*struct/union tag*) * Cabs.cabs_identifier (*member*) 
 
and shift_path =
  list shift_path_element
*)



(*
val update_mem_value: tag_definitions -> write_event -> mem_value -> mem_value
let update_mem_value tagDefs (WriteEvent ty (PV prov ptr_val_) mval') mval =
  match ptr_val_ with
    | PVbase _ ->
        mval'
    | PVshift _ sh ->
        traverse_with_shift_path tagDefs mval sh mval'
    
    | _ ->
        mval (* TODO *)
  end
*)





















let allocate_static tid pref align_ival ty =
  (* the allocated object is given a new address (distinct from all other
     existing addresses) *)
  fresh_address pref >>= fun addr ->
  register_distinctness_constraints addr >>
  
  fresh_allocation_id >>= fun alloc_id ->
  register_allocation alloc_id (Alloc_static ty addr, mkUnspec ty) >>
  
  let ptr_val = PV (Prov_some (Set.singleton alloc_id)) (PVbase alloc_id pref) [] in
  print_debugM 4 ("Allocating (static) with type [" ^ stringFromCtype ty ^ "]: " ^ stringFromPointer_value ptr_val) >> (* DEBUG *)
  
  return ptr_val


let allocate_dynamic tid pref align_ival (IV _ size_ival) =
  (* TODO *)
  fresh_address pref >>= fun addr ->
  register_distinctness_constraints addr >>
  
  fresh_allocation_id >>= fun alloc_id ->
  let unsigned_char = Basic (AilTypes.Integer (AilTypes.Signed AilTypes.Ichar)) in
  register_allocation alloc_id (Alloc_dynamic size_ival addr, mkUnspec (Array unsigned_char (Just 42 (* TODO !!! *)))) >>
  
  return (
    PV (Prov_some (Set.singleton alloc_id)) (PVbase alloc_id pref) []
  )







(* TODO: temporary *)
let structural_equality_provenance prov1 prov2 =
  match (prov1, prov2) with
    | (Prov_wildcard, Prov_wildcard) ->
        true
    | (Prov_none, Prov_none) ->
        true
    | (Prov_device, Prov_device) ->
        true
    | (Prov_some ids1, Prov_some ids2) ->
        ids1 = ids2
    | _ ->
        false
  end

let rec structural_equality_pointer_value (PV prov1 ptr_val_1 sh1) (PV prov2 ptr_val_2 sh2) =
     structural_equality_provenance prov1 prov2
  && structural_equality_pointer_value_base ptr_val_1 ptr_val_2
  && listEqualBy structural_equality_shift_path_element sh1 sh2

and structural_equality_pointer_value_base ptr_val_1 ptr_val_2 =
  match (ptr_val_1, ptr_val_2) with
    | (PVnull ty1, PVnull ty2) ->
        ty1 = ty2
    | (PVfunction sym1, PVfunction sym2) ->
        sym1 = sym2
    | (PVbase alloc_id1 _, PVbase alloc_id2 _) ->
        alloc_id1 = alloc_id2
    | (PVfromint ival_1, PVfromint ival_2) ->
        structural_equality_integer_value_base ival_1 ival_2
    | _ ->
        false
  end

and structural_equality_shift_path_element spe1 spe2 =
  match (spe1, spe2) with
    | (SPE_array ty1 ival_1, SPE_array ty2 ival_2) ->
        ty1 = ty2 && structural_equality_integer_value_base ival_1 ival_2
    | (SPE_member tag_sym1 memb_ident1, SPE_member tag_sym2 memb_ident2) ->
        tag_sym1 = tag_sym2 && memb_ident1 = memb_ident2
    | _ ->
        false
 end
 
and structural_equality_shift_path sh1 sh2 =
  List.all (uncurry structural_equality_shift_path_element) (zip sh1 sh2)

and structural_equality_integer_value_base _ _ =
  error "structural_equality_integer_value_base"




val is_affecting: write_event -> ctype -> pointer_value -> memM bool
let is_affection (WriteEvent w_ty w_ptr_val mval) r_ty r_ptr_val =
(*
  get_allocation_id r_ptr_val >>= fun r_alloc_id_opt ->
  get_allocation_id w_ptr_val >>= fun w_alloc_id_opt ->
  match (r_alloc_id_opt, w_alloc_id_opt) with
    | (Just r_alloc_id, Just w_alloc_id) ->
        if r_alloc_id = w_alloc_id then
          condM (MC_conj (MC_le_ival_ (offset_ival_ w_ptr_val) (offset_ival_ r_ptr_val))
                         (MC_le_ival_ () ())
        else
          wip "is_affecting 1"
        condM (offset_ival 
  end
*)
  error "is_affecting"






(*
val find_allocation_id: pointer_value -> memM allocation_id
let find_allocation_id (PV 
*)

























val     fetch_first_write_event: (write_event -> bool) -> memM (maybe write_event)
let rec fetch_first_write_event_aux pred = function
  | [] ->
      Nothing
  | x :: xs ->
      if pred x then Just x else fetch_first_write_event_aux pred xs
end
let fetch_first_write_event pred =
  wip "fetch_frist_write_event"
(*
  get >>= fun st ->
  return (fetch_first_write_event_aux pred st.writes)
*)




(*
val try_to_dereference_aux: provenance -> shift_path -> pointer_value_base -> memM (maybe mem_value)
let try_to_dereference_aux prov sh = function
  | PVnull _ ->
      error "TODO: raise an undef (I guess)"
  | PVfunction ->
      error "TODO: raise an undef (I guess)"
  | PVbase alloc_id _ ->
      
  | PVfromint _ ->
      error "TODO: (try_to_dereference_aux) ?"
end


val try_to_dereference: pointer_value -> memM (maybe mem_value)
let try_to_dereference (PV prov ptr_val_ sh) =
*)



val apply_shift_path_element: ctype -> shift_path_element -> mem_value -> mem_value
let apply_shift_path_element ty spe mval =
(* TODO: use ty *)
  match (spe, mval) with
    | (SPE_array elem_ty ival_, MVarray mvals) ->
        match eval_integer_value_base ival_ with
          | Just n ->
              let n = natFromInteger n in
              if n < 0 || List.length mvals <= n then
                error "Mem.apply_shift_path_element: out of bound array"
              else
                fromJust $ List.index mvals n
          | Nothing ->
              error "Mem.apply_shift_path_element: symbolic array index"
        end
   | (SPE_array elem_ty ival_, MVpointer _ _) ->
       if ty <> Basic (AilTypes.Integer (AilTypes.Unsigned AilTypes.Ichar)) then
         error ("WIP ==> ty <> not unsigned char, SPE_array, MVpointer ===> ty = " ^ stringFromCtype ty)
       else
         MVinteger (AilTypes.Unsigned AilTypes.Ichar (* TODO: hack, hack *)) (IV Prov_none (IVbyteof ival_ mval))
   
   | (SPE_member tag_sym memb_ident, MVstruct tag_sym_ xs) ->
       if tag_sym <> tag_sym_ then
         error "Mem.apply_shift_path_element, SPE_member vs MVstruct, TODO(msg) the tags didn't match"
       else
         fromJust (List.lookup memb_ident xs)
   
   | (SPE_array _ _, _) ->
       error ("Mem.apply_shift_path_element, SPE_array ==> " ^ stringFromMem_value mval)
   | (SPE_member _ _, _) ->
       error ("Mem.apply_shift_path_element, SPE_member ==> " ^ stringFromMem_value mval)
  end

let apply_shift_path ty sh mval =
  List.foldl (fun acc spe ->
    apply_shift_path_element ty spe acc
  ) mval sh


let load ty (PV _ ptr_val_ sh as ptr_val) : memM mem_value =
  print_debugM 5 ("LOAD [" ^ stringFromCtype ty ^ "]: with pointer value: " ^ stringFromPointer_value ptr_val) >> (* DEBUG *)
  explicitAllocationIdFromPointer_value_aux ptr_val_ >>= function
    | Just alloc_id ->
        get >>= fun mem_st ->
        match Map.lookup alloc_id mem_st.allocations with
          | Just (_, mval) ->
              let mval' = apply_shift_path ty sh mval in
              print_debugM 5 ("==> found value: " ^ stringFromMem_value mval') >> (* DEBUG *)
              return mval'
          | Nothing ->
              fail (MerrUnitialised (stringFromPointer_value ptr_val))
        end
    | Nothing ->
        wip "TODO: load"
  end
  
  

(*
  (* TODO: this just find the latest store done with exactly the same pointer value *)
  fetch_first_write_event (fun (WriteEvent _ ptr_val' _) -> structural_equality_pointer_value ptr_val ptr_val') >>= function
    | Just (WriteEvent _ _ mval) ->
        print_debugM 4 ("Loading [" ^ stringFromCtype ty ^ "]: "^ stringFromMem_value mval ^ " from: " ^ stringFromPointer_value ptr_val) >>
        return mval
    | Nothing ->
        fail (MerrWIP "load failed")
  end
*)








let null_ptrval ty =
  PV Prov_none (PVnull ty) []

let fun_ptrval sym =
  PV Prov_none (PVfunction sym) []


(*
val to_shift_path: tag_definitions -> list (Core_ctype.ctype * integer_value) -> shift_path
let to_shift_path tagDefs xs =
*)


let insert_element_to_path sh spe2 =
  match List.dest_init sh with
    | Just (sh', spe1) ->
        match (spe1, spe2) with
          | (SPE_array ty1 ival1, SPE_array ty2 ival2) ->
              if ty1 = ty2 then
                sh' ++ [SPE_array ty1 (mk_op_ival_ IntAdd ival1 ival2)]
              else
                List.snoc spe2 sh
          | _ ->
              List.snoc spe2 sh
        end
    | Nothing ->
        [spe2]
  end

let internal_shift_ptrval ptr_val spe : pointer_value =
  match ptr_val with
(*
    | PV Prov_none _ ->
        Left (MerrOther "attempted to shift a pointer value with no provenance")
*)
    | PV prov ptr_val_ sh ->
        match get_allocation_id ptr_val_ with
          | Just alloc_id ->
              (* TODO: there should a be check for when we go out of an object *)
              PV prov ptr_val_ (insert_element_to_path sh spe)
          | Nothing ->
              error "TODO internal_shift_ptrval: shift 2"
        end
  end


let array_shift_ptrval ptr_val ty (IV _ ival_) =
  let () = print_debug 5 ("Mem.array_shift_ptrval: " ^ stringFromPointer_value ptr_val) in
  internal_shift_ptrval ptr_val (SPE_array ty ival_)

let member_shift_ptrval ptr_val tag_sym memb_ident =
  internal_shift_ptrval ptr_val (SPE_member tag_sym memb_ident)






let integer_ival n =
  IV Prov_none (IVconcrete n)

let max_ival ity =
  IV Prov_none (IVmax ity)

let min_ival ity =
  IV Prov_none (IVmin ity)





let op_ival iop (IV prov1 ival_1) (IV prov2 ival_2) =
  IV (prov_union prov1 prov2) (mk_op_ival_ iop ival_1 ival_2)


let offsetof_ival tag_sym membr_ident =
  IV Prov_none (IVoffsetof tag_sym membr_ident)


let sizeof_ival ty =
  IV Prov_none (IVsizeof ty)
let alignof_ival ty =
  IV Prov_none (IValignof ty)


let case_integer_value (IV _ ival) fint fother =
  match ival with
    | IVconcrete n ->
        fint n
    | _ ->
        fother ()
  end

let is_concrete_ival ival =
  error "WIP: is_concrete_ival"


(* Memory value constructors *)
let symbolic_mval symb =
  MVsymbolic symb

let unspecified_mval ty =
  MVunspecified ty

let integer_value_mval ity ival =
  MVinteger ity ival

let floating_mval fty str =
  MVfloating fty str

let pointer_mval ref_ty ptr_val =
  MVpointer ref_ty ptr_val

let array_mval = function
  | [] ->
      error "Defacto_memory.array_mval, given an empty list"
  | mvals ->
      MVarray mvals
end

let struct_mval tag_sym xs =
  if List.null xs then
    error "Defacto_memory.struct_mval, given an empty list of member values"
  else
    MVstruct tag_sym xs

let union_mval tag_sym memb_ident mval =
  MVunion tag_sym memb_ident mval


(* Memory value destructor *)
let case_mem_value mval fsymb funspec fival ffval fptrval farr fstruct funion =
  match mval with
    | MVsymbolic symb ->
        fsymb symb
    | MVunspecified ty ->
        funspec ty
    | MVinteger ity ival ->
        fival ity ival
    | MVfloating fty str ->
        ffval fty str
    | MVpointer ref_ty ptr_val ->
        fptrval ref_ty ptr_val
    | MVarray mvals ->
        farr mvals
    | MVstruct tag_sym xs ->
        fstruct tag_sym xs
    | MVunion tag_sym memb_ident mval ->
        funion tag_sym memb_ident mval
  end


val address_of: allocation -> address
let address_of = function
  | Alloc_static _ addr ->
      addr
  | Alloc_dynamic _ addr ->
      addr
end


val isEmptyShift: shift_path -> bool
let isEmptyShift = function
  | [] ->
      true
  | _ ->
      false
end

val     isBeginningShift: shift_path -> memM bool
let rec isBeginningShift sh =
  match sh with
    | [] ->
        return true
    | (SPE_array _ ival_) :: sh' ->
        ifM (MC_eqIV "isBeginningShift" ival_ (IVconcrete 0))
            (isBeginningShift sh')
            (return false)
    | (SPE_member tag_sym memb_ident) :: sh' ->
        match get_membersDefs tag_sym with
          | [] ->
              error "Mem.isBeginningShift, get_membersDefs returning an empty list"
          | (memb_ident', _) :: _ ->
              return (memb_ident = memb_ident')
        end
  end




val is_one_past_pointer: pointer_value -> memM bool
let is_one_past_pointer (PV _ ptr_val_ sh) =
  match ptr_val_ with
    | PVnull _ ->
        return false
    | PVfunction _ ->
        return false
    | _ ->
        explicitAllocationIdFromPointer_value_aux ptr_val_ >>= function
          | Just alloc_id ->
              fst <$> resolve_allocation alloc_id >>= fun alloc ->
                let size_ival_ = match alloc with
                  | Alloc_static ty _ ->
                      IVsizeof ty
                  | Alloc_dynamic ival_ _ ->
                      ival_
                end in
                (* |sh| = sizeof ty *)
                condM (MC_eqIV "is_one_past_pointer"
                  (integer_value_baseFromShift_path sh) size_ival_
                )
          | Nothing ->
              wip "is_one_past_pointer, implicit allocation"
        end
  end

val address_expression_of_pointer: pointer_value -> memM integer_value_base
let address_expression_of_pointer (PV _ ptr_val_ sh) =
  match ptr_val_ with
    | PVnull _ ->
        fail (MerrInternal "called [address_expression_of_pointer] on null pointer")
    | PVfunction _ ->
        fail (MerrInternal "called [address_expression_of_pointer] on function pointer")
    | _ ->
        explicitAllocationIdFromPointer_value_aux ptr_val_ >>= function
          | Just alloc_id ->
              fst <$> resolve_allocation alloc_id >>= function
                | Alloc_static ty addr ->
                  return $ mk_op_ival_ IntAdd (IVaddress addr) (IVsizeof ty)
                | Alloc_dynamic ival_ addr ->
                  return $ mk_op_ival_ IntAdd (IVaddress addr) ival_
              end
          | Nothing ->
              wip "address_expression_of_pointer, implicit allocation"
        end
end

(* WIP *)
let eq_ptrval eqs ptr_val1 ptr_val2 =
  print_debugM 6 ("Mem.eq_ptrval: " ^ stringFromPointer_value ptr_val1 ^ " vs " ^
                  stringFromPointer_value ptr_val2) >>
  match (ptr_val1, ptr_val2) with
    | (PV prov1 ptr_val1_ sh1, PV prov2 ptr_val2_ sh2) ->
        match (ptr_val1_, ptr_val2_) with
          | (PVnull _, PVnull _) ->
              (* STD ยง6.5.9#6 *)
              return true
          | (PVfunction sym1, PVfunction sym2) ->
              return (sym1 = sym2)
          | (PVnull _, _) ->
              return false
          | (_, PVnull _) ->
              return false
          | _ ->
              explicitAllocationIdFromPointer_value_aux ptr_val1_ >>= fun alloc_id1_opt ->
              explicitAllocationIdFromPointer_value_aux ptr_val2_ >>= fun alloc_id2_opt ->
              match (alloc_id1_opt, alloc_id2_opt) with
                | (Just alloc_id1, Just alloc_id2) ->
                    ifFlag Allow_disjoint_alloc_tests
                        (* non-STD flag *)
                        begin
                          address_expression_of_pointer ptr_val1 >>= fun addr_ival_1 ->
                          address_expression_of_pointer ptr_val2 >>= fun addr_ival_2 ->
                          ifM (MC_eqIV "eq_ptrval1" addr_ival_1 addr_ival_2)
                              (* then *)
                              (wip "then")
                              (* else *)
                              (wip "else")
                        end
                        
                        (* STD case *)
                        begin
                          if alloc_id1 = alloc_id2 then
                            (* this tests that at least one pointer is to a base object and the two
                               is to either also to that base object or a beginning subobject *)
                            if      isEmptyShift sh1 then isBeginningShift sh2
                            else if isEmptyShift sh2 then isBeginningShift sh1
                            else
                              (* the pointers are to a same subobject *)
                              return (sh1 = sh2)
                          
                          else
                            is_one_past_pointer ptr_val1 >>= function
                              | true ->
                                  address_expression_of_pointer ptr_val1 >>= fun addr_ival_1 ->
                                  address_expression_of_pointer ptr_val2 >>= fun addr_ival_2 ->
                                  condM (MC_eqIV "eq_ptrval2" addr_ival_1 addr_ival_2)
                              | false ->
                                  is_one_past_pointer ptr_val2 >>= function
                                    | true ->
                                        address_expression_of_pointer ptr_val1 >>= fun addr_ival_1 ->
                                        address_expression_of_pointer ptr_val2 >>= fun addr_ival_2 ->
                                        condM (MC_eqIV "eq_ptrval3" addr_ival_1 addr_ival_2)
                                    | false ->
                                        return false
                                  end
                            end
                        end
                | _ ->
                    error "WIP: Mem.eq_ptrval, not (Just alloc_id1, Just alloc_id2)"
              end





        end
  end





let ne_ptrval eqs ptr_val1 ptr_val2 =
  error "WIP: ne_ptrval"
let lt_ptrval eqs ptr_val1 ptr_val2 =
  error "WIP: lt_ptrval"
let gt_ptrval eqs ptr_val1 ptr_val2 =
  error "WIP: gt_ptrval"
let le_ptrval eqs ptr_val1 ptr_val2 =
  error "WIP: le_ptrval"
let ge_ptrval eqs ptr_val1 ptr_val2 =
  error "WIP: ge_ptrval"



let diff_ptrval (PV prov1 ptr_val_1 sh1) (PV prov2 ptr_val_2 sh2) : integer_value =
  (* TODO: too permissive for now *)
  let prov = match (prov1, prov2) with
    | (Prov_none, Prov_none) ->
        Prov_none
    | (Prov_some _, Prov_none) ->
        prov1
    | (Prov_none, Prov_some _) ->
        prov2
    | (Prov_some ids1, Prov_some ids2) ->
        (* NOTE: note30 only seem to be thinking about the case where both
           pointers have single provenance, so need to see if this
           generalisation is what we want. *)
        Prov_some (Set.difference (ids1 union ids2) (Set.intersection ids1 ids2))
    | _ ->
        error "WIP: diff_ptrval, wildcard/device provenance"
  end in
  IV prov (IVptrdiff ptr_val_1 ptr_val_2)

(*
  match (ptr_val1, ptr_val2) with
    | (PV prov1 ptr_val1_, PV prov2 ptr_val2_) ->
        (* TODO: we probably want to preserve the other kind of provenance
           (other then None) in some cases? *)
        let prov' = match (prov1, prov2) with
          | (Prov_some ids1, Prov_some ids2) ->
              
          end
          if share_common prov1 prov2 then 
          
        else
  end
*)



    
(* TODO: looks too simple to be true *)
let intcast_ptrval ref_ty ity (PV prov ptr_val_ sh) =
  IV Prov_none (
    mk_op_ival_ IntAdd (IVfromptr ref_ty ptr_val_) (integer_value_baseFromShift_path sh)
  )

let validForDeref_ptrval ptr_val =
  true (* error "WIP: validForDeref_ptrval" *)




(* integer types minimal range (STD Annex E #1) *)
val minimal_range: AilTypes.integerType -> bool * integer * integer
let minimal_range = function
 | AilTypes.Char ->
     (* TODO: making an impl-choice here ===> char = signed char *)
     (true, 0-127, 127)
 | AilTypes.Bool ->
     error "WIP: Mem.minimal_range, Bool"
 | AilTypes.Signed AilTypes.Ichar ->
     (true, 0-127, 127)
 | AilTypes.Signed AilTypes.Short ->
     (false, 0-32767, 32767)
 | AilTypes.Signed AilTypes.Int_ ->
     (false, 0-32767, 32767)
 | AilTypes.Signed AilTypes.Long ->
     (false, 0-2147483647, 2147483647)
 | AilTypes.Signed AilTypes.LongLong ->
     (false, 0-(2**63-1), 2**63-1)
 | AilTypes.Signed (AilTypes.IBBuiltin "int8_t")  ->
     (true, 0-127, 127)
 | AilTypes.Signed (AilTypes.IBBuiltin "int16_t")  ->
     (true, 0-32767, 32767)
 | AilTypes.Signed (AilTypes.IBBuiltin "int32_t")  ->
     (true, 0-2147483647, 2147483647)
 | AilTypes.Signed (AilTypes.IBBuiltin "int64_t")  ->
     (true, 0-(2**63-1), 2**63-1)
 | AilTypes.Signed (AilTypes.IBBuiltin str)  ->
     error ("WIP: Mem.minimal_range, Signed IBBuiltin ==> " ^ str)
 | AilTypes.Unsigned AilTypes.Ichar ->
     (true, 0, 255)
 | AilTypes.Unsigned AilTypes.Short ->
     (false, 0, 65535)
 | AilTypes.Unsigned AilTypes.Int_ ->
     (false, 0, 65535)
 | AilTypes.Unsigned AilTypes.Long ->
     (false, 0, 4294967295)
 | AilTypes.Unsigned AilTypes.LongLong ->
     (false, 0, 2**64-1)
 | AilTypes.Unsigned (AilTypes.IBBuiltin "int8_t")  ->
     (true, 0, 255)
 | AilTypes.Unsigned (AilTypes.IBBuiltin "int16_t")  ->
     (true, 0, 65535)
 | AilTypes.Unsigned (AilTypes.IBBuiltin "int32_t")  ->
     (true, 0, 4294967295)
 | AilTypes.Unsigned (AilTypes.IBBuiltin "int64_t")  ->
     (true, 0, 2**64-1)
 | AilTypes.Unsigned (AilTypes.IBBuiltin str)  ->
     error ("WIP: Mem.minimal_range, Unsigned IBBuiltin ==> " ^ str)
 | AilTypes.IBuiltin str ->
     error ("WIP: Mem.minimal_range, IBuiltin ==> " ^ str)
 | AilTypes.Enum sym ->
     error "WIP: Mem.minimal_range, Enum"
end




let rec eq_ival eqs (IV _ ival_1) (IV _ ival_2) =
  match (ival_1, ival_2) with
    | (IVconcrete n1, IVconcrete n2) ->
        Just (n1 = n2)
    | (IVconcrete n, IVoffsetof tag_sym membr_ident) ->
        if n = 0 then
          match get_membersDefs tag_sym with
            | (ident', _)::_ ->
                if membr_ident = ident' then
                  (* TODO: assuming no prefix padding *)
                  Just true
                else
                  Just false
            | _ ->
                error "Mem.eq_ival, get_membersDefs returned an empty list"
          end
        else
          Nothing
    | (IVmin ity, IVconcrete n) ->
        let (is_exact, min, _) = minimal_range ity in
        if is_exact then
          Just (min < n)
        else
          if min < n then
            Just false
          else
            Nothing

(*
    | (IVbyteof ival_1' (MVpointer ref_ty1 ptr_val1), IVbyteof ival_2' (MVpointer ref_ty2 ptr_val2)) ->
        if ref_ty1 <> ref_ty2 then
          Just false
        else match eq_ival tagDefs eqs (IV Prov_none ival_1') (IV Prov_none ival_2') with
          | Just true ->
              eq_ptrval eqs ptr_val1 ptr_val2
          | Just false ->
              Just false
          | Nothing ->
              (* TODO *)
              Nothing
        end
*)

    | _ ->
        (* TODO *)
        Nothing
  end





let lt_ival eqs (IV _ ival_1) (IV _ ival_2) =
  let ival_1' = either (fun z -> IVconcrete z) id (simplify_integer_value_base ival_1) in
  let ival_2' = either (fun z -> IVconcrete z) id (simplify_integer_value_base ival_2) in
  match (ival_1', ival_2') with
    | (IVconcrete n1, IVconcrete n2) ->
        Just (n1 < n2)
    | (IVconcrete n, IVoffsetof tag_sym membr_ident) ->
        if n = 0 then
          match get_membersDefs tag_sym with
            | (ident', _)::_ ->
                if membr_ident = ident' then
                  (* TODO: assuming no prefix padding *)
                  Just false
                else
                  Just true
            | _ ->
                error "Mem.lt_ival, get_membersDefs returned an empty list"
          end
        else
          Nothing
    
    | (IVmin ity, IVconcrete n) ->
        let (is_exact, min, _) = minimal_range ity in
        if is_exact then
          Just (min < n)
        else
          if min < n then
            Just true
          else
            Nothing

    | (IVconcrete n, IVmax ity) ->
        let (is_exact, _, max) = minimal_range ity in
        if is_exact then
          Just (n < max)
        else
          if n < max then
            Just true
          else
            Nothing

    | _ ->
        (* TODO *)
        Nothing
  end

let le_ival eqs (IV _ ival_1 as ival1) (IV _ ival_2 as ival2) =
  let ival_1' = either (fun z -> IVconcrete z) id (simplify_integer_value_base ival_1) in
  let ival_2' = either (fun z -> IVconcrete z) id (simplify_integer_value_base ival_2) in
  match lt_ival eqs ival1 ival2 with
    | Just true ->
        Just true
    | _ ->
        match (ival_1', ival_2') with
          | (IVconcrete n1, IVconcrete n2) ->
              Just (n1 = n2)
          | (IVmin (AilTypes.Signed (AilTypes.IBBuiltin "intptr_t")), IVfromptr _ _) ->
              Just true
          | (IVmin (AilTypes.Unsigned (AilTypes.IBBuiltin "intptr_t")), IVfromptr _ _) ->
              Just true
          | (IVfromptr _ _, IVmax (AilTypes.Signed (AilTypes.IBBuiltin "intptr_t"))) ->
              Just true
          | (IVfromptr _ _, IVmax (AilTypes.Unsigned (AilTypes.IBBuiltin "intptr_t"))) ->
              Just true
          
          | (IVmin ity, IVconcrete n) ->
              let (is_exact, min, _) = minimal_range ity in
              if is_exact then
                Just (min <= n)
              else
                if min <= n then
                  Just true
                else
                  Nothing
          
          | (IVconcrete n, IVmax ity) ->
              let (is_exact, _, max) = minimal_range ity in
              if is_exact then
                Just (n <= max)
              else
                if n <= max then
                  Just true
                else
                  Nothing
          
          (* a byte always range over uchar *)
          | (IVmin (AilTypes.Unsigned AilTypes.Ichar), IVbyteof _ _) ->
              Just true
          | (IVbyteof _ _, IVmax (AilTypes.Unsigned AilTypes.Ichar)) ->
              Just true
          
          | _ ->
              (* TODO *)
              Nothing
        end
  end




let ptrcast_ival int_ty ref_ty ival =
  (* TODO: for integer_value with no provenance, this is define only if the value is within
           the range of "device memory addresses" and the resulting pointer_value has Prov_device *)
  error "WIP: ptrcast_ival"











(* ============================================================================================== *)




(* Decide whether a given pointer value can be use to perform a store *)
val can_store: pointer_value -> memM (maybe allocation_id)
let can_store (PV prov ptr_val_ sh) =
  match ptr_val_ with
    (* null and function pointers obviously can't be used for stores. *)
    | PVnull _     -> return Nothing
    | PVfunction _ -> return Nothing
    
    (* by WF-invariants, we have a pointer to an object *)
    | ptr_val ->
        explicitAllocationIdFromPointer_value_aux ptr_val_ >>= function
          | Just alloc_id ->
              is_dead alloc_id >>= function
                | true ->
                    (* can't store with a pointer to an object whose lifetime ended. *)
                    return Nothing
                | false ->
                    (* add the constraint that the ptr is inside the object *)
                    return (Just alloc_id)
              end
          
          (* we couldn't find an explicit allocation event *)
          | Nothing ->
              error "WIP: can_store ==> don't know how to deal with the absence of explicit allocation id for now."
        end
  end



(*
    | PVbase alloc_id ->
        is_dead alloc_id >>= function
          | true ->
              return Nothing
          | false ->
              return (Just alloc_id)
        end
    | PVshift ptr_val_' sh ->
        explicitAllocationIdFromPointer_value_aux ptr_val_' >>= function
          | Just alloc_id ->
              allocation_is_dead alloc_id >>= function
                | true ->
                    return Nothing
                | false ->
                    resolve_allocation alloc_id >>= function
                      | Alloc_static ty addr_id ->
                          ifM (MC_leIV (integer_value_baseFromShift_path sh) (IVsizeof ty))
                              (* then *)
                              (return (Just alloc_id))
                              (* else *)
                              (return Nothing)
(*
                    wip "WIP: can_store, static" (* ifM (KKKK) *)
*)
                      | Alloc_dynamic ival_ addr_id ->
                          wip "WIP: can_store, dynamic"
                    end
              end
          | Nothing ->
              wip "WIP: can_store, shift 2"
        end
    | _ ->
        wip "WIP: can_store, others"
  end
*)





(* TODO: with temporary simplification *)
val     easy_update_mem_value_aux: bool -> ctype -> shift_path -> mem_value -> mem_value -> mem_value
let rec easy_update_mem_value_aux is_strong write_ty sh write_mval mval =
  let easy_update_mem_value_aux = easy_update_mem_value_aux is_strong in
  match (mval, sh) with
    | (_, []) ->
        (* SIMPLIFICATION: we assume that the footprint of the new value covers all of the old value *)
        write_mval
    | (MVarray mvals, SPE_array elem_ty ival_ :: sh') ->
        match Maybe.map natFromInteger (eval_integer_value_base ival_) with
          | Just n ->
              if n < 0 || 10 > List.length mvals then
                MVarray (List.update mvals n (easy_update_mem_value_aux write_ty sh' write_mval (fromJust $ List.index mvals n)))
              else
                (* TODO: if this can actually happen, then the error needs to be in the monad? *)
                error "easy_update_mem_value_aux ==> concrete SPE_array was out of bound"
          | Nothing ->
              (* TODO: this is going to be complicated, probably require new variants in mem_value *)
              error "WIP: easy_update_mem_value_aux ==> symbolic SPE_array"
        end
    | (MVstruct tag_sym xs, SPE_member tag_sym_ memb_ident :: sh') ->
        if tag_sym <> tag_sym_ then
          error "WIP[easy_update_mem_value_aux]: TODO error message ===> struct value accessed with incompatible SPE"
        else
          MVstruct tag_sym (assoc_adjust (easy_update_mem_value_aux write_ty sh' write_mval) memb_ident xs)
    | _ ->
        if is_strong then
          match sh with
            | SPE_member tag_sym memb_ident :: sh' ->
                MVstruct tag_sym $ List.map (fun (ident, ty) ->
                  (ident, if ident = memb_ident then
                    easy_update_mem_value_aux write_ty sh' write_mval (mkUnspec ty)
                  else
                    mkUnspec ty)
                ) (get_membersDefs tag_sym)
            | _ ->
                error "WIP: easy_update_mem_value_aux, _, is_strong"
          end
        else
          error ("WIP: easy_update_mem_value_aux ===> sh = " ^ stringFromShift_path sh ^ "; mval = " ^ stringFromMem_value mval)
  end


val easy_update_mem_value: bool -> write_event -> mem_value -> mem_value
let easy_update_mem_value is_strong (WriteEvent write_ty (PV prov ptr_val_ sh as ptr_val) write_mval) mval =
  let () = print_debug 2 ("easy_update_mem_value: ptrval=" ^ stringFromPointer_value ptr_val ^ ", mval= " ^ stringFromMem_value mval) in
  easy_update_mem_value_aux is_strong write_ty sh write_mval mval
(*
let easy_update_mem_value tagDefs (WriteEvent ty (PV prov ptr_val_ sh) mval') mval =
  match (mval, sh) with
    | (_, []) ->
    | (MVarray mvals, 
  end
*)
(*
  match (ptr_val_, mval) with
    | (PVbase _, _) ->
        mval'
    | (PVshift _ sh, MVarray mvals) ->
        traverse_with_shift_path tagDefs mval sh mval'
    
    | _ ->
        mval (* TODO *)
  end
*)






(* update the memory state with a write event for a given allocation id *)
val register_write_event: allocation_id -> write_event -> memM unit
let register_write_event alloc_id (WriteEvent _ _ mval as w) =
  get >>= fun st ->
  put <| st with allocations=
    match Map.lookup alloc_id st.allocations with
      | Just (alloc, mval) ->
          let is_strong = match alloc with
            | Alloc_static _ _ ->
                false
            | Alloc_dynamic _ _ ->
                true
          end in
          Map.insert alloc_id (alloc, easy_update_mem_value is_strong w mval) st.allocations
      | Nothing ->
          error "Mem.register_write_event, Nothing"
    end
  |>




(* val store: ctype -> pointer_value -> mem_value -> memM unit *)
let store lvalue_ty ptr_val mval =
  print_debugM 5 ("STORE [" ^ stringFromCtype lvalue_ty ^ "]: with pointer value: " ^ stringFromPointer_value ptr_val ^ " and value: " ^ stringFromMem_value mval) >> (* DEBUG *)
  can_store ptr_val >>= function
    | Just alloc_id ->
        register_write_event alloc_id (WriteEvent lvalue_ty ptr_val mval)
    | Nothing ->
        fail (MerrWIP $ "attempted to store with pointer: " ^ stringFromPointer_value ptr_val)
  end
