(* De-facto C11 memory model *)
open import Pervasives
import Num_extra Set_helpers (* fold *) Map_extra

open import Utils Enum

import Cthread Cabs AilTypes Dlist Loc Float

open import Mem_common Defacto_memory_aux Defacto_memory_types Core_ctype
import Core_ctype_aux

open import {hol} `utilTheory` `tagsTheory`


import State


val stringFromCtype: ctype -> string
declare ocaml target_rep function stringFromCtype = `String_core_ctype.string_of_ctype`

(* TODO: HOL hack *)
declare hol target_rep function stringFromCtype c = ""

(* Semantic switches *)
type mode =
  | Mode_ISO
    (* the bools are: "-no-strict-aliasing", multiple-provenance,
       pointer-lifetime-zap *)
  | Mode_Defacto of bool * bool * bool


(* Basic representation:
     assuming 8-bit bytes and two's complement arithmetic.
 *)



type write_event =
  WriteEvent of Loc.t * ctype * impl_pointer_value * impl_mem_value


type storage =
  | Storage_static of Symbol.prefix * ctype * maybe impl_mem_value
  | Storage_dynamic of Symbol.prefix * integer_value_base * list write_event


type impl_mem_state = <|
  (* this is read-only *)
  flags: list memory_flag;
  
  (* machinery stuff *)
  allocation_id_suppl: UniqueId.supply allocation_id;
  
  (* the semantic stuff starts here *)
(*
  old_allocations:         map allocation_id (allocation * maybe impl_mem_value);
*)
  
  allocations: map allocation_id storage;
  dead_allocations:    set allocation_id;
  
  device_memory: list write_event;
  
  (* For the detection of races, need to be flushed at every sequence point *)
  access_log: list allocation_id;
|>

let impl_initial_mem_state = <|
  flags= [Allow_disjoint_alloc_tests];
  allocation_id_suppl= UniqueId.new_supply;
  
  allocations= Map.empty;
  dead_allocations= Set.empty;
  
  device_memory= [];
  
  access_log= [];
|>


(* BEGIN effect ================================================================================= *)
open import Nondeterminism
type impl_memM 'a =
  ndM 'a mem_error (mem_constraint impl_integer_value) impl_mem_state

let impl_return = return
let inline impl_bind = bind

let inline (>>=)      = impl_bind
let inline (>>) m1 m2 = impl_bind m1 (fun _ -> m2)

let inline (<$>) f m =
  m >>= return -| f


(* TODO: debug *)
val wip: forall 'a. string -> impl_memM 'a (* DEBUG *)
let wip str =
  kill (Other (MerrWIP str))


val defacto_fail: forall 'a. mem_error -> impl_memM 'a
let defacto_fail err =
  match undefinedFromMem_error err with
    | Just ubs ->
        kill (Undef Loc.unknown ubs)
    | Nothing ->
        kill (Other err)
  end
let inline fail = defacto_fail

val print_debugM: nat -> (unit -> string) -> impl_memM unit
let print_debugM n msg =
  return (Debug.print_debug n [Debug.DB_memory] msg)
(* END effect ================================================================================= *)


val fresh_allocation_id: impl_memM allocation_id
let fresh_allocation_id =
  get >>= fun mem_st ->
  let (id, suppl') = UniqueId.fresh_id mem_st.allocation_id_suppl in
  put <| mem_st with allocation_id_suppl= suppl' |> >>
  return id


val register_allocation: allocation_id -> storage -> impl_memM unit
let register_allocation alloc_id stor =
  get >>= fun mem_st ->
  put <| mem_st with allocations=
    Map.insert alloc_id stor mem_st.allocations
  |>

val resolve_allocation: allocation_id -> impl_memM storage
let resolve_allocation alloc_id =
  get >>= fun mem_st ->
  maybe (fail (MerrInternal ("failed to resolve allocation: " ^ show alloc_id))) return
    (Map.lookup alloc_id mem_st.allocations)


val allocation_is_dead: allocation_id -> impl_memM bool
let allocation_is_dead alloc_id =
  get >>= fun mem_st ->
  return (alloc_id IN mem_st.dead_allocations)







(* DEBUG, fixing impl: gcc-5 (Homebrew gcc 5.2.0) 5.2.0 *)
val defacto_integer_range: AilTypes.integerType -> integer * integer
let defacto_integer_range = function
 | AilTypes.Char ->
     (0-128, 127)
 | AilTypes.Bool ->
     error "WIP: Mem.integer_range, Bool"
 | AilTypes.Signed AilTypes.Ichar ->
     (0-128, 127)
 | AilTypes.Signed AilTypes.Short ->
     (0-32768, 32767)
 | AilTypes.Signed AilTypes.Int_ ->
     (0-2147483648, 2147483647)
 | AilTypes.Signed AilTypes.Long ->
     (0-2**63, 2**63-1)
 | AilTypes.Signed AilTypes.LongLong ->
     (0-2**63, 2**63-1)
 | AilTypes.Signed (AilTypes.IntN_t n) ->
     (0-(2**(n-1)), 2**(n-1) - 1)
 | AilTypes.Signed (AilTypes.Int_leastN_t n) ->
     (0-(2**(n-1)), 2**(n-1) - 1)
 | AilTypes.Signed (AilTypes.Int_fastN_t n) ->
     (0-(2**(n-1)), 2**(n-1) - 1)
 | AilTypes.Signed AilTypes.Intmax_t ->
     (0-(2**63), 2**63 - 1)
 | AilTypes.Signed AilTypes.Intptr_t ->
     (0-(2**63), 2**63 - 1)
 | AilTypes.Unsigned AilTypes.Ichar ->
     (0, 255)
 | AilTypes.Unsigned AilTypes.Short ->
     (0, 65535)
 | AilTypes.Unsigned AilTypes.Int_ ->
     (0, 4294967295)
 | AilTypes.Unsigned AilTypes.Long ->
     (0, 2**64-1)
 | AilTypes.Unsigned AilTypes.LongLong ->
     (0, 2**64-1)
 | AilTypes.Unsigned (AilTypes.IntN_t n)  ->
     (0, 2**n - 1)
 | AilTypes.Unsigned (AilTypes.Int_leastN_t n)  ->
     (0, 2**n - 1)
 | AilTypes.Unsigned (AilTypes.Int_fastN_t n)  ->
     (0, 2**n - 1)
 | AilTypes.Unsigned AilTypes.Intmax_t ->
     (0, 2**64 - 1)
 | AilTypes.Unsigned AilTypes.Intptr_t ->
     (0, 2**64 - 1)
 | AilTypes.IBuiltin str ->
     error ("WIP: Mem.integer_range, IBuiltin ==> " ^ str)
 | AilTypes.Enum sym ->
     error "WIP: Mem.integer_range, Enum"
 | AilTypes.Size_t ->
     (0, 2**64-1)
 | AilTypes.Ptrdiff_t ->
     (0-2**63, 2**63-1)
end
let inline integer_range = defacto_integer_range


(* ============================================================================================== *)
val ifFlag: forall 'a. memory_flag -> impl_memM 'a -> impl_memM 'a -> impl_memM 'a
let ifFlag flag mThen mElse =
  get >>= fun st ->
  if List.elem flag st.flags then
    mThen
  else
    mElse


val condM: string -> mem_constraint impl_integer_value -> impl_memM bool
let condM debug_str cs =
  ifM debug_str cs (return true) (return false)


(* ============================================================================================== *)
(*         |  empty    ID       ID'      wildcard
  ---------+-------------------------------------
  empty    |  empty    ID       ID'      wildcard
  ID       |  ID       ID       empty    wildcard
  ID'      |  ID'      empty    ID'      wildcard
  wildcard |  wildcard wildcard wildcard wildcard *)
val combine_prov: provenance -> provenance -> provenance
let combine_prov prov1 prov2 =
  match (prov1, prov2) with
    | (Prov_none, Prov_none) ->
        Prov_none
    | (Prov_none, Prov_some id) ->
        Prov_some id
    | (Prov_none, Prov_wildcard) ->
        Prov_wildcard
    | (Prov_none, Prov_device) ->
        Prov_device
    
    | (Prov_some id, Prov_none) ->
        Prov_some id
    | (Prov_some id1, Prov_some id2) ->
        if id1 = id2 then
          Prov_some id1
        else
          Prov_none
    | (Prov_some _, Prov_wildcard) ->
        Prov_wildcard
    | (Prov_some _, Prov_device) ->
        Prov_device
    
    | (Prov_device, Prov_none) ->
        Prov_device
    | (Prov_device, Prov_some _) ->
        Prov_device
    | (Prov_device, Prov_device) ->
        Prov_device
    | (Prov_device, Prov_wildcard) ->
        Prov_wildcard
    
    | (Prov_wildcard, _) ->
        Prov_wildcard
  end


(* Wellformedness predicates (following the comments in the definitions of the related types). *)
val wf_pointer_value: impl_pointer_value -> bool
let wf_pointer_value = function
  | PV Prov_none (PVnull _) _ ->
      true
  | PV _ (PVnull _) _ ->
      false
  | _ ->
      true (* TODO !!!! error "WIP: wf_pointer_value" *)
end


(* Returns whether a given allocation has reached the end of its lifetime *)
val is_dead: allocation_id -> impl_memM bool
let is_dead alloc_id =
  get >>= fun mem_st ->
  return (Set.member alloc_id mem_st.dead_allocations)


(* TODO: why is that effectfull? *)
val     explicitAllocationIdFromPointer_value_aux: pointer_value_base -> impl_memM (maybe (allocation_id * Symbol.prefix))
let rec explicitAllocationIdFromPointer_value_aux ptr_val_ =
  match ptr_val_ with
    | PVunspecified _ ->
        return Nothing
    | PVnull _ ->
        return Nothing
    | PVfunction _ ->
        return Nothing
    | PVbase alloc_id pref ->
        return (Just (alloc_id, pref))
    | PVfromint ival_ ->
        explicitAllocationIdFromInteger_value_aux ival_
  end

and explicitAllocationIdFromInteger_value_aux ival_ =
  match ival_ with
    | IVunspecified ->
        return Nothing
    | IVconcurRead _ _ ->
        return Nothing
    | IVconcrete _ ->
        return Nothing
    | IVaddress _ _ ->
        return Nothing
    | IVfromptr _ ity ptr_val_ _ ->
        explicitAllocationIdFromPointer_value_aux ptr_val_
    | IVop _ _ ->
        return Nothing
    | IVmin _ ->
        return Nothing
    | IVmax _->
        return Nothing
    | IVsizeof _->
        return Nothing
    | IValignof _->
        return Nothing
    | IVoffsetof _ _ ->
        return Nothing
    | IVpadding _ _->
        return Nothing
    | IVptrdiff _ _ _->
        return Nothing
    | IVbyteof _ _->
        return Nothing
    | IVcomposite _ ->
        return Nothing
    | IVbitwise _ _ ->
        return Nothing
  end


(* Making an indirection here, so that future crazy optimisations won't be duplicated all over. *)
let mk_op_ival_ iop ival_1 ival_2 =
  lifted_simplify_integer_value_base (IVop iop [ival_1; ival_2])


let mk_offsetof_ival_ acc tag_sym memb_ident =
  match Core_ctype_aux.get_membersDefs tag_sym with
    | Core_ctype.StructDef xs ->
        (* we take the prefix the members before the one we want to offset to *)
        let prefix_xs =
          List.takeWhile (fun (ident, _) -> memb_ident <> ident) xs in
        (* then we sum their sizeof and trailing paddings *)
        List.foldl (fun acc' (ident, ty) ->
          if ident = memb_ident then
            (* TODO: this should be dead code since we fold on the prefix *)
            acc'
          else
            mk_op_ival_ IntAdd (IVsizeof ty)
              (mk_op_ival_ IntAdd (IVpadding tag_sym ident) acc')
        ) acc (List.reverse prefix_xs)
    | Core_ctype.UnionDef _ ->
        (* TODO: check, but if we have a struct this should be no offset to do *)
        acc
  end




val get_allocation_id: pointer_value_base -> maybe allocation_id
let rec get_allocation_id ptr_val_ =
  match ptr_val_ with
    | PVnull ty ->
        Nothing
    | PVbase alloc_id _ ->
        Just alloc_id
    | PVfromint (IVfromptr _ _ ptr_val_' _) ->
        get_allocation_id ptr_val_'
    | _ ->
        error "TODO: get_allocation_id, wildcard"
  end




val integer_value_baseFromShift_path: shift_path -> integer_value_base
let integer_value_baseFromShift_path sh =
  List.foldl (fun acc spe ->
    let spe_ival_ = match spe with
      | SPE_array ty ival_ ->
          mk_op_ival_ IntMul (IVsizeof ty) ival_
      | SPE_member tag_sym memb_ident ->
          mk_offsetof_ival_ acc tag_sym memb_ident
    end in
    mk_op_ival_ IntAdd spe_ival_ acc
  ) (IVconcrete 0) sh




val     mkUnspec: ctype -> impl_mem_value
let rec mkUnspec ty =
  match ty with
    | Void ->
        error "Defacto_memory.mkUnspec: called on Void"
    | Basic (AilTypes.Integer ity) ->
        MVinteger ity (IV Prov_none IVunspecified) 
    | Basic (AilTypes.Floating fty) ->
        MVfloating fty FVunspecified
    | Array _ Nothing ->
        error "Defacto_memory.mkUnspec: called on Array _ Nothing"
    | Array ty (Just n) ->
        MVarray $ replicate (natFromInteger n) (mkUnspec ty)
    | Function _ _ _ ->
        error "Defacto_memory.mkUnspec: called on Function _ _ _"
    | (Pointer _ ty') ->
        MVpointer ty' (PV Prov_none (PVunspecified ty') [])
    | Atomic _ ->
        error ("TODO: Defacto_memory.mkUnspec ==> " ^ stringFromCtype ty)
    | Struct tag_sym ->
        let xs = Core_ctype_aux.get_structDef tag_sym in
        MVstruct tag_sym (
          List.map (fun (ident, ty) -> (ident, mkUnspec ty)) xs
        )
    | (Union tag_sym) ->
        let ((memb_ident, ty), _) = Core_ctype_aux.get_unionDef tag_sym in
        MVunion tag_sym memb_ident (mkUnspec ty)
    | Builtin _ ->
        error ("TODO: Defacto_memory.mkUnspec ==> " ^ stringFromCtype ty)
  end















(* BEGIN API IMPLEMENTATION ===================================================================== *)
val impl_eval_integer_value: impl_integer_value -> maybe integer
let impl_eval_integer_value (IV _ ival_) =
  eval_integer_value_base ival_


let impl_offsetof_ival tag_sym memb_ident =
(*  IV Prov_none (lifted_simplify_integer_value_base (IVoffsetof tag_sym membr_ident)) *)
  IV Prov_none (mk_offsetof_ival_ (IVconcrete 0) tag_sym memb_ident)


val addToLog: allocation_id -> impl_memM unit
let addToLog alloc_id =
  print_debugM 1 (fun () -> "addToLog: " ^ show alloc_id) >>
  get >>= fun mem_st ->
  if List.elem alloc_id mem_st.access_log then
    fail (MerrOther ("unsequenced race: " ^ show alloc_id))
  else
    put <| mem_st with access_log= alloc_id :: mem_st.access_log |>


val impl_sequencePoint: impl_memM unit
let impl_sequencePoint =
  get >>= fun mem_st ->
  put <| mem_st with access_log= [] |>







val register_address_constraints: Symbol.prefix -> allocation_id -> integer_value_base -> integer_value_base -> impl_memM unit
let register_address_constraints pref alloc_id size_ival_ align_ival_ =
  get >>= fun st ->
  (* list of previous allocations that must not clash with
     the new allocations *)
  let allocs =
    List.filter (fun (z, _) ->
      not (Set.member z st.dead_allocations)
    ) (Map_extra.toList st.allocations) in
  let distinctness_constrs =
    (* forall z_id: allocations, *)
    List.map (fun (z_id, z_stor) ->
      let (z_pref, z_size_ival_) = match z_stor with
        | Storage_static pref ty _ ->
            (pref, IVsizeof ty)
        | Storage_dynamic pref ival_ _ ->
            (pref, ival_)
      end in
      (* @z_id + sizeof(int) <= @alloc_id \/ @alloc_id + sizeof(int) <= @z_id *)
      MC_or (mk_iv_constr MC_le (IVop IntAdd [IVaddress z_id z_pref;   z_size_ival_]) (IVaddress alloc_id pref))
            (mk_iv_constr MC_le (IVop IntAdd [IVaddress alloc_id pref; size_ival_  ]) (IVaddress z_id z_pref))
    ) allocs in
  (* @alloc_id mod align_ival = 0 *)
  let align_constr =
    mk_iv_constr MC_eq (IVop IntRem_f [IVaddress alloc_id pref; align_ival_]) (IVconcrete 0) in
  addConstraints "address constraint"
    ((*simplify_constraint $ *) MC_conj (align_constr :: distinctness_constrs)) >>
  
  (* TODO: hack simplifying intptr_t/uintptr_t (cast to uintptr_t is the identity for Z3) *)
  addConstraints "address constraint hack"
    (MC_conj [ mk_iv_constr MC_le (IVmin (AilTypes.Unsigned AilTypes.Intptr_t)) (IVaddress alloc_id pref)
             ; mk_iv_constr MC_le (IVaddress alloc_id pref) (IVmax (AilTypes.Unsigned AilTypes.Intptr_t)) ])





(* TODO: readonly case *)
let impl_allocate_static tid pref (IV _ align_ival_) ty init_opt =
  fresh_allocation_id >>= fun alloc_id ->
  register_address_constraints pref alloc_id (IVsizeof ty) (align_ival_) >>
  register_allocation alloc_id (Storage_static pref ty Nothing) >>
  let ptr_val = PV (Prov_some (alloc_id, pref)) (PVbase alloc_id pref) [] in
  print_debugM 1 (fun () ->
    "Allocating (static) with type [" ^ stringFromCtype ty ^ "] alloc_id= " ^
    show alloc_id ^ ": " ^ stringFromPointer_value ptr_val
  ) >> (* DEBUG *)
  return ptr_val

(*
  (* the allocated object is given a new address (distinct from all other
     existing addresses) *)
  fresh_address pref >>= fun addr ->
  register_distinctness_constraints addr (IVsizeof ty) >>
  
  fresh_allocation_id >>= fun alloc_id ->
  register_allocation alloc_id (Alloc_static ty addr, Nothing (* mkUnspec ty *)) >>
  
  let ptr_val = PV (Prov_some alloc_id) (PVbase alloc_id pref) [] in
  print_debugM 4 (fun () -> "Allocating (static) with type [" ^ stringFromCtype ty ^ "]: " ^ stringFromPointer_value ptr_val) >> (* DEBUG *)
  
  return ptr_val
*)


let impl_allocate_dynamic tid pref (IV _ align_ival_) ((IV _ size_ival_) as size_ival) =
  fresh_allocation_id >>= fun alloc_id ->
  register_address_constraints pref alloc_id size_ival_ (align_ival_) >>
  register_allocation alloc_id (Storage_dynamic pref size_ival_ []) >>
  let ptr_val = PV (Prov_some (alloc_id, pref)) (PVbase alloc_id pref) [] in
  print_debugM 1 (fun () ->
    "Allocating (dynamic) with size [" ^ stringFromInteger_value size_ival ^ "] alloc_id= " ^
    show alloc_id ^ ": " ^ stringFromPointer_value ptr_val
  ) >> (* DEBUG *)
  return ptr_val

(*
  (* TODO *)
  fresh_address pref >>= fun addr ->
  register_distinctness_constraints addr size_ival_ >>
  
  fresh_allocation_id >>= fun alloc_id ->
  let unsigned_char = Basic (AilTypes.Integer (AilTypes.Signed AilTypes.Ichar)) in
  register_allocation alloc_id (Alloc_dynamic size_ival_, Nothing (* mkUnspec (Array unsigned_char (Just 42 (* TODO !!! *))) *)) >>
  
  return (
    PV (Prov_some alloc_id) (PVbase alloc_id pref) []
  )
*)


(* TODO: wip *)
let real_address_expression_of_pointer (PV _ ptrval sh) =
  let ival_ = match ptrval with
    | PVunspecified ty ->
        error "real_address_expression_of_pointer, PVunspecified"
    | PVnull ty ->
        error "real_address_expression_of_pointer, PVnull"
    | PVfunction sym ->
        error "real_address_expression_of_pointer, PVfunction"
    | PVbase alloc_id pref ->
        IVaddress alloc_id pref
    | PVfromint ival_ ->
        ival_
  end in
  IVop IntAdd [ival_; integer_value_baseFromShift_path sh]


(* TODO: (for statics) this is not doing the right thing *)
(* TODO: by calling real_address_expression_of_pointer, this is now correct *)
val address_expression_of_pointer: impl_pointer_value -> impl_memM integer_value_base
let address_expression_of_pointer ptr_val =
  return (real_address_expression_of_pointer ptr_val)


let impl_kill (PV _ ptr_val_ sh as ptr_val) =
  print_debugM 5 (fun () -> "KILL with pointer value: " ^ stringFromPointer_value ptr_val) >> (* DEBUG *)
  explicitAllocationIdFromPointer_value_aux ptr_val_ >>= function
    | Just (alloc_id, pref) ->
        address_expression_of_pointer ptr_val >>= fun ptr_ival ->
        ifM "kill"
            (mk_iv_constr MC_eq ptr_ival (IVaddress alloc_id pref))
            begin
              (* TODO: turn the live pointers to this alloc_id into unspec values *)
              get >>= fun mem_st ->
              put <| mem_st with dead_allocations= Set.insert alloc_id mem_st.dead_allocations |>
            end
            (fail (MerrOther "trying to kill with an non-initial pointer"))
    | Nothing ->
        fail (MerrOther "trying to kill with an invalid pointer")
  end


(*
(* TODO: temporary *)
let structural_equality_provenance prov1 prov2 =
  match (prov1, prov2) with
    | (Prov_wildcard, Prov_wildcard) ->
        true
    | (Prov_none, Prov_none) ->
        true
    | (Prov_device, Prov_device) ->
        true
    | (Prov_some id1, Prov_some id2) ->
        id1 = id2
    | _ ->
        false
  end

let rec structural_equality_pointer_value (PV prov1 ptr_val_1 sh1) (PV prov2 ptr_val_2 sh2) =
     structural_equality_provenance prov1 prov2
  && structural_equality_pointer_value_base ptr_val_1 ptr_val_2
  && listEqualBy structural_equality_shift_path_element sh1 sh2

and structural_equality_pointer_value_base ptr_val_1 ptr_val_2 =
  match (ptr_val_1, ptr_val_2) with
    | (PVnull ty1, PVnull ty2) ->
        ty1 = ty2
    | (PVfunction sym1, PVfunction sym2) ->
        sym1 = sym2
    | (PVbase alloc_id1 _, PVbase alloc_id2 _) ->
        alloc_id1 = alloc_id2
    | (PVfromint ival_1, PVfromint ival_2) ->
        structural_equality_integer_value_base ival_1 ival_2
    | _ ->
        false
  end

and structural_equality_shift_path_element spe1 spe2 =
  match (spe1, spe2) with
    | (SPE_array ty1 ival_1, SPE_array ty2 ival_2) ->
        ty1 = ty2 && structural_equality_integer_value_base ival_1 ival_2
    | (SPE_member tag_sym1 memb_ident1, SPE_member tag_sym2 memb_ident2) ->
        tag_sym1 = tag_sym2 && memb_ident1 = memb_ident2
    | _ ->
        false
 end
 
and structural_equality_shift_path sh1 sh2 =
  List.all (uncurry structural_equality_shift_path_element) (zip sh1 sh2)

and structural_equality_integer_value_base _ _ =
  error "structural_equality_integer_value_base"
*)



val is_affecting: write_event -> ctype -> impl_pointer_value -> impl_memM bool
let is_affection (WriteEvent loc w_ty w_ptr_val mval) r_ty r_ptr_val =
(*
  get_allocation_id r_ptr_val >>= fun r_alloc_id_opt ->
  get_allocation_id w_ptr_val >>= fun w_alloc_id_opt ->
  match (r_alloc_id_opt, w_alloc_id_opt) with
    | (Just r_alloc_id, Just w_alloc_id) ->
        if r_alloc_id = w_alloc_id then
          condM (MC_conj (MC_le_ival_ (offset_ival_ w_ptr_val) (offset_ival_ r_ptr_val))
                         (MC_le_ival_ () ())
        else
          wip "is_affecting 1"
        condM (offset_ival 
  end
*)
  error "is_affecting"

























val     fetch_first_write_event: (write_event -> bool) -> impl_memM (maybe write_event)
let rec fetch_first_write_event_aux pred = function
  | [] ->
      Nothing
  | x :: xs ->
      if pred x then Just x else fetch_first_write_event_aux pred xs
end
let fetch_first_write_event pred =
  wip "fetch_frist_write_event"
(*
  get >>= fun st ->
  return (fetch_first_write_event_aux pred st.writes)
*)






val apply_shift_path_element: ctype -> shift_path_element -> impl_mem_value -> impl_memM impl_mem_value
let apply_shift_path_element lvalue_ty spe mval =
(* TODO: use lvalue_ty *)
  match (spe, mval) with
    | (SPE_array elem_ty ival_, MVarray mvals) ->
        match eval_integer_value_base ival_ with
          | Just n ->
              let n = natFromInteger n in
              if n < 0 || List.length mvals <= n then
                error "Mem.apply_shift_path_element: out of bound array"
              else
                return (fromJust "Defacto_memory.apply_shift_path_element, SPE_array vs MVarray" $ List.index mvals n)
          | Nothing ->
              error ("Mem.apply_shift_path_element: symbolic array index ==> " ^
                     stringFromInteger_value (IV Prov_none ival_))
        end
   | (SPE_array elem_ty ival_, MVpointer _ _) ->
(*
       if lvalue_ty <> Basic (AilTypes.Integer (AilTypes.Unsigned AilTypes.Ichar)) then
         error ("WIP ==> result_ty <> not unsigned char, SPE_array, MVpointer ===> result_ty = " ^ stringFromCtype result_ty)
       else
*)
       match lvalue_ty with
         | Basic (AilTypes.Integer lvalue_ity) ->
             return (MVinteger lvalue_ity (IV Prov_none (IVbyteof (mk_op_ival_ IntMul ival_ (IVsizeof elem_ty)) mval)))
         | _ ->
             error ("WIP ==> lvalue_ty <> not an integer value, SPE_array, MVpointer ===> lvalue_ty = " ^ stringFromCtype lvalue_ty)
       end
   
   | (SPE_member tag_sym memb_ident, MVstruct tag_sym_ xs) ->
       if tag_sym <> tag_sym_ then
         fail (MerrOther ("tried to read member of type '" ^
               stringFromCore_ctype (Core_ctype.Struct tag_sym) ^
               "', but a value of type '" ^
               stringFromCore_ctype (Core_ctype.Struct tag_sym_) ^
               "' was found."))
       else
         return (fromJust "Defacto_memory.apply_shift_path_element, SPE_member vs MVstruct" (List.lookup memb_ident xs))
   
   | (SPE_member tag_sym memb_ident, MVunion tag_sym_ memb_ident_ mval') ->
       if tag_sym <> tag_sym_ then
         fail (MerrOther ("tried to read member of type '" ^
               stringFromCore_ctype (Core_ctype.Union tag_sym) ^
               "', but a value of type '" ^
               stringFromCore_ctype (Core_ctype.Union tag_sym_) ^
               "' was found."))
       else
(*
         let Core_ctype.UnionDef xs = Core_ctype_aux.get_membersDefs tag_sym in
*)
         if memb_ident = memb_ident_ then
           return mval'
         else
           error "TODO: union punning"
   
   | (SPE_array elem_ty ival_1, MVinteger ity ival_2) ->
       error ("lvalue_ty: " ^ stringFromCtype lvalue_ty ^
              ", spe: " ^ stringFromShift_path [spe] ^
              ", ity: " ^ stringFromCtype (Basic (AilTypes.Integer ity)))
   
   | (SPE_array elem_ty offset_ival_, MVdelayed xs under_mval) ->
       match xs with
         | [(sh, new_mval)] ->
             ifM "apply_shift_path_element"
               (mk_iv_constr MC_eq (integer_value_baseFromShift_path [SPE_array elem_ty offset_ival_])
                                   (integer_value_baseFromShift_path sh))
               (return new_mval)
               
               (* TODO: hack *)
               (wip ("Mem.apply_shift_path_element, todo MVdelayed ==> didn't match ==> sh: " ^
                     stringFromShift_path [spe] ^ " -- mval: "^ stringFromMem_value mval))
               (* (return (MVinteger (AilTypes.Unsigned AilTypes.Ichar) (IV Prov_none (IVconcrete 142)))) *)
         | _ ->
             error "Mem.apply_shift_path_element, HELLO KKK"
       end
       

   | (SPE_array _ _, _) ->
       error ("Mem.apply_shift_path_element, SPE_array ==> mval: " ^
              stringFromMem_value mval ^ ", lvalue_ty: " ^ stringFromCtype lvalue_ty)
   | (SPE_member _ _, _) ->
       error ("Mem.apply_shift_path_element, SPE_member ==> " ^ stringFromMem_value mval)
  end


(*
let mk_byteof ival_ = function
  | MVinteger _ (IV _ IVunspecified) ->
      IV 
  | MVfloating of AilTypes.floatingType * impl_floating_value
  | MVpointer of ctype * impl_pointer_value (* the first parameter is the referenced type of the pointer value *)
  | MVarray of list impl_mem_value (* INVARIANT: all of the same mem_value constructor and type *)
  | MVstruct of Symbol.sym (*struct/union tag*) * list (Cabs.cabs_identifier (*member*) * impl_mem_value)
  | MVunion of Symbol.sym (*struct/union tag*) * Cabs.cabs_identifier (*member*) * impl_mem_value
  
  | MVdelayed of list (shift_path * impl_mem_value) * impl_mem_value
end
*)

let project_to_lvalue_type lvalue_ty mval =
  match (lvalue_ty, mval) with
    | (Basic (AilTypes.Integer (AilTypes.Unsigned AilTypes.Ichar)), MVinteger (AilTypes.Unsigned AilTypes.Ichar) _) ->
         return mval
    
    | (Basic (AilTypes.Integer ((AilTypes.Unsigned AilTypes.Ichar) as uchar_ity)), _) ->
        let mval_prov = match mval with
          | MVinteger _ (IV prov _) ->
              prov
          | MVpointer _ (PV prov _ _) ->
              prov
          | _ ->
              Prov_none
        end in
        return (MVinteger uchar_ity (IV mval_prov (IVbyteof (IVconcrete 0) mval)))
    
    | (Basic (AilTypes.Integer lvalue_ity), MVinteger mval_ity ival) ->
        if lvalue_ity = mval_ity then
          return mval
        
        (* TODO: check that we really allow arbitrary bytes accesses like this *)
        else match Implementation_.sizeof_ity lvalue_ity with
          | Nothing ->
              error "WIP: project_to_lvalue_type"
          | Just size ->
              let ival_' = IVcomposite (
                List.map (fun i ->
                  IVbyteof (IVconcrete (integerFromNat i)) mval
                ) (enumFromTo 0 (size-1))
              ) in
              return (MVinteger lvalue_ity (IV Prov_none(*TODO*) ival_'))
        end
    
    | (Basic (AilTypes.Floating lvalue_fty), MVfloating mval_fty fval) ->
        error "WIP: project_to_lvalue_type floating"
    
    | (Pointer _ lvalue_ref_ty, MVpointer mval_ref_ty (PV prov _ _)) ->
        if lvalue_ref_ty = mval_ref_ty then
          return mval
        else
          error "project_to_lvalue_type: Pointer vs MVpointer, with different referenced types"

    | (_, MVarray mvals) ->
        (* TODO: I guess that's not allowed *)
        error "WIP: project_to_lvalue_type MVarray"
        
    | (Struct lvalue_tag_sym, MVstruct mval_tag_sym _) ->
        if lvalue_tag_sym = mval_tag_sym then
          return mval
        else
          error "project_to_lvalue_type: Struct vs MVstruct with non-equal tags"
        
    | (Union lvalue_tag_sym, MVunion mval_tag_sym memb_ident _) ->
        if lvalue_tag_sym = mval_tag_sym then
          return mval
        else
          error "project_to_lvalue_type: Union vs MVunion with non-equal tags"
    
    | (_, MVunion mval_tag memb_ident memb_mval) ->
        (* TODO: this implementing that casting a pointer to a union, to
           a pointer to one of it's member *)
          let (x, xs) = Core_ctype_aux.get_unionDef mval_tag in
          match List.lookup memb_ident (x::xs) with
            | Nothing ->
                error "project_to_lvalue_type, MVunion was ill-typed (wrong member_ident)"
            | Just memb_ty ->
                if lvalue_ty = memb_ty then
                  return memb_mval
                else
                  error "TODO: project_to_lvalue_type, union punning"
          end

    | _ ->
        (* TODO *)
        (* return mval *)
        let () = Debug.print_debug 1 [] (fun () ->
          "lvalue_ty  ===> " ^ stringFromCore_ctype lvalue_ty ^ 
          "\nmval ===> " ^ stringFromMem_value mval
        ) in
        error "TODO: project_to_lvalue_type"
  end


let apply_shift_path lvalue_ty sh mval =
  match sh with
    | [] ->
        let () = Debug.print_debug 1 [] (fun () ->
          "Mem.apply_shift_path, sh == []  ===> " ^
          stringFromMem_value mval
        ) in
        project_to_lvalue_type lvalue_ty mval
    | _ ->
      foldlM (fun acc spe ->
        apply_shift_path_element lvalue_ty spe acc
      ) mval sh (* >>=
        project_to_lvalue_type lvalue *)
  end




















let impl_null_ptrval ty =
  PV Prov_none (PVnull ty) []

let impl_fun_ptrval sym =
  PV Prov_none (PVfunction sym) []


(*
val to_shift_path: tag_definitions -> list (Core_ctype.ctype * integer_value) -> shift_path
let to_shift_path tagDefs xs =
*)


let insert_element_to_path sh spe2 =
  match List.dest_init sh with
    | Just (sh', spe1) ->
        match (spe1, spe2) with
          | (SPE_array ty1 ival1, SPE_array ty2 ival2) ->
              if ty1 = ty2 then
                sh' ++ [SPE_array ty1 (mk_op_ival_ IntAdd ival1 ival2)]
              else
                List.snoc spe2 sh
          | _ ->
              List.snoc spe2 sh
        end
    | Nothing ->
        [spe2]
  end

let internal_shift_ptrval ptr_val spe : impl_pointer_value =
  match ptr_val with
(*
    | PV Prov_none _ ->
        Left (MerrOther "attempted to shift a pointer value with no provenance")
*)
    | PV prov ptr_val_ sh ->
        match get_allocation_id ptr_val_ with
          | Just alloc_id ->
              (* TODO: there should a be check for when we go out of an object *)
              PV prov ptr_val_ (insert_element_to_path sh spe)
          | Nothing ->
              (* TODO: here we are probably shifting a NULL pointer, so in ISO this is "unclear" *)
              (* TODO: add a warning or error in ISO mode *)
              PV prov ptr_val_ (insert_element_to_path sh spe)
(*
              error ("TODO internal_shift_ptrval: shift 2 ==>" ^
                     stringFromPointer_value ptr_val)
*)
        end
  end


let impl_array_shift_ptrval ptr_val ty (IV _ ival_) =
  let () = Debug.print_debug 5 [Debug.DB_memory] (fun () -> "Mem.array_shift_ptrval: " ^ stringFromPointer_value ptr_val) in
  internal_shift_ptrval ptr_val (SPE_array ty ival_)

let impl_member_shift_ptrval ptr_val tag_sym memb_ident =
  internal_shift_ptrval ptr_val (SPE_member tag_sym memb_ident)





let impl_concurRead_ival ity sym =
  IV Prov_none (IVconcurRead ity sym)

let impl_integer_ival n =
  IV Prov_none (IVconcrete n)

let impl_max_ival ity =
  IV Prov_none ((*lifted_simplify_integer_value_base*) (IVmax ity))

let impl_min_ival ity =
  IV Prov_none ((*lifted_simplify_integer_value_base*) (IVmin ity))





let impl_op_ival iop (IV prov1 ival_1) (IV prov2 ival_2) =
  IV (combine_prov prov1 prov2) (mk_op_ival_ iop ival_1 ival_2)

let rec impl_sizeof_ival_aux ty =
  match ty with
    | Core_ctype.Void ->
        error "Mem.impl_sizeof_ival_aux, Void"
    | Core_ctype.Basic (AilTypes.Integer ity) ->
        match Implementation_.sizeof_ity ity with
          | Just n ->
              IVconcrete (integerFromNat n)
          | Nothing ->
              IVsizeof ty
        end
    | Core_ctype.Basic (AilTypes.Floating fty) ->
        match Implementation_.sizeof_fty fty with
          | Just n ->
              IVconcrete (integerFromNat n)
          | Nothing ->
              IVsizeof ty
        end
    | Core_ctype.Array _ Nothing ->
        error "Mem.impl_sizeof_ival_aux, Array Nothing"
    | Core_ctype.Array elem_ty (Just n) ->
        IVop IntMul [impl_sizeof_ival_aux elem_ty; IVconcrete n]
    | Core_ctype.Function _ _ _ ->
        error "Mem.impl_sizeof_ival_aux, Function"
    | Core_ctype.Pointer _ _ ->
        IVconcrete 8 (* TODO *)
    | Core_ctype.Atomic atom_ty ->
        impl_sizeof_ival_aux atom_ty
    | Struct tag_sym ->
        (* TODO: move the code from mem_simplify *)
        IVsizeof (Struct tag_sym)
    | Union tag_sym ->
        (* TODO: move the code from mem_simplify *)
        IVsizeof (Union tag_sym)
    | Builtin str ->
        error "TODO: Defacto_memory.impl_sizeof_ival, Builtin"
end



let impl_sizeof_ival ty =
  IV Prov_none (impl_sizeof_ival_aux ty)

let impl_alignof_ival ty =
  IV Prov_none (IValignof ty)


let impl_bitwise_complement_ival ity (IV prov ival_) =
  IV prov (IVbitwise ity (BW_complement ival_))

let impl_bitwise_and_ival ity (IV prov1 ival_1) (IV prov2 ival_2) =
  IV (combine_prov prov1 prov2) (IVbitwise ity (BW_AND ival_1 ival_2))

let impl_bitwise_or_ival ity (IV prov1 ival_1) (IV prov2 ival_2) =
  IV (combine_prov prov1 prov2) (IVbitwise ity (BW_OR ival_1 ival_2))

let impl_bitwise_xor_ival ity (IV prov1 ival_1) (IV prov2 ival_2) =
  IV (combine_prov prov1 prov2) (IVbitwise ity (BW_XOR ival_1 ival_2))



let impl_op_fval fop fval1 fval2 =
  match (fval1, fval2) with
    | (FVunspecified, _) ->
        FVunspecified
    | (_, FVunspecified) ->
        FVunspecified
    | (FVconcrete fval1, FVconcrete fval2) ->
        match fop with
          | FloatAdd -> FVconcrete (fval1 + fval2)
          | FloatSub -> FVconcrete (fval1 - fval2)
          | FloatMul -> FVconcrete (fval1 * fval2)
          | FloatDiv -> FVconcrete (fval1 / fval2)
        end
  end

let impl_eq_fval fval1 fval2 =
  match (fval1, fval2) with
    | (FVconcrete fval1, FVconcrete fval2) ->
        (fval1 = fval2)
    | _ ->
        error "TODO: Defacto_memory.impl_eq_fval, unspecified"
  end

let impl_lt_fval fval1 fval2 =
  match (fval1, fval2) with
    | (FVconcrete fval1, FVconcrete fval2) ->
        (fval1 < fval2)
    | _ ->
        error "TODO: Defacto_memory.impl_lt_fval, unspecified"
  end

let impl_le_fval fval1 fval2 =
  match (fval1, fval2) with
    | (FVconcrete fval1, FVconcrete fval2) ->
        (fval1 <= fval2)
    | _ ->
        error "TODO: Defacto_memory.impl_lt_fval, unspecified"
  end

let impl_fvfromint (IV _ ival_) =
  match ival_ with
    | IVunspecified ->
        FVunspecified
    | IVconcrete ival ->
        FVconcrete (Float.of_integer ival)
    | _ ->
        error "TODO: Defacto_memory.impl_fvfromint, symbolic integer value"
  end

(* TODO: check type ranges after conversion *)
let impl_ivfromfloat _ = function
  | FVunspecified ->
      IV Prov_none IVunspecified
  | FVconcrete fval ->
      IV Prov_none (IVconcrete (Float.to_integer fval))
end

let impl_case_integer_value (IV _ ival) fint fother =
  match ival with
    | IVconcrete n ->
        fint n
    | _ ->
        fother ()
  end

let impl_is_specified_ival (IV _ ival) =
  match ival with
    | IVunspecified ->
        false
    | _ ->
        true
end

let is_concrete_ival ival =
  error "WIP: is_concrete_ival"


(* Memory value constructors *)
(*
let symbolic_mval symb =
  let () = Debug.print_debug 1 "Mem.symbolic_mval !!!!!" in
  MVsymbolic symb
*)

let impl_unspecified_mval ty =
  mkUnspec ty

let impl_integer_value_mval ity ival =
  MVinteger ity ival

let impl_floating_value_mval fty fval =
  MVfloating fty fval

let impl_pointer_mval ref_ty ptr_val =
  MVpointer ref_ty ptr_val

let impl_array_mval = function
  | [] ->
      error "Defacto_memory.array_mval, given an empty list"
  | mvals ->
      MVarray mvals
end

let impl_struct_mval tag_sym xs =
  if List.null xs then
    error "Defacto_memory.struct_mval, given an empty list of member values"
  else
    MVstruct tag_sym xs

let impl_union_mval tag_sym memb_ident mval =
  MVunion tag_sym memb_ident mval


(* Memory value destructor *)
let impl_case_mem_value mval funspec (* fsymb *) fconcur fival ffval fptrval farr fstruct funion =
  match mval with
    | MVinteger ity (IV _ ival_ as ival) ->
        match ival_ with
          | IVunspecified ->
              funspec (Basic (AilTypes.Integer ity))
          | IVconcurRead ity2 sym ->
              (* TODO: check ity1 vs ity2 ? *)
              fconcur ity2 sym
          | _ ->
              fival ity ival
        end
    | MVfloating fty fval ->
        match fval with
          | FVunspecified ->
              funspec (Basic (AilTypes.Floating fty))
          | _ ->
              ffval fty fval
        end
    | MVpointer ref_ty (PV _ ptrval_ _ as ptrval) ->
        match ptrval_ with
          | PVunspecified _ ->
              (* TODO: or use the type in PVunspecified? *)
              funspec (Pointer AilTypes.no_qualifiers ref_ty)
          | _ ->
              fptrval ref_ty ptrval
        end
    | MVarray mvals ->
        farr mvals
    | MVstruct tag_sym xs ->
        fstruct tag_sym xs
    | MVunion tag_sym memb_ident mval ->
        funion tag_sym memb_ident mval
    | MVdelayed _ _ ->
        error "TODO: Defacto_memory.impl_case_mem_value, MVdelayed"
    | MVcomposite _ _ ->
        error "TODO: Defacto_memory.impl_case_mem_value, MVcomposite"
  end


let impl_case_fval fval funspec fconcrete =
  match fval with
    | FVunspecified ->
        funspec ()
    | FVconcrete str ->
        fconcrete str
  end

val impl_zero_fval: impl_floating_value
let impl_zero_fval =
  FVconcrete (Float.of_int 0)

val impl_one_fval: impl_floating_value
let impl_one_fval =
  FVconcrete (Float.of_int 1)

val impl_str_fval: string -> impl_floating_value
let impl_str_fval str = FVconcrete (Float.of_string str)


(*
val address_of: allocation -> address
let address_of = function
  | Alloc_static _ addr ->
      addr
  | Alloc_dynamic _ addr ->
      addr
end
*)


val isEmptyShift: shift_path -> bool
let isEmptyShift = function
  | [] ->
      true
  | _ ->
      false
end

val     isBeginningShift: shift_path -> impl_memM bool
let rec isBeginningShift sh =
  match sh with
    | [] ->
        return true
    | (SPE_array _ ival_) :: sh' ->
        ifM "isBeginningShift"
          (mk_iv_constr MC_eq ival_ (IVconcrete 0))
            (isBeginningShift sh')
            (return false)
    | (SPE_member tag_sym memb_ident) :: sh' ->
        let xs = match Core_ctype_aux.get_membersDefs tag_sym with
          | Core_ctype.StructDef z -> z
          | Core_ctype.UnionDef  z -> z
        end in
        match xs with
          | [] ->
              error "Mem.isBeginningShift, get_membersDefs returning an empty list"
          | (memb_ident', _) :: _ ->
              return (memb_ident = memb_ident')
        end
  end




val is_one_past_pointer: impl_pointer_value -> impl_memM bool
let is_one_past_pointer (PV _ ptr_val_ sh) =
  match ptr_val_ with
    | PVnull _ ->
        return false
    | PVfunction _ ->
        return false
    | _ ->
        explicitAllocationIdFromPointer_value_aux ptr_val_ >>= function
          | Just (alloc_id, _) ->
              resolve_allocation alloc_id >>= fun stor ->
                let size_ival_ = match stor with
                  | Storage_static _ ty _ ->
                      IVsizeof ty
                  | Storage_dynamic _ ival_ _ ->
                      ival_
                end in
                (* |sh| = sizeof ty *)
                condM "is_one_past_pointer"
                  (mk_iv_constr MC_eq (integer_value_baseFromShift_path sh) size_ival_)
          | Nothing ->
              wip "is_one_past_pointer, implicit allocation"
        end
  end


(*
let address_expression_of_pointer (PV _ ptr_val_ sh) =
  match ptr_val_ with
    | PVnull _ ->
        fail (MerrInternal "called [address_expression_of_pointer] on null pointer")
    | PVfunction _ ->
        fail (MerrInternal "called [address_expression_of_pointer] on function pointer")
    | _ ->
        explicitAllocationIdFromPointer_value_aux ptr_val_ >>= function
          | Just alloc_id ->
              resolve_allocation alloc_id >>= function
                | Storage_static ty _ ->
                  return $ mk_op_ival_ IntAdd (IVaddress alloc_id) (IVsizeof ty)
                | Storage_dynamic ival_ _ ->
                  return $ mk_op_ival_ IntAdd (IVaddress alloc_id) ival_
              end
          | Nothing ->
              wip "address_expression_of_pointer, implicit allocation"
        end
end
*)



(*
let rec integerTypes_of_ival ival =
  match ival with
    | IVconcrete _ ->
        Nothing
    | IVaddress _ ->
        Nothing
(*
    | IVfromptr _ _ ->
        [Cty.intptr_t; Cty.unintptr_t]
*)
    | IVop _ [ival_1; ival_2] ->
        
    | IVmin ity ->
        
    | IVmax of AilTypes.integerType
    | IVsizeof of ctype
    | IValignof of ctype
    | IVoffsetof of Symbol.t * Cabs.cabs_identifier
    | IVptrdiff of pointer_value_base * pointer_value_base
    | IVbyteof of integer_value_base * mem_value (* the integer value is the position (indexed from zero) *)
    | IVcomposite of list integer_value_base
  end
*)






(* WIP *)
let impl_eq_ptrval ptr_val1 ptr_val2 =
  print_debugM 6 (fun () -> "Mem.eq_ptrval: " ^ stringFromPointer_value ptr_val1 ^ " vs " ^
                  stringFromPointer_value ptr_val2) >>
  match (ptr_val1, ptr_val2) with
    | (PV _ (PVnull _) [], PV _ (PVnull _) []) ->
        (* STD §6.5.9#6 *)
        return true
    | (PV _ (PVnull _) sh1, PV _ (PVnull _) sh2) ->
        if false (* ISO mode *) then
          (* STD §6.5.9#6 *)
          (* TODO: check. I guess not UB here, because the UB should have come when shifting the pointer? *)
          return false
        else
          condM "shifted null pointers equality"
            (mk_iv_constr MC_eq (integer_value_baseFromShift_path sh1)
                                (integer_value_baseFromShift_path sh2))
    | (PV _ (PVfunction sym1) [], PV _ (PVfunction sym2) []) ->
        return (sym1 = sym2)
    | (PV _ (PVnull _) _, _) ->
        (* STD §6.5.9#6 *)
        return false
    | (_, PV _ (PVnull _) _) ->
        (* STD §6.5.9#6 *)
        return false
    
    | (PV prov1 ptr_val1_ sh1, PV prov2 ptr_val2_ sh2) ->
        let do_honest_equality =
          address_expression_of_pointer ptr_val1 >>= fun addr_ival_1 ->
          address_expression_of_pointer ptr_val2 >>= fun addr_ival_2 ->
          condM "honest pointer equality"
            (mk_iv_constr MC_eq addr_ival_1 addr_ival_2) in
        match (prov1, prov2) with
          | (Prov_some alloc_id1, Prov_some alloc_id2) ->
              ifFlag Allow_disjoint_alloc_tests
                (* defacto flag *)
                begin
                  if alloc_id1 = alloc_id2 then
                    do_honest_equality
                  else
                    Nondeterminism.msum "pointer equality"
                      [ ("using provenance", return false)
                      ; ("ignoring provenance", do_honest_equality) ]
                end
                
                (* STD case *)
                begin
                  if alloc_id1 = alloc_id2 then
                    (* this tests that at least one pointer is to a base object and the two
                       is to either also to that base object or a beginning subobject *)
                    if      isEmptyShift sh1 then isBeginningShift sh2
                    else if isEmptyShift sh2 then isBeginningShift sh1
                    else
                      (* the pointers are to a same subobject *)
                      return (sh1 = sh2)
                  
                  else
                    is_one_past_pointer ptr_val1 >>= function
                      | true ->
                          address_expression_of_pointer ptr_val1 >>= fun addr_ival_1 ->
                          address_expression_of_pointer ptr_val2 >>= fun addr_ival_2 ->
                          condM "eq_ptrval - left is one past"
                            (mk_iv_constr MC_eq addr_ival_1 addr_ival_2)
                      | false ->
                          is_one_past_pointer ptr_val2 >>= function
                            | true ->
                                address_expression_of_pointer ptr_val1 >>= fun addr_ival_1 ->
                                address_expression_of_pointer ptr_val2 >>= fun addr_ival_2 ->
                                condM "eq_ptrval - right is one past"
                                  (mk_iv_constr MC_eq addr_ival_1 addr_ival_2)
                            | false ->
                                return false
                          end
                      end
                end
          | (Prov_some _, _) ->
              do_honest_equality
          | (_, Prov_some _) ->
              do_honest_equality
          | _ ->
              error "WIP: Mem.eq_ptrval, not (Just alloc_id1, Just alloc_id2)"
        end
    end


let rec silly_sh_eq sh1 sh2 =
  match (sh1, sh2) with
    | ([], []) ->
        Just true
    | (SPE_array ty1 ival_1 :: sh1', SPE_array ty2 ival_2 :: sh2') ->
        if ty1 = ty2 then
          match (eval_integer_value_base ival_1, eval_integer_value_base ival_2) with
            | (Just n1, Just n2) ->
                if n1 = n2 then silly_sh_eq sh1' sh2' else Nothing
            | _ ->
              Nothing
          end
        else
          Nothing
    | (SPE_member tag_sym1 membr_ident1 :: sh1', SPE_member tag_sym2 membr_ident2 :: sh2') ->
        if tag_sym1 = tag_sym2 && membr_ident1 = membr_ident2 then
          silly_sh_eq sh1' sh2'
        else
          Nothing
    | _ ->
        Just false
  end

(* TODO: more .... *)
let impl_ne_ptrval (PV prov1 ptr_val_1 sh1 as ptrval1) (PV prov2 ptr_val_2 sh2 as ptrval2) =
  match (ptr_val_1, ptr_val_2) with
  | (PVnull _, PVnull _)->
      return false
  | (PVnull _, PVbase _ _) ->
      return true
  | (PVbase _ _, PVnull _) ->
      return true
  | (PVbase alloc_id1 _, PVbase alloc_id2 _) ->
      if sh1 = [] && sh2 = [] then
        return (alloc_id1 <> alloc_id2)
      else
        match (silly_sh_eq sh1 sh2) with
          | Just true ->
              return (alloc_id1 <> alloc_id2)
          | _ ->
              error ("WIP(1): ne_ptrval ==> " ^ stringFromPointer_value ptrval1 ^ " <|> " ^ stringFromPointer_value ptrval2)
        end
        

  | _ ->
      error ("WIP(2): ne_ptrval ==> " ^ stringFromPointer_value ptrval1 ^ " <|> " ^ stringFromPointer_value ptrval2)
  end




let impl_lt_ptrval ptrval1 ptrval2 =
  let ival_1 = real_address_expression_of_pointer ptrval1 in
  let ival_2 = real_address_expression_of_pointer ptrval2 in
  condM "lt_ptrval" (mk_iv_constr MC_lt ival_1 ival_2)

let impl_gt_ptrval ptrval1 ptrval2 =
  let ival_1 = real_address_expression_of_pointer ptrval1 in
  let ival_2 = real_address_expression_of_pointer ptrval2 in
  condM "gt_ptrval" (mk_iv_constr MC_lt ival_2 ival_1)

let impl_le_ptrval ptrval1 ptrval2 =
  let ival_1 = real_address_expression_of_pointer ptrval1 in
  let ival_2 = real_address_expression_of_pointer ptrval2 in
  condM "le_ptrval" (mk_iv_constr MC_le ival_1 ival_2)

let impl_ge_ptrval ptrval1 ptrval2 = 
  let ival_1 = real_address_expression_of_pointer ptrval1 in
  let ival_2 = real_address_expression_of_pointer ptrval2 in
  condM "ge_ptrval" (mk_iv_constr MC_le ival_2 ival_1)



(*
When two pointers are subtracted, both shall point to elements of the same array object, or one past the last element of the array object;

If the result is not representable in an object of that type, the behavior is undefined.

*)


(* TODO: check that, std says:
Moreover, if the expression P points either to an element of an array object or
one past the last element of an array object, and the expression Q points to the
last element of the same array object, the expression ((Q)+1)-(P) has the same
value as ((Q)-(P))+1 and as -((P)-((Q)+1)), and has the value zero if the
expression P points one past the last element of the array object, even though
the expression (Q)+1 does not point to an element of the array object.
*)
(* STD §6.5.6#9 *)
let impl_diff_ptrval ty ptrval1 ptrval2 : impl_memM impl_integer_value =
  match (ptrval1, ptrval2) with
    | (PV (Prov_some (alloc_id1, _)) ptr_val_1 sh1, PV (Prov_some (alloc_id2, _)) ptr_val_2 sh2) ->
        if alloc_id1 = alloc_id2 then
          address_expression_of_pointer ptrval1 >>= fun ival1 ->
          address_expression_of_pointer ptrval2 >>= fun ival2 ->
          resolve_allocation alloc_id1 >>= function
            | Storage_static pref1 ty _ ->
                (* STD §6.5.9#9 sentence1 *)
                ifM "diff_ptrval_6.5.9#9__sentence_1"
                  (MC_conj [ mk_iv_constr MC_le (IVaddress alloc_id1 pref1) ival1
                           ; mk_iv_constr MC_le ival1 (IVop IntAdd [IVaddress alloc_id1 pref1; IVsizeof ty])
                           ; mk_iv_constr MC_le (IVaddress alloc_id1 pref1) ival2
                           ; mk_iv_constr MC_le ival2 (IVop IntAdd [IVaddress alloc_id1 pref1; IVsizeof ty]) ])
                    (* NOTE: the result of subtraction of two pointer values is an integer value with
                       empty provenance, irrespective of the operand provenances *)
                  (return (IV Prov_none (IVptrdiff ty (ptr_val_1, sh1) (ptr_val_2, sh2))))
                  (print_debugM 1 (fun () -> "MerrPtrdiff 1") >> fail MerrPtrdiff)
            | Storage_dynamic _ _ _ ->
                error "Mem.impl_diff_ptrval, Storage_dynamic"
          end
        else
          print_debugM 1 (fun () -> "MerrPtrdiff 2 ==> alloc_id1=" ^ show alloc_id1 ^ "; alloc_id2= " ^ show alloc_id2) >>
          fail MerrPtrdiff
    | _ ->
        print_debugM 1 (fun () -> "MerrPtrdiff 3") >> fail MerrPtrdiff
  end



    
(* TODO: looks too simple to be true *)
let impl_intcast_ptrval ref_ty ity ((PV prov ptr_val_ sh) as ptrval) =
  let ival = IV prov (IVfromptr ref_ty ity ptr_val_ sh) in
  match ity with
    | AilTypes.Signed AilTypes.Intptr_t ->
        return ival
    | AilTypes.Unsigned AilTypes.Intptr_t ->
        return ival
    | AilTypes.Unsigned AilTypes.Long ->
        (* TODO: check that it's ok to assume intptr_t to caracterise the
           size of pointers *)
        (* TODO: maybe we should have a flag *)
        let intptr_t =
          Basic (AilTypes.Integer (AilTypes.Signed AilTypes.Intptr_t)) in
        let unsigned_long =
          Basic (AilTypes.Integer (AilTypes.Unsigned AilTypes.Long)) in
        
        (* TODO: unsure about this *)
        let unsigned_long_ity = AilTypes.Unsigned AilTypes.Long in
        address_expression_of_pointer ptrval >>= fun ptr_ival_ ->
        ifM "intcast_ptrval (unsigned long)"
          (MC_conj [ mk_iv_constr MC_le (IVmin unsigned_long_ity) ptr_ival_
                   ; mk_iv_constr MC_le ptr_ival_ (IVmax unsigned_long_ity) ])
            (return ival)
            (fail (MerrWIP "casting a pointer to unsigned long, but the type is too small"))
(*
        ifM "intcast_ptrval (unsigned long)"
          (mk_iv_constr MC_le (IVsizeof intptr_t) (IVsizeof unsigned_long))
          (return ival)
          (fail (MerrWIP "casting a pointer to unsigned long, but the type is too small"))
*)
    | _ ->
        fail (MerrWIP "casting a pointer to an invalid integer type")
  end

let impl_validForDeref_ptrval ptr_val =
  let () = Debug.warn [] (fun () ->
    "Mem.impl_validForDeref_ptrval IS WRONG"
  ) in
  true

let impl_isWellAligned_ptrval ref_ty ptr_val =
  error "TODO: Symbolic defacto, isWellAligned_ptrval"


(* integer types minimal range (STD Annex E #1) *)
val minimal_range: AilTypes.integerType -> bool * integer * integer
let minimal_range ity =
  let (min,max) = integer_range ity in
  (true, min, max)


let rec impl_eq_ival mem_st_opt (IV prov1 ival_1) (IV prov2 ival_2) =
  match (ival_1, ival_2) with
    | (IVconcrete n1, IVconcrete n2) ->
        Just (n1 = n2)
    | _ ->
        Nothing
  end



let impl_lt_ival mem_st_opt (IV prov1 ival_1 as ival1) (IV prov2 ival_2 as ival2) =
  let ival_1' = lifted_simplify_integer_value_base ival_1 in
  let ival_2' = lifted_simplify_integer_value_base ival_2 in
  match (ival_1', ival_2') with
    | (IVconcrete n1, IVconcrete n2) ->
        Just (n1 < n2)
    
    | (IVfromptr _ ity1 _ _, IVmin ity2) ->
        let () = Debug.print_debug 3 [Debug.DB_memory] (fun () ->
          "using axiom ==> forall ref_ty ptrval, not (Ivfromptr(ref_ty, ptrval) < Ivmin(\"intptr_t\"))"
        ) in
        if ity1 = ity2 then
          Just false
        else
          Nothing
    
    | (IVmax ity1, IVfromptr _ ity2 _ _) ->
        let () = Debug.print_debug 3 [Debug.DB_memory] (fun () ->
          "using axiom ==> forall ref_ty ptrval, Ivmax(\"intptr_t\") < Ivfromptr(ref_ty, ptrval)"
        ) in
        if ity1 = ity2 then
          Just false
        else
          Nothing
(*
    | (IVfromptr _ (AilTypes.Signed AilTypes.Intptr_t) _, IVmin (AilTypes.Signed AilTypes.Intptr_t)) ->
        let () = Debug.print_debug 3 [Debug.DB_memory] (fun () ->
          "using axiom ==> forall ref_ty ptrval, not (Ivfromptr(ref_ty, ptrval) < Ivmin(\"intptr_t\"))"
        ) in
        Just false
    
    | (IVfromptr _ (AilTypes.Unsigned AilTypes.Intptr_t) _, IVmin (AilTypes.Unsigned AilTypes.Intptr_t)) ->
        let () = Debug.print_debug 3 [Debug.DB_memory] (fun () ->
          "using axiom ==> forall ref_ty ptrval, Ivfromptr(ref_ty, ptrval) < Ivmin(\"uintptr_t\")"
        ) in
        Just false
    
    | (IVmax (AilTypes.Signed AilTypes.Intptr_t), IVfromptr _ (AilTypes.Signed AilTypes.Intptr_t) _) ->
        let () = Debug.print_debug 3 [Debug.DB_memory] (fun () ->
          "using axiom ==> forall ref_ty ptrval, Ivmax(\"intptr_t\") < Ivfromptr(ref_ty, ptrval)"
        ) in
        Just false
    
    | (IVmax (AilTypes.Unsigned AilTypes.Intptr_t), IVfromptr _ (AilTypes.Unsigned AilTypes.Intptr_t) _) ->
        let () = Debug.print_debug 3 [Debug.DB_memory] (fun () ->
          "using axiom ==> forall ref_ty ptrval,  Ivmax(\"uintptr_t\") < Ivfromptr(ref_ty, ptrval)"
        ) in
        Just false
*)
    | (IVbitwise ity1 _, IVmin ity2) ->
        if ity1 = ity2 then
          Just false
        else
          Nothing
    | (IVmax ity1, IVbitwise ity2 _) ->
        if ity1 = ity2 then
          Just false
        else
          Nothing
    
    | (IVconcrete n, IVsizeof _) ->
        if n <= 0 then
          Just true
        else
          Nothing
    
    | (IVmin _, IVsizeof _) ->
        let () = Debug.warn [Debug.DB_memory] (fun () -> "assuming that no integer type has a strictly positive minimal value") in
        Just true
    | (IVmin _, IValignof _) ->
        let () = Debug.warn [Debug.DB_memory] (fun () -> "assuming that no integer type has a strictly positive minimal value") in
        Just true
    
    | (IVconcrete n, IVoffsetof tag_sym membr_ident) ->
        error "WIP"
(*
        if n <= 0 then
          match get_membersDefs tag_sym with
            | (ident', _)::_ ->
                if membr_ident = ident' then
                  (* TODO: assuming no prefix padding *)
                  Just false
                else
                  Just true
            | _ ->
                error "Mem.lt_ival, get_membersDefs returned an empty list"
          end
        else
          Nothing
*)
    
    | (IVmin ity, IVconcrete n) ->
        let (is_exact, min, _) = minimal_range ity in
        if is_exact then
          Just (min < n)
        else
          if min < n then
            Just true
          else
            Nothing

    | (IVconcrete n, IVmax ity) ->
        let (is_exact, _, max) = minimal_range ity in
        if is_exact then
          Just (n < max)
        else
          if n < max then
            Just true
          else
            Nothing

    | _ ->
        let ival_1'' = lifted_simplify_integer_value_base ival_1' in
        let ival_2'' = lifted_simplify_integer_value_base ival_2' in
        match (ival_1'', ival_2'') with
          | (IVconcrete n1, IVconcrete n2) ->
              Just (n1 < n2)
          | _ ->
              (* TODO *)
              Nothing
        end
  end


(* TODO: temporary hack for concurrency (need to use a sat solver) *)
let rec has_concurRead ival_ =
  match ival_ with
    | IVunspecified ->
        false
    | IVconcurRead _ _ ->
        true
    | IVconcrete _ ->
        false
    | IVaddress _ _ ->
        false
    | IVfromptr _ _ _ _ ->
        false
    | IVop _ ival_s ->
        List.any has_concurRead ival_s
    | IVmin _ ->
        false
    | IVmax _ ->
        false
    | IVsizeof _ ->
        false
    | IValignof _ ->
        false
    | IVoffsetof _ _ ->
        false
    | IVpadding _ _ ->
        false
    | IVptrdiff _ _ _ ->
        false
    | IVbyteof _ _ ->
        false
    | IVcomposite ival_s ->
        List.any has_concurRead ival_s
    | IVbitwise _ (BW_complement ival_) ->
        has_concurRead ival_
    | IVbitwise _ (BW_AND ival_1 ival_2) ->
        has_concurRead ival_1 || has_concurRead ival_2
    | IVbitwise _ (BW_OR ival_1 ival_2) ->
        has_concurRead ival_1 || has_concurRead ival_2        
    | IVbitwise _ (BW_XOR ival_1 ival_2) ->
        has_concurRead ival_1 || has_concurRead ival_2
  end


let impl_le_ival mem_st_opt (IV _ ival_1 as ival1) (IV _ ival_2 as ival2) =
  let () = Debug.print_debug 1 [] (fun () ->
    "impl_le_ival ==> " ^ stringFromInteger_value ival1 ^ " -- " ^
    stringFromInteger_value ival2
  ) in
  match impl_lt_ival mem_st_opt ival1 ival2 with
    | Just true ->
        Just true
    | _ ->
        let ival_1' = lifted_simplify_integer_value_base ival_1 in
        let ival_2' = lifted_simplify_integer_value_base ival_2 in
        match (ival_1', ival_2') with
          | (IVconcrete n1, IVconcrete n2) ->
              Just (n1 = n2)
          
          | (IVmin ity1, IVfromptr _ ity2 _ _) ->
              let () = Debug.print_debug 3 [Debug.DB_memory] (fun () ->
                "using axiom ==> forall ref_ty ptrval, Ivmin(\"intptr_t\") <= Ivfromptr(ref_ty, ptrval)"
              ) in
              if ity1 = ity2 then
                Just true
              else
                let () = Debug.print_debug 1 [] (fun () ->
                  "impl_le_ival (IVmin vs IVfromptr) ==> " ^ stringFromInteger_value ival1 ^ " -- " ^
                  stringFromInteger_value ival2
                ) in
                Nothing
          | (IVfromptr _ ity1 _ _, IVmax ity2) ->
              let () = Debug.print_debug 3 [Debug.DB_memory] (fun () ->
                "using axiom ==> forall ref_ty ptrval, Ivfromptr(ref_ty, ptrval) <= Ivmax(\"intptr_t\")"
              ) in
              if ity1 = ity2 then
                Just true
              else
                Nothing


(*
          | (IVmin (AilTypes.Signed AilTypes.Intptr_t), IVfromptr _ (AilTypes.Signed AilTypes.Intptr_t) _) ->
              let () = Debug.print_debug 3 [Debug.DB_memory] (fun () ->
                "using axiom ==> forall ref_ty ptrval, Ivmin(\"intptr_t\") <= Ivfromptr(ref_ty, ptrval)"
              ) in
              Just true
          
          | (IVmin (AilTypes.Unsigned AilTypes.Intptr_t), IVfromptr _ (AilTypes.Unsigned AilTypes.Intptr_t) _) ->
              let () = Debug.print_debug 3 [Debug.DB_memory] (fun () ->
                "using axiom ==> forall ref_ty ptrval, Ivmin(\"uintptr_t\") <= Ivfromptr(ref_ty, ptrval)"
              ) in
              Just true
          
          | (IVfromptr _ (AilTypes.Signed AilTypes.Intptr_t) _, IVmax (AilTypes.Signed AilTypes.Intptr_t)) ->
              let () = Debug.print_debug 3 [Debug.DB_memory] (fun () ->
                "using axiom ==> forall ref_ty ptrval, Ivfromptr(ref_ty, ptrval) <= Ivmax(\"intptr_t\")"
              ) in
              Just true
          
          | (IVfromptr _ (AilTypes.Signed AilTypes.Intptr_t) _, IVmax (AilTypes.Unsigned AilTypes.Intptr_t)) ->
              let () = Debug.print_debug 3 [Debug.DB_memory] (fun () ->
                "using axiom ==> forall ref_ty ptrval, Ivfromptr(ref_ty, ptrval) <= Ivmax(\"uintptr_t\")"
              ) in
              Just true
*)
          | (IVmin ity, IVbitwise ity' _) ->
              if ity = ity' then
                Just true
              else
                Nothing
          | (IVbitwise ity _, IVmax ity') ->
              if ity = ity' then
                Just true
              else
                Nothing
          
          | (IVmin ity, IVconcurRead ity' _) ->
              if ity = ity' then
                Just true
              else
                Nothing
          | (IVconcurRead ity' _, IVmax ity) ->
              if ity = ity' then
                Just true
              else
                Nothing
          
          | (IVmin ity, IVconcrete n) ->
              let (is_exact, min, _) = minimal_range ity in
              if is_exact then
                Just (min <= n)
              else
                if min <= n then
                  Just true
                else
                  Nothing
          
          | (IVconcrete n, IVsizeof _) ->
              if n <= 0 then
                Just true
              else
                Nothing
          | (IVmin _, IVsizeof _) ->
              let () = Debug.warn [Debug.DB_memory] (fun () -> "assuming that no integer type has a strictly positive minimal value") in
              Just true
          | (IVmin _, IValignof _) ->
              let () = Debug.warn [Debug.DB_memory] (fun () -> "assuming that no integer type has a strictly positive minimal value") in
              Just true

          
          | (IVconcrete n, IVmax ity) ->
              let (is_exact, _, max) = minimal_range ity in
              if is_exact then
                Just (n <= max)
              else
                if n <= max then
                  Just true
                else
                  Nothing
          
          | (IVmin (AilTypes.Size_t), IVoffsetof tag_sym membr_ident) ->
              let () = Debug.warn [Debug.DB_memory] (fun () -> "we are assuming that struct/union type '" ^ show tag_sym ^
                             "' isn't so big the offset to member '" ^ show membr_ident ^
                             "' is representable in size_t") in
              (* TODO: check that *)
              Just true
          | (IVoffsetof tag_sym membr_ident, IVmax (AilTypes.Size_t)) ->
              let () = Debug.warn [Debug.DB_memory] (fun () -> "we are assuming that struct/union type '" ^ show tag_sym ^
                             "' isn't so big the offset to member '" ^ show membr_ident ^
                             "' is representable in size_t") in
              Just true
          


          | (IVconcrete n, IVoffsetof tag_sym membr_ident) ->
              if n <= 0 then
                Just true
              else
                Nothing
          
          (* a byte always range over uchar *)
          | (IVmin (AilTypes.Unsigned AilTypes.Ichar), IVbyteof _ _) ->
              Just true
          | (IVbyteof _ _, IVmax (AilTypes.Unsigned AilTypes.Ichar)) ->
              Just true

          | (IVmin (AilTypes.Signed AilTypes.Int_), IVbyteof _ _) ->
              let () = Debug.warn [Debug.DB_memory] (fun () -> "TODO: check + document") in
              Just true
          | (IVbyteof _ _, IVmax (AilTypes.Signed AilTypes.Int_)) ->
              let () = Debug.warn [Debug.DB_memory] (fun () -> "TODO: check + document") in
              Just true
          
          (* sizeof and alignof are always in range of size_t *)
(*
          | (IVmin AilTypes.Size_t, IVsizeof _) ->
              Just true
*)
          | (IVsizeof _, IVmax AilTypes.Size_t) ->
              Just true
(*
          | (IVmin AilTypes.Size_t, IValignof _) ->
              Just true
*)
          | (IValignof _, IVmax AilTypes.Size_t) ->
              Just true
          
          | (IVop IntSub [IVoffsetof tag_sym1 membr_ident1; IVoffsetof tag_sym2 membr_ident2], IVmax AilTypes.Size_t) ->
              if tag_sym1 = tag_sym2 then
                let () = Debug.warn [Debug.DB_memory] (fun () -> "we are assuming that the delta between members '" ^ show membr_ident1 ^
                               "' and '" ^ show membr_ident2 ^ "' of struct/union type '" ^ show tag_sym1 ^
                               "' is representable in size_t") in
                Just true
              else
                Nothing
          | (IVconcrete n, IVop IntSub [IVoffsetof tag_sym1 membr_ident1; IVoffsetof tag_sym2 membr_ident2]) ->
              if n <= 0 then
                Just true
              else
                Nothing
          
          | (IVsizeof (Core_ctype.Pointer _ _), IVmax _) ->
              let () = Debug.warn [Debug.DB_memory] (fun () -> "TODO: document") in
              Just true














          | _ ->
              let ival_1'' = lifted_simplify_integer_value_base ival_1' in
              let ival_2'' = lifted_simplify_integer_value_base ival_2' in
              match (ival_1'', ival_2'') with
                | (IVconcrete n1, IVconcrete n2) ->
                    Just (n1 <= n2)
(* !!!!!! BEGIN HACK FOR CONCURRENCY, WILL FIX LATER *)
          | (IVmin _, _) ->
              Just true (* if has_concurRead ival_2'' then Just true else Nothing *)
          | (_, IVmax _) ->
              Just true (* if has_concurRead ival_1'' then Just true else Nothing *)
(* !!!!!! END HACK FOR CONCURRENCY, WILL FIX LATER *)
                | _ ->
                    (* TODO *)
                    Nothing
              end
        end
  end



(* Converting an integer value into a pointer value *)
(*
let impl_ptrcast_ival int_ty ref_ty (IV prov ival_) =
  (* TODO: check the types *)
  match ival_ with
    | IVfromptr ty ity ptrval_ ->
        (* The integer value was made from an pointer value. the provenance is passed on *)
        return (PV prov ptrval_ [])
    | _ ->
        ifM "ptrcast_ival, null pointer"
          (mk_iv_constr MC_eq ival_ (IVconcrete 0))
          (* if the integer value is zero, then we make a null pointer (see Q28 in notes30) *)
          (return (impl_null_ptrval ref_ty))
          
          begin
            ifM "ptrcast_ival, device pointer"
              (MC_in_device (IV Prov_none ival_))
              (* if the integer value is within the device memory range *)
              (return (PV Prov_device (PVfromint ival_) []))
              (* otherwise we produce a runtime error (check with P) *)
              (fail (MerrWIP "tried to cast to a pointer type an (non device) integer value non-equal to zero"))
          end
  end
*)
let impl_ptrcast_ival int_ty ref_ty ival =
  (* TODO: check the types *)
  match ival with
    | IV prov (IVfromptr ty ity ptrval_ sh) ->
        (* The integer value was made from an pointer value. the provenance is passed on *)
        return (PV prov ptrval_ sh)
    | IV (Prov_some _ as prov) ival_ ->
        return (PV prov (PVfromint ival_) [])
    | IV _ ival_ ->
        ifM "ptrcast_ival, null pointer"
          (mk_iv_constr MC_eq ival_ (IVconcrete 0))
          (* if the integer value is zero, then we make a null pointer (see Q28 in notes30) *)
          (return (impl_null_ptrval ref_ty))
          
          begin
            ifM "ptrcast_ival, device pointer"
              (MC_in_device (IV Prov_none ival_))
              (* if the integer value is within the device memory range *)
              (return (PV Prov_device (PVfromint ival_) []))
              (* otherwise we produce a runtime error (check with P) *)
              (fail (MerrWIP "tried to cast to a pointer type an (non device) integer value non-equal to zero"))
          end
  end











(* ============================================================================================== *)



let get_allocation_size alloc_id =
  get >>= fun st ->
  match Map.lookup alloc_id st.allocations with
    | Just (Storage_static _ ty _) ->
        return (IVsizeof ty)
    | Just (Storage_dynamic _ ival_ _) ->
        return ival_
    | Nothing ->
        error "Mem.get_allocation_size: TODO make it an error in the monad"
  end


(* Decide whether a given pointer value can be use to perform a store *)
val can_store: Loc.t -> impl_pointer_value -> impl_memM (either access_error allocation_id)
let can_store loc (PV prov ptr_val_ sh as ptr_val) =
  match ptr_val_ with
    (* null and function pointers obviously can't be used for stores. *)
    | PVnull _     -> return (Left NullPtr)
    | PVfunction _ -> return (Left FunctionPtr)
    
    (* by WF-invariants, we have a pointer to an object *)
    | _ ->
        explicitAllocationIdFromPointer_value_aux ptr_val_ >>= function
          | Just (alloc_id, pref) ->
              is_dead alloc_id >>= function
                | true ->
                    let () = Debug.print_debug 5 [Debug.DB_memory] (fun () ->
                      "CAN'T STORE : is_dead ==> " ^ stringFromPointer_value ptr_val
                    ) in
                    (* can't store with a pointer to an object whose lifetime ended. *)
                    return (Left DeadPtr)
                | false ->
                    (* add the constraint that the ptr is inside the object *)
                    get_allocation_size alloc_id >>= fun size_ival_ ->

let () = Debug.print_debug 1 [] (fun () ->
  "CAN STORE size_ival_ ===> "  ^ stringFromInteger_value (IV Prov_none size_ival_)

) in

                    let ptr_ival_ = real_address_expression_of_pointer ptr_val in
                    ifM ("can_store[" ^ Loc.stringFromLocation loc ^ "]")
                      (MC_conj [ mk_iv_constr MC_le (IVaddress alloc_id pref) ptr_ival_
                               ; mk_iv_constr MC_lt ptr_ival_ (IVop IntAdd [IVaddress alloc_id pref; size_ival_]) ])
                        (return (Right alloc_id))
                        (return (Left OutOfBoundPtr))
              end
          
          (* we couldn't find an explicit allocation event *)
          | Nothing ->
              error "WIP: can_store ==> don't know how to deal with the absence of explicit allocation id for now."
        end
  end





let rec find_array_index size i ival_ =
  if i >= size then
    (fail (MerrOther "find_array_index failed"))
  else
    ifM "find_array_index"
      (mk_iv_constr MC_eq ival_ (IVconcrete (integerFromNat i)))
        (return i)
        (find_array_index size (i+1) ival_)


(* TODO: bug HOL -- "failure in internal translation to tupled format" *)
(* TODO: with temporary simplification *)
val easy_update_mem_value_aux:
  Loc.t -> bool -> ctype -> shift_path -> impl_mem_value -> impl_mem_value ->
  impl_memM impl_mem_value
let rec easy_update_mem_value_aux loc is_strong write_ty sh write_mval current_mval =
  let () = Debug.print_debug 2 [Debug.DB_memory] (fun () ->
    "ENTERING: easy_update_mem_value_aux\n" ^
    "current_mval ==> " ^ stringFromMem_value current_mval ^ "\n" ^
    "sh ==> " ^ stringFromShift_path sh
  ) in
  let easy_update_mem_value_aux = easy_update_mem_value_aux loc is_strong in
  match (current_mval, sh) with
    | (_, []) ->
        (* SIMPLIFICATION: we assume that the footprint of the new value covers all of the old value *)
        return write_mval
    | (MVarray mvals, SPE_array elem_ty ival_ :: sh') ->
        match Maybe.map natFromInteger (eval_integer_value_base ival_) with
          | Just n ->
              if 0 <= n && n < List.length mvals then
                let () = Debug.print_debug 2 [Debug.DB_memory] (fun () ->
                  "EXITING: easy_update_mem_value_aux, MVarray"
                ) in
                match List.index mvals n with
                  | Just at_n_mval ->
                      easy_update_mem_value_aux write_ty sh' write_mval at_n_mval >>= fun at_n_mval' ->
                      return (MVarray (List.update mvals n at_n_mval'))
                  | Nothing ->
                      (* NOTE: this is impossible *)
                      fail (MerrInternal "easy_update_mem_value_aux, out of array index")
                end
              else
                (* TODO: if this can actually happen, then the error needs to be in the monad? *)
                error "easy_update_mem_value_aux ==> concrete SPE_array was out of bound"
          | Nothing ->
              find_array_index (List.length mvals) 0 ival_ >>= fun n ->
              match List.index mvals n with
                | Just at_n_mval ->
                    easy_update_mem_value_aux write_ty sh' write_mval at_n_mval >>= fun at_n_mval' ->
                    return (MVarray (List.update mvals n at_n_mval'))
                | Nothing ->
                    (* NOTE: this is impossible *)
                    fail (MerrInternal "easy_update_mem_value_aux, out of array index (symb)")
              end
        end
    | (MVstruct tag_sym xs, SPE_member tag_sym_ memb_ident :: sh') ->
        if tag_sym <> tag_sym_ then
          error "WIP[easy_update_mem_value_aux]: TODO error message ===> struct value accessed with incompatible SPE"
        else
          let () = Debug.print_debug 2 [Debug.DB_memory] (fun () -> "EXITING: easy_update_mem_value_aux, MVstruct") in
          MVstruct tag_sym <$>
            mapM (fun (ident, memb_mval) ->
              easy_update_mem_value_aux write_ty sh' write_mval memb_mval >>= fun memb_mval ->
              return (ident, memb_mval)
            ) xs
    
    | (MVunion tag_sym old_memb_ident old_memb_mval, SPE_member tag_sym_ new_memb_ident :: sh') ->
        if tag_sym <> tag_sym_ then
          error "WIP[easy_update_mem_value_aux]: TODO error message ===> union value stored \
                 with incompatible SPE_member tag"
        else
          let (x, xs) = Core_ctype_aux.get_unionDef tag_sym in
          match List.lookup new_memb_ident (x::xs) with
            | Nothing ->
                error "WIP[easy_update_mem_value_aux]: TODO error message ===> union value stored with \
                       incompatible SPE_member memb_ident"
            | Just _ ->
                easy_update_mem_value_aux write_ty sh' write_mval old_memb_mval >>= fun new_memb_mval ->
                return (MVunion tag_sym new_memb_ident new_memb_mval)
          end
    
    | _ ->
        if is_strong then
          match sh with
            | SPE_member tag_sym memb_ident :: sh' ->
                MVstruct tag_sym <$>
                  mapM (fun (ident, ty) ->
                    if ident = memb_ident then
                      easy_update_mem_value_aux write_ty sh' write_mval (mkUnspec ty) >>= fun mval' ->
                      return (ident, mval')
                    else
                      return (ident, mkUnspec ty)
                  ) (Core_ctype_aux.get_structDef tag_sym)
            | _ ->
                error "WIP: easy_update_mem_value_aux, _, is_strong"
          end
        else
(* TODO: this might need to be before the test on "is_strong" *)
          match sh with
            | [SPE_array (Basic (AilTypes.Integer (AilTypes.Unsigned AilTypes.Ichar)) as spe_ty) byte_ival_] ->
                return (MVdelayed [(sh, write_mval)] current_mval)
(*
                match write_mval with
                  | MVinteger _ write_ival ->
                      MVcomposite [(mk_op_ival_ IntMul byte_ival_ (IVsizeof spe_ty), write_ival)] current_mval
                  | _ ->
                      error ("TODO: easy_update_mem_value_aux: object repr access; current_mval = " ^ stringFromMem_value current_mval)
                end
*)

            | _ ->
                (* *)


                let () = Debug.print_debug 1 [] (fun () ->
                  "loc          = " ^ Loc.stringFromLocation loc ^ "\n" ^
                  "sh           = " ^ stringFromShift_path sh ^ "\n" ^
                  "current_mval = " ^ stringFromMem_value current_mval
                ) in
                error "WIP: easy_update_mem_value_aux"
          end
  end

(* TODO: bug HOL -- "failure in internal translation to tupled format" *)
declare hol target_rep function easy_update_mem_value_aux =
                                `tags$easy_update_mem_value_aux`


val easy_update_mem_value: bool -> write_event -> impl_mem_value -> impl_memM impl_mem_value
let easy_update_mem_value is_strong (WriteEvent loc write_ty (PV prov ptr_val_ sh as ptr_val) write_mval) current_mval =
  (*DEBUG*)let () = Debug.print_debug 2 [Debug.DB_memory] (fun () ->
    "easy_update_mem_value: ptrval=" ^ stringFromPointer_value ptr_val ^ ", mval= " ^ stringFromMem_value write_mval
  ) in
  easy_update_mem_value_aux loc is_strong write_ty sh write_mval current_mval >>= fun ret ->
  (*DEBUG*)let () = Debug.print_debug 2 [Debug.DB_memory] (fun () ->
    "DONE WITH easy_update_mem_value: ptrval=" ^ stringFromPointer_value ptr_val ^ ", mval= " ^ stringFromMem_value write_mval
  ) in
  return ret




(* update the memory state with a write event for a given allocation id *)
val register_write_event: allocation_id -> write_event -> impl_memM unit
let register_write_event alloc_id (WriteEvent loc _ _ mval as w) =
  (*DEBUG*)print_debugM 5 (fun () -> "REGISTER_WRITE_EVENT: " ^ stringFromMem_value mval) >>
  get >>= fun st ->
    match Map.lookup alloc_id st.allocations with
      | Just (Storage_static pref obj_ty current) ->
          let is_strong = false in
          let current_mval = match current with
            | Just current_mval ->
                current_mval
            | Nothing ->
                mkUnspec obj_ty
          end in
          easy_update_mem_value is_strong w current_mval >>= fun new_mval ->
          put <| st with allocations=
            Map.insert alloc_id (Storage_static pref obj_ty (Just new_mval)) st.allocations
          |>
     | Just (Storage_dynamic pref size_ival_ ws) ->
         (* TODO: check that the write offset is within range? *)
         put <| st with allocations=
           Map.insert alloc_id (Storage_dynamic pref size_ival_ (w :: ws)) st.allocations
          |>
     
     | Nothing ->
         error "Mem.register_write_event, Nothing"
    end >>
 print_debugM 5 (fun () -> "EXITING register_write_event")




val perform_access: forall 'a. access_kind -> Loc.t -> ctype -> impl_pointer_value ->
  (allocation_id -> impl_memM 'a) ->
  impl_memM 'a ->
  impl_memM 'a
let perform_access accessKind loc lvalue_ty ptrval do_normal do_device =
  match ptrval with
    (* null and function pointers obviously can't be used for accesses. *)
    | PV _ (PVnull _) _     -> fail (MerrAccess loc accessKind NullPtr)
    | PV _ (PVfunction _) _ -> fail (MerrAccess loc accessKind FunctionPtr)
    
    | PV Prov_none _ _ -> fail (MerrAccess loc accessKind NoProvPtr)
    
    (* by WF-invariants, we have a pointer to an object *)
    | (PV (Prov_some (alloc_id, pref)) _ _ as ptrval) ->
        is_dead alloc_id >>= function
          | true ->
              let () = Debug.print_debug 5 [Debug.DB_memory] (fun () ->
                "CAN'T ACCESS : is_dead ==> " ^ stringFromPointer_value ptrval
              ) in
              (* can't store with a pointer to an object whose lifetime ended. *)
              fail (MerrAccess loc accessKind DeadPtr)
          | false ->
              (* add the constraint that the ptr is inside the object *)
              get_allocation_size alloc_id         >>= fun size_ival_ ->
              address_expression_of_pointer ptrval >>= fun ptr_ival_  ->
              (* NOTE: the MC_lt in the second constraint, i.e. we can't
                 have a "one past" pointer *)
              ifM ("perform_access[" ^ Loc.stringFromLocation loc ^ "] provenance check")
                  (MC_conj [ mk_iv_constr MC_le (IVaddress alloc_id pref) ptr_ival_
                           ; mk_iv_constr MC_le (IVop IntAdd [ptr_ival_; IVsizeof lvalue_ty])
                                                (IVop IntAdd [IVaddress alloc_id pref; size_ival_]) ])
                    (do_normal alloc_id)
                    (fail (MerrAccess loc accessKind OutOfBoundPtr))
        end
    
    (* device memory *)
    | (PV Prov_device _ _ as ptrval) ->
        do_device

    | (PV Prov_wildcard _ _ as ptrval) ->
        error "TODO perform_access: Prov_wildcard"
  end









let stringFromWrite_event (WriteEvent loc ty ptrval mval) =
  "WriteEvent[" ^ Loc.stringFromLocation loc ^  "] (" ^ stringFromCore_ctype ty ^ ") ==> ptrval= " ^
  stringFromPointer_value ptrval ^ "; mval= " ^ stringFromMem_value mval



val ival_footprintFromWrite_event: write_event -> impl_memM (integer_value_base * integer_value_base)
let ival_footprintFromWrite_event (WriteEvent loc ty ptrval mval) =
  address_expression_of_pointer ptrval >>= fun ptr_ival_ ->
  return (ptr_ival_, mk_op_ival_ IntAdd ptr_ival_ (mk_op_ival_ IntSub (IVsizeof ty) (IVconcrete 1)))


val isOccludedBy: write_event -> write_event -> impl_memM bool
let isOccludedBy wevent1 wevent2 =
  ival_footprintFromWrite_event wevent1 >>= fun (min_ival_1, max_ival_1) ->
  ival_footprintFromWrite_event wevent2 >>= fun (min_ival_2, max_ival_2) ->
  condM "isOccludedBy"
    (MC_conj [ mk_iv_constr MC_le min_ival_2 min_ival_1
             ; mk_iv_constr MC_le max_ival_1 max_ival_2 ])

let rec anyM pred = function
  | [] ->
      return false
  | x::xs ->
      pred x >>= function
        | true ->
            return true
        | false ->
            anyM pred xs
      end
end


val discardOccluded_write_events: impl_pointer_value -> ctype -> list write_event -> impl_memM (list write_event)
let discardOccluded_write_events view_ptrval view_ty wevents =
  address_expression_of_pointer view_ptrval >>= fun view_ptr_ival_ ->
  let min_view_ival_ = view_ptr_ival_ in
  let max_view_ival_ = mk_op_ival_ IntAdd view_ptr_ival_ (mk_op_ival_ IntSub (IVsizeof view_ty) (IVconcrete 1)) in
  foldlM (fun acc wevent ->
    ival_footprintFromWrite_event wevent >>= fun (min_wevent_ival_, max_wevent_ival_) ->
    ifM "discardOccluded_write_events"
      (* if the view is outside the footprint of the write event *)
      (MC_or (mk_iv_constr MC_lt max_view_ival_ min_wevent_ival_)
             (mk_iv_constr MC_lt max_wevent_ival_ min_view_ival_))
        (return acc)
        (anyM (isOccludedBy wevent) acc >>= function
          | true ->
              return acc
          | false ->
              return (wevent :: acc)
         end)
  ) [] wevents









(* BEGIN ACCESS ================================================================================= *)
let impl_load loc lvalue_ty (PV _ ptrval_ sh as ptrval) : impl_memM (impl_footprint * impl_mem_value) =
  print_debugM 1 (fun () ->
    "LOAD [" ^ stringFromCtype lvalue_ty ^ "]: with pointer value: " ^ stringFromPointer_value ptrval
  ) >>
  perform_access LoadAccess loc lvalue_ty ptrval
    (fun alloc_id ->
      (* addToLog alloc_id >> *)
      resolve_allocation alloc_id >>= function
        | Storage_static stor_pref stor_ty (Just mval) ->
            (* found a stored value static memory *)
            apply_shift_path lvalue_ty sh mval >>= fun mval' ->
            print_debugM 5 (fun () ->
              "==> found value (static): " ^ stringFromMem_value mval'
            ) >>
(*
            if stor_ty = lvalue_ty then
              return (FP_alloc alloc_id lvalue_ty, mval')
            else
              error "WIP: LOAD, lvalue_ty <> stor_ty"
*)
              return (FP_alloc alloc_id lvalue_ty, mval')
        | Storage_static _ _ Nothing ->
            (* loading from uninitialised static memory *)
            return (FP_alloc alloc_id lvalue_ty, mkUnspec lvalue_ty)
        | Storage_dynamic _ _ ws ->
            (* loading from dynamic memory *)
            print_debugM 1 (fun () ->
              "Loading from dynamic storage, found " ^ show (List.length ws) ^ " write events"
            ) >>
            discardOccluded_write_events ptrval lvalue_ty ws >>= fun visible_ws ->
            print_debugM 1 (fun () ->
              "found " ^ show (List.length visible_ws) ^ " visible write events"
            ) >>
            wip "TODO: loading from dynamic memory"
      end
    )
    begin
      wip ("TODO: load from device memory ==> " ^ stringFromPointer_value ptrval)
    end


(*
let impl_load_OLD ty (PV _ ptrval_ sh as ptrval) : impl_memM (impl_footprint * impl_mem_value) =
  print_debugM 5 (fun () ->
    "LOAD [" ^ stringFromCtype ty ^ "]: with pointer value: " ^ stringFromPointer_value ptrval
  ) >>
  match ptrval_ with
    (* null and function pointers obviously can't be used for loads. *)
    | PVnull _     -> fail (MerrAccess loc LoadAccess NullPtr)
    | PVfunction _ -> fail (MerrAccess loc LoadAccess FunctionPtr)
    
    | _ ->
        explicitAllocationIdFromPointer_value_aux ptrval_ >>= function
          | Just alloc_id ->
(*        addToLog alloc_id >> *)
              get >>= fun mem_st ->
              if Set.member alloc_id mem_st.dead_allocations then
                fail (MerrAccess loc LoadAccess DeadPtr)
              else match Map.lookup alloc_id mem_st.allocations with
                | Just (Storage_static _ (Just mval)) ->
                    apply_shift_path ty sh mval >>= fun mval' ->
                    print_debugM 5 (fun () ->
                      "==> found value (static): " ^ stringFromMem_value mval'
                    ) >>
                    return (FP_alloc alloc_id ty, mval')
                | Just (Storage_static _ Nothing) ->
                    return (FP_alloc alloc_id ty, mkUnspec ty)
                | Just (Storage_dynamic _ ws) ->
                    print_debugM 0 (fun () ->
                      "Loading from dynamic storage, found " ^ show (List.length ws) ^ " write events"
                    ) >>
                    error "Mem.load, Storage_dynamic: TODO"
                | Nothing ->
                    error "Mem.load, couldn't find some allocation"
              end
          | Nothing ->
              wip ("TODO: load, Nothing ==> " ^ stringFromPointer_value ptrval)
        end
  end
*)

(*
  (* TODO: this just find the latest store done with exactly the same pointer value *)
  fetch_first_write_event (fun (WriteEvent _ ptr_val' _) -> structural_equality_pointer_value ptr_val ptr_val') >>= function
    | Just (WriteEvent _ _ mval) ->
        print_debugM 4 ("Loading [" ^ stringFromCtype ty ^ "]: "^ stringFromMem_value mval ^ " from: " ^ stringFromPointer_value ptr_val) >>
        return mval
    | Nothing ->
        fail (MerrWIP "load failed")
  end
*)




val impl_store: Loc.t -> ctype -> impl_pointer_value -> impl_mem_value -> impl_memM impl_footprint
let impl_store loc lvalue_ty ptrval mval =
  print_debugM 5 (fun () ->
    "STORE [" ^ stringFromCtype lvalue_ty ^ "]: with pointer value: " ^
    stringFromPointer_value ptrval ^ " and value: " ^ stringFromMem_value mval
  ) >>
  let wevent =
    WriteEvent loc lvalue_ty ptrval mval in
  
  perform_access StoreAccess loc lvalue_ty ptrval
    (fun alloc_id ->
      (* addToLog alloc_id >> *)
      register_write_event alloc_id wevent >>
      return (FP_alloc alloc_id lvalue_ty)
    )
    begin
      get >>= fun st ->
      put <| st with device_memory= wevent :: st.device_memory |> >>
      address_expression_of_pointer ptrval >>= fun ptr_ival_ ->
      return (FP_device ptr_ival_ lvalue_ty)
    end



let impl_memcpy ptr_val1 ptr_val2 size_ival =
  error "WIP: Symbolic memcpy"

(* BEGIN MEMCMP ================================================================================= *)
val     memcmp_load_aux: impl_pointer_value -> integer -> integer -> list impl_mem_value -> impl_memM (list impl_mem_value)
let rec memcmp_load_aux ptrval offset max_offset acc =
  let uchar_ty = Basic (AilTypes.Integer (AilTypes.Unsigned AilTypes.Ichar)) in
  if offset >= max_offset then
    return (List.reverse acc)
  else
    let ptrval' = impl_array_shift_ptrval ptrval uchar_ty (IV Prov_none (IVconcrete offset)) in
    impl_load (Loc.other "memcmp_load_aux") uchar_ty ptrval' >>= fun (fp, mval) ->
    memcmp_load_aux ptrval (offset+1) max_offset (mval :: acc)

let rec memcmp_compare (mval1, mval2) : impl_memM integer =
  match (mval1, mval2) with
    | (MVinteger ity1 (IV _ (IVbyteof offset_ival1 mval1')), MVinteger ity2 (IV _ (IVbyteof offset_ival2 mval2'))) ->
        ifM "memcmp_compare(byte offsets)"
            (mk_iv_constr MC_eq offset_ival1 offset_ival2)
            (memcmp_compare (mval1', mval2'))
            (fail (MerrWIP "memcmp, two IVbyteof with different offsets"))
    | (MVpointer ref_ty1 ptrval1, MVpointer ref_ty2 ptrval2) ->
        address_expression_of_pointer ptrval1 >>= fun ival1 ->
        address_expression_of_pointer ptrval2 >>= fun ival2 ->
        ifM "memcmp_compare(two pointers equals?)"
          (mk_iv_constr MC_eq ival1 ival2)
          (return 0)
          begin
            ifM "memcmp_compare(two pointers equals?)"
                (mk_iv_constr MC_lt ival1 ival2)
                (return (0-1))
                (return 1)
          end
    | _ ->
        error "memcmp_compare"
  end

let rec fold_memcmp_compare mvals1 mvals2 ord_acc =
  if ord_acc = 0 then
    match (mvals1, mvals2) with
      | ([], []) ->
          return 0
      | (mval1 :: xs1, mval2 :: xs2) ->
          memcmp_compare (mval1, mval2) >>= fun ord ->
          fold_memcmp_compare xs1 xs2 ord
      | _ ->
          error "Impossible: fold_memcmp_compare"
    end
  else
    return ord_acc

  

let impl_memcmp ptr_val1 ptr_val2 size_ival =
  match size_ival with
    | IV _ (IVsizeof ty) ->
        impl_load (Loc.other "memcmp, 1st pointer") ty ptr_val1 >>= fun (fp1, mval1) ->
        impl_load (Loc.other "memcmp, 2nd pointer") ty ptr_val2 >>= fun (fp2, mval2) ->
        error "Mem.impl_memcmp"
    | IV _ (IVconcrete n) ->
        memcmp_load_aux ptr_val1 0 n [] >>= fun mvals1 ->
        memcmp_load_aux ptr_val2 0 n [] >>= fun mvals2 ->
        fold_memcmp_compare mvals1 mvals2 0 >>= fun ord ->
        return (IV Prov_none (IVconcrete ord))
(*
        mapM memcmp_compare (List.zip mvals1 mvals2) >>= fun xs ->
        return 
*)
    | _ ->
        error ("Mem.impl_memcmp 3 ==> " ^ stringFromInteger_value size_ival)
  end
