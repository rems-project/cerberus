(* TODO: A negative precision argument is taken as if the precision were omitted. *)
open import Pervasives Global
import String_extra

open import Monadic_parsing
import Errors Core Core_ctype Mem Mem_aux
module Cty = Core_ctype

import Undefined
module U = Undefined


type flags = <|
  flag_minus: bool;
  flag_plus:  bool;
  flag_space: bool;
  flag_hash:  bool;
  flag_zero:  bool
|>

type field_width =
  | FW_num of nat
  | FW_asterisk

type precision =
  | P_num of nat
  | P_asterisk

type length_modifier =
  | LM_hh
  | LM_h
  | LM_l
  | LM_ll
  | LM_j
  | LM_z
  | LM_t
  | LM_L

type conversion_specifier =
  | CS_di
  | CS_o
  | CS_u
  | CS_x
  | CS_X
  | CS_c
  | CS_s
  | CS_p
  | CS_n
  | CS_percent

type conversion_specification = <|
  cp_flags:                flags;
  cp_field_width:          maybe field_width;
  cp_precision:            maybe precision;
  cp_length_modifier:      maybe length_modifier;
  cp_conversion_specifier: conversion_specifier
|>

type format_ =
  | F_text of list char
  | F_conv of conversion_specification
type format = list format_


val nonzero: parserM char
let nonzero =
  sat (function
    | #'1' -> true
    | #'2' -> true
    | #'3' -> true
    | #'4' -> true
    | #'5' -> true
    | #'6' -> true
    | #'7' -> true
    | #'8' -> true
    | #'9' -> true
    | _    -> false
  end)


val digit: parserM char
let digit =
  char #'0' <|> nonzero


val nonnegativeDecimalInteger: parserM nat
let nonnegativeDecimalInteger =
  nonzero    >>= fun c  ->
  many digit >>= fun cs ->
  return (foldl (fun acc n -> n + 10 * acc) 0 $ map (fun c -> String_extra.ord c - 48) (c::cs))


(* TODO: clang/gcc seems to allow 0, ie. this is not like a "C decimal integer constant" *)
val decimalInteger: parserM nat
let decimalInteger =
  many digit >>= fun cs ->
  return (foldl (fun acc n -> n + 10 * acc) 0 $ map (fun c -> String_extra.ord c - 48) cs)


val flags: parserM flags
let flags =
  many (char #'-' <|> char #'+' <|> char #' ' <|> char #'#' <|> char #'0') >>= fun xs ->
  return <|
    flag_minus= elem #'-' xs; flag_plus= elem #'+' xs;
    flag_space= elem #' ' xs; flag_hash= elem #'#' xs;
    flag_zero=  elem #'0' xs
  |>


val fieldWidth: parserM field_width
let fieldWidth =
  (char #'*' >> return FW_asterisk) <|>
  (nonnegativeDecimalInteger >>= fun n -> return $ FW_num n)


val precision: parserM precision
let precision =
      (char #'.' >> char #'*' >> return P_asterisk)
  <|> (char #'.' >> decimalInteger >>= fun n -> return $ P_num n)
  <|> (char #'.' >> return (P_num 0))


val lengthModifier: parserM length_modifier
let lengthModifier =
      (string [#'h'; #'h'] >> return LM_hh)
  <|> (char #'h'           >> return LM_h)
  <|> (char #'l'           >> return LM_l)
  <|> (string [#'l'; #'l'] >> return LM_l)
  <|> (char #'j'           >> return LM_j)
  <|> (char #'z'           >> return LM_z)
  <|> (char #'t'           >> return LM_t)
  <|> (char #'L'           >> return LM_L)


val conversionSpecifier: parserM conversion_specifier
let conversionSpecifier =
      (char #'d' <|> char #'i' >> return CS_di)
  <|> (char #'o' >> return CS_o)
  <|> (char #'u' >> return CS_u)
  <|> (char #'x' >> return CS_x)
  <|> (char #'X' >> return CS_X)
  <|> (char #'c' >> return CS_c)
  <|> (char #'s' >> return CS_s)
  <|> (char #'p' >> return CS_p)
  <|> (char #'n' >> return CS_n)
  <|> (char #'%' >> return CS_percent)


val conversionSpecification: parserM conversion_specification
let conversionSpecification =
  char #'%'                  >>
  flags                      >>= fun fs     ->
  optionMaybe fieldWidth     >>= fun fw_opt ->
  optionMaybe precision      >>= fun p_opt  ->
  optionMaybe lengthModifier >>= fun lm_opt ->
  conversionSpecifier        >>= fun cs     ->
  return <|
    cp_flags=                fs;
    cp_field_width=          fw_opt;
    cp_precision=            p_opt;
    cp_length_modifier=      lm_opt;
    cp_conversion_specifier= cs
  |>


val format: parserM format
let format =
  many (
        (many1 (sat (fun z -> z <> #'%')) >>= fun str -> return (F_text str))
    <|> (conversionSpecification >>= fun cs -> return (F_conv cs))
  )



(* if the given flags require it, prefix the given result of the conversion with
   a sign or space or convert it to an "alternative form".
   This correspond to the flags: + space # *)
val expand: flags -> list char -> list char
let expand fs str =
  if isPrefixOf [#'-'] str then
    str
  else if fs.flag_plus then
      #'+' :: str
  else if fs.flag_space then
    #' ' :: str
  else
    str
(* TODO # flag *)


(* justify the result of a conversion.
   This correspond to the flag: - 0
   ASSUMES that length str < fw *)
val justify: maybe precision -> conversion_specifier -> flags -> nat -> list char -> list char
let justify p_opt cspec fs fw str =
  let d = fw - length str in
  (* see (§7.21.6.1#6 flag 0) *)
  let j = if elem cspec [CS_di; CS_o; CS_u; CS_x; CS_X] then
            if fs.flag_zero && not (fs.flag_minus) && isNothing p_opt then #'0' else #' '
          else
            #' ' in
  if fs.flag_minus then
    str ++ replicate d j
  else
    replicate d j ++ str


(*
(*
val justify2: maybe precision -> conversion_specifier -> flags -> nat -> list char -> list char
let justify2 p_opt cspec fs fw str =
 *)
val justify2: conversion_specification -> list char -> list char
let justify2 cp str =
  (* length of the conversion once the flags '+' 'space' '#' are applied *)
  let l = length str + (if cp.cp_flags.flag_plus || cp.cp_flags.flag_space then 1 else 0) in
  
  (* the amount of justification that will be needed *)
  let d = match cp.cp_field_width with
    | Nothing          -> 0
    | Just (FW_num fw) -> if l < fw then fw - l else 0
    | Just FW_asterisk -> assert_false "TODO"
  end in
  
  (* the character used for the justification (see §7.21.6.1#6 flag 0) *)
  let j = if elem cp.cp_conversion_specifier [CS_di; CS_o; CS_u; CS_x; CS_X] then
            if cp.cp_flags.flag_zero && not (cp.cp_flags.flag_minus) && isNothing cp.cp_precision then #'0' else #' '
          else
            #' ' in
  if cp.cp_flags.flag_minus then
    expand cp.cp_flags (str ++ replicate d j)
  else
    (* TODO: find a better way *)
    match (j, str) with
      | (#'0', #'-' :: str') -> #'-' :: replicate d j ++ str'
      | _            ->         replicate d j ++ str
    end

*)

val isSignedConversion: conversion_specifier -> bool
let isSignedConversion = function
  | CS_di      -> true
  | CS_o       -> false
  | CS_u       -> false
  | CS_x       -> false
  | CS_X       -> false
  | CS_c       -> false
  | CS_s       -> false (* TODO: check *)
  | CS_p       -> false
  | CS_n       -> false (* TODO: check *)
  | CS_percent -> false
end

val applyFlagsAndPadding: bool -> flags -> maybe field_width -> list char -> list char
let applyFlagsAndPadding isSignedConversion fs fw_opt str =
  error "TODO: WIP"



val charFromDigit: bool -> natural -> char
let charFromDigit useUpper = function
  | 0  -> #'0'
  | 1  -> #'1'
  | 2  -> #'2'
  | 3  -> #'3'
  | 4  -> #'4'
  | 5  -> #'5'
  | 6  -> #'6'
  | 7  -> #'7'
  | 8  -> #'8'
  | 9  -> #'9'
  | 10 -> if useUpper then #'A' else #'a'
  | 11 -> if useUpper then #'B' else #'b'
  | 12 -> if useUpper then #'C' else #'c'
  | 13 -> if useUpper then #'D' else #'d'
  | 14 -> if useUpper then #'E' else #'e'
  | 15 -> if useUpper then #'F' else #'f'
end


let rec showNonNegativeWithBasis_aux acc useUpper b n =
  let (r,d) = (n / b, n mod b) in
  if r = 0 then
    charFromDigit useUpper d :: acc
  else
    showNonNegativeWithBasis_aux (charFromDigit useUpper d :: acc) useUpper b r

val showNonNegativeWithBasis: bool -> natural -> natural -> list char
let showNonNegativeWithBasis useUpper b n =
  if n < 0 then
    error "showNonNegativeWithBasis expects an non-negative integer"
  else
    showNonNegativeWithBasis_aux [] useUpper b n

let inline (>>=) = Mem.bind


(* TODO: need the length modifier to perform the loads using the proper ctype *)
val convert: (Core.pexpr -> either Errors.t (Undefined.t Core.value)) ->
             maybe precision -> maybe length_modifier -> conversion_specifier -> list Mem.pointer_value ->
             Mem.memM (either Errors.t (U.t (list char * list Mem.pointer_value)))
let convert full_core_eval prec_opt lm_opt cspec args =
  let prec = match prec_opt with
    | Just (P_num z) ->
        z
    | Just (P_asterisk) ->
        error "TODO: Output.convert, prec" (* TODO *)
    | Nothing ->
        1
  end in
  let aux ty cont =
    match args with
      | [] ->
          Mem.return $
            Right (U.undef [U.Insufficient_arguments_for_format])
      | arg :: args' ->
          Mem.load ty arg >>= fun mem_val ->
          (* TODO: this is wrong if "not (is_integer ty)" *)
          match maybe Nothing (comb Mem_aux.integerFromIntegerValue snd) (Mem_aux.integerValueFromMemValue mem_val) with
            | Nothing ->
                error "WIP: convert --> not integer"
            | Just n ->
                Mem.return $ Right (U.return (
                  if prec = 0 && n = 0 then
                    ([], args')
                  else
                    (cont n, args')
                ))
          end
    end in
  match cspec with
    | CS_di ->
        (* see (§7.21.6.1#8 d,i) *)
        let ty = match lm_opt with
          | Just LM_hh ->
              Cty.signed_char
          | Just LM_h ->
              Cty.signed_short
          | Just LM_l ->
              Cty.signed_long
          | Just LM_ll ->
              Cty.signed_long_long
          | Just LM_j ->
              Cty.intmax_t
          | Just LM_z ->
              Cty.size_t
          | Just LM_t ->
              Cty.ptrdiff_t
          | Just LM_L ->
              error "found a LM_l with a CS_di"
          | Nothing ->
              Cty.signed_int
        end in


        aux ty (fun n ->
          let str = showNonNegativeWithBasis false 10 (naturalFromInteger $ abs n) in
          (if n < 0 then (fun z -> #'-' :: z) else id) $ replicate (prec - length str) #'0' ++ str
        )
(*
        let prec = match prec_opt with
          | Just (P_num z)    -> z
          | Just (P_asterisk) -> error "TODO: output.lem 1" (* TODO *)
          | Nothing           -> 1
        end in
        match args with
          | arg :: args' ->
              Mem.load Cty.signed_int arg >>= fun mem_val ->
              match maybe Nothing (comb Mem_aux.integerFromIntegerValue snd) (Mem_aux.integerValueFromMemValue mem_val) with
                | Nothing ->
                    error "WIP: convert, CS_di --> not integer"
                | Just n ->
                    Mem.return $ if prec = 0 && n = 0 then
                      ([], args')
                    else
                      let str = showNonNegativeWithBasis false 10 (naturalFromInteger $ abs n) in
                      ((if n < 0 then (fun z -> #'-' :: z) else id) $ replicate (prec - length str) #'0' ++ str, args')
              end
          | _ -> error "found no argument to convert a %d or %i"
        end
*)
    
    | CS_o ->
        error "WIP: Output.convert, CS_o"
    | CS_u ->
        (* see (§7.21.6.1#8 o,u,x,X) *)
        aux Cty.unsigned_int (fun n ->
          (* TODO: conversion (n is unsigned int here) *)
          let str = showNonNegativeWithBasis false 10 (naturalFromInteger n) in
          replicate (prec - length str) #'0' ++ str
        )
    | CS_x ->
        (* see (§7.21.6.1#8 o,u,x,X) *)
        aux Cty.unsigned_int (fun n ->
          (* TODO: conversion (n is unsigned int here) *)
          let str = showNonNegativeWithBasis false 16 (naturalFromInteger n) in
          replicate (prec - length str) #'0' ++ str
        )

(*
        let prec = match prec_opt with
          | Just (P_num z)    -> z
          | Just (P_asterisk) -> error "TODO: output.lem 5" (* TODO *)
          | Nothing           -> 1
        end in
        match args with
          | arg :: args' ->
              Mem.load Cty.unsigned_int arg >>= fun mem_val ->
              match maybe Nothing (comb Mem_aux.integerFromIntegerValue snd) (Mem_aux.integerValueFromMemValue mem_val) with
                | Nothing ->
                    error "WIP: convert, CS_X --> not integer"
                | Just n ->
                    Mem.return $ if prec = 0 && n = 0 then
                      ([], args')
                    else
                      (* TODO: conversion (n is unsigned int here) *)
                      let str = showNonNegativeWithBasis false 16 (naturalFromInteger n) in
                      (replicate (prec - length str) #'0' ++ str, args')
              end
          | _ -> error "found no argument to convert an %X"
        end
*)
(*
    | CS_X ->
        (* see (§7.21.6.1#8 o,u,x,X) *)
        let prec = match prec_opt with
          | Just (P_num z)    -> z
          | Just (P_asterisk) -> error "TODO: output.lem 5" (* TODO *)
          | Nothing           -> 1
        end in
        match args with
          | arg :: args' ->
              Mem.load Cty.unsigned_int arg >>= fun mem_val ->
              match maybe Nothing (comb Mem_aux.integerFromIntegerValue snd) (Mem_aux.integerValueFromMemValue mem_val) with
                | Nothing ->
                    error "WIP: convert, CS_X --> not integer"
                | Just n ->
                    Mem.return $ if prec = 0 && n = 0 then
                      ([], args')
                    else
                      (* TODO: conversion (n is unsigned int here) *)
                      let str = showNonNegativeWithBasis true 16 (naturalFromInteger n) in
                      (replicate (prec - length str) #'0' ++ str, args')
              end
          | _ -> error "found no argument to convert an %X"
        end
*)
    | CS_c ->
        error "WIP: Output.convert, CS_c"
    | CS_s ->
        error "WIP: Output.convert, CS_s"
    | CS_p ->
        error "WIP: Output.convert, CS_p"
    | CS_n ->
        error "WIP: Output.convert, CS_n"
    | CS_percent ->
        error "WIP: Output.convert, CS_percent"
  end







val     printf_aux: (Core.pexpr -> either Errors.t (Undefined.t Core.value)) ->
                    list char -> format -> list Mem.pointer_value -> Mem.memM (either Errors.t (Undefined.t (list char)))
let rec printf_aux full_core_eval acc fs ptrvals =
  match (fs, ptrvals) with
    | ([], []) ->
        Mem.return $
          Right (U.return acc)
    | (F_text str :: fs, ptrvals) ->
        printf_aux full_core_eval (acc ++ str) fs ptrvals
    | (F_conv cp :: fs, ptrvals) ->
        convert full_core_eval cp.cp_precision cp.cp_length_modifier cp.cp_conversion_specifier ptrvals >>= function
          | Right (U.Defined (str, ptrvals')) ->
              let expanded  = expand cp.cp_flags str in
              let justified = match cp.cp_field_width with
                | Nothing ->
                    expanded
                | Just (FW_num fw) ->
                    if length expanded < fw then
                      justify cp.cp_precision cp.cp_conversion_specifier cp.cp_flags fw expanded
                    else
                      expanded
                | Just FW_asterisk ->
                    error "TODO: output.lem 6"
              end in
              printf_aux full_core_eval (acc ++ justified) fs ptrvals'
          | Right (U.Error loc str) ->
              Mem.return $ Right (U.Error loc str)
          | Right (U.Undef ubs) ->
              Mem.return $ Right (U.Undef ubs)
          | Left err ->
              Mem.return $ Left err
        end
    | _ ->
        error "Output.printf_aux"
  end



val printf: (Core.pexpr -> either Errors.t (Undefined.t Core.value)) ->
            list char -> list Mem.pointer_value -> Mem.memM (either Errors.t (Undefined.t (list char)))
let printf full_core_eval frmt args =
  match parse format frmt with
    | [(fs, [])] ->
        printf_aux full_core_eval [] fs args
    | _ ->
        Mem.return $
          Right (U.undef [U.Invalid_format (String.toString frmt)])
  end
















(*

(* TODO: hack *)
open Core_ctype
(*
import Memory_order
module Cmm = Memory_order
*)




(* TODO: this could be refactored, but we are limited by lem's pattern matching I std closeness is more important *)
(* TODO: the first argument (load) is a bit silly but avoid module cycle *)
val convert: (ctype -> Memory.mem_addr -> E.t (Cmm_aux_old.cvalue * E.taction_id)) ->
             maybe precision -> conversion_specifier -> list Memory.mem_addr -> E.t (list char * list Memory.mem_addr)
let convert load p_opt cspec args =
  match cspec with
    | CS_di ->
        (* see (§7.21.6.1#8 d,i) *)
        let p = match p_opt with
          | Just (P_num p)    -> p
          | Just (P_asterisk) -> error "TODO: output.lem 1" (* TODO *)
          | Nothing           -> 1
        end in
        match args with
          | arg :: args' -> do E
              (Cmm_aux_old.Mbase (Cmm_aux_old.Cint n), _) <- load (Basic (AilTypes.Integer (AilTypes.Signed (AilTypes.Int_)))) arg; in
                if p = 0 && n = 0 then
                  E.return ([], args')
                else do E
                  str <- showNonNegativeWithBasis false 10 (naturalFromInteger $ abs n); in
                    E.return ((if n < 0 then (fun z -> #'-' :: z) else id) $ replicate (p - length str) #'0' ++ str, args')
                  end
              end
          | _ -> error "found no argument to convert a %d or %i"
        end
    
    | CS_o ->
        (* see (§7.21.6.1#8 o,u,x,X) *)
        let p = match p_opt with
          | Just (P_num p)    -> p
          | Just (P_asterisk) -> error "TODO: output.lem 2" (* TODO *)
          | Nothing           -> 1
        end in
        match args with
          | arg :: args' -> do E
              (Cmm_aux_old.Mbase (Cmm_aux_old.Cint n), _) <- load (Basic (AilTypes.Integer (AilTypes.Unsigned (AilTypes.Int_)))) arg; in
                if p = 0 && n = 0 then
                  E.return ([], args')
                else do E
                  (* TODO: conversion (n is unsigned int here) *)
                  str <- showNonNegativeWithBasis false 8 (naturalFromInteger n); in
                    E.return (replicate (p - length str) #'0' ++ str, args')
                  end
              end
          | _ -> error "found no argument to convert an %o"
        end
    
    | CS_u ->
        (* see (§7.21.6.1#8 o,u,x,X) *)
        let p = match p_opt with
          | Just (P_num p)    -> p
          | Just (P_asterisk) -> error "TODO: output.lem 3" (* TODO *)
          | Nothing           -> 1
        end in
        match args with
          | arg :: args' -> do E
              (Cmm_aux_old.Mbase (Cmm_aux_old.Cint n), _) <- load (Basic (AilTypes.Integer (AilTypes.Unsigned (AilTypes.Int_)))) arg; in
                if p = 0 && n = 0 then
                  E.return ([], args')
                else do E
                  (* TODO: conversion (n is unsigned int here) *)
                  str <- showNonNegativeWithBasis false 10 (naturalFromInteger n); in
                    E.return (replicate (p - length str) #'0' ++ str, args')
                  end
              end
          | _ -> error "found no argument to convert an %u"
        end
    
    | CS_x ->
        (* see (§7.21.6.1#8 o,u,x,X) *)
        let p = match p_opt with
          | Just (P_num p)    -> p
          | Just (P_asterisk) -> error "TODO: output.lem 4" (* TODO *)
          | Nothing           -> 1
        end in
        match args with
          | arg :: args' -> do E
              (Cmm_aux_old.Mbase (Cmm_aux_old.Cint n), _) <- load (Basic (AilTypes.Integer (AilTypes.Unsigned (AilTypes.Int_)))) arg; in
                if p = 0 && n = 0 then
                  E.return ([], args')
                else do E
                  (* TODO: conversion (n is unsigned int here) *)
                  str <- showNonNegativeWithBasis false 16 (naturalFromInteger n); in
                    E.return (replicate (p - length str) #'0' ++ str, args')
                  end
              end
          | _ -> error "found no argument to convert an %x"
        end
    
    | CS_X ->
        (* see (§7.21.6.1#8 o,u,x,X) *)
        let p = match p_opt with
          | Just (P_num p)    -> p
          | Just (P_asterisk) -> error "TODO: output.lem 5" (* TODO *)
          | Nothing           -> 1
        end in
        match args with
          | arg :: args' -> do E
              (Cmm_aux_old.Mbase (Cmm_aux_old.Cint n), _) <- load (Basic (AilTypes.Integer (AilTypes.Unsigned (AilTypes.Int_)))) arg; in
                if p = 0 && n = 0 then
                  E.return ([], args')
                else do E
                  (* TODO: conversion (n is unsigned int here) *)
                  str <- showNonNegativeWithBasis true 16 (naturalFromInteger n); in
                    E.return (replicate (p - length str) #'0' ++ str, args')
                  end
              end
          | _ -> error "found no argument to convert an %X"
        end
    
    | CS_c ->
        (* see (§7.21.6.1#8 c) *)
        error "WIP: CS_c" (* Need to look at lengthModifier *)
    
    | CS_s ->
        (* see (§7.21.6.1#8 s) *)
        (* TODO: ignoring lengthModifier for now *)
        match args with
          | arg :: args' -> do E
              (Cmm_aux_old.Mbase (Cmm_aux_old.Cstring str), _) <- load (Pointer (Basic (AilTypes.Integer (AilTypes.Char)))) arg; in
              (* TODO: should fix the lexing of C string instead of hacking here *)
              E.return (take (length str - 2) $ drop 1 str, args')
            end
          | _ -> error "found no argument to convert an %s"
        end
    
    | CS_p ->
        (* see (§7.21.6.1#8 p) *)
        error "WIP: CS_p" (* Implementation defined *)
    
    | CS_n ->
        (* see (§7.21.6.1#8 n) *)
        error "WIP: CS_n"
    
    | CS_percent ->
        (* see (§7.21.6.1#8 %) *)
        E.return ([#'%'], args)
  end


(* TODO asterisks *)
val formatted_print_aux: (ctype -> Memory.mem_addr -> E.t (Cmm_aux_old.cvalue * E.taction_id)) ->
                         list char -> format -> list Memory.mem_addr -> E.t (list char)
let rec formatted_print_aux load acc fs ns =
  match (fs, ns) with
    | ([], []) ->
        E.return acc
    | (F_text str :: fs, ns) ->
        formatted_print_aux load (acc ++ str) fs ns
    | (F_conv cp :: fs, ns) -> do E
        (str, ns') <- convert load cp.cp_precision cp.cp_conversion_specifier ns; in

          let expanded  = expand cp.cp_flags str in
          let justified = match cp.cp_field_width with
            | Nothing ->
                expanded
            | Just (FW_num fw) ->
                if length expanded < fw then
                  justify cp.cp_precision cp.cp_conversion_specifier cp.cp_flags fw expanded
                else
                  expanded
            | Just FW_asterisk ->
                error "TODO: output.lem 6"
          end in
          formatted_print_aux load (acc ++ justified) fs ns'

(*

TODO: new

          let padded_str = applyFlagsAndPadding (isSignedConversion cp.cp_conversion_specifier) cp.cp_flags cp.cp_field_width str in
          formatted_print_aux load (acc ++ padded_str) fs ns'
 *)
        end
    | _ ->
        error $ "formatted_print_aux, " ^ string_of_natural (naturalFromNat $ length fs) ^ " conv and " ^
                       string_of_natural (naturalFromNat $ length ns) ^ " arguments remaining"
  end


val formatted_print: (ctype -> Memory.mem_addr -> E.t (Cmm_aux_old.cvalue * E.taction_id)) ->
                     list char -> list Memory.mem_addr -> E.t (list char)
let formatted_print load fmrt args =
  match parse format fmrt with
    | [(fs, [])] ->
        formatted_print_aux load [] fs args
    | _ ->
      error "failed to parse the format"
  end

(* END: actual implementation of printf *)


val printf: (ctype -> Memory.mem_addr -> E.t (Cmm_aux_old.cvalue * E.taction_id)) ->
            list char -> list Memory.mem_addr -> E.t (Core.expr E.taction_id)
let printf load frmt args =
  (* TODO: should fix the lexing of C string instead of hacking here *)
  let frmt = take (length frmt - 2) $ drop 1 frmt in
  do E
    str <- formatted_print load frmt args; in
      let str = String.toString str in
(*      let ()  = output_string str   in *)
      E.return $ Core.Eoutput str
    end



*)
