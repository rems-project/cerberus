(* "Core types for the pure side of things"*)
(* Real/Integer aren't used anymore *)
(* Loc ~ Pointer *)
(* lists/sets/tuples aren't used *)
(* AllocId ~ memory model stuff *)
(* types for terms in terms.ml *)

open Pp

type sign =
  | Signed
  | Unsigned
[@@deriving eq, ord]

type basetype =
  | Unit
  | Bool
  | Integer
  | Bits of sign * int
  | Real
  | Alloc_id
  | Loc
  | CType
  | Struct of Sym.t
  | Datatype of Sym.t
  | Record of member_types
  | Map of basetype * basetype
  | List of basetype
  | Tuple of basetype list
  | Set of basetype (* | Option of basetype *)
[@@deriving eq, ord]

and member_types = (Id.t * basetype) list

type t = basetype

val equal : t -> t -> bool

val compare : t -> t -> int

(* This seems to require that variables aren't simply unique to the constructor, but to
   the entire datatype declaration. This is weird, and is probably an arbitrary
   restriction that should be lifted, but it will require effort. *)
type datatype_info =
  { dt_constrs : Sym.t list;
    dt_all_params : member_types
  }

type constr_info =
  { c_params : member_types;
    c_datatype_tag : Sym.t
  }

val cons_dom_rng : constr_info -> t * t

val pp : t -> document

(* | Option t -> !^"option" ^^ angles (pp t) *)

val contained : t -> t list 

val containeds : t list -> t list

val json : t -> Yojson.Safe.t

val struct_bt : t -> Sym.t

val record_bt : t -> Sym.t

val is_map_bt : t -> t * t option

val map_bt : t -> t * t

val is_datatype_bt : t -> Sym.t option

val datatype_bt : t -> Sym.t

val is_list_bt : t -> t option

val is_tuple_bt : t -> t list option

val is_bits_bt : t -> (sign * int) option

val make_map_bt : t -> t -> t

val of_sct : (Cerb_frontend.IntegerType.integerType -> bool) -> (Cerb_frontend.IntegerType.integerType -> int) -> Sctypes.ctype -> t

val uintptr_bt : (Cerb_frontend.IntegerType.integerType -> bool) -> (Cerb_frontend.IntegerType.integerType -> int) -> t


val intptr_bt  : (Cerb_frontend.IntegerType.integerType -> bool) -> (Cerb_frontend.IntegerType.integerType -> int) -> t


val size_bt  : (Cerb_frontend.IntegerType.integerType -> bool) -> (Cerb_frontend.IntegerType.integerType -> int) -> t

val hash : t -> int


(* checking/coercing numeric literals into bits range *)
val bits_cardinality : int -> Z.t

val bits_range : sign * int -> Z.t * Z.t


val fits_range : sign * int -> Z.t -> bool


val normalise_to_range : sign * int -> Z.t -> Z.t


val normalise_to_range_bt : t -> Z.t -> Z.t


val pick_integer_encoding_type : Z.t -> t option