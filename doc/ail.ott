indexvar k, j ::=  {{ com index variables }}

metavar n  ::=  {{ com integer constants }}
metavar id ::=  {{ com identifiers }}


grammar
storage_duration :: '' ::=
  {{ com storage duration (\S6.2.4\#1) }}
  | static    :: :: STATIC
  | thread    :: :: THREAD
  | automatic :: :: AUTOMATIC
  | allocated :: :: ALLOCATED % TODO: look at (§7.22.3)


integer_base_type :: '' ::=
  {{ com standard signed integer types (\S6.2.5\#4) }}
  | ichar     :: :: ICHAR     {{ com corresponds to \textbf{signed/unsigned char} }}
  | short     :: :: SHORT     {{ com corresponds to \textbf{short int}            }}
  | int       :: :: INT       
  | long      :: :: LONG      {{ com corresponds to \textbf{long int}             }}
  | long long :: :: LONG_LONG {{ com corresponds to \textbf{long long int}        }}

integer_type :: '' ::=
  {{ com integer types (\S6.2.5\#17) }} % TODO: add enumerated types
  | bool                        :: :: BOOL     {{ com corresponds to \textbf{\_Bool} }}
  | signed integer_base_type    :: :: SIGNED
  | unsigned integer_base_type  :: :: UNSIGNED

basic_type :: '' ::=
  {{ com basic types (\S6.2.5\#14) }}
  | char         :: :: CHAR
  | integer_type :: :: INTEGER

qualifier :: '' ::=
  {{ com type qualifiers (\S6.7.3) }}
  | const    :: :: CONST
  | restrict :: :: RESTRICT
  | volatile :: :: VOLATILE
  | atomic   :: :: ATOMIC   {{ com \textbf{\_Atomic} in C }}

qualifiers :: '' ::=
  | qualifier1 .. qualifierk :: :: Qualifiers


ty {{ tex \tau }} :: '' ::=
  {{ com $\texttt{Ail}_\tau$ types }}
  | qualifiers void               :: :: VOID             {{ com \texttt{void} type (\S6.2.5\#19) }}
  | qualifiers basic_type         :: :: BASIC            {{ com  basic types       (\S6.2.5\#14) }}
%  | enum
  | ty [ n ]                      :: :: ARRAY            {{ com  array types       (\S6.2.5\#20) }}
%  | struct 
%  | union
  | ty ( ty1 , .. , tyk )         :: :: FUNCTION         {{ com  function types                  }}
  | qualifiers ty *               :: :: POINTER          {{ com  pointer types                   }}
% atomic types
  | lvalue ty                     :: :: LVALUE           {{ com  }}
  | bitfield ty                   :: :: BITFIELD         {{ com  }}


% TODO: member declarator


% TODO: type_class

% TODO: declaration


aop {{ tex \bullet }} :: '' ::= {{ com arithmetic operators }}
  | *   :: :: MULT {{ tex \texttt{*}                }} {{ com multiplication       (\S6.5.5)  }}
  | /   :: :: DIV  {{ tex \texttt{/}                }} {{ com division                        }}
  | %   :: :: MOD  {{ tex \texttt{\%}               }} {{ com modulo operator                 }}
  | +   :: :: ADD  {{ tex \texttt{+}                }} {{ com addition             (\S6.5.6)  }}
  | -   :: :: SUB  {{ tex \texttt{-}                }} {{ com substraction                    }}
  | <<  :: :: SHL  {{ tex \texttt{<<}               }} {{ com bitwise left shift   (\S6.5.7)  }}
  | >>  :: :: SHR  {{ tex \texttt{>>}               }} {{ com bitwise right shift             }}
  | &   :: :: BAND {{ tex \texttt{\&}               }} {{ com bitwise AND          (\S6.5.10) }}
  | ^   :: :: XOR  {{ tex \texttt{\textasciicircum} }} {{ com bitwise exclusive OR (\S6.5.11) }}
  | |   :: :: BOR  {{ tex \texttt{|}                }} {{ com bitwise inclusive OR (\S6.5.12) }}

bop {{ tex \star }} :: '' ::= {{ com binary operators }}
  | aop :: :: ARITHMETIC 
  | ,   :: :: COMMA      {{ tex \texttt{,}    }} {{ com comma operator (\S6.5.17) }}
  | &&  :: :: AND        {{ tex \texttt{\&\&} }} {{ com logical AND    (\S6.5.13) }}
  | ||  :: :: OR         {{ tex \texttt{||}   }} {{ com logical OR     (\S6.5.14) }}
  | <   :: :: LT         {{ tex \texttt{<}    }} {{ com less than      (\S6.5.8)  }}
  | >   :: :: GT         {{ tex \texttt{<}    }} {{ com greater than              }}
  | <=  :: :: LE         {{ tex \texttt{<=}   }} {{ com less than or equal to     }}
  | >=  :: :: GE         {{ tex \texttt{>=}   }} {{ com greater than or equal to  }}
  | ==  :: :: EQ         {{ tex \texttt{==}   }} {{ com equal to       (\S6.5.9)  }}
  | !=  :: :: NE         {{ tex \texttt{!=}   }} {{ com not equal to              }}

uop :: '' ::=
  {{ com unary operators (6.5.3) }}
  {{ tex \diamond }}
  | &  :: :: ADDRESS     {{ tex \texttt{\&}   }} {{ com address operator }}
  | *  :: :: INDIRECTION {{ tex \texttt{*}    }} {{ com indirection operator }}
  | +  :: :: PLUS        {{ tex \texttt{+}    }}
  | -  :: :: MINUS       {{ tex \texttt{-}    }} {{ com negation }}
  | ~  :: :: BNOT        {{ tex \mathtt{\sim} }} {{ com bitwise negation }} % TODO: the typesetting is ugly
%  | ++ :: :: POSTFIX_DECR
%  | -- :: :: POSTFIX_DECR

% integer_constant

% constant


constant :: '' ::=
  {{ com TODO: the other constants }}
  | n  :: :: CONST_INT  {{ com integer constant }}
%  | CONST_FLOAT of string
  | id :: :: CONST_ENUM {{ com enumeration constant }}
%  | CONST_CHAR of int64 list
%  | CONST_WCHAR of int64 list

expression, E :: '' ::=
  | uop E                      :: :: UNARY
  | E ++                       :: :: INCR % TODO: K don't know how to put them in uop while telling
                                           %       the parser expect ++ and -- after the expr.
  | E --                       :: :: DECR
  | E1 bop E2                  :: :: BINARY
  | E1 aop = E2                :: :: ASSIGN
  | E1 ? E2 : E3               :: :: CONDITIONAL
  | ( ty ) E                   :: :: CAST
  | E ( ty1 E1 , .. , tyk Ek ) :: :: CALL
  | E . id                     :: :: MEMBEROF
  | E -> id                    :: :: MEMBEROFPTR
  | constant                   :: :: CONSTANT
  | id                         :: :: VARIABLE
  | sizeof ( ty )              :: :: SIZEOF
  | alignof ( ty )             :: :: ALIGNOF

% E_tau :: 'E_tau_' ::=
%   {{ tex E_\tau }}
%   | E : ty :: :: Expr


% TODO: definitions




S :: '' ::=
  | skip                                         :: :: SKIP
  | E                                            :: :: EXPRESSION
  | begin vars id1 , .. , idk ; S1 ; .. ; Sj end :: :: BLOCK {{ com TODO: check }}
  | if E then S1 else S2                         :: :: IF
  | while E do S done                            :: :: WHILE
  | do S while ( E )                             :: :: DO
  | break                                        :: :: BREAK
  | continue                                     :: :: CONTINUE
  | returnvoid                                   :: :: RETURN_VOID
  | return E                                     :: :: RETURN_EXPRESSION
  | switch ( E ) S                               :: :: SWITCH
  | case constant : S                            :: :: CASE
  | default : S                                  :: :: DEFAULT
  | id : S                                       :: :: LABEL
  | goto id                                      :: :: GOTO
  % | DECLARATION of 'a definition list
















terminals :: 'terminals_' ::=
  | |-                  ::   :: turnstile  {{ tex \vdash }}
  | !=                  ::   :: neq

atom :: 'atom_' ::=
  | ty :: :: Ty
  | promote ty                 :: :: PROMOTE          {{ com integer promotion }}
  | usualArithmetic ty1  ty2  :: :: USUAL_ARITHMETIC

  | id :: :: Id

formula :: 'formula_' ::=          
  | judgement            :: :: judgement
  | atom1 = atom2        :: :: eq
  | atom1 != atom2       :: :: neq {{ tex [[atom1]] \neq [[atom2]] }}
  | formula1 /\ formula2 :: :: and {{ tex [[formula1]] \wedge [[formula2]] }}
  | formula1 \/ formula2 :: :: or  {{ tex [[formula1]] \vee [[formula2]] }}


  G {{ tex \Gamma }} :: 'G_' ::=
    | empty     :: :: base {{ tex \emptyset }}
    | G , id : ty :: :: ctor

parsing

formula_and <= formula_eq
formula_and <= formula_neq
formula_or <= formula_and



defns
  Jtype :: '' ::=
  % [integer types, real types] (6.2.5#17)
  % 
  % "The type *char*, the signed and unsigned integer types, and the enumerated
  %  types are collectively called `integer types`. The integer and real floating
  %  types are collectively called `real types`."
  defn is_integer ( ty ) :: :: is_integer :: integer_ {{ com (6.2.5\#17) }} by
  
  % [arithmetic types] (6.2.5#18)
  % 
  % "Integer and floating types are collectively called `arithmetic types`.
  %  (...)"
  defn is_arithmetic ( ty ) :: :: is_arithmetic :: arith by
  
  
% defn
% isObject ( ty ) :: :: isObject :: isObject_ by

% defn
% isModifiable ( ty ) :: :: isModifiable :: isModifiable_ by

% defn
% isScalar ( ty ) :: :: isScalar :: isScalar_ by

% defn
% isCompatibleUnqualified ( ty1 , ty2 ) :: :: isCompatibleUnqualified :: isCompatibleUnqualified_ by

% defn
% isNullPtrConstant ( E ) :: :: isNullPtrConstant :: isNullPtrConstant_ by



  defn G |- E : ty :: :: Ty :: Ty_ by 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% A.VARIABLE


% A.CALL


% A.CONSTANT (C.CONST_INT (i, None))


% A.CONSTANT (C.CONST_INT (_, Some suffix))


    % A.UNARY A.ADDRESS
    % ------------------------------------------------------------------------ %
    % [& - address operator]                                                   %
    % TODO
    
    (§6.5.3.2#1) "The operand of the unary & operator shall be either a function designator, the result of a [] or unary * operator, or an lvalue that designates an object that is not a bit-field and is not declared with the register storage-class specifier."
    
    
    
    
    
    
    
    % ------------------------------------------------------------------------ %
    % [* - indirection operator]                                               %
    % TODO
    G |- E : qualifiers ty*
    isObject(ty)
    ty' = promote ty
    ----------------------- :: UnaryIndirection
         G |- *E : ty'
    
    
    
    
    
    % ------------------------------------------------------------------------ %
    % [unary +]                                                                %
    % (§6.5.3.3#1) "The operand of the unary + [...] operator shall have       %
    %               arithmetic type;"                                          %
    % (§6.5.3.3#2) "[...] and the result has the promoted type."               %
    G |- E : ty
    is_arithmetic(ty)
    ty' = promote ty
    ----------------- :: UnaryPlus
    G |- +E : ty'
    
    % ------------------------------------------------------------------------ %
    % [unary -]                                                                %
    % (§6.5.3.3#1) "The operand of the unary [...] - operator shall have       %
    %               arithmetic type;"                                          %
    % (§6.5.3.3#3) "[...] and the result has the promoted type."               %
    G |- E : ty
    is_arithmetic(ty)
    ty' = promote ty
    ----------------- :: UnaryMinus
    G |- -E : ty'
    
    
    % ------------------------------------------------------------------------ %
    % [unary ~]                                                                %
    % (§6.5.3.3#1) "The operand [...] of the unary ~ operator, integer type;"  %
    % (§6.5.3.3#4) "[...] and the result has the promoted type."               %
    |- E : ty
    is_integer(ty)
    ty' = promote ty 
    ---------------- :: UnaryBnot
      G |- ~E : ty'
    
    % REMARK ----------------------------------------------------------------- %
    %   In addition to the unary operator present in Ail, Cabs has the         %
    %   ! operator requiring an operand of scalar type and whose result type   %
    %   is [int]. During the desugaring, expressions of the form [!E] are      %
    %   translated to [E==0] (as described in §6.5.3.3#5).                     %
    %   This translation is typesafe: assume the type of [E] is not a scalar   %
    %   type, then by definition (§6.2.5#21) isn't an arithmetic type nor a    %
    %   pointer type. Hence the translated expression is ill-typed (see typing %
    %   of the equality operator). Otherwise the translated expression verify  %
    %   one of the following typing constraint of the equality operator        %
    %   (§6.5.9#2):                                                            %
    %     - both operands have arithmetic type                                 %
    %     - one operand is a pointer and the other is a null pointer constant. %
    %   as 0 is a null pointer constant (§6.3.2.3#3)                           %
    % ------------------------------------------------------------------------ %
    
    






% A.UNARY A.POSTFIX_INCR

% A.UNARY A.POSTFIX_DECR


% not isFunction(ty)
% not isIncomplete(ty)
% -------------------------
% |- sizeof(ty) : (A.T_EXP (A.BASIC {} (A.INTEGER (A.SIGNED A.INT))))


% not isFunction(ty)
% not isIncomplete(ty)
% -------------------------
% |- alignof(ty) : (A.T_EXP (A.BASIC {} (A.INTEGER (A.SIGNED A.INT))))


----------------- :: CastVoid
|- (void)E : void


% TODO: in the tex the ty1 and ty2 both appear as \tay
|- E : ty2
isScalar(ty1)
isScalar(ty2)
--------------------- :: Cast
|- (ty1)E : ty1


|- E1 : ty1
|- E2 : ty2
is_arithmetic(ty1)
is_arithmetic(ty2)
-------------------------------------------- :: Mul
|- E1 * E2 : usualArithmetic(ty1, ty2)


|- E1 : ty1
|- E2 : ty2
is_arithmetic(ty1)
is_arithmetic(ty2)
-------------------------------------------- :: Div
|- E1 / E2 : usualArithmetic(ty1, ty2)


|- E1 : ty1
|- E2 : ty2
is_integer(ty1)
is_integer(ty2)
-------------------------------------------- :: Mod
|- E1 % E2 : usualArithmetic(ty1, ty2)


|- E1 : qualifiers *ty1
|- E2 : ty2
ty1 != void
isObject(ty1)
is_integer(ty2)
-------------------------------------------- :: Add_PtrInt
|- E1 + E2 : qualifiers *ty1


|- E1 : ty1
|- E2 : qualifiers *ty2
ty2 != void
is_integer(ty1)
isObject(ty2)
-------------------------------------------- :: Add_IntPtr
|- E1 + E2 : qualifiers *ty2

|- E1 : ty1
|- E2 : ty2
is_arithmetic(ty1)
is_arithmetic(ty2)
-------------------------------------------- :: Add_ArithArith
|- E1 + E2 : usualArithmetic(ty1, ty2)


% A.BINARY (C.ARITHMETIC C.SUB) e1 e2

|- E1 : ty1
|- E2 : ty2
is_integer(ty1)
is_integer(ty2)
ty' = promote ty1
-------------------------- :: SHL
|- E1 << E2 : ty'


|- E1 : ty1
|- E2 : ty2
is_integer(ty1)
is_integer(ty2)
ty' = promote ty1
-------------------------- :: SHR
|- E1 >> E2 : ty'


% TODO: parsing problem
|- E1 : qualifiers1 *ty1
|- E2 : qualifiers2 *ty2
isObject(ty1)
isObject(ty2)
isCompatibleUnqualified ( ty1 , ty2 )
-------------------------------- :: Lt_PtrPtr
|- E1 < E2 : signed int


% TODO: parsing problem
|- E1 : ty1
|- E2 : ty2
isReal(ty1)
isReal(ty2)
-------------------------------- :: Lt_RealReal
|- E1 < E2 : signed int


% TODO: parsing problem
|- E1 : qualifiers1 *ty1
|- E2 : qualifiers2 *ty2
isObject(ty1)
isObject(ty2)
isCompatibleUnqualified ( ty1 , ty2 )
-------------------------------- :: Gt_PtrPtr
|- E1 > E2 : signed int


% TODO: parsing problem
|- E1 : ty1
|- E2 : ty2
isReal(ty1)
isReal(ty2)
-------------------------------- :: Gt_RealReal
|- E1 > E2 : signed int


% TODO: parsing problem
|- E1 : qualifiers1 *ty1
|- E2 : qualifiers2 *ty2
isObject(ty1)
isObject(ty2)
isCompatibleUnqualified ( ty1 , ty2 )
-------------------------------- :: Le_PtrPtr
|- E1 <= E2 : signed int


% TODO: parsing problem
|- E1 : ty1
|- E2 : ty2
isReal(ty1)
isReal(ty2)
-------------------------------- :: Le_RealReal
|- E1 <= E2 : signed int


% TODO: parsing problem
|- E1 : qualifiers1 *ty1
|- E2 : qualifiers2 *ty2
isObject(ty1)
isObject(ty2)
isCompatibleUnqualified ( ty1 , ty2 )
-------------------------------- :: Ge_PtrPtr
|- E1 >= E2 : signed int


% TODO: parsing problem
|- E1 : ty1
|- E2 : ty2
isReal(ty1)
isReal(ty2)
-------------------------------- :: Ge_RealReal
|- E1 >= E2 : signed int


% A.BINARY C.EQ e1 e2


|- E1 : qualifiers1 *ty1
|- E2 : qualifiers2 *ty2
isCompatibleUnqualified ( ty1 , ty2 )
------------------------------------- :: Ne_PtrPtr1
|- E1 != E2 : signed int


|- E1 : qualifiers1 *ty1
|- E2 : qualifiers2 *ty2
ty1 = void /\ isObject(ty2) \/ isObject(ty1) /\ ty2 = void
------------------------------------- :: Ne_PtrPtr2
|- E1 != E2 : signed int




  % | A.BINARY C.NE e1 e2 ->
  %     type_of e1 >>= fun t1 ->
  %     type_of e2 >>= fun t2 ->

  %     match (t1, t2) with
  %     | (A.POINTER _ b1, A.POINTER _ b2) ->
  %         if T.compatible_unqualified b1 b2 then
  %           E.return (A.T_EXP int) OK

  %         (* void pointer *)
  %         else if T.is_void b1 && T.is_object b2 then
  %           E.return (A.T_EXP int)
  %         else if T.is_object b1 && T.is_void b2 then
  %           E.return (A.T_EXP int)



% TODO: check
|- E1 : qualifiers1 *ty1
|- E2 : qualifiers2 *ty2
ty1 != void /\ ty2 != void
isNullPtrConstant(E1) \/ isNullPtrConstant(E2)
------------------------------------- :: Ne_PtrPtr3
|- E1 != E2 : signed int

  %         (* null pointer constant of pointer type*)
  %         else if is_null_pointer_constant e1 then
  %           E.return (A.T_EXP int)
  %         else if is_null_pointer_constant e2 then
  %           E.return (A.T_EXP int)

  %         else E.fail Type_error.NE_POINTERS

  %     (* null pointer constant of integer type *)
  %     | (A.POINTER _ _, _) ->
  %         if is_null_pointer_constant e2 then
  %           E.return (A.T_EXP int)
  %         else E.fail Type_error.NE_NULL_POINTER_CONSTANT_SECOND
  %     | (_, A.POINTER _ _) ->
  %         if is_null_pointer_constant e1 then
  %           E.return (A.T_EXP int)
  %         else E.fail Type_error.NE_NULL_POINTER_CONSTANT_FIRST

  %     | _ ->
  %         if T.is_arithmetic t1 then
  %           if T.is_arithmetic t2 then
  %             E.return (A.T_EXP int)
  %           else E.fail Type_error.NE_ARITHMETIC
  %         else E.fail Type_error.NE_ALL
  %     end


% ==================================
|- E1 : ty1
|- E2 : ty2
is_integer(ty1)
is_integer(ty2)
----------------------------------------- :: BAND
|- E1 & E2 : usualArithmetic( ty1 , ty2 )


|- E1 : ty1
|- E2 : ty2
is_integer(ty1)
is_integer(ty2)
----------------------------------------- :: XOR
|- E1 ^ E2 : usualArithmetic( ty1 , ty2 )

|- E1 : ty1
|- E2 : ty2
is_integer(ty1)
is_integer(ty2)
----------------------------------------- :: BOR
|- E1 | E2 : usualArithmetic( ty1 , ty2 )

|- E1 : ty1
|- E2 : ty2
isScalar(ty1)
isScalar(ty2)
------------------------------------------ :: AND
|- E1 && E2 : signed int

|- E1 : ty1
|- E2 : ty2
isScalar(ty1)
isScalar(ty2)
------------------------------------------ :: OR
|- E1 || E2 : signed int

% A.QUESTION e1 e2 e3

% A.ASSIGN None e1 e2

% A.ASSIGN (Some C.ADD) e1 e2

% A.ASSIGN (Some C.SUB) e1 e2

% A.ASSIGN (Some o) e1 e2

% A.BINARY C.COMMA e1 e2


% ------- DONE WITH EXPRESSIONS ---------
defn
|- [ S ] ok :: :: StmtOk :: 'StmtOk_' by 
  
  |- E : ty
  isScalar(ty)
  |- [S1] ok
  |- [S2] ok
  -------------------------- :: if
  |- [if E then S1 else S2] ok
  
  
  |- E : ty
  is_integer(ty)
  |- [S] ok
  ----------------------- :: switch
  |- [switch (E) S] ok
  
  
  |- E : ty
  isScalar(ty)
  |- [S] ok
  ----------------------- :: while
  |- [while E do S done] ok
  
  
  |- E : ty
  isScalar(ty)
  |- [S] ok
  ----------------------- :: do
  |- [do S while(E)] ok
  
  
  % BLOCK
  
  
  ------------- :: break
  |- [break] ok
  
  
  ------------- :: continue
  |- [continue] ok
  
  
  ------------- :: returnvoid
  |- [returnvoid] ok
  
  % return E
  % case n: S
  
  
      |- [S] ok
  ------------------ :: default
  |- [default: S] ok
  
  
    |- [S] ok
  ------------- :: label
  |- [id: S] ok
  
  
  --------------- :: goto
  |- [goto id] ok

