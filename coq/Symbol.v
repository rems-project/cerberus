(* Generated by Lem from frontend/model/symbol.lem. *)

From Coq Require Import Arith Bool List String.
Require Import Coq.ZArith.ZArith.

Require Import Coq.Numbers.BinNums.
Require Import Coq.FSets.FMapAVL.
Require Import Coq.Structures.OrderedType.
Require Import Coq.Structures.OrderedTypeEx.

Inductive identifier : Type :=
  | Identifier:  unit  ->  string  -> identifier .

Definition ident_equal (a b: identifier) : bool :=
  match a, b with
  | Identifier _ s1, Identifier _ s2 => String.eqb s1 s1
  end.

Inductive digest : Type := .

Inductive symbol_description : Type :=
  | SD_None: symbol_description
  | SD_Id:  string  -> symbol_description
  | SD_ObjectAddress:  string  -> symbol_description
  | SD_Return: symbol_description
  | SD_FunArg: unit  ->   nat  -> symbol_description .

(* Symbolic identifiers *)
Inductive sym : Set :=
  Symbol:  digest  ->  Z  ->  symbol_description  -> sym .


Definition digest_compare: digest -> digest -> Z.
Proof. admit. Admitted. (* TODO *)

Definition symbolEquality (sym1 sym2: sym): bool :=
  match sym1, sym2 with
  | Symbol d1 n1 _,  Symbol d2 n2 _ =>
      Z.eqb (digest_compare d1 d2) 0 && Z.eqb n1 n2
  end.

(*
(* for [@@deriving eq] *)
Definition equal_sym   : sym  -> sym  -> bool :=  symbolEquality.
(* [?]: removed value specification. *)

Definition symbol_compare  (s : sym ) (s0 : sym )  : ordering :=
  match ( (s,s0)) with (( Symbol d1 n1 _), ( Symbol d2 n2 _)) =>
    if Z.eqb (FAKE_COQ.digest_compare d1 d2)
         ((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) then
      (genericCompare nat_ltb Nat.eqb n1 n2) else
      let cmp := FAKE_COQ.digest_compare d1 d2 in
      if int_ltb cmp ((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) then LT else
        if Z.eqb cmp ((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) then EQ else GT
  end.
(* for [@@ deriving ord] *)
Definition compare_sym   : sym  -> sym  -> ordering :=  symbol_compare.
*)

(* TODO: implement all methods! *)
Module Symbol_sym_as_OT <: UsualOrderedType.
  Definition t := Symbol.sym.

  Definition eq : t -> t -> Prop := @eq t. (* TODO *)
  Definition lt : t -> t -> Prop := fun _ _ => False. (* TODO *)

  Definition eq_refl := @eq_refl t. (* TODO *)
  Definition eq_sym := @eq_sym t. (* TODO *)
  Definition eq_trans := @eq_trans t. (* TODO *)

  Axiom lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z. (* TODO *)
  Axiom lt_not_eq : forall x y : t, lt x y -> ~ eq x y. (* TODO *)

  Definition compare : forall x y : t, Compare lt eq x y.
  Proof. admit. Admitted.

  Lemma eq_dec : forall x y : t, {eq x y} + {~ eq x y}.
  Proof. admit. Admitted.

End Symbol_sym_as_OT.

Module SymMap := FMapAVL.Make(Symbol_sym_as_OT).


(*
Instance x8_Eq : Eq sym := {
   isEqual             :=  (fun  sym1  sym2=>match ( (sym1, sym2)) with
    | (Symbol d1 n1 sd1,  Symbol d2 n2 sd2) =>
        if Z.eqb (FAKE_COQ.digest_compare d1 d2)((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) && Nat.eqb n1 n2 then
          if nat_gteb (FAKE_COQ.get_level tt)( 5%nat) && unsafe_structural_inequality sd1 sd2 then
  match ( FAKE_COQ.print_debug ( 5%nat) []
            (fun u =>
               match ( (u) ) with ( tt) =>
                 String.append
                   "[Symbol.symbolEqual] suspicious equality ==> "
                   (String.append (show_symbol_description sd1)
                      (String.append " <-> " (show_symbol_description sd2)))
               end)) with tt => true end
          else
            true
        else
          false
  end);
   isInequal   sym1  sym2 :=  negb (match ( (sym1, sym2)) with
    | (Symbol d1 n1 sd1,  Symbol d2 n2 sd2) =>
        if Z.eqb (FAKE_COQ.digest_compare d1 d2)((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) && Nat.eqb n1 n2 then
          if nat_gteb (FAKE_COQ.get_level tt)( 5%nat) && unsafe_structural_inequality sd1 sd2 then
  match ( FAKE_COQ.print_debug ( 5%nat) []
            (fun u =>
               match ( (u) ) with ( tt) =>
                 String.append
                   "[Symbol.symbolEqual] suspicious equality ==> "
                   (String.append (show_symbol_description sd1)
                      (String.append " <-> " (show_symbol_description sd2)))
               end)) with tt => true end
          else
            true
        else
          false
  end)
}.


Instance x7_Ord : Ord sym := {
   compare   sym1  sym2 :=
  match ( sym1) with ( Symbol d1 n1 _) =>
    match ( sym2) with ( Symbol d2 n2 _) =>
      if Z.eqb (FAKE_COQ.digest_compare d1 d2)
           ((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) then
        (genericCompare nat_ltb Nat.eqb n1 n2) else
        let cmp := FAKE_COQ.digest_compare d1 d2 in
        if int_ltb cmp ((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) then
        LT else
          if Z.eqb cmp ((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) then
          EQ else GT end end;
   isLess   sym1  sym2 :=
  match ( sym1) with ( Symbol d1 n1 _) =>
    match ( sym2) with ( Symbol d2 n2 _) =>
      int_ltb (FAKE_COQ.digest_compare d1 d2)
        ((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) ||
      ( Z.eqb (FAKE_COQ.digest_compare d1 d2)
          ((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) && nat_ltb n1 n2) end end;
   isLessEqual   sym1  sym2 :=
  match ( sym1) with ( Symbol d1 n1 _) =>
    match ( sym2) with ( Symbol d2 n2 _) =>
      int_lteb (FAKE_COQ.digest_compare d1 d2)
        ((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) ||
      ( Z.eqb (FAKE_COQ.digest_compare d1 d2)
          ((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) && nat_lteb n1 n2) end end;
   isGreater   sym1  sym2 :=
  match ( sym1) with ( Symbol d1 n1 _) =>
    match ( sym2) with ( Symbol d2 n2 _) =>
      int_gtb (FAKE_COQ.digest_compare d1 d2)
        ((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) ||
      ( Z.eqb (FAKE_COQ.digest_compare d1 d2)
          ((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) && nat_gtb n1 n2) end end;
   isGreaterEqual   sym1  sym2 :=
  match ( sym1) with ( Symbol d1 n1 _) =>
    match ( sym2) with ( Symbol d2 n2 _) =>
      int_gteb (FAKE_COQ.digest_compare d1 d2)
        ((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) ||
      ( Z.eqb (FAKE_COQ.digest_compare d1 d2)
          ((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) && nat_gteb n1 n2) end end
}.


Instance x6_NumSucc : NumSucc sym := {
   succ   sym :=  match ( sym) with ( Symbol d n sd) =>
   Symbol d (Coq.Init.Peano.plus n ( 1%nat)) sd end
}.


Instance x5_SetType : SetType sym := {
   setElemCompare   sym1  sym2 :=  ordCompare sym1 sym2
}.


Definition show_symbol  (sym1 : sym )  : string :=
  match ( sym1) with Symbol d n sd =>
    String.append "Symbol"
      (stringFromPair lem_string_extra.stringFromNat show_symbol_description
         (n, sd)) end.

Instance x4_Show : Show sym := {
   show  :=  show_symbol
}.


Definition show_raw_less  (s : sym )  : string :=
  match ( (s)) with (( Symbol _ n sd)) =>
    String.append "Symbol("
      (String.append (lem_string_extra.stringFromNat n)
         (String.append ", " (String.append (show_symbol_description sd) ")")))
  end.
Definition show_raw  (s : sym )  : string :=
  match ( (s)) with (( Symbol d n sd)) =>
    String.append "Symbol("
      (String.append (FAKE_COQ.string_of_digest d)
         (String.append ", "
            (String.append (lem_string_extra.stringFromNat n)
               (String.append ", "
                  (String.append (show_symbol_description sd) ")"))))) end.

*)

(* Location prefix *)
Inductive prefix : Type :=
  | PrefSource:  unit  ->  list  sym  -> prefix
  | PrefFunArg:  unit  ->  digest  ->  Z  -> prefix
  | PrefStringLiteral:  unit  ->  digest  -> prefix
  | PrefCompoundLiteral:  unit  ->  digest  -> prefix
  | PrefMalloc: prefix
| PrefOther:  string  -> prefix .

(*
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition digest_of_sym  (s : sym )  : digest :=
  match ( (s)) with (( Symbol dig _ _)) => dig end.
(* [?]: removed value specification. *)

Definition fresh   tt  : sym :=
  Symbol (FAKE_COQ.digesttt) (FAKE_COQ.fresh_int tt) SD_None.
(* [?]: removed value specification. *)

Definition fresh_pretty  (str : string )  : sym :=
  Symbol (FAKE_COQ.digesttt) (FAKE_COQ.fresh_int tt) (SD_Id str).
(* [?]: removed value specification. *)

Definition fresh_pretty_with_id  (mkStr : nat  -> string )  : sym :=
  let id := FAKE_COQ.fresh_int tt in
  Symbol (FAKE_COQ.digesttt) id (SD_Id (mkStr id)).
(* [?]: removed value specification. *)

Definition fresh_fancy   : option (string )  -> sym :=
  fun (x : option (string ) ) =>
    match (x) with | Some str => fresh_pretty str | None => fresh tt end.

Definition fresh_object_address  (name1 : string )  : sym :=
  Symbol (FAKE_COQ.digesttt) (FAKE_COQ.fresh_int tt) (SD_ObjectAddress name1).

Definition fresh_funarg  (loc : unit ) (i : nat )  : sym :=
  Symbol (FAKE_COQ.digest tt) (FAKE_COQ.fresh_int tt) (SD_FunArg loc i).

Definition fresh_description  (sd : symbol_description )  : sym :=
  Symbol (FAKE_COQ.digest tt) (FAKE_COQ.fresh_int tt) sd.

Definition set_symbol_description  (s : sym ) (sd : symbol_description )  : sym :=
  match ( (s,sd)) with (( Symbol d n _),  sd) => Symbol d n sd end.
(* [?]: removed value specification. *)

Definition from_same_translation_unit  (sym1 : sym ) (sym2 : sym )  : bool :=  Z.eqb((Z.pred (Z.pos (P_of_succ_nat 0%nat)))) (FAKE_COQ.digest_compare (digest_of_sym sym1) (digest_of_sym sym2)).


Definition symbol_description  (s : sym )  : symbol_description :=
  match ( (s)) with (( Symbol _ _ descr)) => descr end.
Definition symbol_num  (s : sym )  : nat :=
  match ( (s)) with (( Symbol _ num _)) => num end.
 *)
