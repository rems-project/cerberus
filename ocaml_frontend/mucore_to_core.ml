(*Generated by Lem from frontend/model/mucore_to_core.lem.*)
open Lem_pervasives

open Ctype
open Annot
open Loc
(*import Symbol Implementation Undefined Cmm_csem*)
open Mem
open Mem_common
(* import Linux *)

(*import Core*)
open Core_aux

open Lem_assert_extra

open Mucore
module Mu = Core_anormalise.Mu
open Mu





let mapsnd (f : 'b -> 'c) (l : ('a * 'b) list) : ('a * 'c) list= 
   (map (fun (a1,b) -> (a1, f b)) l)


type 'bty env = (symbol, ( ('bty, symbol)Core.generic_pexpr)) Pmap.map

let insert_symbol sym1 v env1:('b,'a)Pmap.map=
   (Pmap.add sym1 v env1)

let get_pexpr _where env asym:('b,'a)Core.generic_pexpr= 
  match Pmap.lookup asym.sym env with
  | Some pexpr2 -> pexpr2
  (* Maybe there was already a symbol before a-normalisation. Then the
     a-normalisation would not have added a new let-expression. So
     when reverting, we have to turn those symbols into PEsym
     expressions. *)
  | None -> Core.Pexpr(asym.annot, asym.type_annot, (Core.PEsym asym.sym))


let get_loaded_value env1 asym2:'a Core.generic_loaded_value= 
  match Pmap.lookup asym2.sym env1 with
  | Some (Core.Pexpr( _, _, (Core.PEval (Core.Vloaded lv)))) -> lv
  | Some _ -> failwith "not a loaded value"
  | None -> failwith ("get_loaded_value: symbol not found")

let get_object_value env1 asym:'a Core.generic_object_value= 
  match (lookupBy Symbol.symbolEquality asym.sym env1) with
  | Some (Core.Pexpr( _, _, (Core.PEval (Core.Vobject ov)))) -> ov
  | Some _ -> failwith "not an object value"
  | None -> failwith ("get_object_value: symbol not found")


let get_value env1 asym:'a Core.generic_value= 
  match Pmap.lookup asym.sym env1 with
  | Some (Core.Pexpr( _, _, (Core.PEval v))) -> v
  | Some _ -> failwith "not an object value"
  | None -> failwith ("get_value: symbol not found")



let make_symbol_pexpr asym : ('bty, symbol) Core.generic_pexpr=
  let (_loc, annots, bty, sym) = asym_unpack asym in
   (Core.Pexpr( annots, bty, (Core.PEsym sym)))

let make_ctype_pexpr act : ('bty, symbol) Core.generic_pexpr=
  let (_, annots, bty, ctype) = act_unpack act in
   (Core.Pexpr (annots, bty, (Core.PEval (Core.Vctype ctype))))


let rec mu_to_core__object_value ov:(Symbol.sym)Core.generic_object_value= 
   ((match ov with
  | M_OVinteger iv -> Core.OVinteger iv
  | M_OVfloating fv -> Core.OVfloating fv
  | M_OVpointer ov -> Core.OVpointer ov
  | M_OVstruct( s, is) -> Core.OVstruct( s, is)
  | M_OVunion( s, i, mv) -> Core.OVunion( s, i, mv)
  | M_OVarray is -> Core.OVarray (List.map mu_to_core__loaded_value is)
  ))

and mu_to_core__loaded_value lv:(Symbol.sym)Core.generic_loaded_value= 
   ((match lv with
  | M_LVspecified ov ->
     Core.LVspecified (mu_to_core__object_value ov)
  (* | M_LVunspecified ct -> Core.LVunspecified ct *)
  ))


let rec mu_to_core__value (v : 'bty mu_value)
        : symbol Core.generic_value=
   ((match v with
  | M_Vobject ov -> Core.Vobject (mu_to_core__object_value ov)
  | M_Vloaded lv -> Core.Vloaded (mu_to_core__loaded_value lv)
  | M_Vunit -> Core.Vunit
  | M_Vtrue -> Core.Vtrue
  | M_Vfalse -> Core.Vfalse
  (* | M_Vctype ct -> Core.Vctype ct *)
  | M_Vlist( cbt, is) -> 
     let is = (map mu_to_core__value is) in
     Core.Vlist( cbt, is)
  | M_Vtuple is ->
     let is = (map mu_to_core__value is) in
     Core.Vtuple is
  ))
  
let mu_to_core__ctor:mu_ctor ->Core.generic_ctor=  ((function
 | M_Cnil bt1 -> Core.Cnil bt1
 | M_Ccons -> Core.Ccons
 | M_Ctuple -> Core.Ctuple
 | M_Carray -> Core.Carray
 | M_Cspecified -> Core.Cspecified
))


let rec mu_to_core__pattern (M_Pattern(_, annots, pat_)):(Symbol.sym)Core.generic_pattern= 
  let wrap pat_=  (Core.Pattern(annots, pat_)) in
  match pat_ with
  | M_CaseBase (msym, bt1) -> 
     wrap (Core.CaseBase (msym, bt1))
  | M_CaseCtor( ctor1, pats) -> 
     wrap (Core.CaseCtor( 
             (mu_to_core__ctor ctor1),
             (map mu_to_core__pattern pats)))


let mu_to_core__pexpr (env1 : 'bty env) (pexpr2 : 'bty mu_pexpr)
        : ('bty, symbol) Core.generic_pexpr=
  (let (M_Pexpr(_, annots2, bty, pexpr_)) = pexpr2 in
  let wrap pexpr_=  (Core.Pexpr( annots2, bty, pexpr_)) in
  (match pexpr_ with
  | M_PEsym s ->
     wrap (Core.PEsym s)
  | M_PEimpl ic -> 
     wrap (Core.PEimpl ic)
  | M_PEval v -> 
     wrap (Core.PEval (mu_to_core__value v))
  | M_PEconstrained l -> 
     let l = (mapsnd (get_pexpr "PEconstrained" env1) l) in
     wrap (Core.PEconstrained l)
  | M_PEerror( err, p) -> 
     wrap (Core.PEerror( err, (get_pexpr "PEerror" env1 p)))
  | M_PEctor( ctor1, pes) -> 
     wrap (Core.PEctor( 
             (mu_to_core__ctor ctor1),
             (map (get_pexpr "PEctor" env1) pes)))
  | M_CivCOMPL (act, p1) -> 
     let ct = make_ctype_pexpr act in
     let p1 = get_pexpr "M_CivCOMPL" env1 p1 in
     wrap (Core.PEctor(Core.CivCOMPL, [ct; p1]))
  | M_CivAND (act, p1, p2) -> 
     let ct = make_ctype_pexpr act in
     let p1 = get_pexpr "M_CivAND" env1 p1 in
     let p2 = get_pexpr "M_CivAND" env1 p2 in
     wrap (Core.PEctor(Core.CivAND, [ct; p1; p2]))
  | M_CivOR (act, p1, p2) -> 
     let ct = make_ctype_pexpr act in
     let p1 = get_pexpr "M_CivOR" env1 p1 in
     let p2 = get_pexpr "M_CivOR" env1 p2 in
     wrap (Core.PEctor(Core.CivOR, [ct; p1; p2]))
  | M_CivXOR (act, p1, p2) -> 
     let ct = make_ctype_pexpr act in
     let p1 = get_pexpr "M_CivXOR" env1 p1 in
     let p2 = get_pexpr "M_CivXOR" env1 p2 in
     wrap (Core.PEctor(Core.CivXOR, [ct; p1; p2]))
  | M_Cfvfromint p1 -> 
     let p1 = get_pexpr "M_Cfvfromint" env1 p1 in
     wrap (Core.PEctor(Core.CivXOR, [p1]))
  | M_Civfromfloat (act, p1) -> 
     let ct = make_ctype_pexpr act in
     let p1 = get_pexpr "M_Civfromfloat" env1 p1 in
     wrap (Core.PEctor(Core.CivXOR, [ct; p1]))
  | M_PEarray_shift( pe1, ctype1, pe2) ->
     wrap (Core.PEarray_shift( 
             (get_pexpr "PEarray_shift" env1 pe1), 
             ctype1, 
             (get_pexpr "PEarray_shift" env1 pe2)))
  | M_PEmember_shift( p, s, id1)  ->
     wrap (Core.PEmember_shift( (get_pexpr "PEmember_shift" env1 p), s, id1))
  | M_PEnot p ->
     wrap (Core.PEnot (get_pexpr "PEnot" env1 p))
  | M_PEop( binop1, p11, p21) ->
     wrap (Core.PEop( binop1, 
             (get_pexpr "PEop" env1 p11), 
             (get_pexpr "PEop" env1 p21)))
  | M_PEstruct( sym1, fields) ->
     let fields = (mapsnd (get_pexpr "PEstruct" env1) fields) in
     wrap (Core.PEstruct( sym1, fields))
  | M_PEunion( sym1, id1, p) ->
     wrap (Core.PEunion( sym1, id1, (get_pexpr "PEunion" env1 p)))
  (* | M_PEcfunction f ->
   *    Core.PEcfunction (get_pexpr f) *)
  | M_PEmemberof( sym1, id1, p) ->
     wrap (Core.PEmemberof( sym1, id1, (get_pexpr "PEmemberof" env1 p)))
  | M_PEcall( name1, args) ->
     wrap (Core.PEcall( name1, (map (get_pexpr "PEcall" env1) args)))
  (* | M_PEis_scalar p ->
   *    Core.PEis_scalar (get_pexpr p)
   * | M_PEis_integer p ->
   *    Core.PEis_integer (get_pexpr p)
   * | M_PEis_signed p ->
   *    Core.PEis_signed (get_pexpr p)
   * | M_PEis_unsigned p ->
   *    Core.PEis_unsigned (get_pexpr p)
   * | M_PEbmc_assume e ->
   *    Core.PEbmc_assume (get_pexpr e)
   * | M_PEare_compatible p1 p2 ->
   *    Core.PEare_compatible (get_pexpr p1) (get_pexpr p2) *)
  | _ ->
      failwith "FIXME"
  ))

let rec mu_to_core__tpexpr (env1 : 'bty env) (pexpr2 : 'bty mu_tpexpr)
        : ('bty, symbol) Core.generic_pexpr=
  let (M_TPexpr(_, annots2, bty, pexpr_)) = pexpr2 in
  let wrap pexpr_=  (Core.Pexpr( annots2, bty, pexpr_)) in
  match pexpr_ with
  | M_PEcase( p, pats_pes) ->
     let pats_pes = 
       (map (fun (pat,e) -> 
           (mu_to_core__pattern pat, 
            mu_to_core__tpexpr env1 e)) 
         pats_pes) in
     wrap (Core.PEcase( (get_pexpr "PEcase" env1 p), pats_pes))
  | M_PElet( pat, p11, p21) ->
     (match pat with
     | M_Symbol sym1 ->
        let p11 = (mu_to_core__pexpr env1 p11) in
        let env' = (insert_symbol sym1 p11 env1) in
        mu_to_core__tpexpr env' p21
     | M_Pat pat ->
        wrap (Core.PElet( 
                (mu_to_core__pattern pat),
                (mu_to_core__pexpr env1 p11), 
                (mu_to_core__tpexpr env1 p21)))
     )
  | M_PEif( p0, p11, p21) ->
     wrap (Core.PEif( 
             (get_pexpr "PEif" env1 p0),
                (mu_to_core__tpexpr env1 p11), 
                (mu_to_core__tpexpr env1 p21)))
  | M_PEdone asym ->
     (get_pexpr "PEdone" env1 asym)
  | M_PEundef( loc, undef1) ->
     wrap (Core.PEundef( loc, undef1))




let mu_to_core__kill_kind:m_kill_kind ->Core.kill_kind=  ((function
  | M_Dynamic -> Core.Dynamic
  | M_Static ct1 -> Core.Static0 ct1
  ))

let mu_to_core__action_ env1 (action_ :'bty mu_action_)
        : ('bty, symbol) Core.generic_action_=
   ((match action_ with
  | M_Create( p11, p21, prefix1) ->
     Core.Create( 
       (get_pexpr "Create" env1 p11),
       (make_ctype_pexpr p21),
       prefix1)
  | M_CreateReadOnly( p11, p21, p3, prefix1) ->
     Core.CreateReadOnly( 
       (get_pexpr "CreateReadOnly" env1 p11),
       (make_ctype_pexpr p21),
       (get_pexpr "CreateReadOnly" env1 p3),
       prefix1)
  | M_Alloc( p11, p21, prefix1) ->
     Core.Alloc0( 
       (get_pexpr "Alloc" env1 p11),
       (get_pexpr "Alloc" env1 p21),
       prefix1)
  | M_Kill( kind, p) ->
     Core.Kill( 
       (mu_to_core__kill_kind kind),
       (get_pexpr "Kill" env1 p))
  | M_Store( b, p11, p21, p3, mo1) ->
     Core.Store0( 
       b,
       (make_ctype_pexpr p11),
       (get_pexpr "Store" env1 p21), 
       (get_pexpr "Store" env1 p3),
       mo1)
  | M_Load( p11, p21, mo1) ->
     Core.Load0( 
       (make_ctype_pexpr p11),
       (get_pexpr "Load" env1 p21),
       mo1)
  | M_RMW( p11, p21, p3, p4, mo1, mo2) ->
     Core.RMW0( 
       (make_ctype_pexpr p11),
       (get_pexpr "RMW" env1 p21), 
       (get_pexpr "RMW" env1 p3),
       (get_pexpr "RMW" env1 p4),
       mo1,
       mo2)
  | M_Fence mo1 ->
     Core.Fence0 
       mo1
  | M_CompareExchangeStrong( p11, p21, p3, p4, mo1, mo2) ->
     Core.CompareExchangeStrong( 
       (make_ctype_pexpr p11),
       (get_pexpr "CompareExchangeStrong" env1 p21), 
       (get_pexpr "CompareExchangeStrong" env1 p3),
       (get_pexpr "CompareExchangeStrong" env1 p4),
       mo1,
       mo2)
  | M_CompareExchangeWeak( p11, p21, p3, p4, mo1, mo2) ->
     Core.CompareExchangeWeak(
       (make_ctype_pexpr p11),
       (get_pexpr "CompareExchangeWeak" env1 p21), 
       (get_pexpr "CompareExchangeWeak" env1 p3),
       (get_pexpr "CompareExchangeWeak" env1 p4),
       mo1,
       mo2)
  | M_LinuxFence mo1 ->
     Core.LinuxFence 
       mo1
  | M_LinuxLoad( p11, p21, mo1) ->
     Core.LinuxLoad( 
       (make_ctype_pexpr p11),
       (get_pexpr "LinuxLoad" env1 p21),
       mo1)
  | M_LinuxStore( p11, p21, p3, mo1) ->
     Core.LinuxStore(
       (make_ctype_pexpr p11),
       (get_pexpr "LinuxStore" env1 p21), 
       (get_pexpr "LinuxStore" env1 p3),
       mo1)
  | M_LinuxRMW( p11, p21, p3, mo1) ->
     Core.LinuxRMW(
       (make_ctype_pexpr p11),
       (get_pexpr "LinuxRMW" env1 p21), 
       (get_pexpr "LinuxRMW" env1 p3),
       mo1)
  ))

let mu_to_core__action env1 (M_Action( t5, action_)):((unit),'a,(Symbol.sym))Core.generic_action= 
   (Core.Action( t5, (), (mu_to_core__action_ env1 action_)))

let mu_to_core__paction env1 (M_Paction( p, action3)):((unit),'a,(Symbol.sym))Core.generic_paction= 
   (Core.Paction( p, (mu_to_core__action env1 action3)))




let mu_to_core__memop env1 memop1:memop*(('a,(Symbol.sym))Core.generic_pexpr)list= 
   (let mctype = make_ctype_pexpr in
  let msym where asym2=  (get_pexpr where env1 asym2) in
  (match memop1 with
  | M_PtrEq (sym1,sym2) ->
     (PtrEq, 
      [msym "PtrEq" sym1; 
       msym "PtrEq" sym2])
  | M_PtrNe (sym1,sym2) ->
     (PtrNe, 
      [msym "PtrNe" sym1; 
       msym "PtrNe" sym2])
  | M_PtrLt (sym1,sym2) ->
     (PtrLt, 
      [msym "PtrLt" sym1; 
       msym "PtrLt" sym2])
  | M_PtrGt (sym1,sym2) ->
     (PtrGt, 
      [msym "PtrGt" sym1; 
       msym "PtrGt" sym2])
  | M_PtrLe (sym1,sym2) ->
     (PtrLe, 
      [msym "PtrLe" sym1; 
       msym "PtrLe" sym2])
  | M_PtrGe (sym1,sym2) ->
     (PtrGe, 
      [msym "PtrGe" sym1; 
       msym "PtrGe" sym2])
  | M_Ptrdiff (ct1,sym1,sym2) ->
     (Ptrdiff, 
      [mctype ct1; 
       msym "Ptrdiff" sym1; 
       msym "Ptrdiff" sym2])
  | M_IntFromPtr (ct1,ct2, sym1) ->
     (IntFromPtr, 
      [mctype ct1; 
       mctype ct2;
       msym "IntFromPtr" sym1])
  | M_PtrFromInt (ct1,ct2,sym1) ->
     (PtrFromInt, 
      [mctype ct1; 
       mctype ct2; 
       msym "PtrFromInt" sym1])
  | M_PtrValidForDeref (ct1,sym1) ->
     (PtrValidForDeref, 
      [mctype ct1; 
       msym "PtrValidForDeref" sym1])
  | M_PtrWellAligned (ct1,sym1) ->
     (PtrWellAligned, 
      [mctype ct1; 
       msym "PtrWellAligned" sym1])
  | M_PtrArrayShift (sym1,ct1,sym2) ->
     (PtrArrayShift, 
      [msym "PtrArrayShift" sym1; 
       mctype ct1; 
       msym "PtrArrayShift" sym2])
  | M_PtrMemberShift (tag_sym, membr_ident, sym) ->
      (PtrMemberShift (tag_sym, membr_ident), 
       [msym "PtrMemberShift" sym])
  | M_Memcpy (sym1,sym2,sym3) ->
     (Memcpy, 
      [msym "Memcpy" sym1; 
       msym "Memcpy" sym2; 
       msym "Memcpy" sym3])
  | M_Memcmp (sym1,sym2,sym3) ->
     (Memcmp, 
      [msym "Memcmp" sym1; 
       msym "Memcmp" sym2; 
       msym "Memcmp" sym3])
  | M_Realloc (sym1,sym2,sym3) ->
     (Realloc, 
      [msym "Realloc" sym1; 
       msym "Realloc" sym2; 
       msym "Realloc" sym3])
  | M_Va_start (sym1,sym2) ->
     (Va_start, 
      [msym "Va_start" sym1; 
       msym "Va_start" sym2])
  | M_Va_copy sym1 ->
     (Va_copy, 
      [msym "Va_copy" sym1])
  | M_Va_arg (sym1,ct1) ->
     (Va_arg, 
      [msym "Va_arg" sym1; 
       mctype ct1])
  | M_Va_end sym1 ->
     (Va_end, 
      [msym "Va_end" sym1])
  ))

let mu_to_core__expr env1 expr2 : (unit, 'bty, symbol) Core.generic_expr=
   (let (M_Expr(_, annots, expr_)) = expr2 in
  let wrap expr_=  (Core.Expr(annots, expr_)) in
  (match expr_ with
    | M_Epure p -> 
       wrap (Core.Epure (mu_to_core__pexpr env1 p))
    | M_Ememop memop1 ->
       let (memop1,args) = (mu_to_core__memop env1 memop1) in
       wrap (Core.Ememop( memop1, args))
    | M_Eaction pa ->
       wrap (Core.Eaction (mu_to_core__paction env1 pa))
    | M_Eskip ->
       wrap Core.Eskip
    | M_Eccall( (act), pe2, pes) ->
       wrap (Core.Eccall( (),
               (Core.Pexpr( act.annot, act.type_annot, (Core.PEval (Core.Vctype act.ct)))),
               (get_pexpr "Eccall" env1 pe2), 
               (map (get_pexpr "Eccall" env1) pes)))
    | M_Eproc( name1, pes) ->
       wrap (Core.Eproc( (), name1, (map (get_pexpr "Eproc" env1) pes)))
    | M_Erpredicate (Pack, id, pes) ->
       wrap (Core.Epack (id, map (get_pexpr "Epack" env1) pes))
    | M_Erpredicate (Unpack, id, pes) ->
       wrap (Core.Eunpack (id, map (get_pexpr "Eunpack" env1) pes))
    | M_Elpredicate (Have, id, pes) ->
       wrap (Core.Ehave (id, map (get_pexpr "Ehave" env1) pes))
    | M_Elpredicate (Show, id, pes) ->
       wrap (Core.Eshow (id, map (get_pexpr "Eshow" env1) pes))
    (* | M_Eunseq es ->
     *    Core.Eunseq (map (mu_to_core__expr env) es) *)
    (* | M_Easeq (s,bt) pa ->
     *    Core.Easeq (s,bt) (mu_to_core__action a) (mu_to_core__paction pa) *)
    (* | M_Eindet n e ->
     *    Core.Eindet n (mu_to_core__expr env e) *)
       (* wrap (Core.Erun () sym (map (get_pexpr "Ereturn" env) [pe])) *)
    (* | M_Epar es ->
     *    Core.Epar (map (mu_to_core__expr env) es) *)
    (* | M_Ewait tid -> 
     *    Core.Ewait tid *)
  ))

let rec mu_to_core__texpr env1 expr2 : (unit, 'bty, symbol) Core.generic_expr=
   let (M_TExpr(_, annots, expr_)) = expr2 in
  let wrap expr_=  (Core.Expr(annots, expr_)) in
  match expr_ with
    | M_Ecase( pe, es) ->
       wrap (Core.Ecase( (get_pexpr "Ecase" env1 pe), 
               (map (fun (pat,e) -> 
                    (mu_to_core__pattern pat, 
                     mu_to_core__texpr env1 e)) es)))
    | M_Elet( pat, pe, e) ->
       (match pat with
       | M_Symbol sym1 ->
          let pe = (mu_to_core__pexpr env1 pe) in
          let env' = (insert_symbol sym1 pe env1) in
          mu_to_core__texpr env' e
       | M_Pat pat ->
          wrap (Core.Elet( 
                  (mu_to_core__pattern pat),
                  (mu_to_core__pexpr env1 pe), 
                  (mu_to_core__texpr env1 e)))
       )
    | M_Eif( pe, e1, e2) ->
       wrap (Core.Eif( (get_pexpr "Eif" env1 pe),
               (mu_to_core__texpr env1 e1),
               (mu_to_core__texpr env1 e2)))
    | M_Ewseq( pat, e1, e2) ->
       wrap (Core.Ewseq( 
               (mu_to_core__pattern pat),
               (mu_to_core__expr env1 e1),
               (mu_to_core__texpr env1 e2)))
    | M_Esseq( pat, e1, e2) ->
       begin match pat with
       | M_Symbol sym1 ->
          failwith "todo: M_Essseq with M_Symbol"
       | M_Pat pat ->
          wrap (Core.Esseq( 
                    (mu_to_core__pattern pat),
                    (mu_to_core__expr env1 e1),
                    (mu_to_core__texpr env1 e2)))
       end
    | M_Ebound( n, e) ->
       wrap (Core.Ebound( n, (mu_to_core__texpr env1 e)))
    | M_End es ->
       wrap (Core.End (map (mu_to_core__texpr env1) es))
    | M_Edone asym ->
       failwith "todo: M_Edone"
    | M_Erun( sym1, pes) ->
       wrap (Core.Erun( (), sym1, (map (get_pexpr "Erun" env1) pes)))
    | M_Eundef( loc, undef1) ->
       wrap (Core.Epure (Core.Pexpr ([], (), Core.PEundef( loc, undef1))))






let mu_to_core__impl_decl (i : 'bty mu_impl_decl) 
    : 'bty Core.generic_impl_decl=
   ((match i with
  | M_Def(_, bt1, p) -> 
     Core.Def( bt1, (mu_to_core__tpexpr (Pmap.empty Symbol.symbol_compare) p))
  | M_IFun(_, bt1, args, body) -> 
     Core.IFun( bt1, args, (mu_to_core__tpexpr (Pmap.empty Symbol.symbol_compare) body))
  ))

let mu_to_core__impl (i : 'bty mu_impl) 
    : 'bty Core.generic_impl=
   (Pmap.map mu_to_core__impl_decl i)


let mu_to_core__fun_map_decl d : ('bty, unit) Core.generic_fun_map_decl=
   ((match d with
  | M_Fun( bt1, args, pe) ->
     Core.Fun( bt1, args, (mu_to_core__tpexpr (Pmap.empty Symbol.symbol_compare) pe))
  | M_Proc( loc, bt1, args, e, _labels) ->
     Core.Proc( loc, bt1, args, (mu_to_core__texpr (Pmap.empty Symbol.symbol_compare) e))
  | M_ProcDecl( loc, bt1, bts) ->
     Core.ProcDecl( loc, bt1, bts)
  | M_BuiltinDecl( loc, bt1, bts) ->
     Core.BuiltinDecl( loc, bt1, bts)
  ))

let mu_to_core__fun_map (fmap1 : 'bty mu_fun_map) 
    : ('bty, unit) Core.generic_fun_map= 
   (Pmap.map mu_to_core__fun_map_decl fmap1)
  

let mu_to_core__globs (g : 'bty  mu_globs) 
    : (unit, 'bty) Core.generic_globs= 
   ((match g with
  | M_GlobalDef(_, bt1, e) -> Core.GlobalDef( bt1, (mu_to_core__texpr (Pmap.empty Symbol.symbol_compare) e))
  | M_GlobalDecl (_, bt1) -> Core.GlobalDecl bt1 
  ))

(* let mu_to_core__globs_map (g : Core.generic_globs_map bty) 
 *     : mu_globs_map unit bty = 
 *   Map.map mu_to_core__globs g *)

let mu_to_core__tag_definition = function
  | M_StructDef (l, mf) -> StructDef( l, mf)
  | M_UnionDef l -> UnionDef l


let mu_to_core__tag_definitions dict_Map_MapKeyType_a tagDefs1:('a,(tag_definition))Pmap.map= 
   (Pmap.map mu_to_core__tag_definition tagDefs1)

  
let mu_to_core__globs_list (gs : (symbol * 'bty mu_globs) list )
    : (symbol * (unit, 'bty) Core.generic_globs) list= 
   (map (fun (sym1,g) -> (sym1, mu_to_core__globs g)) gs)


let mu_to_core__funinfo (M_funinfo (loc, annots2, (ret,args,b1), _trusted, b2)):Location_ocaml.t*attributes*'b*'a*bool*bool=
  let args = List.map (fun (s,ct) -> (Some s, ct)) args in
   (loc,annots2,ret,args,b1,b2)

let mu_to_core__funinfos dict_Map_MapKeyType_c funinfos:('c,(Location_ocaml.t*attributes*'a*'b*bool*bool))Pmap.map= 
   (Pmap.map mu_to_core__funinfo funinfos)



let mu_to_core__file file1:('a,(unit))Core.generic_file= 
   ({ Core.main = (file1.mu_main)
   ; Core.tagDefs = (mu_to_core__tag_definitions 
  (instance_Map_MapKeyType_var_dict
     Symbol.instance_Basic_classes_SetType_Symbol_sym_dict) file1.mu_tagDefs)
   ; Core.stdlib = (mu_to_core__fun_map file1.mu_stdlib)
   ; Core.impl = (mu_to_core__impl file1.mu_impl)
   ; Core.globs = (mu_to_core__globs_list file1.mu_globs)
   ; Core.funs = (mu_to_core__fun_map file1.mu_funs)
   ; Core.extern = (file1.mu_extern)
   ; Core.funinfo = (mu_to_core__funinfos 
  (instance_Map_MapKeyType_var_dict
     Symbol.instance_Basic_classes_SetType_Symbol_sym_dict) file1.mu_funinfo)
   ; Core.loop_attributes0 = (file1.mu_loop_attributes)
  })

